"task_id","prompt","code_0","code_1","code_2","code_3","code_4","code_5","code_6","code_7","code_8","code_9","code_10","code_11","code_12","code_13","code_14","code_15","pass_rate_0","pass_rate_1","pass_rate_2","pass_rate_3","pass_rate_4","pass_rate_5","pass_rate_6","pass_rate_7","pass_rate_8","pass_rate_9","pass_rate_10","pass_rate_11","pass_rate_12","pass_rate_13","pass_rate_14","pass_rate_15","err_0","err_1","err_2","err_3","err_4","err_5","err_6","err_7","err_8","err_9","err_10","err_11","err_12","err_13","err_14","err_15"
"APPS/0","
QUESTION:
An accordion is a string (yes, in the real world accordions are musical instruments, but let's forget about it for a while) which can be represented as a concatenation of: an opening bracket (ASCII code $091$), a colon (ASCII code $058$), some (possibly zero) vertical line characters (ASCII code $124$), another colon, and a closing bracket (ASCII code $093$). The length of the accordion is the number of characters in it.

For example, [::], [:||:] and [:|||:] are accordions having length $4$, $6$ and $7$. (:|:), {:||:}, [:], ]:||:[ are not accordions. 

You are given a string $s$. You want to transform it into an accordion by removing some (possibly zero) characters from it. Note that you may not insert new characters or reorder existing ones. Is it possible to obtain an accordion by removing characters from $s$, and if so, what is the maximum possible length of the result?


-----Input-----

The only line contains one string $s$ ($1 \le |s| \le 500000$). It consists of lowercase Latin letters and characters [, ], : and |.


-----Output-----

If it is not possible to obtain an accordion by removing some characters from $s$, print $-1$. Otherwise print maximum possible length of the resulting accordion.


-----Examples-----
Input
|[a:b:|]

Output
4

Input
|]:[|:]

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    opening_bracket = s.find('[')
    closing_bracket = s.rfind(']')
    
    if opening_bracket == -1 or closing_bracket == -1 or opening_bracket >= closing_bracket:
        print(-1)
        return
    
    s = s[opening_bracket:closing_bracket+1]
    colon1 = s.find(':')
    colon2 = s.rfind(':')
    
    if colon1 == -1 or colon2 == -1 or colon1 >= colon2:
        print(-1)
        return
    
    vertical_lines = s.count('|', colon1, colon2)
    
    accordion_length = 4 + vertical_lines
    print(accordion_length)

solve()
","
def solve():
    s = input().strip()
    
    opening_bracket = s.find('[')
    closing_bracket = s.rfind(']')
    
    if opening_bracket == -1 or closing_bracket == -1 or opening_bracket >= closing_bracket:
        print(-1)
        return
    
    colon_index1 = s.find(':', opening_bracket)
    colon_index2 = s.rfind(':', closing_bracket)
    
    if colon_index1 == -1 or colon_index2 == -1 or colon_index1 == colon_index2:
        print(-1)
        return
    
    max_length = 4
    
    vertical_lines = s.count('|', colon_index1, colon_index2)
    max_length += vertical_lines
    
    print(max_length)

solve()
","
def solve():
    s = input()
    
    left_idx = s.find('[')
    right_idx = s.find(']')
    
    if left_idx == -1 or right_idx == -1 or right_idx < left_idx:
        print(-1)
        return
    
    colon_count = s.count(':')
    vertical_bar_count = s.count('|')
    
    for i in range(left_idx + 1, right_idx):
        if s[i] == ':':
            colon_count -= 1
        elif s[i] == '|':
            vertical_bar_count -= 1

    if colon_count < 2 or vertical_bar_count < 1:
        print(-1)
        return
    
    accordion_length = 4 + colon_count + vertical_bar_count
    print(accordion_length)

solve()
","
def solve():
    s = input().strip()
    opening_bracket_index = s.find('[')
    closing_bracket_index = s.find(']')
    
    if opening_bracket_index == -1 or closing_bracket_index == -1 or closing_bracket_index < opening_bracket_index:
        print(-1)
        return
    
    colon_indices = [index for index, char in enumerate(s) if char == ':']
    
    if len(colon_indices) < 2:
        print(-1)
        return
    
    first_colon_index = colon_indices[0]
    last_colon_index = colon_indices[-1]
    
    vertical_lines = s[first_colon_index+1:last_colon_index].count('|')
    
    max_accordion_length = 4 + vertical_lines
    
    print(max_accordion_length)

solve()
","
def solve(s: str) -> int:
    left_bracket = False
    colon1 = False
    colon2 = False
    right_bracket = False
    max_length = 0
    
    for char in s:
        if char == ""["":
            left_bracket = True
        elif char == "":"" and left_bracket and not colon1:
            colon1 = True
        elif char == ""|"" and left_bracket and colon1 and not colon2:
            max_length += 1
        elif char == "":"" and left_bracket and colon1 and not colon2:
            colon2 = True
        elif char == ""]"" and left_bracket and colon1 and colon2 and not right_bracket:
            right_bracket = True
        
    if left_bracket and colon1 and colon2 and right_bracket:
        return max_length + 4
    else:
        return -1

solve()","
def solve():
    s = input().strip()
    open_bracket_idx = s.find('[')
    close_bracket_idx = s.find(']')
    colon_count = s.count(':')
    
    if open_bracket_idx == -1 or close_bracket_idx == -1 or colon_count < 2 or open_bracket_idx > close_bracket_idx:
        print(-1)
    else:
        max_accordion_length = 4 + s.count('|', open_bracket_idx, close_bracket_idx)
        print(max_accordion_length)

if __name__ == ""__main__"":
    solve()
","
def solve():
    s = input().strip()
    
    left_idx = s.find('[')
    right_idx = s.find(']')
    
    if left_idx == -1 or right_idx == -1 or right_idx < left_idx:
        print(-1)
        return
    
    s = s[left_idx:right_idx+1]
    
    colons_idx = [i for i, char in enumerate(s) if char == ':']
    
    if len(colons_idx) < 2 or colons_idx[-1] < colons_idx[0]:
        print(-1)
        return
    
    result = 4 + s.count('|', colons_idx[0], colons_idx[-1])
    
    print(result)

solve()","
def solve():
    s = input().strip()
    opening_bracket = False
    closing_bracket = False
    opened_brackets = 0
    vertical_lines = 0
    closing_bracket_position = 0
    for i, c in enumerate(s):
        if c == '[':
            opening_bracket = True
        elif c == '|' and opening_bracket and not closing_bracket:
            vertical_lines += 1
        elif c == ']' and opening_bracket and not closing_bracket:
            closing_bracket = True
            opened_brackets += 1
            closing_bracket_position = i
    if not opening_bracket or not closing_bracket or opened_brackets != 1 or s[0] != '[' or s[-1] != ']' or vertical_lines < 3:
        print(-1)
    else:
        print(4 + vertical_lines)

solve()
","
def solve():
    s = input().strip()
    stack = []
    opening_bracket_found = False
    max_length = 0
    
    for char in s:
        if char == '[':
            opening_bracket_found = True
        elif char == ':':
            if opening_bracket_found:
                stack.append(char)
        elif char == '|':
            if opening_bracket_found and stack and stack[-1] == ':':
                stack.append(char)
        elif char == ']':
            if opening_bracket_found and stack and stack[-1] == ':' and stack.count('|') >= 1:
                length = 4 + stack.count('|')
                max_length = max(max_length, length)
            stack = []  # reset stack
            opening_bracket_found = False
    
    if max_length == 0:
        print(-1)
    else:
        print(max_length)

solve()
","
def solve():
    s = input().strip()
    
    opening_bracket_idx = s.find('[')
    closing_bracket_idx = s.find(']')
    
    if opening_bracket_idx == -1 or closing_bracket_idx == -1 or closing_bracket_idx < opening_bracket_idx:
        print(-1)
        return
    
    s = s[opening_bracket_idx:closing_bracket_idx+1]
    
    colon_idx = s.find(':')
    if colon_idx == -1:
        print(-1)
        return
    
    s = s[colon_idx:]
    
    vertical_lines = s.count('|')
    
    if vertical_lines < 2:
        print(-1)
    else:
        print(4 + vertical_lines)

solve()
","
def solve():
    s = input().strip()
    opening_bracket = s.find(""["")
    closing_bracket = s.rfind(""]"")
    if opening_bracket == -1 or closing_bracket == -1 or closing_bracket <= opening_bracket:
        print(-1)
        return
    s = s[opening_bracket:closing_bracket+1]
    first_colon = s.find("":"")
    last_colon = s.rfind("":"")
    if first_colon == -1 or last_colon == -1 or last_colon <= first_colon:
        print(-1)
        return
    s = s[first_colon:last_colon+1]
    max_length = 4 + s.count(""|"")
    print(max_length)

import sys
if __name__ == ""__main__"":
    solve()
  ","
def solve():
    s = input().strip()
    n = len(s)
    
    start = s.find('[')
    end = s.rfind(']')
    
    if start == -1 or end == -1:
        print(-1)
        return
    
    start = s.find(':', start)
    end = s.rfind(':', start, end)
    
    if start == -1 or end == -1:
        print(-1)
        return
    
    count = 0
    for i in range(start+1, end):
        if s[i] == '|':
            count += 1
    
    print(count + 4)

solve()
  ","
def solve():
    s = input()
    
    acc_start = s.find('[')
    acc_end = s.find(']')
    
    if acc_start == -1 or acc_end == -1 or acc_start >= acc_end:
        print(-1)
        return
    
    opening_colon = s.find(':', acc_start+1)
    closing_colon = s.rfind(':', acc_start+1, acc_end)
    
    if opening_colon == -1 or closing_colon == -1 or opening_colon >= closing_colon:
        print(-1)
        return
    
    vertical_bars = s.count('|', opening_colon, closing_colon)
    
    accordion_length = 4 + vertical_bars
    
    print(accordion_length)

solve()
  ","
def solve():
    s = input()
    left_bracket = s.find(""["")
    right_bracket = s.find(""]"")
    first_colon = s.find("":"")
    last_colon = s.rfind("":"")
    
    if left_bracket == -1 or right_bracket == -1 or first_colon == -1 or last_colon == -1:
        print(-1)
        return
    
    accordion = s[left_bracket:right_bracket+1]
    result = accordion.count(""|"") + 4
    
    print(result)

solve()
","
def solve():
    s = input().strip()
    
    opening_index = s.find('[')
    closing_index = s.rfind(']')
    
    if opening_index == -1 or closing_index == -1 or opening_index >= closing_index:
        print(-1)
        return
    
    colon_after_opening = s.find(':', opening_index)
    colon_before_closing = s.rfind(':', opening_index, closing_index+1)
    
    if colon_after_opening == -1 or colon_before_closing == -1 or colon_after_opening >= colon_before_closing:
        print(-1)
        return
    
    max_accordion_length = 4 + s.count('|', colon_after_opening, colon_before_closing)
    print(max_accordion_length)

solve()
","
def solve():
    s = input().strip()
    
    opening_idx = s.find('[')
    closing_idx = s.find(']')
    
    if opening_idx == -1 or closing_idx == -1 or closing_idx < opening_idx:
        print(-1)
        return
    
    mid_section = s[opening_idx:closing_idx+1]
    
    colon_idx_1 = mid_section.find(':')
    colon_idx_2 = mid_section.rfind(':')
    
    if colon_idx_1 == -1 or colon_idx_2 == -1 or colon_idx_1 == colon_idx_2:
        print(-1)
        return
    
    vertical_bar_count = mid_section.count('|', colon_idx_1, colon_idx_2)
    
    result_length = 4 + vertical_bar_count
    
    print(result_length)

solve()
","100.0","80.0","80.0","80.0","0.0","66.66666666666666","100.0","80.0","80.0","80.0","100.0","86.66666666666667","100.0","40.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/1","
QUESTION:
Anton has the integer x. He is interested what positive integer, which doesn't exceed x, has the maximum sum of digits.

Your task is to help Anton and to find the integer that interests him. If there are several such integers, determine the biggest of them. 


-----Input-----

The first line contains the positive integer x (1 ≤ x ≤ 10^18) — the integer which Anton has. 


-----Output-----

Print the positive integer which doesn't exceed x and has the maximum sum of digits. If there are several such integers, print the biggest of them. Printed integer must not contain leading zeros.


-----Examples-----
Input
100

Output
99

Input
48

Output
48

Input
521

Output
499
Use user-input-Based format and function signature solve()","
def solve():
    x = int(input())
    max_sum = 0
    result = 0
    for i in range(1, x+1):
        if sum(map(int, str(i))) >= max_sum:
            max_sum = sum(map(int, str(i)))
            result = i
    print(result)

solve()
","
def solve():
    x = int(input())
    max_sum = 0
    result = 0

    for num in range(x, 0, -1):
        current_sum = sum(map(int, str(num)))
        if current_sum > max_sum:
            max_sum = current_sum
            result = num
        elif current_sum == max_sum:
            result = max(result, num)

    print(result)

if __name__ == ""__main__"":
    solve()
","
def solve():
    x = int(input())
    max_sum = 0
    result = 0

    for i in range(1, x+1):
        sum_of_digits = sum(int(digit) for digit in str(i))
        if sum_of_digits >= max_sum:
            max_sum = sum_of_digits
            result = i

    print(result)

solve()
","
def solve():
    x = int(input())
    
    def digit_sum(n):
        return sum(int(digit) for digit in str(n))
    
    max_digit_sum = 0
    max_num = 1
    
    for i in range(1, x+1):
        if digit_sum(i) >= max_digit_sum:
            max_digit_sum = digit_sum(i)
            max_num = i
        
    print(max_num)

solve()
    ","
def solve():
    x = int(input())
    for i in range(x, max(1, x-82), -1):
        if sum(map(int, str(i))) > sum(map(int, str(x))):
            print(i)
            return
    print(x)

solve()","
def solve():
    x = int(input())
    def digit_sum(n):
        return sum(int(digit) for digit in str(n))
    
    max_sum = 0
    result = 0
    for i in range(1, x+1):
        if digit_sum(i) >= max_sum:
            max_sum = digit_sum(i)
            result = i
    
    print(result)

solve()
","
def solve():
    x = int(input())
    max_sum = 0
    result = None

    for i in range(1, x+1):
        sum_of_digits = sum(map(int, str(i)))
        if sum_of_digits >= max_sum and i <= x:
            max_sum = sum_of_digits
            result = i

    print(result)

solve()
","
def solve():
    x = int(input())
    max_sum = 0
    result = 0
    for i in range(1, x+1):
        current_sum = sum(map(int, str(i)))
        if current_sum >= max_sum:
            max_sum = current_sum
            result = i
    print(result)

solve()
","
def solve():
    x = int(input())
    
    def digit_sum(n):
        return sum(map(int, str(n)))
    
    max_sum = 0
    result = 0
    
    for i in range(1, min(x, 1000000) + 1):
        if digit_sum(i) > max_sum:
            max_sum = digit_sum(i)
            result = i
    
    print(result)

if __name__ == ""__main__"":
    solve()
","
def solve():
    x = int(input())
    max_sum = 0
    result = 0
    for i in range(x, max(x-100, 0), -1):
        if sum(int(d) for d in str(i)) > max_sum:
            max_sum = sum(int(d) for d in str(i))
            result = i
    print(result)

solve()
","
def solve():
    x = int(input())
    
    def digit_sum(num):
        return sum([int(d) for d in str(num)])

    max_sum = -1
    best_num = 1
    for num in range(1, x+1):
        if digit_sum(num) >= max_sum:
            max_sum = digit_sum(num)
            best_num = num

    print(best_num)

solve()
  ","
def solve():
    x = int(input())
    
    def calculate_sum_of_digits(n):
        return sum([int(digit) for digit in str(n)])
    
    max_sum = 0
    result = 0
    for i in range(x, max(0, x-100), -1):
        sum_of_digits = calculate_sum_of_digits(i)
        if sum_of_digits > max_sum:
            max_sum = sum_of_digits
            result = i
    
    print(result)

solve()
","
def solve():
    x = int(input())
    max_sum = 0
    res = 0
    
    for i in range(x, max(0, x-100), -1):
        digits_sum = sum(int(d) for d in str(i))
        if digits_sum > max_sum:
            max_sum = digits_sum
            res = i
    
    print(res)

solve()
","
def solve():
    x = int(input())
    
    def digit_sum(n):
        return sum(int(d) for d in str(n))

    max_sum = 0
    max_num = 0
    for i in range(1, x):
        if digit_sum(i) > max_sum:
            max_sum = digit_sum(i)
            max_num = i

    print(max_num)

solve()
","
def solve():
    x = int(input())
    max_sum = 0
    result = 0

    for i in range(x, max(x-100, 0), -1):
        sum_of_digits = sum(map(int, str(i)))
        if sum_of_digits > max_sum:
            max_sum = sum_of_digits
            result = i

    print(result)

if __name__ == ""__main__"":
    solve()
","
def solve():
    x = int(input())
    
    def digit_sum(n):
        return sum(int(digit) for digit in str(n))
    
    max_digit_sum = 0
    result = 0
    for i in range(1, x+1):
        if digit_sum(i) > max_digit_sum:
            max_digit_sum = digit_sum(i)
            result = i
    
    print(result)

solve()
","100.0","100.0","100.0","100.0","80.0","100.0","100.0","100.0","80.0","86.66666666666667","100.0","86.66666666666667","86.66666666666667","28.57142857142857","86.66666666666667","85.71428571428571","","","","","","","","","","","","","","","",""
"APPS/2","
QUESTION:
Apart from having lots of holidays throughout the year, residents of Berland also have whole lucky years. Year is considered lucky if it has no more than 1 non-zero digit in its number. So years 100, 40000, 5 are lucky and 12, 3001 and 12345 are not.

You are given current year in Berland. Your task is to find how long will residents of Berland wait till the next lucky year.


-----Input-----

The first line contains integer number n (1 ≤ n ≤ 10^9) — current year in Berland.


-----Output-----

Output amount of years from the current year to the next lucky one.


-----Examples-----
Input
4

Output
1

Input
201

Output
99

Input
4000

Output
1000



-----Note-----

In the first example next lucky year is 5. In the second one — 300. In the third — 5000.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count('0') + str(n).count('1') == len(str(n)):
            print(n - int(input()))
            break

solve()
","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count('0') + str(n).count('0') == len(str(n)):
            print(n - int(input()))
            break

solve()
  ","
def solve():
    n = int(input())
    next_lucky_year = n + 1
    while not all(digit == '0' or digit == '1' for digit in str(next_lucky_year)):
        next_lucky_year += 1
    return next_lucky_year - n

solve()","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count('0') + str(n).count('0') <= 1:
            return n - int(input())

solve()","
def solve():
    n = int(input())
    
    while True:
        n += 1
        if str(n).count('0') + str(n).count('0') <= 1:
            print(n - int(input()))
            break

solve()","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count('0') + str(n).count('0') == len(str(n)) - 1:
            print(n - int(input()))
            break

solve()
","
def solve():
    current_year = int(input())
    next_lucky_year = current_year + 1
    while True:
        if str(next_lucky_year).count('0') + str(next_lucky_year).count('0') == len(str(next_lucky_year)) - 1:
            break
        next_lucky_year += 1
    return next_lucky_year - current_year

solve()","
def solve():
    n = int(input())
    next_year = n + 1
    while len(set(str(next_year))) > 2:
        next_year += 1
    print(next_year - n)

solve()
","
def solve():
    n = int(input())
    n += 1
    while not sum(int(digit) != 0 for digit in str(n)) <= 1:
        n += 1
    return n - int(input())

solve()","
def solve():
    current_year = int(input())
    
    next_lucky_year = current_year + 1
    while str(next_lucky_year).count('0') + str(next_lucky_year).count('1') != len(str(next_lucky_year)):
        next_lucky_year += 1
    
    return next_lucky_year - current_year

solve()","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count('0') + str(n).count('0') <= 1:
            print(n)
            break

solve()
","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count('0') + str(n).count('1') == len(str(n)):
            print(n - int(input()))
            break

solve()
","
def solve():
    n = int(input())
    
    next_lucky_year = n + 1
    while not is_lucky(next_lucky_year):
        next_lucky_year += 1
    
    return next_lucky_year - n

def is_lucky(year):
    count_nonzero = 0
    while year > 0:
        if year % 10 != 0:
            count_nonzero += 1
        if count_nonzero > 1:
            return False
        year //= 10
    return True

solve()
","
def solve():
    n = int(input())
    
    lucky_year = n
    while True:
        digits = list(str(lucky_year))
        non_zero_count = sum(1 for digit in digits if digit != '0')
        if non_zero_count <= 1:
            break
        lucky_year += 1
    
    return lucky_year - n

solve()","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count(""0"") + str(n).count(""1"") == len(str(n)):
            print(n - int(input()))
            break

solve()
","
def solve():
    n = int(input())
    while True:
        n += 1
        if str(n).count('0') + str(n).count('9') == len(str(n)) - 1:
            break
    print(n - int(input()))

solve()
","0.0","0.0","0.0","0.0","0.0","0.0","0.0","33.33333333333333","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/3","
QUESTION:
You have a long fence which consists of $n$ sections. Unfortunately, it is not painted, so you decided to hire $q$ painters to paint it. $i$-th painter will paint all sections $x$ such that $l_i \le x \le r_i$.

Unfortunately, you are on a tight budget, so you may hire only $q - 2$ painters. Obviously, only painters you hire will do their work.

You want to maximize the number of painted sections if you choose $q - 2$ painters optimally. A section is considered painted if at least one painter paints it.


-----Input-----

The first line contains two integers $n$ and $q$ ($3 \le n, q \le 5000$) — the number of sections and the number of painters availible for hire, respectively.

Then $q$ lines follow, each describing one of the painters: $i$-th line contains two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le n$).


-----Output-----

Print one integer — maximum number of painted sections if you hire $q - 2$ painters.


-----Examples-----
Input
7 5
1 4
4 5
5 6
6 7
3 5

Output
7

Input
4 3
1 1
2 2
3 4

Output
2

Input
4 4
1 1
2 2
2 3
3 4

Output
3
Use user-input-Based format and function signature solve()","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]
    painters.sort(key=lambda x: x[0])

    max_painted = 0
    for i in range(q):
        for j in range(i+1, q):
            painted = 0
            for k in range(n):
                for l, r in [painters[i], painters[j]]:
                    if l <= k+1 <= r:
                        painted += 1
                        break
            max_painted = max(max_painted, painted)

    return max_painted

solve()
","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]
    
    initial_painted_sections = [0] * (n + 1)
    
    for l, r in painters:
        initial_painted_sections[l] += 1
        initial_painted_sections[r + 1] -= 1
    
    prefix_sum = [0] * (n + 1)
    max_painted = 0
    running_sum = 0
    
    for i in range(1, n + 1):
        running_sum += initial_painted_sections[i]
        prefix_sum[i] = running_sum
    
    for i in range(1, n):
        for j in range(i + 1, n + 1):
            total_painted = prefix_sum[i] + prefix_sum[j] - (initial_painted_sections[i] + initial_painted_sections[j])
            max_painted = max(max_painted, total_painted)
    
    print(max_painted)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, q = map(int, input().split())
    painters = [tuple(map(int, input().split())) for _ in range(q)]

    painted_sections = set()
    for i in range(q):
        for j in range(painters[i][0], painters[i][1] + 1):
            painted_sections.add(j)

    max_painted = 0
    for i in range(1, n+1):
        for j in range(i, n+1):
            count = len([x for x in range(i, j+1) if x in painted_sections])
            max_painted = max(max_painted, count)

    return max_painted

# Example usage
print(solve())

solve()","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]
    painters.sort(key=lambda x: x[0])

    max_painted_sections = 0
    for i in range(q):
        for j in range(i + 1, q):
            total_painted = 0
            for k in range(n):
                for l, r in painters[i:j+1]:
                    if l <= k+1 <= r:
                        total_painted += 1
                        break
            max_painted_sections = max(max_painted_sections, total_painted)

    print(max_painted_sections)

import sys

if __name__ == ""__main__"":
    solve()
","
def solve():
    import sys

    n, q = map(int, sys.stdin.readline().strip().split())
    painters = []
    for _ in range(q):
        l, r = map(int, sys.stdin.readline().strip().split())
        painters.append((l, r))

    painters.sort(key=lambda x: x[0])

    max_painted = 0
    for i in range(q):
        for j in range(i + 1, q):
            painted = 0
            for section in range(1, n + 1):
                for painter in painters[i:j+1]:
                    if painter[0] <= section <= painter[1]:
                        painted += 1
                        break
            max_painted = max(max_painted, painted)

    return max_painted

solve()","
from itertools import combinations

def solve():
    # Input
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]

    total_sections = set()
    for l, r in painters:
        total_sections.update(range(l, r + 1))

    max_painted = 0
    for chosen_painters in combinations(painters, q - 2):
        painted_sections = set()
        for l, r in chosen_painters:
            painted_sections.update(range(l, r + 1))
        max_painted = max(max_painted, len(total_sections.union(painted_sections)))

    return max_painted

solve()","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]
    
    painted_sections = set()
    for i in range(q - 2):
        for j in range(i + 1, q - 1):
            painted_sections.update(range(painters[i][0], painters[i][1] + 1))
            painted_sections.update(range(painters[j][0], painters[j][1] + 1))
    
    max_painted = len(painted_sections)
    print(max_painted)

# Main function to read input and call solve()
if __name__ == '__main__':
    solve()
","
def solve():
    from itertools import combinations

    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]

    max_painted = 0

    for hired_painters in combinations(painters, q-2):
        painted_sections = set()
        for l, r in hired_painters:
            for x in range(l, r+1):
                painted_sections.add(x)
        max_painted = max(max_painted, len(painted_sections))

    print(max_painted)
  
solve()","
def solve():
    n, q = map(int, input().split())
    painters = []
    
    for _ in range(q):
        l, r = map(int, input().split())
        painters.append((l, r))
    
    painters.sort(key=lambda x: x[0])
    best_solution = 0
    
    for i in range(q):
        for j in range(i + 1, q):
            painted_sections = 0
            for k in range(n):
                for l, r in painters[i:j+1]:
                    if l <= k + 1 <= r:
                        painted_sections += 1
                        break
            best_solution = max(best_solution, painted_sections)
    
    print(best_solution)

solve()
","
from heapq import *
from collections import deque

def solve():
    n, q = map(int, input().split())
    painters = []
    for _ in range(q):
        l, r = map(int, input().split())
        painters.append((l, r))
    
    painters.sort()

    sections = []
    for l, r in painters:
        heappush(sections, (r, l))

    max_painted = 0
    for i in range(q - 2):
        right, left = heappop(sections)
        if left > max_painted:
            max_painted = left
        if right > max_painted:
            heappush(sections, (right, max_painted))
    
    max_painted = max(max_painted, max(sections, key=lambda x: x[1])[1])

    print(max_painted)

# Input examples
# solve()
","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]

    painter_ranges = []
    for i in range(q):
        for j in range(i+1, q):
            range_intersection = [max(painters[i][0], painters[j][0]), min(painters[i][1], painters[j][1])]
            painter_ranges.append(range_intersection)
    
    max_painted = 0
    for section in range(1, n+1):
        painted_by = 0
        for l, r in painter_ranges:
            if l <= section <= r:
                painted_by += 1
        max_painted = max(max_painted, painted_by)

    print(max_painted)

solve()
","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]

    sections = [0] * (n + 1)
    for l, r in painters:
        sections[l] += 1
        sections[r + 1] -= 1

    partial_sums = [0] * (n + 1)
    for i in range(1, n + 1):
        partial_sums[i] = partial_sums[i - 1] + sections[i]

    max_painted = max(partial_sums)
    print(max_painted)

import sys
solve()
","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]

    sections_painted = [0] * (n + 1)
    for l, r in painters:
        sections_painted[l] += 1
        sections_painted[r + 1] -= 1

    for i in range(1, n + 1):
        sections_painted[i] += sections_painted[i - 1]

    sections_painted.sort()

    return sum(sections_painted[-q+2:])

solve()","
def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]
    sections = [0] * n
    
    for painter in painters:
        for i in range(painter[0]-1, painter[1]):
            sections[i] += 1
    
    sections.sort(reverse=True)
    
    max_sections = 0
    for i in range(q-2):
        max_sections += sections[i]
    
    print(max_sections)

solve()","
def solve():
    import sys
    
    n, q = map(int, input().split())
    painters = []
    
    for _ in range(q):
        l, r = map(int, input().split())
        painters.append((l, r))
    
    painters.sort(key=lambda x: x[0])
    best = 0
    
    for i in range(q):
        for j in range(i, q):
            sections = set()
            for k in range(i, j + 1):
                sections |= set(range(painters[k][0], painters[k][1]+1))
            best = max(best, len(sections))
    
    available_painters = q - 2
    if available_painters < 1:
        print(best)
        return
    
    for i in range(q):
        for j in range(i, q):
            sections = set()
            for k in range(i, j + 1):
                sections |= set(range(painters[k][0], painters[k][1]+1))
            sections_covered = len(sections)
            remaining_painters = q - (j - i + 1)
            best = max(best, sections_covered - remaining_painters)
    
    print(best)


solve()","
from itertools import combinations

def solve():
    n, q = map(int, input().split())
    painters = [list(map(int, input().split())) for _ in range(q)]
    
    max_painted_sections = 0
    for chosen_painters in combinations(painters, q - 2):
        painted_sections = set()
        for painter in chosen_painters:
            for x in range(painter[0], painter[1] + 1):
                painted_sections.add(x)
        max_painted_sections = max(max_painted_sections, len(painted_sections))
    
    print(max_painted_sections)


solve()","0.0","6.666666666666667","0.0","46.666666666666664","0.0","0.0","66.66666666666666","100.0","46.666666666666664","0.0","6.666666666666667","6.666666666666667","0.0","20.0","46.666666666666664","100.0","","","","","","","","","","","","","","","",""
"APPS/4","
QUESTION:
Jamie loves sleeping. One day, he decides that he needs to wake up at exactly hh: mm. However, he hates waking up, so he wants to make waking up less painful by setting the alarm at a lucky time. He will then press the snooze button every x minutes until hh: mm is reached, and only then he will wake up. He wants to know what is the smallest number of times he needs to press the snooze button.

A time is considered lucky if it contains a digit '7'. For example, 13: 07 and 17: 27 are lucky, while 00: 48 and 21: 34 are not lucky.

Note that it is not necessary that the time set for the alarm and the wake-up time are on the same day. It is guaranteed that there is a lucky time Jamie can set so that he can wake at hh: mm.

Formally, find the smallest possible non-negative integer y such that the time representation of the time x·y minutes before hh: mm contains the digit '7'.

Jamie uses 24-hours clock, so after 23: 59 comes 00: 00.


-----Input-----

The first line contains a single integer x (1 ≤ x ≤ 60).

The second line contains two two-digit integers, hh and mm (00 ≤ hh ≤ 23, 00 ≤ mm ≤ 59).


-----Output-----

Print the minimum number of times he needs to press the button.


-----Examples-----
Input
3
11 23

Output
2

Input
5
01 07

Output
0



-----Note-----

In the first sample, Jamie needs to wake up at 11:23. So, he can set his alarm at 11:17. He would press the snooze button when the alarm rings at 11:17 and at 11:20.

In the second sample, Jamie can set his alarm at exactly at 01:07 which is lucky.
Use user-input-Based format and function signature solve()","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    def is_lucky_time(h, m):
        return '7' in str(h) or '7' in str(m)
    
    y = 0
    while not is_lucky_time(hh, mm):
        y += 1
        mm -= x
        if mm < 0:
            mm += 60
            hh = (hh - 1) % 24
    
    print(y)

solve()
","
# Define the solve function
def solve():
    # Import sys module to read input
    import sys

    # Read input values
    x = int(sys.stdin.readline())
    hh, mm = map(int, sys.stdin.readline().split())

    # Calculate the target time in minutes
    target_time = hh * 60 + mm

    # Initialize the number of snooze presses
    snooze_presses = 0

    # Calculate the time y*x minutes before target time and check if it contains digit '7'
    while True:
        target_time -= x
        if target_time < 0:
            target_time += 24 * 60
        if '7' in str(target_time // 60) + str(target_time % 60):
            break
        snooze_presses += 1

    # Print the minimum number of times he needs to press the button
    print(snooze_presses)

# Call the solve function
solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    def contains_lucky_digit(time):
        return '7' in str(time)
    
    y = 0
    alarm_time = hh * 60 + mm
    while True:
        if contains_lucky_digit(hh) or contains_lucky_digit(mm):
            break
        y += 1
        alarm_time -= x
        if alarm_time < 0:
            alarm_time += 24 * 60
        hh, mm = divmod(alarm_time, 60)
    
    print(y)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())

    y = 0
    while True:
        total_minutes = hh * 60 + mm - x*y
        if '7' in str(total_minutes):
            print(y)
            break
        y += 1

if __name__ == ""__main__"":
    solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    count = 0
    while '7' not in str(hh) and '7' not in str(mm):
        count += 1
        mm -= x
        if mm < 0:
            mm += 60
            hh -= 1
        if hh < 0:
            hh += 24

    print(count)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    def lucky_time(hour, minute):
        return '7' in str(hour) or '7' in str(minute)
    
    time = hh * 60 + mm
    
    alarm_time = (time - x) % 1440
    count = 0
    
    while not lucky_time(alarm_time // 60, alarm_time % 60):
        count += 1
        alarm_time = (alarm_time - x) % 1440
        
    print(count)

# Required imports
import sys

# Input
solve()
  ","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())

    y = 0
    while True:
        if '7' in str(hh) or '7' in str(mm):
            break
        y += 1
        mm -= x
        if mm < 0:
            mm += 60
            hh = (hh - 1) % 24

    print(y)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    button_presses = 0
    while '7' not in str(hh) + str(mm):
        mm -= x
        if mm < 0:
            mm += 60
            hh = (hh - 1) % 24
        button_presses += 1
        
    print(button_presses)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    y = 0
    while True:
        if '7' in str(hh) or '7' in str(mm):
            break
        y += 1
        mm -= x
        if mm < 0:
            mm += 60
            hh -= 1
        if hh < 0:
            hh += 24
    
    print(y)

if __name__ == ""__main__"":
    solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    alarm_time = hh * 60 + mm

    count = 0
    while True:
        alarm_time -= x
        if alarm_time < 0:
            alarm_time += 24 * 60
        if '7' in str(alarm_time // 60) or '7' in str(alarm_time % 60):
            break
        count += 1

    print(count)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())

    y = 0
    while True:
        current_time = str((hh - (x * y) // 60) % 24).zfill(2) + str((mm - (x * y) % 60) % 60).zfill(2)
        if '7' in current_time:
            print(y)
            break
        y += 1

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    count = 0
    while '7' not in str(hh) + str(mm):
        mm -= x
        if mm < 0:
            mm += 60
            hh = (hh - 1) % 24
        count += 1
    print(count)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())

    button_presses = 0
    while True:
        if '7' in str(hh) or '7' in str(mm):
            break
        button_presses += 1
        mm -= x
        if mm < 0:
            mm += 60
            hh -= 1
            if hh < 0:
                hh += 24

    print(button_presses)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    total_minutes = hh * 60 + mm
    y = 0

    while True:
        total_minutes -= x
        if total_minutes < 0:
            total_minutes += 1440
        y += 1
        hh, mm = divmod(total_minutes, 60)
        if '7' in str(hh) or '7' in str(mm):
            break

    print(y)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    count = 0
    while '7' not in str(hh) and '7' not in str(mm):
        mm -= x
        if mm < 0:
            mm += 60
            hh -= 1
        if hh < 0:
            hh += 24
        count += 1
    print(count)

solve()
","
def solve():
    x = int(input())
    hh, mm = map(int, input().split())
    
    if '7' in str(hh) or '7' in str(mm):
        return 0
    
    num_snooze = 0
    while True:
        mm -= x
        if mm < 0:
            mm += 60
            hh = (hh - 1) % 24
        
        if '7' in str(hh) or '7' in str(mm):
            return num_snooze
        
        num_snooze += 1

# Required imports
import sys

# Running the function with input from stdin and printing the output
if __name__ == '__main__':
    print(solve())

solve()","100.0","0.0","100.0","53.333333333333336","100.0","0.0","100.0","100.0","100.0","0.0","80.0","100.0","100.0","80.0","100.0","0.0","","","","","","","","","","","","","","","",""
"APPS/5","
QUESTION:
Luba is surfing the Internet. She currently has n opened tabs in her browser, indexed from 1 to n from left to right. The mouse cursor is currently located at the pos-th tab. Luba needs to use the tabs with indices from l to r (inclusive) for her studies, and she wants to close all the tabs that don't belong to this segment as fast as possible.

Each second Luba can either try moving the cursor to the left or to the right (if the cursor is currently at the tab i, then she can move it to the tab max(i - 1, a) or to the tab min(i + 1, b)) or try closing all the tabs to the left or to the right of the cursor (if the cursor is currently at the tab i, she can close all the tabs with indices from segment [a, i - 1] or from segment [i + 1, b]). In the aforementioned expressions a and b denote the minimum and maximum index of an unclosed tab, respectively. For example, if there were 7 tabs initially and tabs 1, 2 and 7 are closed, then a = 3, b = 6.

What is the minimum number of seconds Luba has to spend in order to leave only the tabs with initial indices from l to r inclusive opened?


-----Input-----

The only line of input contains four integer numbers n, pos, l, r (1 ≤ n ≤ 100, 1 ≤ pos ≤ n, 1 ≤ l ≤ r ≤ n) — the number of the tabs, the cursor position and the segment which Luba needs to leave opened.


-----Output-----

Print one integer equal to the minimum number of seconds required to close all the tabs outside the segment [l, r].


-----Examples-----
Input
6 3 2 4

Output
5

Input
6 3 1 3

Output
1

Input
5 2 1 5

Output
0



-----Note-----

In the first test Luba can do the following operations: shift the mouse cursor to the tab 2, close all the tabs to the left of it, shift the mouse cursor to the tab 3, then to the tab 4, and then close all the tabs to the right of it.

In the second test she only needs to close all the tabs to the right of the current position of the cursor.

In the third test Luba doesn't need to do anything.
Use user-input-Based format and function signature solve()","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(r - pos) + 1)
    elif r == n:
        print(abs(pos - l) + 1)
    else:
        print(min(abs(pos - l), abs(pos - r)) + r - l + 2)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(r - pos) + 1)
    elif r == n:
        print(abs(l - pos) + 1)
    else:
        print(min(abs(pos - l), abs(pos - r)) + r - l + 2)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        return 0
    elif l == 1:
        return abs(r - pos) + 1 if pos <= r else r - pos + 1
    elif r == n:
        return abs(pos - l) + 1 if pos >= l else pos - l + 1
    else:
        return min(r - l + abs(pos - l), r - l + abs(pos - r)) + 2

solve()","
def solve():
    n, pos, l, r = map(int, input().split())
    
    if l == 1 and r == n:
        return 0
    elif l == 1:
        return abs(r - pos) + 1
    elif r == n:
        return abs(l - pos) + 1
    else:
        return min(abs(pos - l), abs(pos - r)) + r - l + 2

solve()","
def solve():
    n, pos, l, r = map(int, input().split())
    
    seconds = 0
    if l > 1:
        seconds += 1  # Move cursor to the leftmost tab
        seconds += abs(pos - l)  # Move cursor to the left end of the segment
    if r < n:
        seconds += 1  # Move cursor to the rightmost tab
        seconds += abs(pos - r)  # Move cursor to the right end of the segment
    
    print(seconds)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        return 0
    elif l == 1:
        return abs(r - pos) + 1 if pos <= r else r - pos + 2
    elif r == n:
        return abs(l - pos) + 1 if pos >= l else pos - l + 2
    else:
        return min(abs(pos - l), abs(pos - r)) + r - l + 2

solve()","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(pos - r) + 1)
    elif r == n:
        print(abs(pos - l) + 1)
    else:
        print(min(abs(pos - l), abs(pos - r)) + r - l + 2)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(pos - r) + 1)
    elif r == n:
        print(abs(pos - l) + 1)
    else:
        print(min(abs(pos - l), abs(pos - r)) + r - l + 2)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(r - pos) + 1)
    elif r == n:
        print(abs(pos - l) + 1)
    else:
        print(min(abs(r - pos), abs(pos - l)) + r - l + 2)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(pos - r) + 1) if pos <= r else print(r - 1 + abs(pos - r) + 1) if pos > r else print(abs(pos - r) + 1)
    elif r == n:
        print(abs(pos - l) + 1)  if pos >= l else print(n - l + abs(pos - l) + 1) if pos < l else print(abs(pos - l) + 1)
    else:
        print(min(abs(pos - l), abs(pos - r)) + r - l + 2)

solve()","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(r - pos) + 1)
    elif r == n:
        print(abs(l - pos) + 1)
    else:
        print(min(r - pos, pos - l) + r - l + 2)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(r - pos) + 1)
    elif r == n:
        print(abs(l - pos) + 1)
    else:
        print(2 + min(abs(pos - l), abs(pos - r)) + r - l)

solve()","
def solve():
    n, pos, l, r = map(int, input().split())
    
    if l == 1 and r == n:
        return 0
    
    if l == 1:
        return abs(r - pos) + 1
    
    if r == n:
        return abs(pos - l) + 1
    
    return min(abs(pos - l), abs(pos - r)) + r - l + 2

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(r - pos) + 1)
    elif r == n:
        print(abs(l - pos) + 1)
    else:
        print(min(r - l, abs(pos - l), abs(r - pos)) + r - l + 2)

solve()","
def solve():
    n, pos, l, r = map(int, input().split())
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(pos - r) + 1)
    elif r == n:
        print(abs(pos - l) + 1)
    else:
        print(min(abs(pos - l), abs(pos - r)) + r - l + 2)

solve()
","
def solve():
    n, pos, l, r = map(int, input().split())
    
    if l == 1 and r == n:
        print(0)
    elif l == 1:
        print(abs(r - pos) + 1)
    elif r == n:
        print(abs(l - pos) + 1)
    else:
        print(min(abs(pos - l), abs(pos - r)) + r - l + 2)  

solve()
","100.0","100.0","0.0","0.0","60.0","0.0","100.0","100.0","100.0","93.33333333333333","100.0","100.0","0.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/6","
QUESTION:
You are fighting with Zmei Gorynich — a ferocious monster from Slavic myths, a huge dragon-like reptile with multiple heads! 

 $m$ 

Initially Zmei Gorynich has $x$ heads. You can deal $n$ types of blows. If you deal a blow of the $i$-th type, you decrease the number of Gorynich's heads by $min(d_i, curX)$, there $curX$ is the current number of heads. But if after this blow Zmei Gorynich has at least one head, he grows $h_i$ new heads. If $curX = 0$ then Gorynich is defeated. 

You can deal each blow any number of times, in any order.

For example, if $curX = 10$, $d = 7$, $h = 10$ then the number of heads changes to $13$ (you cut $7$ heads off, but then Zmei grows $10$ new ones), but if $curX = 10$, $d = 11$, $h = 100$ then number of heads changes to $0$ and Zmei Gorynich is considered defeated.

Calculate the minimum number of blows to defeat Zmei Gorynich!

You have to answer $t$ independent queries.


-----Input-----

The first line contains one integer $t$ ($1 \le t \le 100$) – the number of queries.

The first line of each query contains two integers $n$ and $x$ ($1 \le n \le 100$, $1 \le x \le 10^9$) — the number of possible types of blows and the number of heads Zmei initially has, respectively.

The following $n$ lines of each query contain the descriptions of types of blows you can deal. The $i$-th line contains two integers $d_i$ and $h_i$ ($1 \le d_i, h_i \le 10^9$) — the description of the $i$-th blow.


-----Output-----

For each query print the minimum number of blows you have to deal to defeat Zmei Gorynich. 

If Zmei Gorynuch cannot be defeated print $-1$.


-----Example-----
Input
3
3 10
6 3
8 2
1 4
4 10
4 1
3 2
2 6
1 100
2 15
10 11
14 100

Output
2
3
-1



-----Note-----

In the first query you can deal the first blow (after that the number of heads changes to $10 - 6 + 3 = 7$), and then deal the second blow.

In the second query you just deal the first blow three times, and Zmei is defeated. 

In third query you can not defeat Zmei Gorynich. Maybe it's better to convince it to stop fighting?
Use user-input-Based format and function signature solve()","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            elif d - h <= 0:
                continue
            else:
                min_blows = min(min_blows, (x - d + h - 1) // (d - h) + 1)
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","
def solve():
    t = int(input().strip())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            elif d - h <= 0:
                continue
            else:
                min_blows = min(min_blows, (x - d)//(d - h) + 1)
        if min_blows == float('inf'):
            print('-1')
        else:
            print(min_blows)

solve()","
def solve():
    t = int(input())
    
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)

        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            elif (x - d) <= 0:
                continue
            else:
                new_heads = ((x - d + (d - 1)) // d) * h
                min_blows = min(min_blows, ((x - 1) // d) + 1)
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
  ","
def solve():
    t = int(input())
    
    for _ in range(t):
        n, x = map(int, input().split())
        blows = []
        for _ in range(n):
            d, h = map(int, input().split())
            blows.append((d, h))

        min_blows = float('inf')
        for i in range(2**n):
            cur_x = x
            cur_blows = 0
            for j in range(n):
                if i & (1 << j):
                    cur_d, cur_h = blows[j]
                    cur_x -= min(cur_d, cur_x)
                    cur_x += cur_h
                    cur_blows += 1
                if cur_x <= 0:
                    min_blows = min(min_blows, cur_blows)
                    break
        
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            else:
                remaining_heads = max(x - d, 0)
                min_blows = min(min_blows, (h - 1) // remaining_heads + 1)
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","
def solve():
    t = int(input())
    
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        
        can_defeat = False
        
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
                can_defeat = True
            else:
                remaining_heads = max(0, x - d) + h
                if remaining_heads <= 0:
                    min_blows = min(min_blows, 1)
                    can_defeat = True
                else:
                    min_blows = min(min_blows, ((x - 1) // d) + 1)
        
        if can_defeat:
            print(min_blows)
        else:
            print(-1)

# Call the function to run
solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            else:
                k = max((x - d - 1) // (d - h) + 1, 0)
                min_blows = min(min_blows, k + 1)
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","
def solve():
    t = int(input())
    
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            elif d - h <= 0:
                continue
            else:
                min_blows = min(min_blows, (x - d) // (d - h) + 1 + ((x - d) % (d - h) != 0))
        
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

# Call the function to execute
solve()
  ","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            else:
                remaining_heads = x - d
                additional_heads = (h - 1) // d
                total_heads = 1 + additional_heads * d
                min_blows = min(min_blows, (remaining_heads + total_heads - 1) // total_heads + 1)
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            else:
                blows_needed = max((x - d + d - 1) // d, 0)  # Integer division rounded up
                min_blows = min(min_blows, blows_needed + 1)
        print(min_blows if min_blows != float('inf') else -1)

solve()","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        blows = [tuple(map(int, input().split())) for _ in range(n)]
        min_blows = -1

        for i in range(1, x + 1):
            cur_x = x
            num_blows = 0
            for d, h in blows:
                while cur_x > 0:
                    cur_x -= min(d, cur_x)
                    if cur_x > 0:
                        num_blows += 1
                        cur_x += h
                if cur_x <= 0:
                    if min_blows == -1 or num_blows < min_blows:
                        min_blows = num_blows
        
        print(min_blows)

solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            elif (x - d) // (d - h) >= 0 and (x - d) % (d - h) == 0:
                min_blows = min(min_blows, (x - d) // (d - h) + 1)
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        blows = [list(map(int, input().split())) for _ in range(n)]
        min_blows = float('inf')
        for di, hi in blows:
            if di >= x:
                min_blows = min(min_blows, 1)
            elif hi >= 1:
                min_blows = min(min_blows, (x - di) // (di - hi) + 2)
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        min_blows = float('inf')
        for _ in range(n):
            d, h = map(int, input().split())
            if d >= x:
                min_blows = min(min_blows, 1)
            elif d - h <= 0:
                continue
            else:
                min_blows = min(min_blows, (x - d + h - 1) // (d - h) + 1)
            
        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)


solve()","
def solve():
    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        blows = []
        for _ in range(n):
            d, h = map(int, input().split())
            blows.append((d, h))

        min_blows = float('inf')
        for i in range(1, x+1):
            cur_x = x
            cur_blows = 0
            for d, h in blows:
                while cur_x > 0 and d > 0:
                    cur_x -= min(d, cur_x)
                    cur_blows += 1
                    cur_x += h - 1
                if cur_x <= 0:
                    min_blows = min(min_blows, cur_blows)
                    break

        if min_blows == float('inf'):
            print(-1)
        else:
            print(min_blows)

solve()
","86.66666666666667","86.66666666666667","86.66666666666667","86.66666666666667","0.0","86.66666666666667","86.66666666666667","86.66666666666667","93.33333333333333","86.66666666666667","86.66666666666667","0.0","86.66666666666667","80.0","86.66666666666667","100.0","","","","","","","","","","","","","","","",""
"APPS/7","
QUESTION:
Anton likes to listen to fairy tales, especially when Danik, Anton's best friend, tells them. Right now Danik tells Anton a fairy tale:

""Once upon a time, there lived an emperor. He was very rich and had much grain. One day he ordered to build a huge barn to put there all his grain. Best builders were building that barn for three days and three nights. But they overlooked and there remained a little hole in the barn, from which every day sparrows came through. Here flew a sparrow, took a grain and flew away...""

More formally, the following takes place in the fairy tale. At the beginning of the first day the barn with the capacity of n grains was full. Then, every day (starting with the first day) the following happens:  m grains are brought to the barn. If m grains doesn't fit to the barn, the barn becomes full and the grains that doesn't fit are brought back (in this problem we can assume that the grains that doesn't fit to the barn are not taken into account).  Sparrows come and eat grain. In the i-th day i sparrows come, that is on the first day one sparrow come, on the second day two sparrows come and so on. Every sparrow eats one grain. If the barn is empty, a sparrow eats nothing. 

Anton is tired of listening how Danik describes every sparrow that eats grain from the barn. Anton doesn't know when the fairy tale ends, so he asked you to determine, by the end of which day the barn will become empty for the first time. Help Anton and write a program that will determine the number of that day!


-----Input-----

The only line of the input contains two integers n and m (1 ≤ n, m ≤ 10^18) — the capacity of the barn and the number of grains that are brought every day.


-----Output-----

Output one integer — the number of the day when the barn will become empty for the first time. Days are numbered starting with one.


-----Examples-----
Input
5 2

Output
4

Input
8 1

Output
5



-----Note-----

In the first sample the capacity of the barn is five grains and two grains are brought every day. The following happens:  At the beginning of the first day grain is brought to the barn. It's full, so nothing happens.  At the end of the first day one sparrow comes and eats one grain, so 5 - 1 = 4 grains remain.  At the beginning of the second day two grains are brought. The barn becomes full and one grain doesn't fit to it.  At the end of the second day two sparrows come. 5 - 2 = 3 grains remain.  At the beginning of the third day two grains are brought. The barn becomes full again.  At the end of the third day three sparrows come and eat grain. 5 - 3 = 2 grains remain.  At the beginning of the fourth day grain is brought again. 2 + 2 = 4 grains remain.  At the end of the fourth day four sparrows come and eat grain. 4 - 4 = 0 grains remain. The barn is empty. 

So the answer is 4, because by the end of the fourth day the barn becomes empty.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    return day

solve()","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    return day

solve()","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            print(day)
            break
        n += m
        day += 1

solve()
","
def solve():
    n, m = map(int, input().split())

    day = 1
    grains = n
    sparrows = 0

    while grains > 0:
        grains += m
        grains -= sparrows
        sparrows += day
        day += 1

    print(day-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    
    day = 1
    grains = n
    while grains > 0:
        if grains >= day:
            grains -= day
        else:
            break
        grains += m
        day += 1
        
    return day - 1

solve()","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    print(day)

solve()","
def solve():
    n, m = map(int, input().split())
    
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    
    return day

solve()","
def solve():
    n,m = map(int, input().split())
    day = 1
    
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    
    print(day)

solve()
","
def solve():
    n, m = map(int, input().split())
    
    day = 1
    grains_remain = n
    
    while grains_remain > 0:
        grains_remain += m
        
        if grains_remain >= day:
            grains_remain -= day
        
        day += 1
    
    return day - 1

solve()","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    return day

solve()","
def solve():
    n, m = map(int, input().split())
    
    day = 1
    while n > 0:
        if n < day:
            print(day)
            break
        n -= day if n >= m else n
        day += 1

solve()
","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n = min(n+m, 10**18)
        day += 1
    print(day)

solve()
","
def solve():
    n, m = map(int, input().split())
    day = 0
    grains = n
    while grains > 0:
        day += 1
        grains -= day
        if grains < 0:
            grains += m
    print(day)


solve()","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        if n >= day:
            n -= day
        else:
            break
        n += m
        day += 1
    return day - 1

solve()","
def solve():
    n, m = map(int, input().split())
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    return day

solve()","
def solve():
    n, m = map(int, input().split())
    
    day = 1
    while n > 0:
        n -= day
        if n <= 0:
            break
        n += m
        day += 1
    
    print(day)

solve()","0.0","0.0","42.857142857142854","9.090909090909092","0.0","42.857142857142854","0.0","42.857142857142854","0.0","0.0","0.0","42.857142857142854","57.14285714285714","0.0","0.0","42.857142857142854","","","","","","","","","","","","","","","",""
"APPS/8","
QUESTION:
Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from $1$ to $9$). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, $\ldots$, 9m, 1p, 2p, $\ldots$, 9p, 1s, 2s, $\ldots$, 9s.

In order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.

Do you know the minimum number of extra suited tiles she needs to draw so that she can win?

Here are some useful definitions in this game:  A mentsu, also known as meld, is formed by a koutsu or a shuntsu;  A koutsu, also known as triplet, is made of three identical tiles, such as [1m, 1m, 1m], however, [1m, 1p, 1s] or [1m, 4m, 7m] is NOT a koutsu;  A shuntsu, also known as sequence, is made of three sequential numbered tiles in the same suit, such as [1m, 2m, 3m] and [5s, 7s, 6s], however, [9m, 1m, 2m] or [1m, 2p, 3s] is NOT a shuntsu. 

Some examples:   [2m, 3p, 2s, 4m, 1s, 2s, 4s] — it contains no koutsu or shuntsu, so it includes no mentsu;  [4s, 3m, 3p, 4s, 5p, 4s, 5p] — it contains a koutsu, [4s, 4s, 4s], but no shuntsu, so it includes a mentsu;  [5p, 5s, 9m, 4p, 1s, 7p, 7m, 6p] — it contains no koutsu but a shuntsu, [5p, 4p, 6p] or [5p, 7p, 6p], so it includes a mentsu. 

Note that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.


-----Input-----

The only line contains three strings — the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from $1$ to $9$ and the second character is m, p or s.


-----Output-----

Print a single integer — the minimum number of extra suited tiles she needs to draw.


-----Examples-----
Input
1s 2s 3s

Output
0

Input
9m 9m 9m

Output
0

Input
3p 9m 2p

Output
1



-----Note-----

In the first example, Tokitsukaze already has a shuntsu.

In the second example, Tokitsukaze already has a koutsu.

In the third example, Tokitsukaze can get a shuntsu by drawing one suited tile — 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].
Use user-input-Based format and function signature solve()","
def solve():
    import itertools

    def is_koutsu(tiles):
        return len(set(tiles)) == 1

    def is_shuntsu(tiles):
        return sorted(tiles) in [[x, x+1, x+2] for x in range(1, 8)]

    def has_mentsu(tiles):
        for i in range(0, 3):
            for comb in itertools.combinations(tiles, 3):
                if is_koutsu(comb) or is_shuntsu(comb):
                    return True
            tiles.append(tiles.pop(0))
        return False

    tiles = input().split()
    tiles = [int(tile[0]) for tile in tiles]

    if has_mentsu(tiles):
        print(0)
    else:
        print(1)

solve()
","
def solve():
    hand = input().split()
    
    hand_dict = {}
    for tile in hand:
        suit = tile[1]
        if suit not in hand_dict:
            hand_dict[suit] = []
        hand_dict[suit].append(int(tile[0]))
    
    extra_tiles_needed = 2
    for suit in hand_dict:
        hand_dict[suit].sort()
        if len(hand_dict[suit]) >= 3:
            if hand_dict[suit][2] - hand_dict[suit][0] <= 2:
                extra_tiles_needed = 0
            elif len(hand_dict[suit]) == 3:
                extra_tiles_needed = min(extra_tiles_needed, 2)
            elif len(hand_dict[suit]) == 4:
                extra_tiles_needed = min(extra_tiles_needed, 1)
    
    print(extra_tiles_needed)

solve()
","
def solve():
    hand = input().split()
    suits = {'m': [], 'p': [], 's': []}

    for tile in hand:
        suits[tile[1]].append(int(tile[0]))

    extra_tiles = 2

    for suit in suits.values():
        suit.sort()
        if len(suit) < 3:
            diff = 3 - len(suit)
            extra_tiles = min(extra_tiles, diff)

        for i in range(len(suit) - 2):
            if suit[i:i + 3] == [suit[i], suit[i] + 1, suit[i] + 2]:
                extra_tiles = 0
                break

        if extra_tiles == 0:
            break
    
    print(extra_tiles)

solve()
","
def solve():
    from collections import Counter

    def is_koutsu(tiles):
        return any(count >= 3 for count in Counter(tiles).values())

    def is_shuntsu(tiles):
        suits = {}
        for tile in tiles:
            number, suit = tile[0], tile[1]
            if suit not in suits:
                suits[suit] = [int(number)]
            else:
                suits[suit].append(int(number))
        for numbers in suits.values():
            numbers.sort()
            if len(numbers) < 3:
                continue
            for i in range(len(numbers) - 2):
                if numbers[i] + 1 in numbers and numbers[i] + 2 in numbers:
                    return True
        return False

    hand = input().split()
    if is_koutsu(hand) or is_shuntsu(hand):
        return 0
    else:
        return 1

solve()","
def solve():
    import itertools
    hand = input().split()
    suits = {'m': [], 'p': [], 's': []}
    
    for tile in hand:
        number, suit = tile
        suits[suit].append(int(number))
    
    extra_tiles_needed = float('inf')
    
    for suit in suits.values():
        suit.sort()
        
        for i in range(len(suit)):
            for j in range(i+2, len(suit)):
                if suit[j] - suit[i] <= 2 and all(suit[k] in suit[i:j+1] for k in range(i,j+1)):
                    extra_tiles_needed = min(extra_tiles_needed, 3 - (j-i+1))
    
    print(extra_tiles_needed)

solve()
","
def solve():
    import itertools

    def is_koutsu(tiles):
        if len(set(tiles)) == 1:
            return True
        return False

    def is_shuntsu(tiles):
        if len(set(tiles)) == 3 and all(tile in tiles for tile in range(min(tiles), max(tiles)+1)):
            return True
        return False

    def has_mentsu(tiles):
        for i in range(3):
            for subset in itertools.combinations(tiles, 3):
                if is_koutsu(subset) or is_shuntsu(subset):
                    return True
        return False

    hand = input().split()
    tiles = []
    for tile in hand:
        tiles.append(int(tile[0]))

    if has_mentsu(tiles):
        print(0)
    else:
        print(1)

solve()","
def solve():
    import collections

    def is_koutsu(hand):
        counter = collections.Counter(hand)
        return any(count >= 3 for count in counter.values())

    def is_shuntsu(hand):
        suits = collections.defaultdict(list)
        for tile in hand:
            number, suit = tile
            suits[suit].append(number)
        
        for suit in suits.values():
            suit.sort()
            for i in range(len(suit)):
                if i+2 < len(suit) and suit[i+1] == suit[i]+1 and suit[i+2] == suit[i]+2:
                    return True
        
        return False

    def count_extra_tiles(hand):
        if is_koutsu(hand):
            return 0
        if is_shuntsu(hand):
            return 0
        
        return 1

    tiles = input().split()
    print(count_extra_tiles(tiles))


solve()
","
def solve():
    tiles = input().split()
    
    suits = {'m': [], 'p': [], 's': []}
    
    for tile in tiles:
        suits[tile[1]].append(int(tile[0]))
    
    extra_tiles = 2
    for suit in suits.values():
        suit.sort()
        for i in range(len(suit) - 2):
            if suit[i] + 1 in suit and suit[i] + 2 in suit:
                extra_tiles = 0

    print(extra_tiles)

solve()","
def solve():
    suited_tiles = input().split()
    suits = [tile[1] for tile in suited_tiles]
    numbers = [int(tile[0]) for tile in suited_tiles]
    
    mentsu_count = 0
    
    for suit in ""mps"":
        suit_tiles = [num for num, s in zip(numbers, suits) if s == suit]
        suit_tiles.sort()
        
        for i in range(len(suit_tiles) - 2):
            if suit_tiles[i] == suit_tiles[i+1] == suit_tiles[i+2]:
                mentsu_count += 1
                break
            elif suit_tiles[i] + 1 in suit_tiles and suit_tiles[i] + 2 in suit_tiles:
                mentsu_count += 1
                break
    
    extra_tiles_needed = 2 - mentsu_count
    extra_tiles_needed = max(extra_tiles_needed, 0)
    
    print(extra_tiles_needed)

solve()
","
def solve():
    import itertools
    
    def is_koutsu(tiles):
        return len(set(tiles)) == 1
    
    def is_shuntsu(tiles):
        suits = ['m', 'p', 's']
        for s in suits:
            suit_tiles = [int(tile[0]) for tile in tiles if tile[1] == s]
            suit_tiles.sort()
            for i in range(len(suit_tiles)-2):
                if suit_tiles[i:i+3] == [suit_tiles[i], suit_tiles[i]+1, suit_tiles[i]+2]:
                    return True
        return False
    
    def has_mentsu(tiles):
        if is_koutsu(tiles) or is_shuntsu(tiles):
            return True
        return False
    
    tiles = input().split()
    extra_tiles = 0
    for comb in itertools.combinations(['1m', '2m', '3m', '4m', '5m', '6m', '7m', '8m', '9m', '1p', '2p', '3p', '4p', '5p', '6p', '7p', '8p', '9p', '1s', '2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s'], 3):
        if has_mentsu(list(comb) + tiles):
            break
        extra_tiles += 1
    
    print(extra_tiles)


solve()","
def solve():
    import itertools

    hand = input().split()
    suits = {'m': [], 'p': [], 's': []}

    for tile in hand:
        number = int(tile[0])
        suit = tile[1]
        suits[suit].append(number)

    extra_tiles_needed = float('inf')

    for suit in suits.values():
        suit.sort()
        for i in range(len(suit)):
            for j in range(i, len(suit)+1):
                if j-i >= 3:
                    remain = suit[:i] + suit[j:]
                    remain_mins = [abs(x - remain[idx]) for idx, x in enumerate(remain[1:], start=1)]
                    extra_tiles_needed = min(extra_tiles_needed, sum(remain_mins))

    print(extra_tiles_needed)

solve()","
def solve():
    import itertools

    hand = input().split()
    hand_suits = [tile[1] for tile in hand]
    hand_nums = [int(tile[0]) for tile in hand]

    def is_shuntsu(tiles):
        return sorted(tiles) in [[x, x + 1, x + 2] for x in range(1, 8)]

    def is_koutsu(tiles):
        return all(tile == tiles[0] for tile in tiles)

    def has_mentsu(hand):
        for i in range(3):
            for subset in itertools.combinations(hand, i):
                if is_koutsu(subset) or is_shuntsu(subset):
                    return True
        return False

    extra_tiles = 0
    while not has_mentsu(hand):
        extra_tiles += 1
        hand.append(input().strip()[::-1])

    print(extra_tiles)

solve()
","
def solve():
    tiles = input().split()
    hand = [tile[1] for tile in tiles]
    
    koutsu_count = sum(hand.count(hand[i]) // 3 for i in range(3))
    
    shuntsu_count = 0
    for i in range(1, 8):
        if all(str(i+j)+hand[0] in hand for j in range(3)):
            shuntsu_count += 1
    
    min_extra_tiles = max(0, 2 - koutsu_count - shuntsu_count)
    
    print(min_extra_tiles)

solve()","
def solve():
    hand = input().split()
    
    suits = {'m': [], 'p': [], 's': []}
    for tile in hand:
        suits[tile[1]].append(int(tile[0]))
    
    min_draws = 2
    for suit in suits.values():
        suit.sort()
        if len(suit) >= 2:
            min_draws = min(min_draws, min(suit[1] - suit[0], suit[2] - suit[1]) - 1)
    
    print(max(0, min_draws))

solve()
","
def solve():
    import itertools

    def is_koutsu(tiles):
        for tile in tiles:
            if tiles.count(tile) >= 3:
                return True
        return False

    def is_shuntsu(tiles):
        suit = tiles[0][1]
        for i in range(1, 8):
            if [str(i) + suit, str(i+1) + suit, str(i+2) + suit] in tiles:
                return True
        return False

    hand = input().split()
    possible_tiles = []
    extra_tiles = 0

    for tile in hand:
        possible_tiles.append(tile)
        possible_tiles.append(tile)
        possible_tiles.append(tile)

    if is_koutsu(possible_tiles) or is_shuntsu(possible_tiles):
        print(0)
    else:
        all_possible_tiles = [str(digit) + suit for digit in range(1, 10) for suit in ['m', 'p', 's']]
        for draw in itertools.product(all_possible_tiles, repeat=2):
            if draw[0] != draw[1]:
                if is_koutsu(possible_tiles + [draw[0], draw[1]]) or is_shuntsu(possible_tiles + [draw[0], draw[1]]):
                    extra_tiles = 1
                    break

        print(extra_tiles)

solve()
","
def solve():
    tiles = input().split()
    
    suits = {'m': [], 'p': [], 's': []}
    for tile in tiles:
        num, suit = int(tile[0]), tile[1]
        suits[suit].append(num)
    
    extra_tiles_needed = 2
    for suit_values in suits.values():
        suit_values.sort()
        for i in range(0, len(suit_values) - 2):
            if suit_values[i+2] - suit_values[i] <= 2:
                extra_tiles_needed = min(extra_tiles_needed, 0)
    
    print(extra_tiles_needed)

solve()
","46.666666666666664","66.66666666666666","53.333333333333336","0.0","13.333333333333334","46.666666666666664","26.666666666666668","60.0","53.333333333333336","13.333333333333334","13.333333333333334","13.333333333333334","66.66666666666666","46.666666666666664","13.333333333333334","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/9","
QUESTION:
Yet another round on DecoForces is coming! Grandpa Maks wanted to participate in it but someone has stolen his precious sofa! And how can one perform well with such a major loss?

Fortunately, the thief had left a note for Grandpa Maks. This note got Maks to the sofa storehouse. Still he had no idea which sofa belongs to him as they all looked the same!

The storehouse is represented as matrix n × m. Every sofa takes two neighbouring by some side cells. No cell is covered by more than one sofa. There can be empty cells.

Sofa A is standing to the left of sofa B if there exist two such cells a and b that x_{a} < x_{b}, a is covered by A and b is covered by B. Sofa A is standing to the top of sofa B if there exist two such cells a and b that y_{a} < y_{b}, a is covered by A and b is covered by B. Right and bottom conditions are declared the same way. 

Note that in all conditions A ≠ B. Also some sofa A can be both to the top of another sofa B and to the bottom of it. The same is for left and right conditions.

The note also stated that there are cnt_{l} sofas to the left of Grandpa Maks's sofa, cnt_{r} — to the right, cnt_{t} — to the top and cnt_{b} — to the bottom.

Grandpa Maks asks you to help him to identify his sofa. It is guaranteed that there is no more than one sofa of given conditions.

Output the number of Grandpa Maks's sofa. If there is no such sofa that all the conditions are met for it then output -1.


-----Input-----

The first line contains one integer number d (1 ≤ d ≤ 10^5) — the number of sofas in the storehouse.

The second line contains two integer numbers n, m (1 ≤ n, m ≤ 10^5) — the size of the storehouse.

Next d lines contains four integer numbers x_1, y_1, x_2, y_2 (1 ≤ x_1, x_2 ≤ n, 1 ≤ y_1, y_2 ≤ m) — coordinates of the i-th sofa. It is guaranteed that cells (x_1, y_1) and (x_2, y_2) have common side, (x_1, y_1)  ≠  (x_2, y_2) and no cell is covered by more than one sofa.

The last line contains four integer numbers cnt_{l}, cnt_{r}, cnt_{t}, cnt_{b} (0 ≤ cnt_{l}, cnt_{r}, cnt_{t}, cnt_{b} ≤ d - 1).


-----Output-----

Print the number of the sofa for which all the conditions are met. Sofas are numbered 1 through d as given in input. If there is no such sofa then print -1.


-----Examples-----
Input
2
3 2
3 1 3 2
1 2 2 2
1 0 0 1

Output
1

Input
3
10 10
1 2 1 1
5 5 6 5
6 4 5 4
2 1 2 0

Output
2

Input
2
2 2
2 1 1 1
1 2 2 2
1 0 0 0

Output
-1



-----Note-----

Let's consider the second example.   The first sofa has 0 to its left, 2 sofas to its right ((1, 1) is to the left of both (5, 5) and (5, 4)), 0 to its top and 2 to its bottom (both 2nd and 3rd sofas are below).  The second sofa has cnt_{l} = 2, cnt_{r} = 1, cnt_{t} = 2 and cnt_{b} = 0.  The third sofa has cnt_{l} = 2, cnt_{r} = 1, cnt_{t} = 1 and cnt_{b} = 1. 

So the second one corresponds to the given conditions.

In the third example   The first sofa has cnt_{l} = 1, cnt_{r} = 1, cnt_{t} = 0 and cnt_{b} = 1.  The second sofa has cnt_{l} = 1, cnt_{r} = 1, cnt_{t} = 1 and cnt_{b} = 0. 

And there is no sofa with the set (1, 0, 0, 0) so the answer is -1.
Use user-input-Based format and function signature solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, sofa in enumerate(sofas, 1):
        left = right = top = bottom = 0
        for other_sofa in sofas:
            if other_sofa[0] < sofa[0] and other_sofa[2] < sofa[0]:
                left += 1
            if other_sofa[0] > sofa[2] and other_sofa[2] > sofa[2]:
                right += 1
            if other_sofa[1] < sofa[1] and other_sofa[3] < sofa[1]:
                top += 1
            if other_sofa[1] > sofa[3] and other_sofa[3] > sofa[3]:
                bottom += 1
        
        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:
            return i
    
    return -1

solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, sofa in enumerate(sofas):
        x1, y1, x2, y2 = sofa
        current_l = current_r = current_t = current_b = 0
        
        for other_sofa in sofas:
            if other_sofa == sofa:
                continue
            
            ox1, oy1, ox2, oy2 = other_sofa
            
            if ox1 > x1 and ox1 < x2 and y1 <= oy1 <= y2:
                current_r += 1
            if ox2 < x2 and ox2 > x1 and y1 <= oy1 <= y2:
                current_l += 1
            if oy1 > y1 and oy1 < y2 and x1 <= ox1 <= x2:
                current_b += 1
            if oy2 < y2 and oy2 > y1 and x1 <= ox1 <= x2:
                current_t += 1
        
        if current_l == cnt_l and current_r == cnt_r and current_t == cnt_t and current_b == cnt_b:
            return i + 1
    
    return -1


solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, sofa in enumerate(sofas, start=1):
        left = 0
        right = 0
        top = 0
        bottom = 0
        for other_sofa in sofas:
            if other_sofa[0] > sofa[2]:
                left += 1
            if other_sofa[2] < sofa[0]:
                right += 1
            if other_sofa[1] > sofa[3]:
                top += 1
            if other_sofa[3] < sofa[1]:
                bottom += 1
        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:
            return i
    
    return -1

solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    sofas = []
    
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    target_sofa = -1
    
    for i, (x1, y1, x2, y2) in enumerate(sofas, start=1):
        left_sofas = right_sofas = top_sofas = bottom_sofas = 0
        
        for x, y in sofas:
            if x < x1:
                left_sofas += 1
            elif x > x2:
                right_sofas += 1
            if y < y1:
                top_sofas += 1
            elif y > y2:
                bottom_sofas += 1
        
        if left_sofas == cnt_l and right_sofas == cnt_r and top_sofas == cnt_t and bottom_sofas == cnt_b:
            target_sofa = i
            break
    
    print(target_sofa)

solve()
","
def solve():
    import sys

    d = int(input())
    n, m = map(int, input().split())
    sofa_coords = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofa_coords.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())

    possible_sofa = -1
    for i in range(d):
        cnt_left = 0
        cnt_right = 0
        cnt_top = 0
        cnt_bottom = 0
        for j in range(d):
            if sofa_coords[j][0] < sofa_coords[i][0] and sofa_coords[j][2] == sofa_coords[i][0]:
                cnt_left += 1
            if sofa_coords[j][0] > sofa_coords[i][0] and sofa_coords[j][0] == sofa_coords[i][2]:
                cnt_right += 1
            if sofa_coords[j][1] < sofa_coords[i][1] and sofa_coords[j][3] == sofa_coords[i][1]:
                cnt_top += 1
            if sofa_coords[j][1] > sofa_coords[i][1] and sofa_coords[j][1] == sofa_coords[i][3]:
                cnt_bottom += 1
        
        if cnt_left == cnt_l and cnt_right == cnt_r and cnt_top == cnt_t and cnt_bottom == cnt_b:
            possible_sofa = i+1
            break

    print(possible_sofa)

  
solve()","
def solve():
    n = int(input())
    sofas = []
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((min(x1, x2), max(x1, x2), min(y1, y2), max(y1, y2)))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, sofa in enumerate(sofas, 1):
        left_sofas = right_sofas = top_sofas = bottom_sofas = 0
        
        for j, other_sofa in enumerate(sofas, 1):
            if sofa[0] > other_sofa[1]:
                left_sofas += 1
            if sofa[1] < other_sofa[0]:
                right_sofas += 1
            if sofa[2] > other_sofa[3]:
                top_sofas += 1
            if sofa[3] < other_sofa[2]:
                bottom_sofas += 1
        
        if left_sofas == cnt_l and right_sofas == cnt_r and top_sofas == cnt_t and bottom_sofas == cnt_b:
            return i
    
    return -1

solve()","
def solve():
    # Input
    d = int(input())
    n, m = map(int, input().split())
    sofas = [list(map(int, input().split())) for _ in range(d)]
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    # Processing
    for i in range(d):
        left_sofas, right_sofas, top_sofas, bottom_sofas = 0, 0, 0, 0
        
        for j in range(d):
            if sofas[j][0] < sofas[i][0]:  # Check sofas to the left
                left_sofas += 1
            if sofas[j][0] > sofas[i][0]:  # Check sofas to the right
                right_sofas += 1
            if sofas[j][1] < sofas[i][1]:  # Check sofas to the top
                top_sofas += 1
            if sofas[j][1] > sofas[i][1]:  # Check sofas to the bottom
                bottom_sofas += 1
        
        if left_sofas == cnt_l and right_sofas == cnt_r and top_sofas == cnt_t and bottom_sofas == cnt_b:
            return i + 1
    
    return -1

solve()","
from collections import defaultdict

def solve():
    d = int(input())
    n, m = map(int, input().split())
    
    sofas = defaultdict(list)

    for i in range(1, d+1):
        x1, y1, x2, y2 = map(int, input().split())
        sofas[i] = [x1, y1, x2, y2]

    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())

    left = [0] * (n + 1)
    right = [0] * (n + 1)
    top = [0] * (m + 1)
    bottom = [0] * (m + 1)

    for i in range(1, d+1):
        x1, y1, x2, y2 = sofas[i]
        left_x, right_x = min(x1, x2), max(x1, x2)
        top_y, bottom_y = min(y1, y2), max(y1, y2)

        left[right_x] += 1
        right[left_x] += 1
        top[bottom_y] += 1
        bottom[top_y] += 1

    for i in range(1, d+1):
        x1, y1, x2, y2 = sofas[i]
        left_x, right_x = min(x1, x2), max(x1, x2)
        top_y, bottom_y = min(y1, y2), max(y1, y2)
        
        if left[left_x] == cnt_l and right[right_x] == cnt_r and top[top_y] == cnt_t and bottom[bottom_y] == cnt_b:
            return i
            
    return -1
  
solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))

    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())

    for i, sofa in enumerate(sofas, 1):
        left_sofas = len([s for s in sofas if s[2] < sofa[0]])
        right_sofas = len([s for s in sofas if s[0] > sofa[2]])
        top_sofas = len([s for s in sofas if s[3] < sofa[1]])
        bottom_sofas = len([s for s in sofas if s[1] > sofa[3]])

        if left_sofas == cnt_l and right_sofas == cnt_r and top_sofas == cnt_t and bottom_sofas == cnt_b:
            print(i)
            return

    print(-1)

solve()
","
from collections import defaultdict

def solve():
    d = int(input())
    n, m = map(int, input().split())
    
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    left_count = defaultdict(int)
    right_count = defaultdict(int)
    top_count = defaultdict(int)
    bottom_count = defaultdict(int)
    
    for i, (x1, y1, x2, y2) in enumerate(sofas, 1):
        left_count[x1] += 1
        right_count[x2] += 1
        top_count[y1] += 1
        bottom_count[y2] += 1
    
    possible_sofas = []
    for i, (x1, y1, x2, y2) in enumerate(sofas, 1):
        if left_count[x1] == cnt_l and right_count[x2] == cnt_r and top_count[y1] == cnt_t and bottom_count[y2] == cnt_b:
            possible_sofas.append(i)
    
    if not possible_sofas:
        print(-1)
    else:
        print(possible_sofas[0])
  
solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, sofa in enumerate(sofas, 1):
        cnt_l_check = cnt_r_check = cnt_t_check = cnt_b_check = 0
        for other_sofa in sofas:
            if other_sofa[0] < sofa[0] and other_sofa[2] < sofa[0]:
                cnt_l_check += 1
            if other_sofa[0] > sofa[2] and other_sofa[2] > sofa[2]:
                cnt_r_check += 1
            if other_sofa[1] < sofa[1] and other_sofa[3] < sofa[1]:
                cnt_t_check += 1
            if other_sofa[1] > sofa[3] and other_sofa[3] > sofa[3]:
                cnt_b_check += 1
        if cnt_l_check == cnt_l and cnt_r_check == cnt_r and cnt_t_check == cnt_t and cnt_b_check == cnt_b:
            return i
    return -1
  
solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    sofas = []
    
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, sofa in enumerate(sofas, 1):
        x1, y1, x2, y2 = sofa
        left_sofas = sum(1 for sx1, sy1, sx2, sy2 in sofas if sx2 < x1)
        right_sofas = sum(1 for sx1, sy1, sx2, sy2 in sofas if sx1 > x2)
        top_sofas = sum(1 for sx1, sy1, sx2, sy2 in sofas if sy2 < y1)
        bottom_sofas = sum(1 for sx1, sy1, sx2, sy2 in sofas if sy1 > y2)
        
        if left_sofas == cnt_l and right_sofas == cnt_r and top_sofas == cnt_t and bottom_sofas == cnt_b:
            return i
    
    return -1

solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)))
        
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, (x1, y1, x2, y2) in enumerate(sofas, 1):
        l_count, r_count, t_count, b_count = 0, 0, 0, 0
        
        for x1_comp, y1_comp, x2_comp, y2_comp in sofas:
            if x1_comp < x1 and y1_comp <= y1 <= y2_comp:
                l_count += 1
            if x1_comp > x1 and y1_comp <= y1 <= y2_comp:
                r_count += 1
            if y1_comp < y1 and x1_comp <= x1 <= x2_comp:
                t_count += 1
            if y1_comp > y1 and x1_comp <= x1 <= x2_comp:
                b_count += 1
        
        if l_count == cnt_l and r_count == cnt_r and t_count == cnt_t and b_count == cnt_b:
            return i
    
    return -1

solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((min(x1, x2), max(x1, x2), min(y1, y2), max(y1, y2)))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, (x1, x2, y1, y2) in enumerate(sofas, start=1):
        cnt_left = cnt_right = cnt_top = cnt_bottom = 0
        for x1_, x2_, y1_, y2_ in sofas:
            if (x1_ < x1 and x2_ < x1) or (x1_ > x2 and x2_ > x2):
                cnt_left += 1
            if (x1_ < x2 and x2_ < x2) or (x1_ > x1 and x2_ > x1):
                cnt_right += 1
            if (y1_ < y1 and y2_ < y1) or (y1_ > y2 and y2_ > y2):
                cnt_top += 1
            if (y1_ < y2 and y2_ < y2) or (y1_ > y1 and y2_ > y1):
                cnt_bottom += 1
            
        if cnt_left == cnt_l and cnt_right == cnt_r and cnt_top == cnt_t and cnt_bottom == cnt_b:
            return i
    
    return -1

solve()","
def solve():
    d = int(input())
    n, m = map(int, input().split())
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())
    
    for i, sofa in enumerate(sofas):
        x1, y1, x2, y2 = sofa
        left_sofas = right_sofas = top_sofas = bottom_sofas = 0
        
        for other_sofa in sofas:
            if other_sofa != sofa:
                ox1, oy1, ox2, oy2 = other_sofa
                if ox1 < x1 and ox2 < x1:
                    left_sofas += 1
                if ox1 > x2 and ox2 > x2:
                    right_sofas += 1
                if oy1 < y1 and oy2 < y1:
                    top_sofas += 1
                if oy1 > y2 and oy2 > y2:
                    bottom_sofas += 1
        
        if left_sofas == cnt_l and right_sofas == cnt_r and top_sofas == cnt_t and bottom_sofas == cnt_b:
            return i + 1
    
    return -1

solve()","
def solve():
    import sys
    
    d = int(input().strip())
    n, m = map(int, input().strip().split())
    sofas = []
    for _ in range(d):
        x1, y1, x2, y2 = map(int, input().strip().split())
        sofas.append((x1, y1, x2, y2))
    
    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().strip().split())
    
    for i, sofa in enumerate(sofas, 1):
        x1, y1, x2, y2 = sofa
        left, right, top, bottom = 0, 0, 0, 0
        
        for other_sofa in sofas:
            if other_sofa != sofa:
                ox1, oy1, ox2, oy2 = other_sofa
                
                if ox2 < x1:
                    left += 1
                if ox1 > x2:
                    right += 1
                if oy2 < y1:
                    top += 1
                if oy1 > y2:
                    bottom += 1
        
        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:
            print(i)
            return
    
    print(-1)

solve()
","0.0","0.0","0.0","0.0","60.0","0.0","0.0","0.0","33.33333333333333","20.0","0.0","0.0","0.0","0.0","0.0","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/10","
QUESTION:
On the planet Mars a year lasts exactly n days (there are no leap years on Mars). But Martians have the same weeks as earthlings — 5 work days and then 2 days off. Your task is to determine the minimum possible and the maximum possible number of days off per year on Mars.


-----Input-----

The first line of the input contains a positive integer n (1 ≤ n ≤ 1 000 000) — the number of days in a year on Mars.


-----Output-----

Print two integers — the minimum possible and the maximum possible number of days off per year on Mars.


-----Examples-----
Input
14

Output
4 4

Input
2

Output
0 2



-----Note-----

In the first sample there are 14 days in a year on Mars, and therefore independently of the day a year starts with there will be exactly 4 days off .

In the second sample there are only 2 days in a year on Mars, and they can both be either work days or days off.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(n // 7 * 2 + min(n % 7, 2), n)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(2, n)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = (n // 7) * 2 + min(2, n % 7)
    print(min_days_off, max_days_off)

solve()","
def solve():
    n = int(input())
    max_days_off = (n // 7) * 2 + min(2, n % 7)
    min_days_off = max(0, (n // 7) * 2 - 1 + max(0, n % 7 - 5))
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(n // 2, 2)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(2, n - 1)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(2, n)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(n // 7 * 2 + min(n % 7, 2), n)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(n % 7, 2)
    
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input().strip())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(2, n)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_off = (n // 7) * 2 + max(n % 7 - 5, 0)
    max_off = (n // 7) * 2 + min(n % 7, 2)
    
    print(min_off, max_off)

solve()","
def solve():
    n = int(input())
    
    min_days_off = (n//7) * 2 + max(0, n % 7 - 5)
    max_days_off = min(n//7 * 2 + min(n % 7, 2), n)
    
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())
    min_days_off = (n // 7) * 2 + max(0, n % 7 - 5)
    max_days_off = (n // 7) * 2 + min(2, n % 7)
    print(min_days_off, max_days_off)

solve()
","
import math

def solve():
    n = int(input())
    min_days_off = math.ceil(n / 7) * 2
    max_days_off = min(n // 7 * 2 + min(n % 7, 2), n)
    print(min_days_off, max_days_off)

solve()","
def solve():
    n = int(input())
    min_days_off = n // 7 * 2 + max(0, n % 7 - 5)
    max_days_off = min(n // 7 * 2 + min(2, n % 7), n // 2)
    print(min_days_off, max_days_off)

solve()
","
def solve():
    n = int(input())

    min_days_off = (2 * n + 5) // 7
    max_days_off = min((n // 7) * 2, n - (n // 7) * 5)

    print(min_days_off, max_days_off)

solve()
","100.0","46.666666666666664","100.0","33.33333333333333","26.666666666666668","33.33333333333333","46.666666666666664","100.0","40.0","46.666666666666664","100.0","100.0","100.0","13.333333333333334","80.0","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/11","
QUESTION:
Little Joty has got a task to do. She has a line of n tiles indexed from 1 to n. She has to paint them in a strange pattern.

An unpainted tile should be painted Red if it's index is divisible by a and an unpainted tile should be painted Blue if it's index is divisible by b. So the tile with the number divisible by a and b can be either painted Red or Blue.

After her painting is done, she will get p chocolates for each tile that is painted Red and q chocolates for each tile that is painted Blue.

Note that she can paint tiles in any order she wants.

Given the required information, find the maximum number of chocolates Joty can get.


-----Input-----

The only line contains five integers n, a, b, p and q (1 ≤ n, a, b, p, q ≤ 10^9).


-----Output-----

Print the only integer s — the maximum number of chocolates Joty can get.

Note that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.


-----Examples-----
Input
5 2 3 12 15

Output
39

Input
20 2 3 3 5

Output
51
Use user-input-Based format and function signature solve()","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    red_chocolates = red_tiles * p + max(0, common_tiles - red_tiles) * p
    blue_chocolates = blue_tiles * q + max(0, common_tiles - blue_tiles) * q
    total_chocolates = red_chocolates + blue_chocolates
    print(total_chocolates)

import math

solve()
","
def solve():
    from math import gcd
    n, a, b, p, q = map(int, input().split())
    lcm = a * b // gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    chocolates = max(red_tiles*p, blue_tiles*q, common_tiles*max(p,q))
    print(chocolates)

solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    
    lcm = (a*b) // math.gcd(a, b)
    
    red_tiles = n // a
    blue_tiles = n // b
    purple_tiles = n // lcm
    
    red_chocolates = red_tiles * p
    blue_chocolates = blue_tiles * q
    purple_chocolates = purple_tiles * max(p, q)
    
    extra_red = max(0, n%a - purple_tiles)
    extra_blue = max(0, n%b - purple_tiles)
    
    total_chocolates = red_chocolates + blue_chocolates + purple_chocolates - extra_red*p - extra_blue*q
    
    print(total_chocolates)

import math

solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    red_count = n // a - n // lcm
    blue_count = n // b - n // lcm
    total_chocolates = red_count * p + blue_count * q + max(p, q) * min(red_count, blue_count)
    print(total_chocolates)

import math

solve()","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    
    red_tiles = n // a - n // lcm
    blue_tiles = n // b - n // lcm
    
    max_chocolates = red_tiles * p + blue_tiles * q + (n // lcm) * max(p, q)
    
    print(max_chocolates)

import math

solve()
","
def solve():
    import math
    n, a, b, p, q = map(int, input().split())
    lcm = a * b // math.gcd(a, b)
    red_tiles = n // a - n // lcm
    blue_tiles = n // b - n // lcm
    result = red_tiles * p + blue_tiles * q + max(p, q) * min(red_tiles, n // a) + max(p, q) * min(blue_tiles, n // b)
    print(result)

solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = a * b // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    red_chocolates = red_tiles * p + max(0, common_tiles - red_tiles) * p
    blue_chocolates = blue_tiles * q + max(0, common_tiles - blue_tiles) * q
    total_chocolates = red_chocolates + blue_chocolates
    print(total_chocolates)

import math
solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = a * b // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    
    red_chocolates = red_tiles * p + max(0, common_tiles - red_tiles) * p
    blue_chocolates = blue_tiles * q + max(0, common_tiles - blue_tiles) * q
    
    max_chocolates = max(red_chocolates, blue_chocolates)
    
    return max_chocolates

import math

solve()","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    red_chocolates = (red_tiles - common_tiles) * p + common_tiles * max(p, q)
    blue_chocolates = (blue_tiles - common_tiles) * q + common_tiles * max(p, q)
    return red_chocolates + blue_chocolates

import math

solve()","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    red_chocolates = (n // a) * p + max((n // lcm) - (n // a), 0) * q
    blue_chocolates = (n // b) * q + max((n // lcm) - (n // b), 0) * p
    print(max(red_chocolates, blue_chocolates))

import math

solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = a * b // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    chocolates = max(p, q) * red_tiles + min(p, q) * blue_tiles - min(p, q) * common_tiles
    print(chocolates)

import math

solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    
    red_chocolates = p * (red_tiles - common_tiles)
    blue_chocolates = q * (blue_tiles - common_tiles)
    common_chocolates = max(p, q) * common_tiles
    
    total_chocolates = red_chocolates + blue_chocolates + common_chocolates
    print(total_chocolates)

import math
solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a*b) // math.gcd(a, b)
    red_chocolates = ((n//a) - (n//lcm)) * p
    blue_chocolates = ((n//b) - (n//lcm)) * q
    total_chocolates = (n // a) * p + (n // b) * q - min(red_chocolates, blue_chocolates)
    return total_chocolates

import math

solve()
  ","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    chocolates = max(red_tiles - common_tiles, 0) * p + max(blue_tiles - common_tiles, 0) * q + common_tiles * max(p, q)
    print(chocolates)

import math

solve()
","
def solve():
    n, a, b, p, q = map(int, input().split())
    lcm = (a * b) // math.gcd(a, b)
    red_tiles = n // a
    blue_tiles = n // b
    common_tiles = n // lcm
    red_chocolates = (red_tiles - common_tiles) * p + common_tiles * max(p, q)
    blue_chocolates = (blue_tiles - common_tiles) * q + common_tiles * max(p, q)
    print(max(red_chocolates, blue_chocolates))

import math

solve()","
def solve():
    n, a, b, p, q = map(int, input().split())
    
    lcm = a * b // math.gcd(a, b)
    count_red = n // a
    count_blue = n // b
    overlap = n // lcm
    
    max_chocolates = max(count_red * p, count_blue * q) + min(p, q) * overlap
    print(max_chocolates)

import math

solve()
","73.33333333333333","66.66666666666666","0.0","53.333333333333336","100.0","26.666666666666668","73.33333333333333","0.0","0.0","66.66666666666666","73.33333333333333","100.0","0.0","100.0","66.66666666666666","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/12","
QUESTION:
Vova has won $n$ trophies in different competitions. Each trophy is either golden or silver. The trophies are arranged in a row.

The beauty of the arrangement is the length of the longest subsegment consisting of golden trophies. Vova wants to swap two trophies (not necessarily adjacent ones) to make the arrangement as beautiful as possible — that means, to maximize the length of the longest such subsegment.

Help Vova! Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap.


-----Input-----

The first line contains one integer $n$ ($2 \le n \le 10^5$) — the number of trophies.

The second line contains $n$ characters, each of them is either G or S. If the $i$-th character is G, then the $i$-th trophy is a golden one, otherwise it's a silver trophy. 


-----Output-----

Print the maximum possible length of a subsegment of golden trophies, if Vova is allowed to do at most one swap.


-----Examples-----
Input
10
GGGSGGGSGG

Output
7

Input
4
GGGG

Output
4

Input
3
SSS

Output
0



-----Note-----

In the first example Vova has to swap trophies with indices $4$ and $10$. Thus he will obtain the sequence ""GGGGGGGSGS"", the length of the longest subsegment of golden trophies is $7$. 

In the second example Vova can make no swaps at all. The length of the longest subsegment of golden trophies in the sequence is $4$. 

In the third example Vova cannot do anything to make the length of the longest subsegment of golden trophies in the sequence greater than $0$.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    trophies = input().strip()
    
    g_count = trophies.count('G')
    
    max_beauty = 0
    for i in range(n):
        for j in range(i, n):
            if trophies[i] == 'S' and trophies[j] == 'S':
                max_beauty = max(max_beauty, g_count + 1)
            elif trophies[i] == 'S' or trophies[j] == 'S':
                max_beauty = max(max_beauty, g_count)
            else:
                max_beauty = max(max_beauty, g_count - (j - i + 1))
    
    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    trophies = input().strip()
    
    g_count = trophies.count(""G"")
    max_beauty = min(g_count + 1, trophies.rfind(""G"") - trophies.find(""G"") + 1)
    
    for i in range(n):
        if trophies[i] == 'S':
            max_beauty = max(max_beauty, min(g_count, trophies[:i].count('G') + 1 + (trophies[i+1:].count('G'))))
    
    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    trophies = input().strip()
    num_golden = trophies.count('G')
    max_beauty = trophies.count('G')
    
    for i in range(n):
        if trophies[i] == 'S':
            left_golden = trophies[:i].count('G')
            right_golden = num_golden - left_golden
            max_beauty = max(max_beauty, left_golden + 1, right_golden + 1)
    
    print(min(max_beauty, num_golden))

solve()","
def solve():
    n = int(input())
    trophies = input()

    g_count = trophies.count('G')
    max_beauty = g_count

    for i in range(n):
        if trophies[i] == 'S':
            left = trophies[:i]
            right = trophies[i+1:]
            updated_trophies = left + 'G' + right
            updated_g_count = updated_trophies.count('G')
            max_beauty = max(max_beauty, updated_g_count)

    print(max_beauty)

solve()","
def solve():
    n = int(input())
    trophies = input().strip()
    
    golden_indices = [i for i, trophy in enumerate(trophies) if trophy == 'G']
    max_beauty = 0
    
    for i in range(len(golden_indices)):
        for j in range(len(golden_indices)):
            if abs(golden_indices[i] - golden_indices[j]) <= 1:
                continue
            else:
                beauty = abs(golden_indices[i] - golden_indices[j]) - 1
                max_beauty = max(max_beauty, beauty)
    
    swapped_beauty = max_beauty
    if len(golden_indices) >= 2:
        max_distance = golden_indices[-1] - golden_indices[0] - 1
        swapped_beauty = max(swapped_beauty, max_distance)
    
    return swapped_beauty

import sys
solve()
","
def solve():
    n = int(input())
    trophies = input().strip()

    g_indices = [i for i, t in enumerate(trophies) if t == 'G']
    num_g = len(g_indices)

    if num_g == 0:
        print(0)
    elif num_g == n:
        print(n)
    else:
        max_beauty = max(g_indices[i+1] - g_indices[i] for i in range(num_g-1))
        for i in range(num_g):
            if g_indices[i] != 0:
                temp_beauty = g_indices[i-1] + 1 + n - g_indices[i]
                max_beauty = max(max_beauty, temp_beauty)
            if g_indices[i] != n - 1:
                temp_beauty = g_indices[i] + 1 + n - g_indices[i+1]
                max_beauty = max(max_beauty, temp_beauty)

        print(max_beauty)

solve()
","
def solve():
    n = int(input())
    trophies = list(input())
    
    golden_indices = [i for i in range(n) if trophies[i] == 'G']
    
    max_length = 0
    for i in range(n):
        for j in range(i, n):
            if trophies[i] == 'G':
                continue
            temp_trophies = trophies[:]
            temp_trophies[i], temp_trophies[j] = temp_trophies[j], temp_trophies[i]
            temp_length = 0
            for k in range(n):
                if temp_trophies[k] == 'G':
                    length = 1
                    while k + length < n and temp_trophies[k + length] == 'G':
                        length += 1
                    temp_length = max(temp_length, length)
            max_length = max(max_length, temp_length)
    
    print(max_length)

solve()
","
def solve():
    n = int(input())
    trophies = input().strip()
    
    g_count = trophies.count('G')
    
    max_beauty = 0
    for i in range(n):
        if trophies[i] == 'S':
            current_beauty = trophies[:i].count('G') + 1 + (trophies[i+1:]).count('G')
            max_beauty = max(max_beauty, current_beauty)
    
    if g_count == n or g_count == n - 1:
        max_beauty = n
    
    print(max_beauty)
  
solve()","
def solve():
    n = int(input())
    trophies = input().strip()
    
    max_beauty = 0
    continuous = 0
    for trophy in trophies:
        if trophy == 'G':
            continuous += 1
        else:
            max_beauty = max(max_beauty, continuous)
            continuous = 0
    
    max_beauty = max(max_beauty, continuous)  # Check after the loop ends
    
    if 'S' not in trophies:
        return n
    else:
        max_beauty = min(max_beauty + 1, trophies.count('G'))
    
    return max_beauty

solve()
","
def solve():
    n = int(input())
    trophies = input().strip()
    
    g_indices = [i for i, trophy in enumerate(trophies) if trophy == 'G']
    
    max_beauty = 0
    for i in range(len(g_indices)):
        for j in [-1, 1]:
            swap_index = g_indices[i] + j
            if 0 <= swap_index < n and trophies[swap_index] == 'S':
                beauty = g_indices[i+1] - g_indices[i-1] if i > 0 and i < len(g_indices)-1 else g_indices[i+1] - g_indices[i] + 1
                max_beauty = max(max_beauty, beauty)
    
    return max_beauty

solve()","
def solve():
    n = int(input())
    trophies = input()

    g_count = trophies.count('G')
    max_beauty = min(g_count + 1, n)

    for i in range(n):
        if trophies[i] == 'S':
            left_g = trophies[:i].count('G')
            right_g = g_count - left_g
            max_beauty = max(max_beauty, min(left_g + 1, g_count) + min(right_g + 1, g_count))

    print(max_beauty)
  
solve()","
def solve():
    n = int(input())
    trophies = input().strip()
    
    count_g = trophies.count('G')
    
    if count_g == n or count_g == 0:
        print(count_g)
    elif count_g < n:
        max_beauty = 0
        for i in range(n):
            if trophies[i] == 'S':
                left_g = trophies[:i].count('G')
                right_g = count_g - left_g
                max_beauty = max(max_beauty, min(left_g+1, right_g+1))
        print(max_beauty)

# Required imports
import sys

def main():
    solve()

if __name__ == ""__main__"":
    main()

solve()","
def solve():
    n = int(input())
    trophies = input().strip()
    gold_count = trophies.count('G')
    
    if gold_count == n or gold_count == 0:
        print(gold_count)
        return
    
    max_beauty = 0
    for i in range(n):
        for j in range(i, n):
            temp_trophies = list(trophies)
            temp_beauty = 0
            if trophies[i] == 'S':
                temp_trophies[i] = 'G'
                temp_beauty = 1
            if trophies[j] == 'S':
                temp_trophies[j] = 'G'
                temp_beauty = max(temp_beauty, 1)
            
            curr_beauty = 0
            curr_max = 0
            for trophy in temp_trophies:
                if trophy == 'G':
                    curr_beauty += 1
                else:
                    curr_max = max(curr_max, curr_beauty)
                    curr_beauty = 0
            
            max_beauty = max(max_beauty, curr_max + temp_beauty)
    
    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    trophies = input().strip()

    def max_beauty(arr, n):
        max_len = 0
        for i in range(n):
            for j in range(i, n):
                if arr[j] == 'G':
                    max_len = max(max_len, j - i + 1)
        for i in range(n):
            if arr[i] == 'S':
                arr[i] = 'G'
                max_len = max(max_len, max_beauty(arr, n))
                arr[i] = 'S'
        return max_len

    trophies = list(trophies)
    max_len = max_beauty(trophies, n)

    for i in range(n):
        if trophies[i] == 'S':
            trophies[i] = 'G'
            max_len = max(max_len, max_beauty(trophies, n))
            trophies[i] = 'S'

    print(max_len)

solve()
  ","
def solve():
    n = int(input())
    trophies = input().strip()

    num_golds = trophies.count('G')

    if num_golds == n or num_golds == n - 1:
        print(num_golds)
    else:
        max_beauty = -1
        for i in range(n):
            for j in range(i, n):
                updated_trophies = list(trophies)
                updated_trophies[i], updated_trophies[j] = updated_trophies[j], updated_trophies[i]

                beauty = 0
                curr_beauty = 0
                for trophy in updated_trophies:
                    if trophy == 'G':
                        curr_beauty += 1
                        beauty = max(beauty, curr_beauty)
                    else:
                        curr_beauty = 0
                
                max_beauty = max(max_beauty, beauty)

        print(max_beauty)

solve()
","
def solve():
    n = int(input())
    trophies = input().strip()

    g_count = trophies.count('G')
    max_beauty = min(g_count + 1, n)

    for i in range(n):
        if trophies[i] == 'S':
            left_g = trophies[:i].count('G')
            right_g = g_count - left_g
            max_beauty = max(max_beauty, min(left_g + 1, g_count, right_g + 1))

    print(max_beauty)

solve()","0.0","26.666666666666668","73.33333333333333","13.333333333333334","0.0","26.666666666666668","80.0","13.333333333333334","0.0","0.0","13.333333333333334","0.0","40.0","14.285714285714285","100.0","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/13","
QUESTION:
Now you can take online courses in the Berland State University! Polycarp needs to pass k main online courses of his specialty to get a diploma. In total n courses are availiable for the passage.

The situation is complicated by the dependence of online courses, for each course there is a list of those that must be passed before starting this online course (the list can be empty, it means that there is no limitation).

Help Polycarp to pass the least number of courses in total to get the specialty (it means to pass all main and necessary courses). Write a program which prints the order of courses. 

Polycarp passes courses consistently, he starts the next course when he finishes the previous one. Each course can't be passed more than once. 


-----Input-----

The first line contains n and k (1 ≤ k ≤ n ≤ 10^5) — the number of online-courses and the number of main courses of Polycarp's specialty. 

The second line contains k distinct integers from 1 to n — numbers of main online-courses of Polycarp's specialty. 

Then n lines follow, each of them describes the next course: the i-th of them corresponds to the course i. Each line starts from the integer t_{i} (0 ≤ t_{i} ≤ n - 1) — the number of courses on which the i-th depends. Then there follows the sequence of t_{i} distinct integers from 1 to n — numbers of courses in random order, on which the i-th depends. It is guaranteed that no course can depend on itself. 

It is guaranteed that the sum of all values t_{i} doesn't exceed 10^5. 


-----Output-----

Print -1, if there is no the way to get a specialty. 

Otherwise, in the first line print the integer m — the minimum number of online-courses which it is necessary to pass to get a specialty. In the second line print m distinct integers — numbers of courses which it is necessary to pass in the chronological order of their passage. If there are several answers it is allowed to print any of them.


-----Examples-----
Input
6 2
5 3
0
0
0
2 2 1
1 4
1 5

Output
5
1 2 3 4 5 

Input
9 3
3 9 5
0
0
3 9 4 5
0
0
1 8
1 6
1 2
2 1 2

Output
6
1 2 9 4 5 3 

Input
3 3
1 2 3
1 2
1 3
1 1

Output
-1



-----Note-----

In the first test firstly you can take courses number 1 and 2, after that you can take the course number 4, then you can take the course number 5, which is the main. After that you have to take only the course number 3, which is the last not passed main course.
Use user-input-Based format and function signature solve()","
def solve():
    import sys
    from collections import deque

    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))

    graph = {}
    for i in range(1, n+1):
        dependencies = list(map(int, input().split()))[1:]
        graph[i] = dependencies

    in_degree = [0] * (n+1)
    for course in graph.values():
        for dependency in course:
            in_degree[dependency] += 1

    queue = deque()
    for i in range(1, n+1):
        if in_degree[i] == 0:
            queue.append(i)

    order = []
    while queue:
        course = queue.popleft()
        order.append(course)
        for dependent_course in graph[course]:
            in_degree[dependent_course] -= 1
            if in_degree[dependent_course] == 0:
                queue.append(dependent_course)

    if len(order) < k:
        print(-1)
    else:
        print(len(order))
        print("" "".join(map(str, order)))

solve()
","
from collections import defaultdict

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))
    
    dependencies = defaultdict(set)
    for i in range(1, n+1):
        dependencies[i] = set(map(int, input().split()[1:]))
    
    passed_courses = set()
    order = []
    
    for main_course in main_courses:
        if main_course not in passed_courses:
            stack = [main_course]
            while stack:
                current_course = stack.pop()
                if current_course not in passed_courses:
                    passed_courses.add(current_course)
                    order.append(current_course)
                    stack.extend(dependencies[current_course])
    
    if len(passed_courses) < len(main_courses):
        print(-1)
    else:
        print(len(order))
        print("" "".join(map(str, order)))

solve()
","
def solve():
    import sys
    from collections import defaultdict, deque

    n, k = map(int, sys.stdin.readline().split())
    main_courses = set(map(int, sys.stdin.readline().split()))
    dependencies = defaultdict(set)
    in_degrees = [0] * (n + 1)

    for i in range(1, n + 1):
        line = list(map(int, sys.stdin.readline().split()))
        if len(line) > 1:
            in_degrees[i] = line[0]
            for dep_course in line[1:]:
                dependencies[i].add(dep_course)

    queue = deque([course for course in range(1, n + 1) if course not in main_courses])

    result = []
    while queue:
        curr_course = queue.popleft()
        if curr_course in main_courses:
            result.append(curr_course)
        else:
            for dep_course in dependencies[curr_course]:
                in_degrees[dep_course] -= 1
                if in_degrees[dep_course] == 0:
                    queue.append(dep_course)

    if len(result) == len(main_courses):
        print(len(result))
        print(' '.join(map(str, result)))
    else:
        print(-1)

solve()","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))

    prerequisites = {}
    for i in range(1, n+1):
        line = list(map(int, input().split()))
        prerequisites[i] = line[1:]

    completed_courses = set()
    order = []

    def dfs(course):
        if course in completed_courses:
            return
        for prerequisite in prerequisites[course]:
            if prerequisite not in completed_courses:
                dfs(prerequisite)
        completed_courses.add(course)
        order.append(course)

    for main_course in main_courses:
        dfs(main_course)

    if len(order) < k:
        print(-1)
    else:
        print(len(order))
        print(*order)

# Example usage
solve()
","
from collections import defaultdict

def solve():
    n, k = map(int, input().split())
    main_courses = list(map(int, input().split()))
    graph = defaultdict(list)
    for i in range(1, n+1):
        dependencies = list(map(int, input().split()))[1:]
        for dep in dependencies:
            graph[i].append(dep)
    
    passed = set()
    courses_order = []
    
    def dfs(course):
        if course in passed:
            return
        for dep in graph[course]:
            dfs(dep)
        passed.add(course)
        courses_order.append(course)
    
    for course in main_courses:
        dfs(course)
    
    if len(passed) < k:
        print(-1)
    else:
        print(len(passed))
        print(*courses_order[::-1])

solve()
","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))
    dependencies = {}
    for i in range(1, n+1):
        input_list = list(map(int, input().split()))
        dependencies[i] = input_list[1:]
    
    in_degree = [0] * (n+1)
    for courses in dependencies.values():
        for course in courses:
            in_degree[course] += 1
    
    order = []
    q = deque()
    for course in main_courses:
        if in_degree[course] == 0:
            q.append(course)
    
    while q:
        course = q.popleft()
        order.append(course)
        for next_course in dependencies.get(course, []):
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                q.append(next_course)
    
    if len(order) < len(main_courses):
        print(-1)
    else:
        print(len(order))
        print(*order)

solve()
  ","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))
    
    dependencies = {}
    for i in range(1, n+1):
        data = list(map(int, input().split()))[1:]
        dependencies[i] = data
    
    in_degree = [0] * (n+1)
    for key in dependencies:
        for val in dependencies[key]:
            in_degree[val] += 1
    
    queue = deque()
    for course in range(1, n+1):
        if in_degree[course] == 0:
            queue.append(course)
    
    result = []
    while queue:
        curr_course = queue.popleft()
        result.append(curr_course)
        
        for key in dependencies:
            if curr_course in dependencies[key]:
                in_degree[key] -= 1
                if in_degree[key] == 0:
                    queue.append(key)
    
    if len(result) < k or any(course not in result for course in main_courses):
        print(-1)
    else:
        print(len(result))
        print(' '.join(map(str, result)))

solve()
","
def solve():
    import collections

    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))
    dependencies = {}
    for i in range(1, n+1):
        data = list(map(int, input().split()))[1:]
        dependencies[i] = set(data)

    in_degree = [0] * (n+1)
    for k, v in dependencies.items():
        for course in v:
            in_degree[course] += 1

    queue = collections.deque()
    for i in range(1, n+1):
        if in_degree[i] == 0:
            queue.append(i)

    order = []
    while queue:
        course = queue.popleft()
        order.append(course)
        for dependent_course, prereqs in dependencies.items():
            if course in prereqs:
                in_degree[dependent_course] -= 1
                if in_degree[dependent_course] == 0:
                    queue.append(dependent_course)

    if len(order) < len(main_courses):
        print(-1)
    else:
        courses_for_specialty = [str(course) for course in order if course in main_courses]
        print(len(courses_for_specialty))
        print("" "".join(courses_for_specialty))

solve()
  ","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))

    depends_on = {}
    for i in range(1, n+1):
        _, *deps = map(int, input().split())
        depends_on[i] = deps

    in_degree = {i: 0 for i in range(1, n+1)}
    for course, dependencies in depends_on.items():
        for dep in dependencies:
            in_degree[dep] += 1
    
    queue = deque([course for course in depends_on if in_degree[course] == 0 and course in main_courses])
    result = []

    while queue:
        current_course = queue.popleft()
        result.append(current_course)

        for req_course, dependencies in depends_on.items():
            if current_course in dependencies:
                in_degree[req_course] -= 1
                if in_degree[req_course] == 0:
                    queue.append(req_course)
    
    if len(result) < len(main_courses):
        print(-1)
    else:
        print(len(result))
        print(' '.join(map(str, result)))

solve()
","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))
    dependencies = {}
    for i in range(1, n+1):
        line = list(map(int, input().split()))[1:]
        dependencies[i] = line
    
    passed_courses = set()
    order = []
    for main_course in main_courses:
        queue = deque([main_course])
        while queue:
            current_course = queue.popleft()
            if current_course not in passed_courses:
                passed_courses.add(current_course)
                order.append(current_course)
                for course in dependencies[current_course]:
                    if course not in passed_courses:
                        queue.append(course)

    if len(order) == k:
        print(len(order))
        print(*order)
    else:
        print(-1)

solve()","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))

    prerequisites = {}
    for i in range(1, n+1):
        line = list(map(int, input().split()))
        prerequisites[i] = line[1:]

    in_degree = {i: 0 for i in range(1, n+1)}
    for course in prerequisites.values():
        for c in course:
            in_degree[c] += 1

    queue = deque([c for c in range(1, n+1) if in_degree[c] == 0])

    courses_taken = []
    while queue:
        current = queue.popleft()
        courses_taken.append(current)

        for course, prerequisites_list in prerequisites.items():
            if current in prerequisites_list:
                in_degree[course] -= 1
                if in_degree[course] == 0:
                    queue.append(course)

    if len(courses_taken) < k or not set(courses_taken) >= main_courses:
        print(-1)
    else:
        print(len(courses_taken))
        print(*courses_taken)

solve()
","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))
    course_dependencies = [set(map(int, input().split()[1:])) for _ in range(n)]

    in_degree = [0] * n
    for dependencies in course_dependencies:
        for course in dependencies:
            in_degree[course-1] += 1

    queue = deque()
    for i in range(n):
        if in_degree[i] == 0:
            queue.append(i+1)

    result = []
    while queue:
        course = queue.popleft()
        if course in main_courses:
            result.append(course)
        for i, dependencies in enumerate(course_dependencies):
            if course in dependencies:
                in_degree[i] -= 1
                if in_degree[i] == 0:
                    queue.append(i+1)

    if len(result) < k:
        print(-1)
    else:
        print(len(result))
        print("" "".join(map(str, result)))

solve()
","
from collections import deque

def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))

    dependencies = {}
    for i in range(1, n+1):
        dependencies[i] = set(map(int, input().split()[1:]))

    order = []
    visited = set()

    def dfs(course):
        if course in visited:
            return
        visited.add(course)
        for dep in dependencies[course]:
            dfs(dep)
        order.append(course)

    for course in range(1, n+1):
        if course not in visited and course in main_courses:
            dfs(course)

    if len(order) < k:
        print(-1)
    else:
        order.reverse()
        print(len(order))
        print(*order)

solve()
","
from collections import defaultdict

def solve():
    n, k = map(int, input().split())
    main_courses = list(map(int, input().split()))
    
    prerequisites = defaultdict(list)
    for i in range(1, n+1):
        line = list(map(int, input().split()))
        prerequisites[i] = line[1:]
    
    topological_sorted = []
    visited = [0] * (n + 1)
    
    def dfs(course):
        if visited[course] == -1:
            return False
        if visited[course] == 1:
            return True
        
        visited[course] = -1
        for prerequisite in prerequisites[course]:
            if not dfs(prerequisite):
                return False
        
        visited[course] = 1
        topological_sorted.append(course)
        return True

    for i in range(1, n + 1):
        if not dfs(i):
            print(-1)
            return
    
    topological_sorted = topological_sorted[::-1]
    passed = []
    
    for course in topological_sorted:
        if course in main_courses:
            passed.append(course)
    
    print(len(passed))
    print(*passed)

solve()","
def solve():
    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))
    
    courses = {}
    for i in range(1, n+1):
        courses[i] = list(map(int, input().split())[1:])
    
    visited = set()
    stack = []
    ans = []

    for course in main_courses:
        stack.append(course)

    while stack:
        curr = stack.pop()
        if curr in visited:
            continue

        ans.append(curr)
        visited.add(curr)

        for c in courses.values():
            if curr in c:
                stack.append(courses.key(c))

    if len(visited) < k:
        print(""-1"")
    else:
        print(len(visited))
        print("" "".join(str(c) for c in ans[::-1]))

solve()
","
def solve():
    import sys

    n, k = map(int, input().split())
    main_courses = set(map(int, input().split()))

    prerequisites = {}
    for i in range(1, n+1):
        line = map(int, input().split())
        prerequisites[i] = set(line[1:])

    visited = set()
    order = []

    def dfs(course):
        if course in visited:
            return

        visited.add(course)

        for prereq in prerequisites[course]:
            dfs(prereq)

        order.append(course)

    for course in range(1, n+1):
        dfs(course)

    order.reverse()

    passed_courses = []
    for course in order:
        if course in main_courses:
            passed_courses.append(course)
            main_courses.remove(course)

    if main_courses:
        print(-1)
    else:
        print(len(passed_courses))
        print("" "".join(map(str, passed_courses)))
  
solve()","33.33333333333333","33.33333333333333","26.666666666666668","66.66666666666666","13.333333333333334","40.0","33.33333333333333","40.0","40.0","46.666666666666664","33.33333333333333","40.0","6.666666666666667","33.33333333333333","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/14","
QUESTION:
Let's suppose you have an array a, a stack s (initially empty) and an array b (also initially empty).

You may perform the following operations until both a and s are empty:

  Take the first element of a, push it into s and remove it from a (if a is not empty);  Take the top element from s, append it to the end of array b and remove it from s (if s is not empty). 

You can perform these operations in arbitrary order.

If there exists a way to perform the operations such that array b is sorted in non-descending order in the end, then array a is called stack-sortable.

For example, [3, 1, 2] is stack-sortable, because b will be sorted if we perform the following operations:

  Remove 3 from a and push it into s;  Remove 1 from a and push it into s;  Remove 1 from s and append it to the end of b;  Remove 2 from a and push it into s;  Remove 2 from s and append it to the end of b;  Remove 3 from s and append it to the end of b. 

After all these operations b = [1, 2, 3], so [3, 1, 2] is stack-sortable. [2, 3, 1] is not stack-sortable.

You are given k first elements of some permutation p of size n (recall that a permutation of size n is an array of size n where each integer from 1 to n occurs exactly once). You have to restore the remaining n - k elements of this permutation so it is stack-sortable. If there are multiple answers, choose the answer such that p is lexicographically maximal (an array q is lexicographically greater than an array p iff there exists some integer k such that for every i < k q_{i} = p_{i}, and q_{k} > p_{k}). You may not swap or change any of first k elements of the permutation.

Print the lexicographically maximal permutation p you can obtain.

If there exists no answer then output -1.


-----Input-----

The first line contains two integers n and k (2 ≤ n ≤ 200000, 1 ≤ k < n) — the size of a desired permutation, and the number of elements you are given, respectively.

The second line contains k integers p_1, p_2, ..., p_{k} (1 ≤ p_{i} ≤ n) — the first k elements of p. These integers are pairwise distinct.


-----Output-----

If it is possible to restore a stack-sortable permutation p of size n such that the first k elements of p are equal to elements given in the input, print lexicographically maximal such permutation.

Otherwise print -1.


-----Examples-----
Input
5 3
3 2 1

Output
3 2 1 5 4 
Input
5 3
2 3 1

Output
-1

Input
5 1
3

Output
3 2 1 5 4 
Input
5 2
3 4

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    import sys
    input = sys.stdin.readline

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    s = []
    b = []
    used = [False] * (n + 1)

    for i in p:
        used[i] = True

    cur = k + 1
    for i in range(1, k + 1):
        while cur <= n and used[cur]:
            cur += 1
        if cur > n:
            print(-1)
            return
        if p[i - 1] != cur:
            b.append(cur)
        else:
            b.append(p[i - 1])
            cur += 1

    for i in range(k, 0, -1):
        s.append(p[i - 1])
        while s and s[-1] == cur:
            b.append(s.pop())
            cur += 1

    if len(b) < n:
        for i in range(cur, n + 1):
            if not used[i]:
                b.append(i)

    print(*b)

solve()
","
def solve():
    import sys

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    s = []
    a = [i for i in range(n, 0, -1)]
    for i in p:
        a.remove(i)
        s.append(i)
   
    b = []
    current = n
    ok = True
   
    while ok:
        ok = False
        if s and s[-1] == current:
            b.append(s.pop())
            current -= 1
            ok = True
        elif a:
            s.append(a.pop())
            ok = True

    if not a and not s:
        print("" "".join(map(str, p + b)))
    else:
        print(-1)

solve()
","
def solve():
    import sys

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    arr = []
    for i in range(1, n + 1):
        if i not in p:
            arr.append(i)

    stack = []
    result = []
    current = k - 1

    for num in p:
        result.append(num)
        while stack and stack[-1] == current + 1:
            result.append(stack.pop())
            current += 1

        if num == current + 1:
            result.append(arr.pop())
            current += 1
        else:
            stack.append(num)

    while stack:
        if stack[-1] == current + 1:
            result.append(stack.pop())
            current += 1
        else:
            break

    if current == n - 1:
        print(*result)
    else:
        print(-1)

solve()
","
from heapq import heappop, heappush

def solve():
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    rem_elems = list(set(range(1, n + 1)) - set(p))
    s = []
    ans = []
    
    for num in p:
        while s and s[-1] < num:
            max_num = heappop(s)
            if not rem_elems:
                print(-1)
                return
            ans.append(rem_elems.pop())
        heappush(s, num)
        ans.append(num)
    
    while s:
        max_num = heappop(s)
        if not rem_elems:
            print(-1)
            return
        ans.append(rem_elems.pop())
    
    for num in ans:
        print(num, end=' ')


solve()","
def solve():
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    s = []
    b = []
    ans = [0] * n
    
    curr = n
    for i in range(k):
        while s and s[-1] == curr:
            b.append(s.pop())
            curr -= 1
        s.append(p[i])
    
    for i in range(curr, 0, -1):
        while s and s[-1] == i:
            b.append(s.pop())
        if not s:
            break
        s.append(i)
    
    if len(b) < n - k:
        print(-1)
    else:
        idx = 0
        for i in range(n):
            if ans[i] == 0:
                ans[i] = b[idx]
                idx += 1
            if ans[i] == 0:
                ans[i] = curr
                curr += 1
        print(*ans)
  
solve()","
def solve():
    import heapq

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    stk = []
    ans = [0] * n

    for i in range(1, k + 1):
        ans[i - 1] = p[i - 1]
        stk.append(-p[i - 1])

    heapq.heapify(stk)
    current = k + 1

    for i in range(k, n):
        if stk:
            top = -heapq.heappop(stk)
            if top > current:
                return -1
            ans[i] = top
            if top != current:
                heapq.heappush(stk, -current)
            current += 1

    return ' '.join(map(str, ans))


print(solve())

solve()","
from collections import deque

def solve():
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    
    s = deque()
    a = [i for i in range(1, n + 1) if i not in p]
    b = []
    
    rest = n - k
    for i in range(k):
        while s and s[-1] < p[i]:
            b.append(s.pop())
            rest -= 1
        s.append(p[i])
    
    if rest < 0:
        print(-1)
        return
    
    cur = n
    while s:
        if s[-1] == cur:
            b.append(s.pop())
            cur -= 1
        else:
            break
    
    if rest > 0:
        for i in range(rest):
            b.append(cur - i - 1)
    
    print(*b)

solve()
","
def solve():
    import heapq

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    s = []
    a = [i for i in range(n, 0, -1) if i not in p]

    next_val = n + 1
    b = []

    for val in p:
        while s and s[-1] == next_val:
            b.append(s.pop())
            next_val -= 1

        if val == next_val:
            b.append(val)
            next_val -= 1
        else:
            s.append(val)

    while s:
        if s[-1] == next_val:
            b.append(s.pop())
            next_val -= 1
        else:
            break

    if len(b) == n:
        print(' '.join(map(str, b)))
    else:
        print(-1)

solve()
  ","
def solve():
    import sys

    n, k = map(int, sys.stdin.readline().split())
    p = list(map(int, sys.stdin.readline().split()))

    used = [False] * (n + 1)
    for num in p:
        used[num] = True

    s = []
    b = []
    for i in range(1, p[-1] + 1):
        if not used[i]:
            s.append(i)
    
    if not s:
        print(-1)
        return

    cur_max = p[-1]
    for num in reversed(s):
        if num > cur_max:
            print(-1)
            return
        b.append(num)
        cur_max = num

    for num in p:
        b.append(num)

    next_num = p[-1] + 1
    for _ in range(n - k):
        while used[next_num]:
            next_num += 1
        b.append(next_num)
        next_num += 1

    print(*b)

solve()
  ","
from collections import deque

def solve(n, k, p):
    p_seen = set(p)
    available_nums = deque([i for i in range(1, n+1) if i not in p_seen])
    result = list(p)
    
    stack = []
    for num in p[::-1]:
        while stack and stack[-1] == available_nums[0]:
            result.append(stack.pop())
            available_nums.popleft()
        
        if num == available_nums[0]:
            result.append(available_nums.popleft())
        else:
            stack.append(num)
    
    return result if len(result) == n else -1

solve()","
def solve():
    import sys
    input = sys.stdin.readline

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    used = [False] * (n + 1)
    for num in p:
        used[num] = True

    ans = p[:]
    stack = []
    last = k

    for i in range(1, k + 1):
        while len(stack) > 0 and stack[-1] == last:
            last += 1
            stack.pop()

        if p[k - i] != last:
            stack.append(p[k - i])
            continue

        while len(stack) > 0 and stack[-1] == last:
            last += 1
            stack.pop()

        ans[k - i] = last
        last += 1

    if len(stack) > 0:
        print(-1)
    else:
        for i in range(k, n):
            while used[last]:
                last += 1
            ans[i] = last
            last += 1
        
        print(*ans)

solve()
  ","
from collections import deque

def solve():
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    
    ans = [-1] * n
    s = deque()
    
    current_num = n
    for i in range(k - 1):
        if p[i] == p[i+1] - 1:
            if ans[p[i] - 1] != -1:
                return -1
            ans[p[i] - 1] = p[i]
        else:
            ans[p[i] - 1] = p[i]
            s.append(p[i])
            while current_num in s:
                s.pop()
                ans[current_num - 1] = current_num
                current_num -= 1
    
    for i in range(k, n):
        if ans[i] == -1:
            ans[i] = current_num
            current_num -= 1
    
    return ' '.join(str(num) for num in ans)

print(solve())

solve()","
def solve():
    import heapq

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    remaining = list(set(range(1, n+1)) - set(p))

    stack = []
    stack_max = 0

    for i in range(k):
        if p[i] == stack_max + 1:
            stack_max += 1
            while stack and stack[-1] == stack_max + 1:
                stack_max = stack.pop()

        stack.append(p[i])

    heapq.heapify(remaining)

    result = []
    for i in range(k, n):
        if stack and stack[-1] == stack_max + 1:
            stack_max += 1
            while stack and stack[-1] == stack_max + 1:
                stack_max = stack.pop()
        if stack and remaining[0] > stack[-1]:
            result.append(remaining[0])
            remaining.pop(0)
        else:
            result.append(stack.pop())

    if not stack:
        print("" "".join(map(str, p + result)))
    else:
        print(-1)

solve()
","
def solve():
    import heapq
    
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    
    missing_elements = [i for i in range(1, n+1) if i not in p]
    heapq.heapify(missing_elements)
    
    stack = []
    result = []
    
    for i in range(k):
        while stack and stack[-1] == p[i]:
            result.append(stack.pop())
        result.append(p[i])
    
    for i in range(k+1, n):
        if not stack:
            break
        while stack[-1] < missing_elements[0]:
            result.append(stack.pop())
        result.append(missing_elements[0])
        missing_elements.pop(0)
    
    if len(result) != n:
        print(-1)
    else:
        print(' '.join(map(str, result)))

solve()
","
def solve():
    import heapq

    def find_rest(n, k, p):
        remaining = []
        used = set(p)
        for i in range(1, n+1):
            if i not in used:
                remaining.append(i)
        return remaining

    def restore_permutation(n, k, p):
        remaining = find_rest(n, k, p)
        s = []
        res = []
        for num in reversed(p):
            while s and s[-1] < num:
                res.append(s.pop())
            s.append(num)
        heapq.heapify(s)
        max_val = n
        if res and res[-1] == n:
            max_val -= 1
        for remaining_num in remaining:
            if s and s[0] == max_val:
                res.append(s.pop())
                max_val -= 1
            res.append(remaining_num)
        return ' '.join(map(str, res)) if len(res) == n else '-1'

    n, k = map(int, input().split())
    p = list(map(int, input().split()))

    print(restore_permutation(n, k, p))

solve()
","
def solve():
    import heapq
    
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    
    rest = list(i for i in range(1, n+1) if i not in p)
    
    ans = p.copy()
    s = []
    for i in range(k):
        while s and s[-1] == ans[-1] + 1:
            ans.append(s.pop())
        
        if ans[-1] == rest[0]:
            ans.append(rest.pop(0))
        else:
            s.append(ans.pop())
    
    if s:
        return -1
    
    while rest:
        ans.append(rest.pop())
    
    return ' '.join(map(str, ans))

# Example usage:
# print(solve())
  
solve()","20.0","80.0","66.66666666666666","33.33333333333333","73.33333333333333","0.0","26.666666666666668","80.0","20.0","0.0","80.0","0.0","40.0","80.0","80.0","0.0","","","","","","","","","","","","","","","",""
"APPS/15","
QUESTION:
Vasya likes everything infinite. Now he is studying the properties of a sequence s, such that its first element is equal to a (s_1 = a), and the difference between any two neighbouring elements is equal to c (s_{i} - s_{i} - 1 = c). In particular, Vasya wonders if his favourite integer b appears in this sequence, that is, there exists a positive integer i, such that s_{i} = b. Of course, you are the person he asks for a help.


-----Input-----

The first line of the input contain three integers a, b and c ( - 10^9 ≤ a, b, c ≤ 10^9) — the first element of the sequence, Vasya's favorite number and the difference between any two neighbouring elements of the sequence, respectively.


-----Output-----

If b appears in the sequence s print ""YES"" (without quotes), otherwise print ""NO"" (without quotes).


-----Examples-----
Input
1 7 3

Output
YES

Input
10 10 0

Output
YES

Input
1 -4 5

Output
NO

Input
0 60 50

Output
NO



-----Note-----

In the first sample, the sequence starts from integers 1, 4, 7, so 7 is its element.

In the second sample, the favorite integer of Vasya is equal to the first element of the sequence.

In the third sample all elements of the sequence are greater than Vasya's favorite integer.

In the fourth sample, the sequence starts from 0, 50, 100, and all the following elements are greater than Vasya's favorite integer.
Use user-input-Based format and function signature solve()","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    elif (b - a) % c == 0 and (b - a) * c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if c > 0:
            if (b - a) % c == 0 and (b - a) // c >= 0:
                print(""YES"")
            else:
                print(""NO"")
        else:
            if (b - a) % c == 0 and (b - a) // c <= 0:
                print(""YES"")
            else:
                print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()","
# Function signature: 
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    if (b - a) % c == 0 and (b - a) / c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    elif (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    elif (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    elif (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if a == b:
        print(""YES"")
    elif c == 0:
        print(""NO"")
    elif (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    elif (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    elif (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:
        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
  ","100.0","100.0","100.0","80.0","100.0","100.0","73.33333333333333","100.0","100.0","73.33333333333333","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/16","
QUESTION:
A string is called bracket sequence if it does not contain any characters other than ""("" and "")"". A bracket sequence is called regular if it it is possible to obtain correct arithmetic expression by inserting characters ""+"" and ""1"" into this sequence. For example, """", ""(())"" and ""()()"" are regular bracket sequences; ""))"" and "")(("" are bracket sequences (but not regular ones), and ""(a)"" and ""(1)+(1)"" are not bracket sequences at all.

You have a number of strings; each string is a bracket sequence of length $2$. So, overall you have $cnt_1$ strings ""(("", $cnt_2$ strings ""()"", $cnt_3$ strings "")("" and $cnt_4$ strings ""))"". You want to write all these strings in some order, one after another; after that, you will get a long bracket sequence of length $2(cnt_1 + cnt_2 + cnt_3 + cnt_4)$. You wonder: is it possible to choose some order of the strings you have such that you will get a regular bracket sequence? Note that you may not remove any characters or strings, and you may not add anything either.


-----Input-----

The input consists of four lines, $i$-th of them contains one integer $cnt_i$ ($0 \le cnt_i \le 10^9$).


-----Output-----

Print one integer: $1$ if it is possible to form a regular bracket sequence by choosing the correct order of the given strings, $0$ otherwise.


-----Examples-----
Input
3
1
4
3

Output
1

Input
0
0
0
0

Output
1

Input
1
2
3
4

Output
0



-----Note-----

In the first example it is possible to construct a string ""(())()(()((()()()())))"", which is a regular bracket sequence.

In the second example it is possible to construct a string """", which is a regular bracket sequence.
Use user-input-Based format and function signature solve()","
def solve():
    cnt1 = int(input())
    cnt2 = int(input())
    cnt3 = int(input())
    cnt4 = int(input())
    
    if cnt1 == cnt4 and cnt3 == 0:
        print(1)
    else:
        print(0)

solve()
","
def solve():
    cnt = [int(input()) for _ in range(4)]
    if cnt[1] > 0 or cnt[2] == 0:
        if cnt[0] == cnt[3]:
            print(1)
        else:
            print(0)
    else:
        print(1)

solve()
","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())

    if cnt_1 == cnt_4 and cnt_1 > 0:
        print(0)
    elif cnt_3 > 0 and cnt_1 == 0 and cnt_4 == 0:
        print(0)
    else:
        print(1)

solve()
","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())

    if cnt_1 == cnt_4 and cnt_1 > 0:
        print(0)
    elif cnt_3 > 0 and (cnt_1 == 0 or cnt_4 == 0):
        print(0)
    elif cnt_1 == 0 and cnt_4 == 0 and cnt_2 % 2 == 0:
        print(1)
    else:
        print(1)


solve()
","
def solve():
    cnt1 = int(input())
    cnt2 = int(input())
    cnt3 = int(input())
    cnt4 = int(input())
    
    if cnt1 > 0 and cnt4 > 0:
        print(0)
    elif cnt3 > 0 and (cnt1 > 0 or cnt2 > 0 or cnt3 > 1):
        print(0)
    else:
        print(1)

solve()
","
def solve():
    cnt1 = int(input())
    cnt2 = int(input())
    cnt3 = int(input())
    cnt4 = int(input())
    
    if cnt1 == cnt4 and (cnt3 == 0 or cnt1 > 0):
        print(1)
    else:
        print(0)

solve()
  ","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())
    
    # Check if it is possible to form a regular bracket sequence
    if cnt_1 > 0 or cnt_3 > 0 or (cnt_2 % 2 == 0 and cnt_4 % 2 == 0):
        print(1)
    else:
        print(0)

solve()
","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())
    
    if cnt_1 > 0 and cnt_3 == 0 and cnt_4 == 0:
        if cnt_1 == cnt_2:
            print(1)
        else:
            print(0)
    elif cnt_2 == cnt_4:
        print(1)
    else:
        print(0)

solve()
","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())

    even_odd = abs((cnt_1 + cnt_2) - (cnt_3 + cnt_4))
    
    if cnt_1 + cnt_2 > 0 and cnt_3 + cnt_4 > 0 and even_odd % 2 == 0:
        print(1)
    elif cnt_1 == cnt_3 and cnt_2 == cnt_4:
        print(1)
    else:
        print(0)

solve()
","
def solve():
    cnt1 = int(input())
    cnt2 = int(input())
    cnt3 = int(input())
    cnt4 = int(input())

    if cnt1 == cnt4 and cnt3 == 0:
        if cnt1 > 0:
            print(1)
        else:
            if cnt2 > 0:
                print(1)
            else:
                print(0)
    else:
        print(0)

solve()","
def solve():
    cnt1 = int(input())
    cnt2 = int(input())
    cnt3 = int(input())
    cnt4 = int(input())
    
    if cnt1 % 2 == 0 and cnt2 % 2 == 0 and cnt3 == 0 and cnt4 == 0:
        print(1)
    elif cnt3 > 0 or cnt4 > 0:
        print(0)
    elif cnt1 > 0 and cnt2 > 0:
        print(1)
    else:
        print(0)

solve()
","
def solve():
    cnt1 = int(input())
    cnt2 = int(input())
    cnt3 = int(input())
    cnt4 = int(input())
    
    if cnt1 == 0 and cnt4 == 0:
        print(1)
    elif cnt1 > 0 and (cnt3 > 0 or cnt4 > 0):
        print(1)
    elif cnt3 == 0:
        print(cnt1 <= cnt2)
    else:
        print(0)
  
solve()","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())

    if cnt_1 == cnt_4 and cnt_1 > 0:
        print(0)
    elif cnt_3 > 0 and (cnt_1 == 0 or cnt_4 == 0):
        print(0)
    else:
        print(1)

solve()
","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())
    
    if cnt_1 > 0 and cnt_4 > 0:
        print(0)
    elif cnt_3 > 0 and (cnt_1 > 0 or cnt_2 > 0):
        print(0)
    else:
        print(1)

solve()
","
def solve():
    cnt_1 = int(input())
    cnt_2 = int(input())
    cnt_3 = int(input())
    cnt_4 = int(input())
    
    if cnt_1 == cnt_4 and cnt_1 > 0:
        print(0)
    elif cnt_3 > 0 and cnt_1 == cnt_4 == 0:
        print(0)
    else:
        print(1)

solve()
","
def solve():
    cnt1 = int(input())
    cnt2 = int(input())
    cnt3 = int(input())
    cnt4 = int(input())

    if cnt1 == cnt4 and cnt3 == 0:
        print(1)
    elif cnt3 == 1 and cnt1 == cnt4 == 0:
        print(0)
    else:
        print(1)

solve()
","66.66666666666666","80.0","26.666666666666668","33.33333333333333","60.0","100.0","46.666666666666664","46.666666666666664","33.33333333333333","60.0","66.66666666666666","46.666666666666664","33.33333333333333","60.0","26.666666666666668","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/17","
QUESTION:
Arpa is researching the Mexican wave.

There are n spectators in the stadium, labeled from 1 to n. They start the Mexican wave at time 0. 

  At time 1, the first spectator stands.  At time 2, the second spectator stands.  ...  At time k, the k-th spectator stands.  At time k + 1, the (k + 1)-th spectator stands and the first spectator sits.  At time k + 2, the (k + 2)-th spectator stands and the second spectator sits.  ...  At time n, the n-th spectator stands and the (n - k)-th spectator sits.  At time n + 1, the (n + 1 - k)-th spectator sits.  ...  At time n + k, the n-th spectator sits. 

Arpa wants to know how many spectators are standing at time t.


-----Input-----

The first line contains three integers n, k, t (1 ≤ n ≤ 10^9, 1 ≤ k ≤ n, 1 ≤ t < n + k).


-----Output-----

Print single integer: how many spectators are standing at time t.


-----Examples-----
Input
10 5 3

Output
3

Input
10 5 7

Output
5

Input
10 5 12

Output
3



-----Note-----

In the following a sitting spectator is represented as -, a standing spectator is represented as ^.

  At t = 0  ---------- $\Rightarrow$ number of standing spectators = 0.  At t = 1  ^--------- $\Rightarrow$ number of standing spectators = 1.  At t = 2  ^^-------- $\Rightarrow$ number of standing spectators = 2.  At t = 3  ^^^------- $\Rightarrow$ number of standing spectators = 3.  At t = 4  ^^^^------ $\Rightarrow$ number of standing spectators = 4.  At t = 5  ^^^^^----- $\Rightarrow$ number of standing spectators = 5.  At t = 6  -^^^^^---- $\Rightarrow$ number of standing spectators = 5.  At t = 7  --^^^^^--- $\Rightarrow$ number of standing spectators = 5.  At t = 8  ---^^^^^-- $\Rightarrow$ number of standing spectators = 5.  At t = 9  ----^^^^^- $\Rightarrow$ number of standing spectators = 5.  At t = 10 -----^^^^^ $\Rightarrow$ number of standing spectators = 5.  At t = 11 ------^^^^ $\Rightarrow$ number of standing spectators = 4.  At t = 12 -------^^^ $\Rightarrow$ number of standing spectators = 3.  At t = 13 --------^^ $\Rightarrow$ number of standing spectators = 2.  At t = 14 ---------^ $\Rightarrow$ number of standing spectators = 1.  At t = 15 ---------- $\Rightarrow$ number of standing spectators = 0.
Use user-input-Based format and function signature solve()","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n + k - t)

solve()
","
def solve():
    n, k, t = map(int, input().split())
    
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n - (t - n))

solve()","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n - (t - n))

solve()
","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n - (t - n))

solve()","
def solve():
    n, k, t = map(int, input().split())
    
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n + k - t)

solve()","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n + k - t)

solve()
","
def solve():
    n, k, t = map(int, input().split())
    remaining_time = min(t, n)
    if remaining_time <= k:
        print(remaining_time)
    else:
        print(k - (remaining_time - k))

solve()
","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n + k - t)

solve()
","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(k - (t - n))

solve()
","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(k - (t - n))

solve()
  ","
def solve():
    n, k, t = map(int, input().split())
    
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n - (t - n))

solve()
","
def solve():
    n, k, t = map(int, input().split())
    remaining_standings = max(0, min(n, t + 1) - max(1, t - k + 1))
    print(remaining_standings)

solve()
","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n + k - t)

solve()
","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(max(n + k - t, 0))

solve()
","
def solve():
    n, k, t = map(int, input().split())
    if t <= k:
        print(t)
    elif t <= n:
        print(k)
    else:
        print(n + k - t)

solve()
","
def solve():
    n, k, t = map(int, input().split())
    result = 0
    
    if t <= n:
        result = min(t, k)
    else:
        result = max(0, k - (t - n))
    
    print(result)
  
solve()","100.0","66.66666666666666","66.66666666666666","66.66666666666666","100.0","100.0","33.33333333333333","100.0","100.0","100.0","66.66666666666666","66.66666666666666","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/18","
QUESTION:
Petya recieved a gift of a string s with length up to 10^5 characters for his birthday. He took two more empty strings t and u and decided to play a game. This game has two possible moves:  Extract the first character of s and append t with this character.  Extract the last character of t and append u with this character. 

Petya wants to get strings s and t empty and string u lexicographically minimal.

You should write a program that will help Petya win the game.


-----Input-----

First line contains non-empty string s (1 ≤ |s| ≤ 10^5), consisting of lowercase English letters.


-----Output-----

Print resulting string u.


-----Examples-----
Input
cab

Output
abc

Input
acdb

Output
abdc
Use user-input-Based format and function signature solve()","
def solve():
    import sys
    input_string = sys.stdin.readline().strip()
    
    t = """"
    u = """"
    
    for char in input_string:
        if char < u[0]:
            u += char
        else:
            t = char + t
    
    print(u)

solve()
","
def solve():
    import sys
    input_string = sys.stdin.readline().strip()
    
    t = """"
    u = []
    
    for char in input_string:
        if not u or char <= u[-1]:
            u.append(char)
        else:
            t += char
    
    print(''.join(u))

solve()","
def solve():
    import collections

    s = input()

    t = collections.deque()
    u = []

    s = list(s)

    while s:
        t.appendleft(s.pop(0))
        if len(s) > 0 and s[0] >= t[-1]:
            u.append(t.pop())

    print(''.join(u))

solve()","
def solve():
    import heapq
    s = input()
    s = list(s)
    t = []
    u = []
    
    heapq.heapify(s)
    
    while s:
        next_char = heapq.heappop(s)
        t.append(next_char)
        if len(t) >= len(u):
            heapq.heappush(u, t.pop(0))
    
    print(''.join(u))

solve()","
def solve():
    from collections import deque

    s = input().strip()
    t = ''
    u = deque()

    for char in s:
        if t and char < t[0]:
            u.append(char)
        else:
            t = char + t

    return ''.join(u)

solve()
","
def solve():
    import collections

    s = input().strip()
    t = collections.deque()
    u = []

    for ch in s:
        t.appendleft(ch)

        while t and t[-1] <= u[-1] if u else t:
            u.append(t.pop())
    
    print(''.join(u))
  
solve()","
def solve():
    import sys
    s = sys.stdin.readline().strip()
    
    n = len(s)
    t = []
    u = []
    
    i, j = 0, n-1
    while i <= j:
        if s[i] <= s[j]:
            u.append(s[i])
            i += 1
        else:
            t.append(s[j])
            j -= 1
    
    print(''.join(u))

solve()
","
def solve():
    from collections import deque
    
    s = input()
    t = deque()
    u = deque()
    
    for char in s:
        if not t or char < t[0]:
            t.appendleft(char)
        else:
            u.append(char)
    
    return ''.join(u)

solve()
","
def solve():
    import sys
    from collections import deque
    s = sys.stdin.readline().strip()
    t = deque()
    u = []
    for i in range(len(s)):
        if i % 2 == 0:
            t.appendleft(s[i])
        else:
            u.append(s[i])
    if len(s) % 2 != 0:
        u.extend(reversed(t))
    else:
        u.extend(t)
    print(''.join(u))

solve()","
def solve():
    import collections
    s = input().strip()
    cnt = collections.Counter(s)
    u = []
    t = []
    
    for ch in s:
        cnt[ch] -= 1
        if not t or t[-1] >= ch:
            t.append(ch)
        else:
            while u and u[-1] <= ch and cnt[u[-1]] > 0:
                t.append(u.pop())
            u.append(ch)
            
    u.extend(reversed(t))
    print("""".join(u))

solve()
","
def solve():
    import sys
    s = input().strip()
    t = []
    u = []
    
    for char in s:
        if len(t) == 0 or char >= t[0]:
            t.insert(0, char)
        else:
            u.append(char)
    
    u.reverse()
    print(''.join(u))


solve()
","
def solve():
    s = input().strip()
    t = """"
    u = """"

    while len(s) > 0:
        if len(t) == 0 or s[0] <= t[-1]:
            t += s[0]
            s = s[1:]
        else:
            u += t[-1]
            t = t[:-1]

    print(u)

solve()
","
def solve():
    import heapq

    s = input().strip()
    t = []
    u = []
    char_count = {}
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1

    char_heap = []
    for char, count in char_count.items():
        heapq.heappush(char_heap, (char, count))

    while char_heap:
        char, count = heapq.heappop(char_heap)
        if t and t[-1] <= char:
            u.append(t.pop())
            t.append(char)
        else:
            t.append(char)

    print(''.join(u))

solve()
","
def solve():
    s = input().strip()

    t = """"
    u = """"

    for char in s:
        if not u or char < u[-1]:
            u += char
        else:
            t = char + t

    print(u)

solve()
","
def solve():
    s = input().strip()
    t = []
    u = []
    
    i = 0
    j = len(s) - 1
    
    while i <= j:
        if len(t) == 0 or s[i] <= t[-1]:
            t.append(s[i])
            i += 1
        else:
            u.append(t.pop())
            j -= 1
    
    u.extend(reversed(t))
    
    print(''.join(u))

solve()","
def solve():
    s = input().strip()
    t = """"
    u = """"
    
    char_freq = [0] * 26
    
    for char in s:
        char_freq[ord(char) - ord('a')] += 1
    
    first = 0
    last = len(s) - 1
    
    while first <= last:
        if char_freq[ord(s[first]) - ord('a')] > 1:
            while last >= first and s[last] != s[first]:
                u += s[last]
                char_freq[ord(s[last]) - ord('a')] -= 1
                last -= 1
            u += s[first]
            char_freq[ord(s[first]) - ord('a')] = 0
            first += 1
        else:
            u += s[first]
            first += 1
    
    print(u)

solve()
  ","0.0","20.0","0.0","26.666666666666668","0.0","20.0","26.666666666666668","0.0","26.666666666666668","26.666666666666668","0.0","0.0","0.0","13.333333333333334","26.666666666666668","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/19","
QUESTION:
Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.

All levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by $1$. If he manages to finish the level successfully then the number of clears increases by $1$ as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).

Polycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.

So he peeked at the stats $n$ times and wrote down $n$ pairs of integers — $(p_1, c_1), (p_2, c_2), \dots, (p_n, c_n)$, where $p_i$ is the number of plays at the $i$-th moment of time and $c_i$ is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).

Between two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.

Finally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.

Help him to check the correctness of his records.

For your convenience you have to answer multiple independent test cases.


-----Input-----

The first line contains a single integer $T$ $(1 \le T \le 500)$ — the number of test cases.

The first line of each test case contains a single integer $n$ ($1 \le n \le 100$) — the number of moments of time Polycarp peeked at the stats.

Each of the next $n$ lines contains two integers $p_i$ and $c_i$ ($0 \le p_i, c_i \le 1000$) — the number of plays and the number of clears of the level at the $i$-th moment of time.

Note that the stats are given in chronological order.


-----Output-----

For each test case print a single line.

If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print ""YES"".

Otherwise, print ""NO"".

You can print each letter in any case (upper or lower).


-----Example-----
Input
6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0

Output
NO
YES
NO
YES
NO
YES



-----Note-----

In the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.

The second test case is a nice example of a Super Expert level.

In the third test case the number of plays decreased, which is impossible.

The fourth test case is probably an auto level with a single jump over the spike.

In the fifth test case the number of clears decreased, which is also impossible.

Nobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.
Use user-input-Based format and function signature solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        correct = True
        prev_plays, prev_clears = map(int, input().split())
        for _ in range(1, n):
            plays, clears = map(int, input().split())
            if plays < prev_plays or clears < prev_clears or plays - prev_plays < clears - prev_clears:
                correct = False
            prev_plays, prev_clears = plays, clears
        if correct:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        plays = 0
        clears = 0
        
        valid = True
        for _ in range(n):
            p, c = map(int, input().split())
            if p < plays or c < clears or p - plays < c - clears:
                valid = False
            plays = p
            clears = c
        
        if valid:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        records = []
        for _ in range(n):
            p, c = map(int, input().split())
            records.append((p, c))
        
        for i in range(1, n):
            if records[i][0] < records[i-1][0] or records[i][1] < records[i-1][1] or records[i][0]-records[i-1][0] < records[i][1]-records[i-1][1]:
                print(""NO"")
                break
        else:
            print(""YES"")

solve()
","
def solve():
    T = int(input())
    
    for _ in range(T):
        n = int(input())
        valid = True
        
        prev_plays, prev_clears = map(int, input().split())
        
        for _ in range(1, n):
            curr_plays, curr_clears = map(int, input().split())
            
            if curr_plays < prev_plays or curr_clears < prev_clears or curr_plays - prev_plays < curr_clears - prev_clears:
                valid = False
                
            prev_plays, prev_clears = curr_plays, curr_clears
        
        if valid:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        stats = []
        for _ in range(n):
            p, c = map(int, input().split())
            stats.append((p, c))
        
        possible = True
        prev_p = 0
        prev_c = 0
        for p, c in stats:
            if p < prev_p or c < prev_c or p - prev_p < c - prev_c:
                possible = False
                break
            prev_p = p
            prev_c = c
        
        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        stats = []
        for _ in range(n):
            stats.append(tuple(map(int, input().split())))

        possible = True
        for i in range(n-1):
            if stats[i][0] > stats[i][1] or stats[i][0] > stats[i+1][0] or stats[i][1] > stats[i+1][1]:
                possible = False
                break
        
        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        stats = []
        for _ in range(n):
            p, c = map(int, input().split())
            stats.append((p, c))

        possible = True
        prev_p, prev_c = 0, 0
        for p, c in stats:
            if p < prev_p or c < prev_c or p - prev_p < c - prev_c:
                possible = False
                break
            prev_p, prev_c = p, c

        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        valid = True
        prev_p, prev_c = map(int, input().split())

        for _ in range(1, n):
            p, c = map(int, input().split())
            diff_p = p - prev_p
            diff_c = c - prev_c

            if diff_p < 0 or diff_c < 0 or diff_c > diff_p:
                valid = False

            prev_p, prev_c = p, c

        if valid:
            print(""YES"")
        else:
            print(""NO"")

solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        valid = True
        prev_plays, prev_clears = map(int, input().split())
        for _ in range(1, n):
            curr_plays, curr_clears = map(int, input().split())
            if curr_plays < prev_plays or curr_clears < prev_clears or curr_clears - prev_clears > curr_plays - prev_plays:
                valid = False
        if valid:
            print(""YES"")
        else:
            print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    T = int(input())
    
    for _ in range(T):
        n = int(input())
        records = []
        for _ in range(n):
            p, c = map(int, input().split())
            records.append((p, c))
        
        valid = True
        for i in range(1, n):
            diff_p = records[i][0] - records[i-1][0]
            diff_c = records[i][1] - records[i-1][1]
            if diff_p < 0 or diff_c < 0 or diff_c > diff_p:
                valid = False
                break
        
        if valid:
            print(""YES"")
        else:
            print(""NO"")

solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        correctness = ""YES""
        for _ in range(n):
            p, c = map(int, input().split())
            if c > p or (c - p) % 2 != 0:
                correctness = ""NO""
        print(correctness)

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        records = []
        for _ in range(n):
            p, c = map(int, input().split())
            records.append((p, c))

        possible = True
        prev_p = 0
        prev_c = 0

        for p, c in records:
            if p < prev_p or c < prev_c or p - prev_p < c - prev_c:
                possible = False
                break
            prev_p = p
            prev_c = c

        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        for _ in range(n):
            p, c = map(int, input().split())
        if all(c >= p and (c - p) % 2 == 0 for p, c in zip(range(n), range(n), map(int, input().split()))):
            print(""YES"")
        else:
            print(""NO"")

solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        for _ in range(n):
            p, c = map(int, input().split())
        if p >= c:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    
    for _ in range(T):
        n = int(input())
        valid = True
        prev_plays = prev_clears = 0
        
        for _ in range(n):
            p, c = map(int, input().split())
            
            if p < prev_plays or c < prev_clears or c > p or p - prev_plays < c - prev_clears:
                valid = False
                
            prev_plays, prev_clears = p, c
        
        if valid:
            print(""YES"")
        else:
            print(""NO"")

solve()
  ","
def solve():
    T = int(input())
    for _ in range(T):
        n = int(input())
        correct = True
        prev_plays = 0
        prev_clears = 0
        
        for _ in range(n):
            p, c = map(int, input().split())
            if p < prev_plays or c < prev_clears or p - prev_plays < c - prev_clears:
                correct = False
            prev_plays = p
            prev_clears = c
        
        if correct:
            print(""YES"")
        else:
            print(""NO"")

solve()","100.0","100.0","100.0","100.0","100.0","86.66666666666667","100.0","100.0","80.0","100.0","86.66666666666667","100.0","0.0","13.333333333333334","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/20","
QUESTION:
Karen is getting ready for a new school day!

 [Image] 

It is currently hh:mm, given in a 24-hour format. As you know, Karen loves palindromes, and she believes that it is good luck to wake up when the time is a palindrome.

What is the minimum number of minutes she should sleep, such that, when she wakes up, the time is a palindrome?

Remember that a palindrome is a string that reads the same forwards and backwards. For instance, 05:39 is not a palindrome, because 05:39 backwards is 93:50. On the other hand, 05:50 is a palindrome, because 05:50 backwards is 05:50.


-----Input-----

The first and only line of input contains a single string in the format hh:mm (00 ≤  hh  ≤ 23, 00 ≤  mm  ≤ 59).


-----Output-----

Output a single integer on a line by itself, the minimum number of minutes she should sleep, such that, when she wakes up, the time is a palindrome.


-----Examples-----
Input
05:39

Output
11

Input
13:31

Output
0

Input
23:59

Output
1



-----Note-----

In the first test case, the minimum number of minutes Karen should sleep for is 11. She can wake up at 05:50, when the time is a palindrome.

In the second test case, Karen can wake up immediately, as the current time, 13:31, is already a palindrome.

In the third test case, the minimum number of minutes Karen should sleep for is 1 minute. She can wake up at 00:00, when the time is a palindrome.
Use user-input-Based format and function signature solve()","
def solve():
    from datetime import datetime, timedelta

    time_str = input().strip()
    current_time = datetime.strptime(time_str, '%H:%M')

    while True:
        current_time += timedelta(minutes=1)
        if current_time.strftime('%H:%M') == current_time.strftime('%H:%M')[::-1]:
            print((current_time - datetime.strptime(time_str, '%H:%M')).seconds // 60)
            break

solve()","
def solve():
    from datetime import datetime, timedelta
    
    current_time = input().strip()
    hh, mm = map(int, current_time.split("":""))
    
    current_datetime = datetime(year=2000, month=1, day=1, hour=hh, minute=mm)
    
    while True:
        current_datetime += timedelta(minutes=1)
        current_time = current_datetime.strftime(""%H:%M"")
        if current_time == current_time[::-1]:
            return int((current_datetime - datetime(year=2000, month=1, day=1, hour=hh, minute=mm)).seconds // 60)
            break
    
print(solve())

solve()","
def solve():
    import datetime

    def is_palindrome(time_str):
        return time_str == time_str[::-1]

    def calculate_minutes_to_palindrome(input_time):
        current_time = datetime.datetime.strptime(input_time, '%H:%M')
        while not is_palindrome(current_time.strftime('%H:%M')):
            current_time += datetime.timedelta(minutes=1)
        delta = current_time - datetime.datetime.strptime(input_time, '%H:%M')
        return int(delta.total_seconds() // 60)

    input_time = input().strip()
    minutes_to_palindrome = calculate_minutes_to_palindrome(input_time)
    print(minutes_to_palindrome)

solve()
","
def solve():
    from datetime import datetime, timedelta
    current_time = input().strip()
    hh, mm = map(int, current_time.split(':'))
    
    def is_palindrome(time_str):
        return time_str == time_str[::-1]
    
    time_str = current_time
    while not is_palindrome(time_str):
        dt = datetime.strptime(time_str, '%H:%M') + timedelta(minutes=1)
        time_str = dt.strftime('%H:%M')
    
    wakeup_time = datetime.strptime(time_str, '%H:%M')
    sleep_minutes = (wakeup_time - datetime.strptime(current_time, '%H:%M')).seconds // 60
    print(sleep_minutes)

solve()
","
from datetime import datetime

def solve():
    time = input().strip()
    current_time = datetime.strptime(time, '%H:%M')
    
    while True:
        current_time += timedelta(minutes=1)
        next_time_str = current_time.strftime('%H:%M')
        if next_time_str == next_time_str[::-1]:
            break
            
    sleep_min = (current_time - datetime.strptime(time, '%H:%M')).seconds // 60
    return sleep_min

solve()","
def solve():
    current_time = input().strip()
    hh, mm = map(int, current_time.split(':'))

    def is_palindrome(time):
        return time == time[::-1]

    while True:
        if is_palindrome(f'{hh:02d}:{mm:02d}'):
            break
        mm += 1
        if mm == 60:
            hh = (hh + 1) % 24
            mm = 0

    minutes_to_sleep = (60 - int(current_time.split(':')[1])) % 60
    print(minutes_to_sleep)

solve()
","
def solve():
    from datetime import datetime, timedelta
    
    current_time = input().strip()
    current_time_obj = datetime.strptime(current_time, ""%H:%M"")
    
    def is_palindrome(time_str):
        return time_str == time_str[::-1]
    
    while True:
        current_time_obj += timedelta(minutes=1)
        if is_palindrome(current_time_obj.strftime(""%H:%M"")):
            break
    
    minutes_to_sleep = (current_time_obj - datetime.strptime(current_time, ""%H:%M"")).seconds // 60
    print(minutes_to_sleep)

solve()
","
def solve():
    time = input().strip()
    hh, mm = map(int, time.split(':'))

    while True:
        mm += 1
        if mm == 60:
            mm = 0
            hh = (hh + 1) % 24

        if str(hh).zfill(2) == str(hh).zfill(2)[::-1] and str(mm).zfill(2) == str(mm).zfill(2)[::-1]:
            break

    print((int(str(hh).zfill(2)) - int(time[:2])) * 60 + int(str(mm).zfill(2)) - int(time[3:]))

solve()
","
def solve():
    from datetime import datetime, timedelta
    
    current_time_str = input()
    current_time = datetime.strptime(current_time_str, ""%H:%M"")
    
    sleep_time = 0
    
    while True:
        current_time += timedelta(minutes=1)
        current_time_str = current_time.strftime(""%H:%M"")
        if current_time_str == current_time_str[::-1]:
            break
        sleep_time += 1
    
    return sleep_time

solve()","
def solve():
    current_time = input().strip()
    hh, mm = map(int, current_time.split(':'))

    while True:
        mm += 1
        if mm == 60:
            mm = 0
            hh = (hh + 1) % 24

        hh_str = str(hh).zfill(2)
        mm_str = str(mm).zfill(2)

        if hh_str == hh_str[::-1] and mm_str == mm_str[::-1]:
            break

    minutes_to_sleep = (int(hh_str) - hh) * 60 + int(mm_str) - mm
    print(minutes_to_sleep)

solve()
  ","
from datetime import datetime, timedelta

def solve():
    current_time = input().strip()
    current_datetime = datetime.strptime(current_time, ""%H:%M"")
    
    def is_palindrome(time):
        return time == time[::-1]
    
    while True:
        if is_palindrome(current_time):
            return 0
        current_datetime += timedelta(minutes=1)
        current_time = current_datetime.strftime(""%H:%M"")
        if is_palindrome(current_time):
            return (current_datetime - datetime.strptime(current_time, ""%H:%M"")).seconds // 60

solve()","
def solve():
    current_time = input().strip()
    hh, mm = map(int, current_time.split(':'))
    
    def is_palindrome(time_str):
        return time_str == time_str[::-1]
    
    while not is_palindrome(f'{hh:02d}:{mm:02d}'):
        mm += 1
        if mm == 60:
            mm = 0
            hh = (hh + 1) % 24

    minutes_slept = (hh - int(current_time[:2])) * 60 + (mm - int(current_time[3:]))
    if minutes_slept < 0:
        minutes_slept += 1440

    print(minutes_slept)

solve()
","
def solve():
    time = input().split(':')
    hh = int(time[0])
    mm = int(time[1])

    def is_palindrome(hour, minute):
        if int(hour) < 10:
            hour = '0' + hour
        if int(minute) < 10:
            minute = '0' + minute
        return hour[0] == minute[1] and hour[1] == minute[0]

    while not is_palindrome(str(hh), str(mm)):
        mm += 1
        if mm == 60:
            mm = 0
            hh = (hh + 1) % 24

    minutes_to_sleep = (hh - int(time[0])) * 60 + (mm - int(time[1]))
    if minutes_to_sleep < 0:
        minutes_to_sleep += 1440

    return minutes_to_sleep

# Test cases
# print(solve())

solve()","
def solve():
    def is_palindrome(s):
        return s == s[::-1]

    def get_minutes_diff(current_time):
        hours, minutes = map(int, current_time.split(':'))
        minutes_diff = 0
        while True:
            next_minutes = (minutes + minutes_diff) % 60
            next_hours = hours + (minutes + minutes_diff) // 60
            next_time = f""{next_hours:02}:{next_minutes:02}""
            if is_palindrome(next_time):
                return minutes_diff
            minutes_diff += 1

    current_time = input().strip()
    print(get_minutes_diff(current_time))

solve()
","
def solve():
    current_time = input().strip()
    
    hours, minutes = map(int, current_time.split(':'))
    
    while True:
        minutes += 1
        if minutes == 60:
            minutes = 0
            hours = (hours + 1) % 24
        
        current_time = f""{hours:02d}:{minutes:02d}""
        
        if current_time == current_time[::-1]:  # Check if the time is a palindrome
            mins_asleep = (int(current_time[:2]) - int(current_time[3:])) * 60 + int(current_time[:2]) - hours
            print(mins_asleep)
            break

# Run the function
solve()
  ","
def solve():
    current_time = input().strip()
    hh, mm = map(int, current_time.split(':'))

    total_minutes = hh * 60 + mm

    while True:
        total_minutes = (total_minutes + 1) % (24 * 60)
        hh = total_minutes // 60
        mm = total_minutes % 60

        if (hh // 10 == mm % 10) and (hh % 10 == mm // 10):
            break

    return (total_minutes - (int(current_time[:2]) * 60 + int(current_time[3:])))

solve()
  ","60.0","0.0","100.0","100.0","0.0","6.666666666666667","60.0","0.0","0.0","40.0","0.0","100.0","0.0","93.33333333333333","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/21","
QUESTION:
Nicholas has an array a that contains n distinct integers from 1 to n. In other words, Nicholas has a permutation of size n.

Nicholas want the minimum element (integer 1) and the maximum element (integer n) to be as far as possible from each other. He wants to perform exactly one swap in order to maximize the distance between the minimum and the maximum elements. The distance between two elements is considered to be equal to the absolute difference between their positions.


-----Input-----

The first line of the input contains a single integer n (2 ≤ n ≤ 100) — the size of the permutation.

The second line of the input contains n distinct integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ n), where a_{i} is equal to the element at the i-th position.


-----Output-----

Print a single integer — the maximum possible distance between the minimum and the maximum elements Nicholas can achieve by performing exactly one swap.


-----Examples-----
Input
5
4 5 1 3 2

Output
3

Input
7
1 6 5 3 4 7 2

Output
6

Input
6
6 5 4 3 2 1

Output
5



-----Note-----

In the first sample, one may obtain the optimal answer by swapping elements 1 and 2.

In the second sample, the minimum and the maximum elements will be located in the opposite ends of the array if we swap 7 and 2.

In the third sample, the distance between the minimum and the maximum elements is already maximum possible, so we just perform some unnecessary swap, for example, one can swap 5 and 2.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_idx = a.index(1)
    max_idx = a.index(n)
    
    max_distance = max(max_idx, min_idx, n - 1 - min_idx, n - 1 - max_idx)
    
    if min_idx > max_idx:
        min_idx, max_idx = max_idx, min_idx
    
    for i in range(n):
        if a[i] != 1 and a[i] != n and i != min_idx and i != max_idx:
            continue
        if i < min_idx:
            max_distance = max(max_distance, max_idx - i)
        elif i > max_idx:
            max_distance = max(max_distance, i - min_idx)
    
    print(max_distance)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_idx = a.index(1)
    max_idx = a.index(n)

    max_distance = max(max_idx, min_idx, n - 1 - min_idx, n - 1 - max_idx)

    if min_idx > max_idx:
        min_idx, max_idx = max_idx, min_idx

    max_distance = max(max_distance, max_idx - 0, n - 1 - min_idx)

    print(max_distance)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_pos = a.index(1)
    max_pos = a.index(n)
    
    ans = max(max_pos, min_pos, n - 1 - min_pos, n - 1 - max_pos)
    print(ans)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    min_index = a.index(1)
    max_index = a.index(n)
    
    max_distance = max(abs(min_index - 0), abs(min_index - (n-1)), abs(max_index - 0), abs(max_index - (n-1)))
    
    for i in range(n):
        if a[i] != 1 and a[i] != n:
            max_distance = max(max_distance, max(abs(i - min_index), abs(i - max_index)))
    
    print(max_distance)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_idx = a.index(1)
    max_idx = a.index(n)

    distances = [max_idx, min_idx, n - 1 - min_idx, n - 1 - max_idx]

    print(max(distances))

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_idx = a.index(1)
    max_idx = a.index(n)
    
    dist1 = max_idx - min_idx
    dist2 = abs(n - 1 - min_idx)
    dist3 = abs(n - 1 - max_idx)
    
    print(max(dist1, dist2, dist3))

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_pos = a.index(1)
    max_pos = a.index(n)

    distance = max(abs(min_pos - n), abs(max_pos - n), abs(min_pos - 1), abs(max_pos - 1))

    if min_pos == 0 and max_pos == n-1:
        distance = n-1

    print(distance)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_index = a.index(min(a))
    max_index = a.index(max(a))
    
    max_distance = max(max_index, min_index, n - 1 - min_index, n - 1 - max_index)
    
    if abs(max_index - min_index) == n - 1:
        print(n - 1)
    else:
        print(max_distance)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    min_idx = a.index(1)
    max_idx = a.index(n)

    max_distance = max(max_idx - min_idx, n - 1 - min_idx, max_idx)

    print(max_distance)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_index = a.index(1)
    max_index = a.index(n)
    
    max_distance = max(abs(min_index - 0), abs(min_index - (n-1)), abs(max_index - 0), abs(max_index - (n-1)))
    
    if min_index > max_index:
        max_distance = max(max_distance, min_index, n-1-max_index)
    
    elif max_index > min_index:
        max_distance = max(max_distance, max_index, n-1-min_index)
    
    print(max_distance)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_pos = a.index(min(a))
    max_pos = a.index(max(a))

    ans = max(abs(min_pos - max_pos), abs(min_pos - 0), abs(max_pos - (n-1)))
    print(ans)

solve()","
def solve():
    # Input
    n = int(input())
    a = list(map(int, input().split()))

    # Find positions of minimum and maximum elements
    min_pos = a.index(min(a))
    max_pos = a.index(max(a))

    # Calculate distance between min and max elements
    initial_distance = abs(min_pos - max_pos)

    # Calculate maximum possible distance after one swap
    max_distance = max(initial_distance, abs(min_pos - n+1), abs(max_pos - n+1))

    # Output maximum possible distance
    print(max_distance)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_index = a.index(1)
    max_index = a.index(n)
    
    dist1 = max(min_index, max_index)
    dist2 = n - 1 - min_index + n - 1 - max_index
    
    print(max(dist1, dist2))

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_idx = a.index(1)
    max_idx = a.index(n)
    
    swap_max = max(min_idx, max_idx, n - 1 - min_idx, n - 1 - max_idx)
    
    print(swap_max)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_index = a.index(1)
    max_index = a.index(n)

    max_distance = max(max_index, min_index, n - 1 - min_index, n - 1 - max_index)

    print(max_distance)
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_pos = a.index(1)
    max_pos = a.index(n)
    
    dist = max(max_pos, min_pos, n - 1 - min_pos, n - 1 - max_pos)
    
    if min_pos > max_pos:
        min_pos, max_pos = max_pos, min_pos
    
    return max(dist, max_pos - 0, n - 1 - min_pos)

solve()","100.0","100.0","100.0","100.0","100.0","66.66666666666666","26.666666666666668","100.0","33.33333333333333","100.0","80.0","66.66666666666666","60.0","100.0","100.0","0.0","","","","","","","","","","","","","","","",""
"APPS/22","
QUESTION:
Let's call a string ""s-palindrome"" if it is symmetric about the middle of the string. For example, the string ""oHo"" is ""s-palindrome"", but the string ""aa"" is not. The string ""aa"" is not ""s-palindrome"", because the second half of it is not a mirror reflection of the first half.

 [Image] English alphabet 

You are given a string s. Check if the string is ""s-palindrome"".


-----Input-----

The only line contains the string s (1 ≤ |s| ≤ 1000) which consists of only English letters.


-----Output-----

Print ""TAK"" if the string s is ""s-palindrome"" and ""NIE"" otherwise.


-----Examples-----
Input
oXoxoXo

Output
TAK

Input
bod

Output
TAK

Input
ER

Output
NIE
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    mirror = ""AHIMOTUVWXY""
    
    n = len(s)
    if n % 2 == 0:
        return ""NIE""
    
    mid = n // 2
    if s[mid] not in mirror:
        return ""NIE""
    
    for i in range(mid):
        if s[i] not in alphabet or s[i] != mirror[25 - alphabet.index(s[mid] * 2 - i)]:
            return ""NIE""
    
    return ""TAK""

solve()","
def solve():
    s = input().strip()
    n = len(s)
    mid = n // 2

    mirror_chars = {'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y'}

    for i in range(mid):
        if s[i] not in mirror_chars or s[n - 1 - i] != mirror_chars[s[i]]:
            print(""NIE"")
            return
    
    print(""TAK"")

solve()
","
def solve():
    s = input().strip()
    alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    for i in range(len(s)):
        if s[i] != alphabet[25 - alphabet.index(s[len(s) - i - 1])]:
            print(""NIE"")
            return
    print(""TAK"")

solve()","
def solve():
    s = input().strip()

    alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    mirror = ""AHIMOTUVWXY""
    
    for i in range(len(s) // 2):
        if s[i] not in alphabet or s[i] != s[len(s) - i - 1] or s[i] not in mirror:
            print(""NIE"")
            return
    
    print(""TAK"")

solve()
","
def solve():
    s = input().strip()
    alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

    for i in range(len(s)//2):
        if s[i] != s[len(s)-1-i] and alphabet.find(s[i].upper()) != alphabet.find(s[len(s)-1-i].upper()):
            print(""NIE"")
            return

    print(""TAK"")

solve()","
def solve():
    s = input().strip()
    n = len(s)
    alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    
    for i in range((n+1)//2):
        if s[i] != s[n-1-i] and alphabet.find(s[i]) == alphabet.rfind(s[n-1-i]):
            print(""NIE"")
            return
    print(""TAK"")

solve()
","
def solve():
    s = input().strip()
    mid = len(s) // 2
    if len(s) % 2 == 0:
        return ""TAK"" if s[:mid] == s[mid:][::-1] else ""NIE""
    else:
        return ""TAK"" if s[:mid] == s[mid+1:][::-1] else ""NIE""

solve()
","
def solve():
    s = input()
    n = len(s)
    for i in range(n // 2):
        if s[i] != s[n - i - 1]:
            print(""NIE"")
            return
    print(""TAK"")

solve()
","
def solve():
    s = input().strip()
    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    mirror = {'A': 'A', 'B': None, 'C': None, 'D': None, 'E': 'E', 'F': None, 'G': None, 'H': 'H', 'I': None, 'J': None,
    'K': 'K', 'L': None, 'M': None, 'N': None, 'O': 'O', 'P': None, 'Q': None, 'R': 'R', 'S': None, 'T': None, 'U': None,
    'V': None, 'W': None, 'X': 'X', 'Y': None, 'Z': None}
    
    if len(s) % 2 == 1:
        mid = len(s) // 2
        if s[mid] != alphabet[mid]:
            print(""NIE"")
            return
        s = s[:mid] + s[mid+1:]
    
    if all(mirror[s[i]] == s[-i-1] for i in range(len(s) // 2)):
        print(""TAK"")
    else:
        print(""NIE"")

solve()
","
def solve():
    s = input()
    alphabet_mirror = {
        'A': 'A', 'B': ' ', 'C': ' ', 'D': ' ', 'E': '3', 'F': ' ', 'G': ' ', 'H': 'H',
        'I': 'I', 'J': 'L', 'K': ' ', 'L': 'J', 'M': 'M', 'N': ' ', 'O': 'O', 'P': ' ', 'Q': ' ',
        'R': 'R', 'S': '2', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': '5',
        '0': '0', '1': '1', '2': 'S', '3': 'E', '4': ' ', '5': 'Z', '6': ' ', '7': ' ', '8': '8', '9': ' '
    }
    
    def is_s_palindrome(s):
        n = len(s)
        for i in range(n):
            if s[i] != alphabet_mirror.get(s[n-i-1]):
                return False
            if n-i-1 <= i:
                break
        return True

    if is_s_palindrome(s.upper()):
        print(""TAK"")
    else:
        print(""NIE"")

solve()
  ","
def solve():
    s = input().strip()
    alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    
    for i in range(len(s)):
        if s[i] != s[len(s)-1-i] and alphabet.find(s[i]) + alphabet.find(s[len(s)-1-i]) != 25:
            print(""NIE"")
            return
    
    print(""TAK"")

solve()
","
def solve():
    s = input()

    def is_s_palindrome(s):
        mid = len(s) // 2
        return s[:mid] == s[-mid:][::-1]

    if is_s_palindrome(s):
        print(""TAK"")
    else:
        print(""NIE"")

solve()
","
def solve():
    s = input().strip()

    def is_s_palindrome(s):
        half_length = len(s) // 2
        return s[:half_length] == s[-half_length:][::-1]

    if is_s_palindrome(s):
        print(""TAK"")
    else:
        print(""NIE"")
        
solve()
","
def solve():
    s = input().strip()

    n = len(s)
    mid = n // 2

    if n % 2 == 0:  # Even length
        if s[:mid] == s[mid:][::-1]:
            print(""TAK"")
        else:
            print(""NIE"")
    else:  # Odd length
        if s[:mid] == s[mid+1:][::-1]:
            print(""TAK"")
        else:
            print(""NIE"")

solve()
","
def solve():
    s = input().strip()
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    mirrored = 'A   3  HIL JM O   2TUVWXY51SE Z  8 '
    
    def is_s_palindrome(s):
        mirrored_chars = {alphabet[i]: mirrored[i] for i in range(len(alphabet))}
        n = len(s)
        for i in range((n+1)//2):
            if s[i] != mirrored_chars.get(s[n-1-i], None):
                return False
        return True
    
    if is_s_palindrome(s):
        print(""TAK"")
    else:
        print(""NIE"")

solve()
","
def solve():
    s = input()
    n = len(s)
    
    if n % 2 == 0:
        return ""NIE""
    
    mid = n // 2
    mirror = {'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y'}
    
    for i in range(mid):
        if s[i] not in mirror or s[mid+i+1] != mirror.get(s[i]):
            return ""NIE""
    
    return ""TAK""

solve()
","0.0","60.0","20.0","60.0","53.333333333333336","40.0","0.0","53.333333333333336","40.0","66.66666666666666","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","60.0","0.0","","","","","","","","","","","","","","","",""
"APPS/23","
QUESTION:
You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0.

It is allowed to leave a as it is.


-----Input-----

The first line contains integer a (1 ≤ a ≤ 10^18). The second line contains integer b (1 ≤ b ≤ 10^18). Numbers don't have leading zeroes. It is guaranteed that answer exists.


-----Output-----

Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can't have any leading zeroes. It is guaranteed that the answer exists.

The number in the output should have exactly the same length as number a. It should be a permutation of digits of a.


-----Examples-----
Input
123
222

Output
213

Input
3921
10000

Output
9321

Input
4940
5000

Output
4940
Use user-input-Based format and function signature solve()","
from itertools import permutations

def solve():
    a = input().strip()
    b = int(input().strip())
    
    a_permutations = sorted(set(permutations(a, len(a))), reverse=True)
    
    for perm in a_permutations:
        num = int(''.join(perm))
        if num <= b:
            print(num)
            break


solve()","
def solve():
    a = int(input().strip())
    b = int(input().strip())
    
    a_str = sorted(str(a), reverse=True)
    b_str = str(b)
    
    result = ''
    for digit in a_str:
        if b_str.count(digit) > 0:
            result += digit
            b_str = b_str.replace(digit, '', 1)
        else:
            break
    
    print(result)

solve()","
def solve():
    from itertools import permutations

    a = input().strip()
    b = int(input().strip())
    
    perm = [''.join(p) for p in permutations(a)]
    valid_perms = [int(p) for p in perm if int(p) <= b]
    
    max_perm = max(valid_perms)
    
    print(max_perm)

solve()","
from itertools import permutations

def solve():
    a = input()
    b = input()

    sorted_perms = sorted(permutations(str(a), len(str(a))), reverse=True)

    for perm in sorted_perms:
        num = int(''.join(perm))
        if num <= int(b):
            return num

a = solve()
print(a)

solve()","
from itertools import permutations

def solve():
    a = input().strip()
    b = input().strip()

    max_num = -1
    for perm in permutations(a):
        num = int("""".join(perm))
        if num <= int(b):
            max_num = max(max_num, num)

    print(max_num)

solve()","
from itertools import permutations

def solve():
    a = input()
    b = input()

    str_a = str(a)
    digits_a = sorted(str_a)

    for perm in permutations(digits_a, len(str_a)):
        current_num = int(''.join(perm))
        if current_num <= b:
            max_num_permutation = perm

    return int(''.join(max_num_permutation))


solve()","
def solve():
    from itertools import permutations

    a = input()
    b = input()

    a_str = sorted(str(a), reverse=True)
    perms = permutations(a_str)

    max_num = -1
    for perm in perms:
        num = int(''.join(perm))
        if num <= int(b) and num > max_num:
            max_num = num
    
    return max_num

solve()","
from itertools import permutations

def solve():
    a = input().strip()
    b = int(input().strip())
    
    max_num = 0
    for perm in permutations(a):
        num = int(''.join(perm))
        if num <= b:
            max_num = max(max_num, num)
    
    print(max_num)

solve()
","
from itertools import permutations

def solve():
    a = input().strip()
    b = input().strip()
    
    sorted_permutations = sorted(permutations(a, len(a)), reverse=True)
    
    for perm in sorted_permutations:
        num = int(''.join(perm))
        if num <= int(b):
            print(num)
            break

solve()
","
from itertools import permutations

def solve():
    a = input()
    b = input()

    a_str = str(a)
    b_str = str(b)

    max_num = a
    for perm in permutations(a_str):
        num = int("""".join(perm))
        if num <= b and num > max_num:
            max_num = num

    return str(max_num)
  
solve()","
from itertools import permutations

def solve():
    a = input().strip()
    b = int(input().strip())
    
    digits_a = sorted(str(a))
    
    max_num = 0
    for perm in permutations(digits_a):
        num = int(''.join(perm))
        if num <= b:
            max_num = max(max_num, num)
    
    print(max_num)

solve()
","
def solve():
    a = input().strip()
    b = input().strip()
    
    a_sorted = sorted(a, reverse=True)
    b_sorted = sorted(b, reverse=True)
    
    for i in range(len(a_sorted)):
        for j in range(len(b_sorted)):
            if a_sorted[i] > b_sorted[j]:
                a_sorted[i], b_sorted[j] = b_sorted[j], a_sorted[i]
                break
            elif a_sorted[i] == b_sorted[j]:
                if i < len(a_sorted) - 1 and a_sorted[i] < a_sorted[i+1]:
                    a_sorted[i], a_sorted[i+1] = a_sorted[i+1], a_sorted[i]
                break
    
    print(''.join(a_sorted))

if __name__ == ""__main__"":
    solve()
","
from itertools import permutations

def solve():
    a = input()
    b = input()
    
    a_str = list(str(a))
    b_str = list(str(b))

    max_num = a
    for perm in permutations(a_str, len(a_str)):
        if perm[0] != '0' and int(''.join(perm)) <= int(b):
            max_num = max(max_num, int(''.join(perm)))

    return max_num

solve()","
from itertools import permutations

def solve():
    a = input().strip()
    b = int(input().strip())
    
    digits = sorted(a, reverse=True)
    for perm in permutations(digits):
        num = int(''.join(perm))
        if num <= b:
            print(num)
            break


solve()","
def solve():
    from itertools import permutations
    a = input().strip()
    b = int(input())
    
    a_str = sorted(a, reverse=True)
    
    for perm in permutations(a_str):
        num = int("""".join(perm))
        if num <= b:
            return str(num)

print(solve())

solve()","
from itertools import permutations

def solve():
    a = input().strip()
    b = input().strip()

    def find_max_permutation(a, b):
        a_permutations = list(permutations(a))
        max_permutation = a

        for perm in a_permutations:
            num = int(''.join(perm))
            if num <= int(b) and num > int(max_permutation):
                max_permutation = str(num)

        return max_permutation

    print(find_max_permutation(a, b))

solve()
","100.0","20.0","100.0","0.0","100.0","0.0","0.0","100.0","100.0","0.0","100.0","20.0","0.0","100.0","0.0","100.0","","","","","","","","","","","","","","","",""
"APPS/24","
QUESTION:
Alice and Bob play 5-in-a-row game. They have a playing field of size 10 × 10. In turns they put either crosses or noughts, one at a time. Alice puts crosses and Bob puts noughts.

In current match they have made some turns and now it's Alice's turn. She wonders if she can put cross in such empty cell that she wins immediately.

Alice wins if some crosses in the field form line of length not smaller than 5. This line can be horizontal, vertical and diagonal.


-----Input-----

You are given matrix 10 × 10 (10 lines of 10 characters each) with capital Latin letters 'X' being a cross, letters 'O' being a nought and '.' being an empty cell. The number of 'X' cells is equal to the number of 'O' cells and there is at least one of each type. There is at least one empty cell.

It is guaranteed that in the current arrangement nobody has still won.


-----Output-----

Print 'YES' if it's possible for Alice to win in one turn by putting cross in some empty cell. Otherwise print 'NO'.


-----Examples-----
Input
XX.XX.....
.....OOOO.
..........
..........
..........
..........
..........
..........
..........
..........

Output
YES

Input
XXOXX.....
OO.O......
..........
..........
..........
..........
..........
..........
..........
..........

Output
NO
Use user-input-Based format and function signature solve()","
def solve():
    field = [input() for _ in range(10)]

    def check_win():
        for i in range(10):
            for j in range(10):
                if field[i][j] == '.':
                    field[i] = field[i][:j] + 'X' + field[i][j+1:]
                    if check_line(i, j):
                        return True
                    field[i] = field[i][:j] + '.' + field[i][j+1:]
        return False

    def check_line(x, y):
        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
        for dx, dy in directions:
            count = 1
            for k in range(1, 5):
                nx, ny = x + k*dx, y + k*dy
                if 0 <= nx < 10 and 0 <= ny < 10 and field[nx][ny] == 'X':
                    count += 1
                else:
                    break
            for k in range(1, 5):
                nx, ny = x - k*dx, y - k*dy
                if 0 <= nx < 10 and 0 <= ny < 10 and field[nx][ny] == 'X':
                    count += 1
                else:
                    break
            if count >= 5:
                return True
        return False

    if check_win():
        print('YES')
    else:
        print('NO')

solve()
","
def solve():
    def check_line(line):
        if 'XXXXX' in line:
            return True
        return False
    
    def check_diagonals(matrix):
        for i in range(6):
            for j in range(6):
                diagonal1 = [matrix[i+k][j+k] for k in range(5)]
                diagonal2 = [matrix[i+k][j+4-k] for k in range(5)]
                if check_line(diagonal1) or check_line(diagonal2):
                    return True
        return False
    
    def check_rows(matrix):
        for row in matrix:
            if check_line(''.join(row)):
                return True
        return False
    
    def check_columns(matrix):
        for col in range(10):
            column = [matrix[row][col] for row in range(10)]
            if check_line(''.join(column)):
                return True
        return False
    
    game_matrix = [input() for _ in range(10)]

    if check_diagonals(game_matrix) or check_rows(game_matrix) or check_columns(game_matrix):
        print('YES')
    else:
        print('NO')

solve()
  ","
from itertools import product

def solve():
    def check_win(board):
        for i in range(10):
            for j in range(10):
                if board[i][j] == '.':
                    for dx, dy in product([-1, 0, 1], repeat=2):
                        if dx == dy == 0:
                            continue
                        cnt = 0
                        for k in range(5):
                            x, y = i + k*dx, j + k*dy
                            if 0 <= x < 10 and 0 <= y < 10 and board[x][y] == 'X':
                                cnt += 1
                            else:
                                break
                        if cnt == 5:
                            return True
        return False

    board = [input() for _ in range(10)]
    for i in range(10):
        for j in range(10):
            if board[i][j] == '.':
                board[i][j] = 'X'
                if check_win(board):
                    print('YES')
                    return
                board[i][j] = '.'
    print('NO')
  
solve()","
def solve():
    field = [input() for _ in range(10)]
    
    for i in range(10):
        for j in range(10):
            if field[i][j] == '.':
                field[i] = field[i][:j] + 'X' + field[i][j+1:]
                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:
                    if 0 <= i + 4*di < 10 and 0 <= j + 4*dj < 10:
                        line = [field[i + k*di][j + k*dj] for k in range(5)]
                        if line.count('X') >= 5:
                            return 'YES'
                field[i] = field[i][:j] + '.' + field[i][j+1:]
    
    return 'NO'
  
solve()","
def solve():
    field = [list(input()) for _ in range(10)]

    def check_line(line):
        count = 0
        for cell in line:
            if cell == 'X':
                count += 1
            else:
                count = 0
            if count >= 5:
                return True
        return False

    for i in range(10):
        for j in range(10):
            if field[i][j] == '.':
                field[i][j] = 'X'
                for row in field:
                    if check_line(row):
                        print(""YES"")
                        return
                for col in range(10):
                    if check_line([field[r][col] for r in range(10)]):
                        print(""YES"")
                        return
                for k in range(-4, 5):
                    if 0 <= i+k < 10 and 0 <= j+k < 10:
                        if check_line([field[i+a][j+b] for a, b in zip(range(k, k+5), range(k, k+5))]):
                            print(""YES"")
                            return
                    if 0 <= i+k < 10 and 0 <= j-k < 10:
                        if check_line([field[i+a][j+b] for a, b in zip(range(k, k+5), range(-k, -k-5, -1))]):
                            print(""YES"")
                            return
                field[i][j] = '.'

    print(""NO"")

solve()
","
def solve():
    field = [input() for _ in range(10)]
    
    for i in range(10):
        for j in range(10):
            if field[i][j] == '.':
                field[i] = field[i][:j] + 'X' + field[i][j+1:]
                
                lines = []
                for k in range(10):
                    lines.append(field[k])
                    lines.append(''.join(field[x][k] for x in range(10)))
                lines.append(''.join(field[x][x] for x in range(10)))
                lines.append(''.join(field[x][9-x] for x in range(10)))

                for line in lines:
                    if 'XXXXX' in line:
                        print('YES')
                        return
                field[i] = field[i][:j] + '.' + field[i][j+1:]
    
    print('NO')
  
solve()","
from collections import Counter

def solve():
    matrix = [input() for _ in range(10)]
    
    def check_win(i, j, di, dj):
        player = 'X'
        count = 1
        while 0 <= i < 10 and 0 <= j < 10:
            if matrix[i][j] == player:
                count += 1
                if count >= 5:
                    return True
            else:
                count = 1
                player = matrix[i][j]
            i += di
            j += dj
        return False
    
    for i in range(10):
        for j in range(10):
            if matrix[i][j] == '.':
                if check_win(i, j, 0, 1) or check_win(i, j, 1, 0) or check_win(i, j, 1, 1) or check_win(i, j, 1, -1):
                    print('YES')
                    return
    print('NO')

solve()
","
def solve():
    matrix = [input() for _ in range(10)]
    
    def check_win(matrix, row, col, dx, dy):
        count = 0
        while 0 <= row < 10 and 0 <= col < 10 and matrix[row][col] == ""X"":
            count += 1
            row += dy
            col += dx
        return count >= 5
    
    for i in range(10):
        for j in range(10):
            if matrix[i][j] == ""."":
                for dx, dy in [(1, 0), (0, 1), (1, 1), (1, -1)]:
                    if check_win(matrix, i, j, dx, dy):
                        print(""YES"")
                        return
    print(""NO"")

solve()","
def solve():
    matrix = [list(input()) for _ in range(10)]

    def check_win(x, y, dx, dy):
        for i in range(5):
            nx, ny = x + i * dx, y + i * dy
            if nx < 0 or nx >= 10 or ny < 0 or ny >= 10 or matrix[nx][ny] == 'O':
                return False
        return True

    for i in range(10):
        for j in range(10):
            if matrix[i][j] == '.':
                for di, dj in [(0, 1), (1, 0), (1, 1), (1, -1)]:
                    if check_win(i, j, di, dj):
                        print('YES')
                        return
    print('NO')

solve()
  ","
def solve():
    import numpy as np
    
    def check_win(arr, symbol):
        for i in range(10):
            for j in range(10):
                if arr[i][j] == symbol:
                    # Check horizontal
                    if j+4 < 10 and all(arr[i][k] == symbol for k in range(j, j+5)):
                        return True
                    # Check vertical
                    if i+4 < 10 and all(arr[k][j] == symbol for k in range(i, i+5)):
                        return True
                    # Check diagonal
                    if i+4 < 10 and j+4 < 10 and all(arr[i+k][j+k] == symbol for k in range(5)):
                        return True
                    if i-4 >= 0 and j+4 < 10 and all(arr[i-k][j+k] == symbol for k in range(5)):
                        return True
        return False
    
    board = [list(input()) for _ in range(10)]
    board_arr = np.array(board)
    
    for i in range(10):
        for j in range(10):
            if board_arr[i][j] == '.':
                board_arr[i][j] = 'X'
                if check_win(board_arr, 'X'):
                    print('YES')
                    return
                board_arr[i][j] = '.'
    
    print('NO')

solve()","
def solve():
    field = [input().strip() for _ in range(10)]

    for i in range(10):
        for j in range(10):
            if field[i][j] == '.':
                for dx, dy in [(0, 1), (1, 0), (1, 1), (1, -1)]:
                    counter = 1
                    for k in range(1, 5):
                        x, y = i + k * dx, j + k * dy
                        if x < 0 or x >= 10 or y < 0 or y >= 10 or field[x][y] == 'O':
                            break
                        if field[x][y] == 'X':
                            counter += 1
                    if counter >= 5:
                        print('YES')
                        return
    print('NO')
  
solve()","
def solve():
    import numpy as np
    
    def check_win(matrix, player):
        for r in range(10):
            for c in range(10):
                if matrix[r, c] == '.':
                    matrix[r, c] = player
                    # Check rows
                    if 'X' * 5 in ''.join(matrix[r]):
                        return True
                    # Check cols
                    if 'X' * 5 in ''.join(matrix[:, c]):
                        return True
                    # Check diagonals
                    if 'X' * 5 in ''.join(np.diagonal(matrix, c - r)):
                        return True
                    if 'X' * 5 in ''.join(np.diagonal(np.fliplr(matrix), 9 - c - r)):
                        return True
                    matrix[r, c] = '.'
        return False

    matrix = np.array([list(input()) for _ in range(10)])
    if check_win(matrix, 'X'):
        print('YES')
    else:
        print('NO')

solve()
","
def solve():
    matrix = [input() for _ in range(10)]

    for i in range(10):
        for j in range(10):
            if matrix[i][j] == '.':
                for dx, dy in [(0, 1), (1, 0), (1, 1), (1, -1)]:
                    cnt = 1
                    x, y = i + dx, j + dy
                    while 0 <= x < 10 and 0 <= y < 10 and matrix[x][y] == 'X':
                        cnt += 1
                        x += dx
                        y += dy
                    x, y = i - dx, j - dy
                    while 0 <= x < 10 and 0 <= y < 10 and matrix[x][y] == 'X':
                        cnt += 1
                        x -= dx
                        y -= dy
                    if cnt >= 5:
                        return 'YES'
    return 'NO'

solve()","
def solve():
    matrix = []
    for _ in range(10):
        matrix.append(input())
    for i in range(10):
        for j in range(10):
            if matrix[i][j] == '.':
                # Check horizontal
                horiz_count = 0
                for x in range(j, min(j + 5, 10)):
                    if matrix[i][x] == 'X':
                        horiz_count += 1
                    else:
                        break
                if horiz_count >= 5:
                    return 'YES'
                
                # Check vertical
                vert_count = 0
                for y in range(i, min(i + 5, 10)):
                    if matrix[y][j] == 'X':
                        vert_count += 1
                    else:
                        break
                if vert_count >= 5:
                    return 'YES'
                
                # Check diagonal (top-left to bottom-right)
                diag1_count = 0
                for k in range(5):
                    if i+k < 10 and j+k < 10 and matrix[i+k][j+k] == 'X':
                        diag1_count += 1
                    else:
                        break
                if diag1_count >= 5:
                    return 'YES'
                
                # Check diagonal (bottom-left to top-right)
                diag2_count = 0
                for l in range(5):
                    if i-l >= 0 and j+l < 10 and matrix[i-l][j+l] == 'X':
                        diag2_count += 1
                    else:
                        break
                if diag2_count >= 5:
                    return 'YES'
                    
    return 'NO'
  
solve()","
def solve():
    matrix = []
    for _ in range(10):
        line = input()
        matrix.append(line)
    
    for i in range(10):
        for j in range(10):
            if matrix[i][j] == '.':
                matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]
                if check_win(matrix, i, j):
                    print('YES')
                    return
                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]
    
    print('NO')

def check_win(matrix, x, y):
    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]
    for dx, dy in directions:
        count = 1
        nx, ny = x, y
        while 0 <= nx + dx < 10 and 0 <= ny + dy < 10 and matrix[nx+dx][ny+dy] == 'X':
            count += 1
            nx += dx
            ny += dy
        nx, ny = x, y
        while 0 <= nx - dx < 10 and 0 <= ny - dy < 10 and matrix[nx-dx][ny-dy] == 'X':
            count += 1
            nx -= dx
            ny -= dy
        if count >= 5:
            return True
    return False

solve()
","
def solve():
    from itertools import product

    def check_line(line):
        for i in range(len(line) - 4):
            if line[i:i+5].count('X') == 5:
                return True
        return False
    
    matrix = [input().strip() for _ in range(10)]

    for i, j in product(range(10), repeat=2):
        if matrix[i][j] == '.':
            matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]
            if any(check_line(matrix[i]) for i in range(10)):
                print('YES')
                return
            if any(check_line(''.join(matrix[i]) for i in range(10))):
                print('YES')
                return
            if any(check_line(''.join(matrix[i][j] for i in range(10))) for j in range(10)):
                print('YES')
                return
            if any(check_line(''.join(matrix[i][j] for i in range(10-j))) for j in range(10)):
                print('YES')
                return
            if any(check_line(''.join(matrix[i][j] for i in range(j, 10))) for j in range(10)):
                print('YES')
                return
            matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]

    print('NO')

solve()","100.0","66.66666666666666","0.0","0.0","13.333333333333334","86.66666666666667","26.666666666666668","66.66666666666666","33.33333333333333","100.0","73.33333333333333","100.0","0.0","0.0","100.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/25","
QUESTION:
You are given matrix with n rows and n columns filled with zeroes. You should put k ones in it in such a way that the resulting matrix is symmetrical with respect to the main diagonal (the diagonal that goes from the top left to the bottom right corner) and is lexicographically maximal.

One matrix is lexicographically greater than the other if the first different number in the first different row from the top in the first matrix is greater than the corresponding number in the second one.

If there exists no such matrix then output -1.


-----Input-----

The first line consists of two numbers n and k (1 ≤ n ≤ 100, 0 ≤ k ≤ 10^6).


-----Output-----

If the answer exists then output resulting matrix. Otherwise output -1.


-----Examples-----
Input
2 1

Output
1 0 
0 0 

Input
3 2

Output
1 0 0 
0 1 0 
0 0 0 

Input
2 5

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    import numpy as np

    n, k = map(int, input().split())
    if k > n*n:
        print(-1)
        return

    matrix = np.zeros((n, n), dtype=int)
    for i in range(n):
        if k == 0:
            break
        matrix[i][i] = 1
        k -= 1
        if k > 0:
            matrix[n-1-i][i] = 1
            k -= 1

    for row in matrix:
        print(' '.join(map(str, row)))

solve()
","
def solve():
    import numpy as np
    
    n, k = map(int, input().split())
    if k > n*n:
        print(-1)
        return
    
    mat = np.zeros((n, n), dtype=int)
    for i in range(n):
        for j in range(n):
            if k == 0:
                break
            if i == j:
                mat[i][j] = 1
                k -= 1
            elif i > j:
                continue
            else:
                if k >= 2:
                    mat[i][j] = 1
                    mat[j][i] = 1
                    k -= 2
                else:
                    break
    
    if k > 0:
        print(-1)
        return
    
    for row in mat:
        print(' '.join(map(str, row)))

solve()
","
def solve():
    import numpy as np

    n, k = map(int, input().split())

    if k > n * (n - 1) // 2:
        print(-1)
        return

    res = np.zeros((n, n), dtype=int)

    for i in range(n):
        extra_ones = min(k, 2)
        res[i, i] = 1
        k -= extra_ones
        if k <= 0:
            break

    for i in range(n - 1, -1, -1):
        extra_ones = min(k, 1)
        res[i, n - i - 1] = extra_ones
        k -= extra_ones
        if k <= 0:
            break

    for row in res:
        print(*row)

solve()","
from typing import List

def solve(n: int, k: int) -> List[List[int]]:
    if k > n * n:
        return -1

    result = [[0] * n for _ in range(n)]
    for i in range(n):
        if k == 0:
            break
        result[i][i] = 1
        k -= 1
    
    for i in range(n - 1, -1, -1):
        if k == 0:
            break
        result[i][i] = 1
        k -= 1
    
    return result

solve()","
import numpy as np

def solve(n, k):
    if k > n*n:
        return -1

    matrix = np.zeros((n, n))

    for i in range(n):
        if k == 0:
            break
        matrix[i][i] = 1
        k -= 1
        if k > 0:
            matrix[n-1-i][i] = 1
            k -= 1

    if k > 0:
        return -1

    return matrix

solve()","
def solve():
    import numpy as np
    
    n, k = map(int, input().split())
    
    if k > n*n:
        print(-1)
        return
    
    mat = np.zeros((n, n), dtype=int)
    
    for i in range(n):
        if k == 0:
            break
        mat[i, i] = 1
        k -= 1
        
        if k > 0:
            mat[i, n-1-i] = 1
            k -= 1
    
    for i in range(n):
        for j in range(i+1, n):
            if k >= 2:
                mat[i, j] = mat[j, i] = 1
                k -= 2
    
    if k == 0:
        for row in mat:
            print(' '.join(str(e) for e in row))
    else:
        print(-1)

solve()","
def solve():
    import numpy as np
    import itertools
    
    def is_valid(matrix):
        n = len(matrix)
        for i in range(n):
            for j in range(i + 1, n):
                if matrix[i][j] != matrix[j][i]:
                    return False
        return True
    
    n, k = map(int, input().split())
    
    matrix = np.zeros((n, n), dtype=int)
    
    for comb in itertools.combinations(range(n), 2):
        if k == 0:
            break
        i, j = comb
        matrix[i][j] = matrix[j][i] = 1
        k -= 1
    
    if k == 0 and is_valid(matrix):
        for row in matrix:
            print(*row)
    else:
        print(-1)

solve()
","
from typing import List

def solve(n: int, k: int) -> List[List[int]]:
    if k > n*n:
        return -1
    result = [[0]*n for _ in range(n)]
    for i in range(n):
        if k <= 0:
            break
        result[i][i] = 1
        k -= 1
    for i in range(n):
        for j in range(i+1, n):
            if k >= 2:
                result[i][j] = result[j][i] = 1
                k -= 2
    if k > 0:
        return -1
    return result

solve()","
def solve():
    import numpy as np

    n, k = map(int, input().split())

    if k > n * (n - 1) // 2:
        print(-1)
        return

    matrix = np.zeros((n, n), dtype=int)

    for i in range(n):
        if k == 0:
            break
        matrix[i, i] = 1
        k -= 1
        if k == 0:
            break
        matrix[n - i - 1, n - i - 1] = 1
        k -= 1

    for row in matrix:
        print(*row)

solve()
","
from typing import List

def solve(n: int, k: int) -> List[List[int]]:
    if k > n*n - n:
        return -1
    result = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        if k <= 0:
            break
        result[i][i] = 1
        k -= 1
    for i in range(n-1, -1, -1):
        if k <= 0:
            break
        result[i][i] = 1
        k -= 1
    return result

solve()","
def solve():
    import numpy as np
    
    n, k = map(int, input().split())
    
    if k > n * n:
        print(-1)
        return
    
    mat = np.zeros((n, n), dtype=int)
    
    for i in range(n):
        if k == 0:
            break
        mat[i][i] = 1
        k -= 1
        
    for i in range(n // 2):
        if k >= 2:
            mat[i][n - i - 1] = 1
            mat[n - i - 1][i] = 1
            k -= 2
        else:
            break
        
    if k > 0:
        print(-1)
    else:
        for row in mat:
            print(' '.join(map(str, row)))

solve()
","
def solve():
    import numpy as np
    
    def generate_symmetric_matrix(n, k):
        if k > n*n or k < n:
            return None
        
        mat = np.zeros((n, n))
        if k == n:
            for i in range(n):
                mat[i, i] = 1
        else:
            remaining = k - n
            for i in range(n):
                if remaining >= 2:
                    mat[i, i] = 1
                    mat[i, (i+1)%n] = 1
                    remaining -= 2
                elif remaining == 1:
                    mat[i, i] = 1
                    remaining -= 1
                else:
                    break
            
            if remaining > 0:
                return None
        
        return mat.tolist() if np.array_equal(mat, mat.T) else None
    
    n, k = map(int, input().split())
    result = generate_symmetric_matrix(n, k)
    if result is None:
        return -1
    else:
        for row in result:
            print(' '.join(map(str, row)))

solve()
","
from typing import List

def solve(n: int, k: int) -> List[List[int]]:
    if k > n * (n - 1) // 2:
        return -1

    res = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(i, n):
            if k == 0:
                break
            if i == j:
                res[i][j] = 1
                k -= 1
            else:
                res[i][j] = res[j][i] = 1
                k -= 2

    return res

solve()","
def solve():
    import numpy as np
    n, k = map(int, input().split())
    if k > n*n:
        print(-1)
    else:
        mat = np.zeros((n, n), dtype=int)
        for i in range(n):
            if k == 0:
                break
            if k >= 2:
                mat[i][i] = 1
                mat[i][n-1-i] = 1
                k -= 2
            else:
                mat[i][i] = 1
                k -= 1
        for row in mat:
            print(*row)

solve()
","
from typing import List

def solve(n: int, k: int) -> List[List[int]]:
    if k > n*n:
        return -1
    
    matrix = [[0] * n for _ in range(n)]
    
    for i in range(n):
        if k == 0:
            break
        matrix[i][i] = 1
        k -= 1
    
    for i in range(n):
        for j in range(i+1, n):
            if k >= 2:
                matrix[i][j] = 1
                matrix[j][i] = 1
                k -= 2
            else:
                break
        
    if k != 0:
        return -1
    else:
        return matrix

solve()","
from itertools import combinations

def solve():
    n, k = map(int, input().split())

    # Check if it's possible to fill the matrix with k ones
    if k > n*n:
        print(-1)
        return

    # Generate all possible combinations to place the ones on the main diagonal
    diag_combinations = combinations(range(n), k)
    
    for diag_comb in diag_combinations:
        matrix = [[0] * n for _ in range(n)]
        for i, diag_idx in enumerate(diag_comb):
            matrix[i][diag_idx] = 1
        
        # Fill the matrix symmetrically
        for row in matrix:
            row.reverse()
        
        print('\n'.join([' '.join(map(str, row)) for row in matrix]))
        return
        
    print(-1)

solve()","33.33333333333333","33.33333333333333","26.666666666666668","0.0","0.0","33.33333333333333","26.666666666666668","0.0","26.666666666666668","0.0","33.33333333333333","0.0","0.0","33.33333333333333","0.0","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/26","
QUESTION:
Wet Shark asked Rat Kwesh to generate three positive real numbers x, y and z, from 0.1 to 200.0, inclusive. Wet Krash wants to impress Wet Shark, so all generated numbers will have exactly one digit after the decimal point.

Wet Shark knows Rat Kwesh will want a lot of cheese. So he will give the Rat an opportunity to earn a lot of cheese. He will hand the three numbers x, y and z to Rat Kwesh, and Rat Kwesh will pick one of the these twelve options:  a_1 = x^{y}^{z};  a_2 = x^{z}^{y};  a_3 = (x^{y})^{z};  a_4 = (x^{z})^{y};  a_5 = y^{x}^{z};  a_6 = y^{z}^{x};  a_7 = (y^{x})^{z};  a_8 = (y^{z})^{x};  a_9 = z^{x}^{y};  a_10 = z^{y}^{x};  a_11 = (z^{x})^{y};  a_12 = (z^{y})^{x}. 

Let m be the maximum of all the a_{i}, and c be the smallest index (from 1 to 12) such that a_{c} = m. Rat's goal is to find that c, and he asks you to help him. Rat Kwesh wants to see how much cheese he gets, so he you will have to print the expression corresponding to that a_{c}.

 


-----Input-----

The only line of the input contains three space-separated real numbers x, y and z (0.1 ≤ x, y, z ≤ 200.0). Each of x, y and z is given with exactly one digit after the decimal point.


-----Output-----

Find the maximum value of expression among x^{y}^{z}, x^{z}^{y}, (x^{y})^{z}, (x^{z})^{y}, y^{x}^{z}, y^{z}^{x}, (y^{x})^{z}, (y^{z})^{x}, z^{x}^{y}, z^{y}^{x}, (z^{x})^{y}, (z^{y})^{x} and print the corresponding expression. If there are many maximums, print the one that comes first in the list. 

x^{y}^{z} should be outputted as x^y^z (without brackets), and (x^{y})^{z} should be outputted as (x^y)^z (quotes for clarity). 


-----Examples-----
Input
1.1 3.4 2.5

Output
z^y^x

Input
2.0 2.0 2.0

Output
x^y^z

Input
1.9 1.8 1.7

Output
(x^y)^z
Use user-input-Based format and function signature solve()","
def solve():
    x, y, z = map(float, input().split())
    expressions = [
        x ** (y ** z),
        x ** (z ** y),
        (x ** y) ** z,
        (x ** z) ** y,
        y ** (x ** z),
        y ** (z ** x),
        (y ** x) ** z,
        (y ** z) ** x,
        z ** (x ** y),
        z ** (y ** x),
        (z ** x) ** y,
        (z ** y) ** x
    ]
    max_val = max(expressions)
    max_index = expressions.index(max_val)
    
    if max_index == 0:
        print(""x^y^z"")
    elif max_index == 1:
        print(""x^z^y"")
    elif max_index == 2:
        print(""(x^y)^z"")
    elif max_index == 3:
        print(""(x^z)^y"")
    elif max_index == 4:
        print(""y^x^z"")
    elif max_index == 5:
        print(""y^z^x"")
    elif max_index == 6:
        print(""(y^x)^z"")
    elif max_index == 7:
        print(""(y^z)^x"")
    elif max_index == 8:
        print(""z^x^y"")
    elif max_index == 9:
        print(""z^y^x"")
    elif max_index == 10:
        print(""(z^x)^y"")
    elif max_index == 11:
        print(""(z^y)^x"")


solve()","
def solve():
    x, y, z = map(float, input().split())
    
    options = [
        (x ** y) ** z, (x ** z) ** y, x ** (y ** z), x ** (z ** y),
        (y ** x) ** z, (y ** z) ** x, y ** (x ** z), y ** (z ** x),
        (z ** x) ** y, (z ** y) ** x, z ** (x ** y), z ** (y ** x)
    ]
    
    max_val = max(options)
    max_idx = options.index(max_val)
    
    if max_idx // 2 == 0:
        return 'x^y^z'
    elif max_idx // 2 == 1:
        return 'x^z^y'
    elif max_idx // 2 == 2:
        return '(x^y)^z'
    elif max_idx // 2 == 3:
        return '(x^z)^y'
    elif max_idx // 2 == 4:
        return 'y^x^z'
    elif max_idx // 2 == 5:
        return 'y^z^x'
    elif max_idx // 2 == 6:
        return '(y^x)^z'
    elif max_idx // 2 == 7:
        return '(y^z)^x'
    elif max_idx // 2 == 8:
        return 'z^x^y'
    elif max_idx // 2 == 9:
        return 'z^y^x'
    else:
        return '(z^x)^y'

solve()","
def solve():
    x, y, z = map(float, input().split())

    expressions = [
        (x ** y) ** z, (x ** z) ** y, x ** (y ** z), x ** (z ** y),
        (y ** x) ** z, (y ** z) ** x, y ** (x ** z), y ** (z ** x),
        (z ** x) ** y, (z ** y) ** x, z ** (x ** y), z ** (y ** x)
    ]

    max_value = max(expressions)
    max_index = expressions.index(max_value)

    if max_index < 4:
        print(f'x^y^z')
    elif max_index < 8:
        print(f'y^x^z')
    else:
        print(f'z^y^x')


solve()","
def solve():
    x, y, z = map(float, input().split())

    expressions = [
        x**y**z, x**z**y, (x**y)**z, (x**z)**y,
        y**x**z, y**z**x, (y**x)**z, (y**z)**x,
        z**x**y, z**y**x, (z**x)**y, (z**y)**x
    ]
    
    max_expr = max(expressions)
    max_index = expressions.index(max_expr)

    output = [
        'x^y^z', 'x^z^y', '(x^y)^z', '(x^z)^y',
        'y^x^z', 'y^z^x', '(y^x)^z', '(y^z)^x',
        'z^x^y', 'z^y^x', '(z^x)^y', '(z^y)^x'
    ]
    
    return output[max_index]

solve()","
def solve():
    x, y, z = map(float, input().split())

    options = [
        x ** y ** z,
        x ** z ** y,
        (x ** y) ** z,
        (x ** z) ** y,
        y ** x ** z,
        y ** z ** x,
        (y ** x) ** z,
        (y ** z) ** x,
        z ** x ** y,
        z ** y ** x,
        (z ** x) ** y,
        (z ** y) ** x
    ]

    max_val = max(options)
    max_index = options.index(max_val)

    expressions = [
        f'x^y^z',
        f'x^z^y',
        f'(x^y)^z',
        f'(x^z)^y',
        f'y^x^z',
        f'y^z^x',
        f'(y^x)^z',
        f'(y^z)^x',
        f'z^x^y',
        f'z^y^x',
        f'(z^x)^y',
        f'(z^y)^x'
    ]

    print(expressions[max_index])


solve()","
def solve():
    x, y, z = map(float, input().split())

    options = [
        x**y**z, x**z**y, (x**y)**z, (x**z)**y,
        y**x**z, y**z**x, (y**x)**z, (y**z)**x,
        z**x**y, z**y**x, (z**x)**y, (z**y)**x
    ]

    max_val = max(options)
    max_index = options.index(max_val) + 1

    expressions = [
        f'x^y^z', f'x^z^y', f'(x^y)^z', f'(x^z)^y',
        f'y^x^z', f'y^z^x', f'(y^x)^z', f'(y^z)^x',
        f'z^x^y', f'z^y^x', f'(z^x)^y', f'(z^y)^x'
    ]

    print(expressions[max_index - 1])

solve()","
def solve():
    x, y, z = map(float, input().split())

    expressions = [
        (x**(y**z), ""x^y^z""),
        (x**(z**y), ""x^z^y""),
        ((x**y)**z, ""(x^y)^z""),
        ((x**z)**y, ""(x^z)^y""),
        (y**(x**z), ""y^x^z""),
        (y**(z**x), ""y^z^x""),
        ((y**x)**z, ""(y^x)^z""),
        ((y**z)**x, ""(y^z)^x""),
        (z**(x**y), ""z^x^y""),
        (z**(y**x), ""z^y^x""),
        ((z**x)**y, ""(z^x)^y""),
        ((z**y)**x, ""(z^y)^x"")
    ]

    max_value = max([expr[0] for expr in expressions])
    for expr in expressions:
        if expr[0] == max_value:
            print(expr[1])
            break

solve()
","
def solve():
    x, y, z = map(float, input().split())

    expressions = [
        (x ** y) ** z, (x ** z) ** y, x ** (y ** z), x ** (z ** y),
        (y ** x) ** z, (y ** z) ** x, y ** (x ** z), y ** (z ** x),
        (z ** x) ** y, (z ** y) ** x, z ** (x ** y), z ** (y ** x)
    ]

    max_val = max(expressions)
    max_idx = expressions.index(max_val)
    expressions_str = [
        ""x^y^z"", ""x^z^y"", ""(x^y)^z"", ""(x^z)^y"",
        ""y^x^z"", ""y^z^x"", ""(y^x)^z"", ""(y^z)^x"",
        ""z^x^y"", ""z^y^x"", ""(z^x)^y"", ""(z^y)^x""
    ]

    print(expressions_str[max_idx])

solve()
","
def solve():
    x, y, z = map(float, input().split())
    
    options = [
        (x**y**z, 'x^y^z'),
        (x**z**y, 'x^z^y'),
        ((x**y)**z, '(x^y)^z'),
        ((x**z)**y, '(x^z)^y'),
        (y**x**z, 'y^x^z'),
        (y**z**x, 'y^z^x'),
        ((y**x)**z, '(y^x)^z'),
        ((y**z)**x, '(y^z)^x'),
        (z**x**y, 'z^x^y'),
        (z**y**x, 'z^y^x'),
        ((z**x)**y, '(z^x)^y'),
        ((z**y)**x, '(z^y)^x')
    ]
    
    max_val = max(val for val, expr in options)
    result_expr = next(expr for val, expr in options if val == max_val)
    
    print(result_expr)

solve()","
def solve():
    import itertools

    x, y, z = map(float, input().split())
    options = ['x^y^z', 'x^z^y', '(x^y)^z', '(x^z)^y', 'y^x^z', 'y^z^x', '(y^x)^z', '(y^z)^x', 'z^x^y', 'z^y^x', '(z^x)^y', '(z^y)^x']

    expressions = [x**y**z, x**z**y, (x**y)**z, (x**z)**y, y**x**z, y**z**x, (y**x)**z, (y**z)**x, z**x**y, z**y**x, (z**x)**y, (z**y)**x]

    max_value = max(expressions)
    max_index = expressions.index(max_value)
    
    print(options[max_index])

solve()","
def solve():
    import itertools
    
    x, y, z = map(float, input().split())
    
    expressions = ['x^y^z', 'x^z^y', '(x^y)^z', '(x^z)^y', 'y^x^z', 'y^z^x', '(y^x)^z', '(y^z)^x', 'z^x^y', 'z^y^x', '(z^x)^y', '(z^y)^x']
    
    max_val = float('-inf')
    max_exp = None
    
    for expression in expressions:
        val = eval(expression.replace('x', str(x)).replace('y', str(y)).replace('z', str(z)))
        if val > max_val:
            max_val = val
            max_exp = expression
    
    print(max_exp)


solve()","
def solve():
    x, y, z = map(float, input().split())
    options = [
        (x ** y) ** z, (x ** z) ** y, (x ** y) ** z, (x ** z) ** y,
        (y ** x) ** z, (y ** z) ** x, (y ** x) ** z, (y ** z) ** x,
        (z ** x) ** y, (z ** y) ** x, (z ** x) ** y, (z ** y) ** x
    ]
    max_val = max(options)
    max_index = options.index(max_val)
    
    expressions = [
        f'x^y^z', f'x^z^y', f'(x^y)^z', f'(x^z)^y',
        f'y^x^z', f'y^z^x', f'(y^x)^z', f'(y^z)^x',
        f'z^x^y', f'z^y^x', f'(z^x)^y', f'(z^y)^x'
    ]
    
    print(expressions[max_index])

solve()
","
def solve():
    import itertools
    
    x, y, z = map(float, input().split())
    
    expressions = [(""x^y^z"", x ** y ** z),
                   (""x^z^y"", x ** z ** y),
                   (""(x^y)^z"", (x ** y) ** z),
                   (""(x^z)^y"", (x ** z) ** y),
                   (""y^x^z"", y ** x ** z),
                   (""y^z^x"", y ** z ** x),
                   (""(y^x)^z"", (y ** x) ** z),
                   (""(y^z)^x"", (y ** z) ** x),
                   (""z^x^y"", z ** x ** y),
                   (""z^y^x"", z ** y ** x),
                   (""(z^x)^y"", (z ** x) ** y),
                   (""(z^y)^x"", (z ** y) ** x)]
    
    max_value = max(expression[1] for expression in expressions)
    max_indices = [i for i, expression in enumerate(expressions, start=1) if expression[1] == max_value]
    
    for i in range(1, 13):
        if i in max_indices:
            print(expressions[i-1][0])
            break

solve()
 ","
def solve():
    from itertools import permutations
    x, y, z = map(float, input().split())
    expressions = [""x**y**z"", ""x**z**y"", ""(x**y)**z"", ""(x**z)**y"", ""y**x**z"", ""y**z**x"", ""(y**x)**z"", ""(y**z)**x"", ""z**x**y"", ""z**y**x"", ""(z**x)**y"", ""(z**y)**x""]
    
    max_val = float('-inf')
    max_exp = """"
    
    for perm in permutations([x, y, z]):
        for i, exp in enumerate(expressions, 1):
            val = eval(exp.replace('x', str(perm[0])).replace('y', str(perm[1])).replace('z', str(perm[2])))
            if val > max_val:
                max_val = val
                max_exp = exp
    
    print(max_exp)
  
solve()","
def solve():
    from itertools import permutations
    
    x, y, z = map(float, input().split())
    
    expressions = [
        (""x^y^z"", x**y**z),
        (""x^z^y"", x**z**y),
        (""(x^y)^z"", (x**y)**z),
        (""(x^z)^y"", (x**z)**y),
        (""y^x^z"", y**x**z),
        (""y^z^x"", y**z**x),
        (""(y^x)^z"", (y**x)**z),
        (""(y^z)^x"", (y**z)**x),
        (""z^x^y"", z**x**y),
        (""z^y^x"", z**y**x),
        (""(z^x)^y"", (z**x)**y),
        (""(z^y)^x"", (z**y)**x),
    ]
    
    max_val = max(expression[1] for expression in expressions)
    max_expression = [expression[0] for expression in expressions if expression[1] == max_val][0]
    
    print(max_expression)

solve()","
def solve():
    x, y, z = map(float, input().split())
    
    expressions = [
        x**y**z, x**z**y, (x**y)**z, (x**z)**y, 
        y**x**z, y**z**x, (y**x)**z, (y**z)**x, 
        z**x**y, z**y**x, (z**x)**y, (z**y)**x
    ]
    
    max_val = max(expressions)
    max_idx = expressions.index(max_val)
    
    options = [
        f'x^{y}^z', 'x^z^y', '(x^y)^z', '(x^z)^y', 
        'y^x^z', 'y^z^x', '(y^x)^z', '(y^z)^x', 
        'z^x^y', 'z^y^x', '(z^x)^y', '(z^y)^x'
    ]
    
    print(options[max_idx])

solve()
","40.0","0.0","13.333333333333334","0.0","40.0","40.0","40.0","6.666666666666667","40.0","40.0","0.0","13.333333333333334","40.0","0.0","40.0","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/27","
QUESTION:
You are given a string s consisting of n lowercase Latin letters. You have to type this string using your keyboard.

Initially, you have an empty string. Until you type the whole string, you may perform the following operation:  add a character to the end of the string. 

Besides, at most once you may perform one additional operation: copy the string and append it to itself.

For example, if you have to type string abcabca, you can type it in 7 operations if you type all the characters one by one. However, you can type it in 5 operations if you type the string abc first and then copy it and type the last character.

If you have to type string aaaaaaaaa, the best option is to type 4 characters one by one, then copy the string, and then type the remaining character.

Print the minimum number of operations you need to type the given string.


-----Input-----

The first line of the input containing only one integer number n (1 ≤ n ≤ 100) — the length of the string you have to type. The second line containing the string s consisting of n lowercase Latin letters.


-----Output-----

Print one integer number — the minimum number of operations you need to type the given string.


-----Examples-----
Input
7
abcabca

Output
5

Input
8
abcdefgh

Output
8



-----Note-----

The first test described in the problem statement.

In the second test you can only type all the characters one by one.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input()
    
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    for i in range(1, n + 1):
        dp[i] = min(dp[i], dp[i - 1] + 1)
        for j in range(i):
            if s[j:i] in s[:i]:
                dp[i] = min(dp[i], dp[j] + 1)
    
    print(dp[n])

solve()
","
def solve():
    n = int(input())
    s = input()
    
    if s.count(s[0]) == len(s):
        print((len(s) + 2) // 3)
    else:
        print(len(s))

solve()
","
def solve():
    n = int(input())
    s = input()
    min_ops = n
    
    for i in range(1, n):
        if s[:i] * 2 == s:
            min_ops = min(min_ops, i + 2)
    
    min_ops = min(min_ops, n)
    
    print(min_ops)

solve()
","
def solve():
    n = int(input())
    s = input().strip()

    dp = [float('inf')]*(n+1)
    dp[0] = 0

    for i in range(1, n+1):
        dp[i] = min(dp[i], dp[i-1]+1)
        for j in range(i-1):
            if s[j:i] == s[i-j-1:i]:
                dp[i] = min(dp[i], dp[i-j-1]+1)

    print(dp[n])

solve()
","
def solve():
    n = int(input())
    s = input()

    count = n  # initialize with the length of the string
    for i in range(1, n):
        if s[:i] == s[i:]:
            count = min(count, i + 1 + (n - i))  # copy operation at position i
    print(count)

solve()","
def solve():
    n = int(input())
    s = input()

    if n == 1:
        print(1)
    else:
        for i in range(1, n):
            sub = s[:i]
            if sub * (n // len(sub)) + sub[:n % len(sub)] == s:
                print(i + (n - i) // len(sub) + 1)
                break


solve()","
def solve():
    n = int(input())
    s = input().strip()
    
    doubled_s = s + s

    for i in range(1, n+1):
        substring = s[:i]
        if substring * 2 in doubled_s:
            return n - i + 2

    return n

solve()
","
def solve():
    n = int(input())
    s = input()
    
    if s.count(s[0]) == n:
        print((n + 2) // 3)
    elif s[:n // 2] == s[n // 2:]:
        print(2)
    else:
        print(n)

solve()","
def solve():
    n = int(input())
    s = input()
    
    min_operations = n
    for i in range(1, n+1):
        if n % i == 0 and s[:i] * (n // i) == s:
            min_operations = min(min_operations, 1 + i + n // i)
    
    print(min_operations)

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    dp = [float('inf')] * (n + 1)
    dp[0] = 0

    for i in range(1, n + 1):
        dp[i] = min(dp[i], dp[i-1] + 1)
        for j in range(i-2, -1, -1):
            if s[j:i] == s[i-j-1:i]:
                dp[i] = min(dp[i], dp[j] + 1)

    print(dp[n])

solve()
","
def solve():
    n = int(input())
    s = input()
    
    def count_operations(s):
        for i in range(1, len(s)+1):
            if s[:i] * (len(s) // i) + s[:len(s) % i] == s:
                return i + len(s) // i - 1
    print(count_operations(s))

solve()
","
def solve():
    n = int(input())
    s = input()

    duplicate = s + s

    if s in duplicate: # check if s can be formed by duplicating a part of itself
        print(min(len(s), n + 1))
    else:
        print(n)

solve()
  ","
def solve():
    from math import ceil

    n = int(input())
    s = input()

    min_operations = n

    for i in range(1, n // 2 + 1):
        if s[:i] == s[i:2 * i]:
            min_operations = min(min_operations, i + ceil((n - i) / i))

    print(min_operations)

solve()
","
def solve():
    n = int(input())
    s = input()

    if s == s[0] * n:
        return n // 4 * 2 + 1 if n % 4 == 0 else n // 4 * 2 + 2
    return n

solve()","
def solve():
    n = int(input())
    s = input()
    
    if s == s[0] * n:
        print(n // 4 * 2 + n % 4)
    else:
        print(n)

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    dp = [float('inf')] * (n+1)
    dp[0] = 0
    
    for i in range(1, n+1):
        dp[i] = min(dp[i], dp[i-1] + 1)
        for j in range(1, i):
            if s[j-1:i] == s[:i-j]:
                dp[i] = min(dp[i], dp[i-j] + 1)
    
    print(dp[n])

solve()
","0.0","46.666666666666664","46.666666666666664","6.666666666666667","46.666666666666664","13.333333333333334","0.0","46.666666666666664","46.666666666666664","6.666666666666667","40.0","46.666666666666664","86.66666666666667","0.0","53.333333333333336","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/28","
QUESTION:
The All-Berland National Olympiad in Informatics has just ended! Now Vladimir wants to upload the contest from the Olympiad as a gym to a popular Codehorses website.

Unfortunately, the archive with Olympiad's data is a mess. For example, the files with tests are named arbitrary without any logic.

Vladimir wants to rename the files with tests so that their names are distinct integers starting from 1 without any gaps, namely, ""1"", ""2"", ..., ""n', where n is the total number of tests.

Some of the files contain tests from statements (examples), while others contain regular tests. It is possible that there are no examples, and it is possible that all tests are examples. Vladimir wants to rename the files so that the examples are the first several tests, all all the next files contain regular tests only.

The only operation Vladimir can perform is the ""move"" command. Vladimir wants to write a script file, each of the lines in which is ""move file_1 file_2"", that means that the file ""file_1"" is to be renamed to ""file_2"". If there is a file ""file_2"" at the moment of this line being run, then this file is to be rewritten. After the line ""move file_1 file_2"" the file ""file_1"" doesn't exist, but there is a file ""file_2"" with content equal to the content of ""file_1"" before the ""move"" command.

Help Vladimir to write the script file with the minimum possible number of lines so that after this script is run:  all examples are the first several tests having filenames ""1"", ""2"", ..., ""e"", where e is the total number of examples;  all other files contain regular tests with filenames ""e + 1"", ""e + 2"", ..., ""n"", where n is the total number of all tests. 


-----Input-----

The first line contains single integer n (1 ≤ n ≤ 10^5) — the number of files with tests.

n lines follow, each describing a file with test. Each line has a form of ""name_i type_i"", where ""name_i"" is the filename, and ""type_i"" equals ""1"", if the i-th file contains an example test, and ""0"" if it contains a regular test. Filenames of each file are strings of digits and small English letters with length from 1 to 6 characters. The filenames are guaranteed to be distinct.


-----Output-----

In the first line print the minimum number of lines in Vladimir's script file.

After that print the script file, each line should be ""move file_1 file_2"", where ""file_1"" is an existing at the moment of this line being run filename, and ""file_2"" — is a string of digits and small English letters with length from 1 to 6.


-----Examples-----
Input
5
01 0
2 1
2extra 0
3 1
99 0

Output
4
move 3 1
move 01 5
move 2extra 4
move 99 3

Input
2
1 0
2 1

Output
3
move 1 3
move 2 1
move 3 2
Input
5
1 0
11 1
111 0
1111 1
11111 0

Output
5
move 1 5
move 11 1
move 1111 2
move 111 4
move 11111 3
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    
    examples = [file[0] for file in files if file[1] == '1']
    regular_tests = [file[0] for file in files if file[1] == '0']
    
    script = []
    for i, example in enumerate(examples, start=1):
        script.append(f""move {example} {i}"")
    
    for j, regular_test in enumerate(regular_tests, start=len(examples) + 1):
        script.append(f""move {regular_test} {j}"")
    
    print(len(script))
    for line in script:
        print(line)

solve()
","
from collections import defaultdict

def solve():
    n = int(input())
    files = []
    examples = []
    regular = []

    for _ in range(n):
        name, file_type = input().split()
        if file_type == '1':
            examples.append(name)
        else:
            regular.append(name)

    script = []
    script_count = 0

    for i, example in enumerate(examples):
        script.append(f""move {example} {i+1}"")
        script_count += 1

    for i, reg in enumerate(regular):
        script.append(f""move {reg} {i+len(examples)+1}"")
        script_count += 1

    print(script_count)
    for line in script:
        print(line)


solve()","
def solve():
    n = int(input())
    tests = [input().split() for _ in range(n)]
    examples = []
    regular_tests = []
    for i, (name, test_type) in enumerate(tests, start=1):
        if test_type == '1':
            examples.append((name, i))
        else:
            regular_tests.append((name, i))
    script = []
    
    for i, (name, new_name) in enumerate(examples + regular_tests, start=1):
        script.append(f""move {name} {i}"")
        
    print(len(script))
    for line in script:
        print(line)
  
solve()","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    examples = [f[0] for f in files if f[1] == '1']
    regular_tests = [f[0] for f in files if f[1] == '0']
    moves = []

    e = len(examples)
    for i, example in enumerate(examples, 1):
        moves.append(f""move {example} {i}"")

    for i, regular_test in enumerate(regular_tests, e + 1):
        moves.append(f""move {regular_test} {i}"")

    print(len(moves))
    for move in moves:
        print(move)
  
solve()","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    examples = [(name, i+1) for i, (name, type_) in enumerate(files) if type_ == '1']
    regular_tests = [(name, i+1) for i, (name, type_) in enumerate(files) if type_ == '0']

    script = []
    for i, (name, new_name) in enumerate(examples):
        script.append(f""move {name} {i+1}"")
    for i, (name, new_name) in enumerate(regular_tests):
        script.append(f""move {name} {len(examples) + i + 1}"")

    print(len(script))
    for line in script:
        print(line)

solve()","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    
    examples = [(int(files[i][0]), i + 1) for i in range(n) if files[i][1] == '1']
    regular_tests = [(int(files[i][0]), i + 1) for i in range(n) if files[i][1] == '0']
    
    examples.sort()
    regular_tests.sort()

    min_lines = 0
    script = []
    e = len(examples)
    
    for i in range(e):
        if examples[i][1] != i + 1:
            script.append(f""move {examples[i][0]} {i + 1}"")
            min_lines += 1

    for i in range(n - e):
        if regular_tests[i][1] != e + i + 1:
            script.append(f""move {regular_tests[i][0]} {e + i + 1}"")
            min_lines += 1
    
    print(min_lines)
    for line in script:
        print(line)

solve()","
def solve():
    n = int(input())
    tests = []
    examples = []
    for _ in range(n):
        name, type = input().split()
        if type == '1':
            examples.append(name)
        else:
            tests.append(name)

    examples.sort()
    tests.sort()
    
    script = []
    e = len(examples)
    for i, example in enumerate(examples, 1):
        script.append(f""move {example} {i}"")
    for i, test in enumerate(tests, e+1):
        script.append(f""move {test} {i}"")

    print(len(script))
    for line in script:
        print(line)

solve()
","
def solve():
    n = int(input())
    files = []
    for _ in range(n):
        name, file_type = input().split()
        files.append((name, int(file_type)))

    files.sort(key=lambda x: (x[1], x[0]))

    examples = [file[0] for file in files if file[1] == 1]
    regular_tests = [file[0] for file in files if file[1] == 0]

    script = []
    for i in range(n):
        if i < len(examples):
            script.append(f""move {examples[i]} {i + 1}"")
        else:
            script.append(f""move {regular_tests[i - len(examples)]} {i + 1}"")

    print(len(script))
    for line in script:
        print(line)

solve()","
def solve():
    n = int(input())
    example_count = 0
    example_files = []
    regular_files = []
    
    for i in range(n):
        file_info = input().split()
        filename = file_info[0]
        file_type = int(file_info[1])
        
        if file_type == 1:
            example_count += 1
            example_files.append(filename)
        else:
            regular_files.append(filename)
    
    moves = []
    moves_count = example_count + len(regular_files)
    
    for i in range(example_count):
        moves.append(f""move {example_files[i]} {i+1}"")
    
    for i in range(len(regular_files)):
        moves.append(f""move {regular_files[i]} {example_count+i+1}"")
    
    print(moves_count)
    for move in moves:
        print(move)

solve()","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    examples = [(name, i+1) for i, (name, is_example) in enumerate(files) if is_example == '1']
    regular_tests = [(name, i+1) for i, (name, is_example) in enumerate(files) if is_example == '0']
    
    script = []
    for i, (name, _) in enumerate(examples):
        script.append(f""move {name} {i+1}"")
    
    for i, (name, _) in enumerate(regular_tests, start=len(examples)):
        script.append(f""move {name} {i+1}"")
    
    print(len(script))
    for line in script:
        print(line)

solve()","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    
    examples = [(f[0], i+1) for i, f in enumerate(files) if f[1] == '1']
    examples.sort()
    
    regulars = [(f[0], i+1) for i, f in enumerate(files) if f[1] == '0']
    regulars.sort()
    
    moves = []
    for i in range(len(examples)):
        moves.append(f""move {examples[i][0]} {i+1}"")
    for i in range(len(regulars)):
        moves.append(f""move {regulars[i][0]} {i+len(examples)+1}"")
    
    print(len(moves))
    for move in moves:
        print(move)
  
solve()","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    
    examples = [file[0] for file in files if file[1] == '1']
    regular_tests = [file[0] for file in files if file[1] == '0']
    
    script = []
    e = len(examples)
    for i, example in enumerate(examples, 1):
        script.append(f""move {example} {i}"")
    
    for i, regular_test in enumerate(regular_tests, e+1):
        script.append(f""move {regular_test} {i}"")
    
    print(len(script))
    for line in script:
        print(line)

solve()
  ","
def solve():
    n = int(input())
    tests = []
    examples = []
    
    for _ in range(n):
        name, test_type = input().split()
        if test_type == '1':
            examples.append(name)
        else:
            tests.append(name)
    
    script = []
    
    for i in range(len(examples)):
        script.append(f""move {examples[i]} {i+1}"")
    
    for i in range(len(tests)):
        script.append(f""move {tests[i]} {i+len(examples)+1}"")
    
    print(len(script))
    for line in script:
        print(line)
  
solve()","
def solve():
    n = int(input())
    files = []
    for _ in range(n):
        name, file_type = input().split()
        files.append((name, int(file_type)))

    examples = [(name, i+1) for i, (name, file_type) in enumerate(files) if file_type == 1]
    regular_tests = [(name, i+1) for i, (name, file_type) in enumerate(files) if file_type == 0]

    script = []
    e = len(examples)

    for i in range(e):
        script.append(f""move {examples[i][0]} {i+1}"")

    for i in range(len(examples), n):
        script.append(f""move {regular_tests[i - e][0]} {i+1}"")

    print(len(script))
    for move in script:
        print(move)

solve()
","
def solve():
    n = int(input())
    files = [input().split() for _ in range(n)]
    
    examples = []
    regular_tests = []
    
    for i, (name, type_i) in enumerate(files, start=1):
        if type_i == '1':
            examples.append((name, str(i)))
        else:
            regular_tests.append((name, str(i)))
    
    script = []
    
    for i, (name, new_name) in enumerate(examples + regular_tests, start=1):
        script.append(f""move {name} {str(i)}"")
    
    print(len(script))
    for line in script:
        print(line)

solve()","
def solve():
    n = int(input())
    files = []
    for _ in range(n):
        filename, file_type = input().split()
        files.append((filename, int(file_type)))

    examples = [(filename, idx+1) for idx, (filename, file_type) in enumerate(files) if file_type == 1]
    regular_tests = [(filename, idx+1) for idx, (filename, file_type) in enumerate(files) if file_type == 0]

    script = []
    for idx, (filename, _) in enumerate(examples):
        script.append(f""move {filename} {idx+1}"")
    for idx, (filename, _) in enumerate(regular_tests):
        script.append(f""move {filename} {len(examples) + idx + 1}"")

    print(len(script))
    for line in script:
        print(line)

solve()","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","0.0","6.666666666666667","6.666666666666667","13.333333333333334","13.333333333333334","6.666666666666667","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/29","
QUESTION:
Luba has a ticket consisting of 6 digits. In one move she can choose digit in any position and replace it with arbitrary digit. She wants to know the minimum number of digits she needs to replace in order to make the ticket lucky.

The ticket is considered lucky if the sum of first three digits equals to the sum of last three digits.


-----Input-----

You are given a string consisting of 6 characters (all characters are digits from 0 to 9) — this string denotes Luba's ticket. The ticket can start with the digit 0.


-----Output-----

Print one number — the minimum possible number of digits Luba needs to replace to make the ticket lucky.


-----Examples-----
Input
000000

Output
0

Input
123456

Output
2

Input
111000

Output
1



-----Note-----

In the first example the ticket is already lucky, so the answer is 0.

In the second example Luba can replace 4 and 5 with zeroes, and the ticket will become lucky. It's easy to see that at least two replacements are required.

In the third example Luba can replace any zero with 3. It's easy to see that at least one replacement is required.
Use user-input-Based format and function signature solve()","
def solve():
    ticket = input()
    first_half = sum(map(int, ticket[:3]))
    second_half = sum(map(int, ticket[3:]))
    replacements = abs(first_half - second_half) // 2
    print(replacements)

solve()
","
def solve():
    ticket = input()
    first_half_sum = sum(int(ticket[i]) for i in range(3))
    second_half_sum = sum(int(ticket[i]) for i in range(3, 6))
    diff = abs(first_half_sum - second_half_sum)
    replacements = max(0, diff - 1)
    print(replacements)

solve()
","
def solve():
    ticket = input()
    first_half = list(map(int, ticket[:3]))
    second_half = list(map(int, ticket[3:]))

    target_sum = sum(first_half)
    replacements = 0

    for i in range(3):
        if first_half[i] + second_half[i] != target_sum:
            replacements += 1

    print(replacements)

solve()
","
def solve():
    ticket = input()
    first_sum = sum(map(int, ticket[:3]))
    second_sum = sum(map(int, ticket[3:]))
    replacements = abs(first_sum - second_sum)
    return replacements

solve()","
def lucky_ticket(ticket: str) -> int:
    first_half = [int(digit) for digit in ticket[:3]]
    second_half = [int(digit) for digit in ticket[3:]]

    diff = abs(sum(first_half) - sum(second_half))
    return diff // 9 + diff % 9

def solve():
    ticket = input()
    print(lucky_ticket(ticket))

solve()
","
def solve():
    ticket = input()
    first_sum = sum([int(digit) for digit in ticket[:3]])
    second_sum = sum([int(digit) for digit in ticket[3:]])
    
    replacements = abs(first_sum - second_sum)
    
    print(replacements)

solve()
","
def solve():
    ticket = input()
    first_sum = int(ticket[0]) + int(ticket[1]) + int(ticket[2])
    second_sum = int(ticket[3]) + int(ticket[4]) + int(ticket[5])
    
    count = 0
    for i in range(3):
        count += max(0, first_sum - second_sum)
        first_sum -= int(ticket[i])
        second_sum -= int(ticket[i+3])
        
    print(count)

solve()
","
def solve():
    ticket = input()
    first_sum = sum(map(int, ticket[:3]))
    last_sum = sum(map(int, ticket[3:]))

    diff = abs(first_sum - last_sum)

    return max(diff, 1)

solve()
","
def solve():
    ticket = input()
    first_sum = int(ticket[0]) + int(ticket[1]) + int(ticket[2])
    second_sum = int(ticket[3]) + int(ticket[4]) + int(ticket[5])
    
    num_replacements = abs(first_sum - second_sum)
    
    print(num_replacements)

solve()","
def solve():
    ticket = input().strip()
    first_half_sum = sum(map(int, ticket[:3]))
    second_half_sum = sum(map(int, ticket[3:]))
    
    replacements = abs(first_half_sum - second_half_sum)
    
    return replacements

solve()","
def solve():
    ticket = input()
    left_sum = sum(map(int, ticket[:3]))
    right_sum = sum(map(int, ticket[3:]))
    diff = abs(left_sum - right_sum)
    return diff // 2 + diff % 2

solve()
","
def solve():
    ticket = input()
    
    first_sum = int(ticket[0]) + int(ticket[1]) + int(ticket[2])
    second_sum = int(ticket[3]) + int(ticket[4]) + int(ticket[5])
    
    replacements = abs(first_sum - second_sum)
    
    print(replacements)

solve()
","
def solve():
    ticket = input()
    first_half_sum = sum(map(int, ticket[:3]))
    second_half_sum = sum(map(int, ticket[3:]))
    
    diff = abs(first_half_sum - second_half_sum)
    
    return diff // 2 + diff % 2

solve()
","
def solve():
    ticket = input()
    first_half = list(map(int, ticket[:3]))
    second_half = list(map(int, ticket[3:]))
    diff = abs(sum(first_half) - sum(second_half))
    return diff // 2

solve()
","
def solve():
    ticket = input()
    first_half_sum = sum([int(digit) for digit in ticket[:3]])
    second_half_sum = sum([int(digit) for digit in ticket[3:]])
    replacements_needed = abs(first_half_sum - second_half_sum) // 2
    print(replacements_needed)

solve()","
def solve():
    ticket = input()
    sum_first_three = sum(int(digit) for digit in ticket[:3])
    sum_last_three = sum(int(digit) for digit in ticket[3:])
    replacements = abs(sum_first_three - sum_last_three) // 9
    print(replacements)

solve()
","40.0","26.666666666666668","20.0","0.0","46.666666666666664","26.666666666666668","26.666666666666668","0.0","26.666666666666668","0.0","0.0","26.666666666666668","0.0","0.0","40.0","40.0","","","","","","","","","","","","","","","",""
"APPS/30","
QUESTION:
The campus has $m$ rooms numbered from $0$ to $m - 1$. Also the $x$-mouse lives in the campus. The $x$-mouse is not just a mouse: each second $x$-mouse moves from room $i$ to the room $i \cdot x \mod{m}$ (in fact, it teleports from one room to another since it doesn't visit any intermediate room). Starting position of the $x$-mouse is unknown.

You are responsible to catch the $x$-mouse in the campus, so you are guessing about minimum possible number of traps (one trap in one room) you need to place. You are sure that if the $x$-mouse enters a trapped room, it immediately gets caught.

And the only observation you made is $\text{GCD} (x, m) = 1$.


-----Input-----

The only line contains two integers $m$ and $x$ ($2 \le m \le 10^{14}$, $1 \le x < m$, $\text{GCD} (x, m) = 1$) — the number of rooms and the parameter of $x$-mouse. 


-----Output-----

Print the only integer — minimum number of traps you need to install to catch the $x$-mouse.


-----Examples-----
Input
4 3

Output
3

Input
5 2

Output
2



-----Note-----

In the first example you can, for example, put traps in rooms $0$, $2$, $3$. If the $x$-mouse starts in one of this rooms it will be caught immediately. If $x$-mouse starts in the $1$-st rooms then it will move to the room $3$, where it will be caught.

In the second example you can put one trap in room $0$ and one trap in any other room since $x$-mouse will visit all rooms $1..m-1$ if it will start in any of these rooms.
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    m, x = map(int, input().split())
    traps = 1
    room = x
    while room != 0:
        traps += 1
        room = (room * x) % m
    print(traps)

solve()
","
from math import gcd

def solve():
    m, x = map(int, input().split())
    min_traps = m - 1

    for i in range(1, m):
        if pow(x, i, m) == 1:
            min_traps = i
            break

    print(min_traps)

solve()
","
import math

def solve():
    # Take input
    m, x = map(int, input().split())
    
    # Calculate minimum number of traps
    traps = m - math.totient(m) // math.totient(m // math.gcd(m, x))
    
    # Print the result
    print(traps)

solve()
","
from math import gcd

def solve():
    m, x = map(int, input().split())
    
    def phi(n):
        res = n
        p = 2
        while p * p <= n:
            if n % p == 0:
                res -= res // p
                while n % p == 0:
                    n //= p
            p += 1
        if n > 1:
            res -= res // n
        return res
    
    res = phi(m) // gcd(x, phi(m))
    print(res)

solve()
","
import math

def solve():
    m, x = map(int, input().split())
    traps = m
    for i in range(1, m):
        if pow(x, i, m) == 0:
            traps = i
            break
    print(traps)

solve()
","
import math

def solve():
    m, x = map(int, input().split())
    
    def phi(n):
        result = n
        p = 2
        while p * p <= n:
            if n % p == 0:
                while n % p == 0:
                    n //= p
                result -= result // p
            p += 1
        if n > 1:
            result -= result // n
        return result
    
    traps = phi(m)
    print(traps)

solve()","
import math

def solve():
    m, x = map(int, input().split())
    phi_m = m // math.gcd(m, x)
    print(phi_m)

solve()","
def solve():
    import math

    m, x = map(int, input().split())

    def phi(n):
        result = n
        for i in range(2, int(math.sqrt(n)) + 1):
            if n % i ==0:
                while n % i == 0:
                    n //= i
                result -= result // i
        if n > 1:
            result -= result // n
        return result

    print(phi(m) // phi(math.gcd(m, x)))

solve()
","
from math import gcd

def solve():
    m, x = map(int, input().split())
    traps = 1
    room = x
    while room != 0:
        traps += 1
        room = (room * x) % m
    print(traps)

solve()
","
from math import gcd

def solve():
    m, x = map(int, input().split())
    traps = m - 1
    for i in range(1, m):
        if pow(x, i, m) == 1:
            traps = i
            break
    print(traps)

solve()
","
from math import gcd

def solve():
    m, x = map(int, input().split())

    def phi(n):
        result = n
        p = 2
        while p * p <= n:
            if n % p == 0:
                while n % p == 0:
                    n //= p
                result -= result // p
            p += 1

        if n > 1:
            result -= result // n
        return result

    print(phi(m) // gcd(m, x))

solve()
","
from math import gcd

def solve():
    m, x = map(int, input().split())
    count = m
    for i in range(1, m):
        if (i * x) % m == 1:
            count = min(count, i)
    print(count)

solve()
  ","
from math import gcd

def solve():
    m, x = map(int, input().split())
    traps = 1
    curr = x
    while curr != 1:
        curr = (curr * x) % m
        traps += 1
    print(traps)

solve()
","
import math

def solve():
    m, x = map(int, input().split())
    res = m if m % 2 == 0 else 2 * m // math.gcd(m, x)
    print(res)

solve()
","
def solve():
    import math
    m, x = map(int, input().split())
    traps = m // math.gcd(m, x)
    print(traps)

solve()
","
def solve():
    import math
    
    m, x = map(int, input().split())
    
    if x == 1:
        print(m-1)
    else:
        print(math.totient(m))

solve()
","0","6.666666666666667","0.0","13.333333333333334","23.076923076923077","0.0","26.666666666666668","0.0","0","6.666666666666667","0.0","7.6923076923076925","6.666666666666667","20.0","26.666666666666668","0.0","All tests timed out","","","","","","","","All tests timed out","","","","","","",""
"APPS/31","
QUESTION:
ZS the Coder has recently found an interesting concept called the Birthday Paradox. It states that given a random set of 23 people, there is around 50% chance that some two of them share the same birthday. ZS the Coder finds this very interesting, and decides to test this with the inhabitants of Udayland.

In Udayland, there are 2^{n} days in a year. ZS the Coder wants to interview k people from Udayland, each of them has birthday in one of 2^{n} days (each day with equal probability). He is interested in the probability of at least two of them have the birthday at the same day. 

ZS the Coder knows that the answer can be written as an irreducible fraction $\frac{A}{B}$. He wants to find the values of A and B (he does not like to deal with floating point numbers). Can you help him?


-----Input-----

The first and only line of the input contains two integers n and k (1 ≤ n ≤ 10^18, 2 ≤ k ≤ 10^18), meaning that there are 2^{n} days in a year and that ZS the Coder wants to interview exactly k people.


-----Output-----

If the probability of at least two k people having the same birthday in 2^{n} days long year equals $\frac{A}{B}$ (A ≥ 0, B ≥ 1, $\operatorname{gcd}(A, B) = 1$), print the A and B in a single line.

Since these numbers may be too large, print them modulo 10^6 + 3. Note that A and B must be coprime before their remainders modulo 10^6 + 3 are taken.


-----Examples-----
Input
3 2

Output
1 8
Input
1 3

Output
1 1
Input
4 3

Output
23 128


-----Note-----

In the first sample case, there are 2^3 = 8 days in Udayland. The probability that 2 people have the same birthday among 2 people is clearly $\frac{1}{8}$, so A = 1, B = 8.

In the second sample case, there are only 2^1 = 2 days in Udayland, but there are 3 people, so it is guaranteed that two of them have the same birthday. Thus, the probability is 1 and A = B = 1.
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k > 2**n:
        print(1, 1)
    else:
        A = 0
        B = 1
        for i in range(k):
            A = (A + pow(2, n-i, 10**6 + 3) * pow(B, 10**6 + 1, 10**6 + 3)) % (10**6 + 3)
            B = (B * (i+1)) % (10**6 + 3)
        
        g = gcd(A, B)
        print(A // g, B // g)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())

    if k > 2**n:
        print(1, 1)
    else:
        B = pow(2, n, 10**6 + 3)
        A = (B - 1) * pow(2, n - 1, 10**6 + 3) % (10**6 + 3)
        GCD = gcd(A, B)
        print(A // GCD, B // GCD)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k > 2**n:
        print(""1 1"")
    else:
        B = 2**n
        A = (B - 1) * pow(2*B - 1, k-1, 10**6 + 3) % (10**6 + 3)
        gcd_val = gcd(A, B)
        print(A // gcd_val, B // gcd_val)

solve()
","
import math

def solve():
    n, k = map(int, input().split())
    if k > 2**n:
        print(""1 1"")
    else:
        B = 2**n
        A = B
        for i in range(1, k):
            A *= (B - i)
            A %= 10**6 + 3
        print(A, B)

solve()
","
import math

def solve():
    n, k = map(int, input().split())
    
    if k > 2**n:
        print(""1 1"")
        return
    
    B = pow(2, n, 10**6 + 3)
    A = 0
    
    for i in range(k):
        A = (A + pow(B - i, k, 10**6 + 3)) % (10**6 + 3)
    
    print(A, B)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k <= 2**n:
        if k == 2**n:
            print(1, 1 % (10**6 + 3))
        else:
            a = (2**n) * (2**n - 1)
            b = 2**(n*k)
            g = gcd(a, b)
            print(a // g % (10**6 + 3), b // g % (10**6 + 3))
    else:
        print(0, 1)

solve()","
def solve():
    from math import gcd
    
    n, k = map(int, input().split())
    
    if k > 2 ** n:
        print(1, 1)
        return
    
    A = B = 1
    for i in range(2 ** n - k + 1, 2 ** n):
        A = (A * i) % (10**6 + 3)
    for i in range(1, k):
        B = (B * i) % (10**6 + 3)
    
    result = pow(B, 10**6 + 1 - 2, 10**6 + 3)
    result = (A * result) % (10**6 + 3)
    
    print(result, B)

solve()
","
def solve():
    MOD = 10**6 + 3
    
    n, k = map(int, input().split())
    
    if k > 2**n:
        print(0, 1)
        return
    
    num = 1
    den = 1
    
    for i in range(k):
        num = num * (2**n - i) % MOD
        den = den * (i + 1) % MOD
    
    inv_den = pow(den, MOD - 2, MOD)
    result = num * inv_den % MOD
    
    print(result, den)
  
solve()","
def solve():
    from math import gcd
    n, k = map(int, input().split())
    
    if k > 2**n:
        print(1, 1)
    else:
        B = pow(2, n, 10**6+3)
        A = 0
        for i in range(k):
            A = (A + pow(B - i, k, 10**6+3)) % (10**6+3)
        
        GCD = gcd(A, B)
        print(A // GCD, B // GCD)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    days_in_year = 2 ** n
    
    if k <= days_in_year:
        A = 1
        B = days_in_year
    else:
        A = days_in_year
        B = days_in_year ** k
        
    common_divisor = gcd(A, B)
    
    A //= common_divisor
    B //= common_divisor
    
    print(A % ((10 ** 6) + 3), B % ((10 ** 6) + 3))

solve()
","
def solve():
    import math

    n, k = map(int, input().split())

    if k > 2**n:
        print(1, 1)
    else:
        A = 0
        B = 1
        for i in range(0, k):
            A = (A + pow(2**n - i, k, 10**6 + 3)) % (10**6 + 3)
        for i in range(1, k + 1):
            B = (B * i) % (10**6 + 3)
        A = (A * math.factorial(k)) % (10**6 + 3)
        B = pow(B, 10**6 + 1, 10**6 + 3)
        B = pow(B, -1, 10**6 + 3)
        A = (A * B) % (10**6 + 3)
        print(A, 1)

solve()
 ","
import math

def solve():
    n, k = map(int, input().split())
    
    if k > 2**n:
        print(1, 1)
    else:
        A = 0
        B = 1
        for i in range(2**n - k + 1, 2**n):
            A += math.comb(2**n, i)
        gcd = math.gcd(A, B)
        A //= gcd
        B //= gcd
        print(A % (10**6 + 3), B % (10**6 + 3))

solve()
","
import math

def solve():
    n, k = map(int, input().strip().split())
    
    if k <= 2**n:
        A = 0
        B = 1
    else:
        A = 2**n * math.comb(k, 2) - k * math.factorial(k-1)
        B = 2**(n*k)
    
    gcd = math.gcd(A, B)
    A //= gcd
    B //= gcd
    
    print(A % (10**6 + 3), B % (10**6 + 3))

solve()","
from math import gcd

def solve():
    n, k = map(int, input().split())

    if k > 2**n:
        print(1, 1)
    else:
        A = 0
        base = 2**n
        for i in range(k, base + 1):
            curr_prod = 1
            for j in range(k):
                curr_prod = (curr_prod * (i - j)) % (10**6 + 3)
            A = (A + curr_prod) % (10**6 + 3)
        
        B = pow(base, k, 10**6 + 3)     
        g = gcd(A, B)
        print(A//g, B//g)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())

    if k <= (1 << n):
        A = 1
        B = 1
    else:
        total_days = 1 << n
        B = pow(total_days, k, 10**6 + 3)
        A = (B - total_days) % (10**6 + 3)
    
    g = gcd(A, B)
    A //= g
    B //= g
    
    print(A, B)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    if k > 2**n:
        print(1, 1)
        return
    
    A = 0
    B = 2**n
    for i in range(k, B+1):
        A += (-1)**(i-k) * B // i
    
    print(A % (10**6 + 3), B % (10**6 + 3))

solve()
","28.57142857142857","25.0","25.0","28.57142857142857","28.57142857142857","0.0","28.57142857142857","0.0","28.57142857142857","14.285714285714285","28.57142857142857","40.0","0.0","40.0","0.0","50.0","","","","","","","","","","","","","","","",""
"APPS/32","
QUESTION:
In this problem we assume the Earth to be a completely round ball and its surface a perfect sphere. The length of the equator and any meridian is considered to be exactly 40 000 kilometers. Thus, travelling from North Pole to South Pole or vice versa takes exactly 20 000 kilometers.

Limak, a polar bear, lives on the North Pole. Close to the New Year, he helps somebody with delivering packages all around the world. Instead of coordinates of places to visit, Limak got a description how he should move, assuming that he starts from the North Pole. The description consists of n parts. In the i-th part of his journey, Limak should move t_{i} kilometers in the direction represented by a string dir_{i} that is one of: ""North"", ""South"", ""West"", ""East"".

Limak isn’t sure whether the description is valid. You must help him to check the following conditions:  If at any moment of time (before any of the instructions or while performing one of them) Limak is on the North Pole, he can move only to the South.  If at any moment of time (before any of the instructions or while performing one of them) Limak is on the South Pole, he can move only to the North.  The journey must end on the North Pole. 

Check if the above conditions are satisfied and print ""YES"" or ""NO"" on a single line.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 50).

The i-th of next n lines contains an integer t_{i} and a string dir_{i} (1 ≤ t_{i} ≤ 10^6, $\operatorname{dir}_{i} \in \{\text{North, South, West, East} \}$) — the length and the direction of the i-th part of the journey, according to the description Limak got.


-----Output-----

Print ""YES"" if the description satisfies the three conditions, otherwise print ""NO"", both without the quotes.


-----Examples-----
Input
5
7500 South
10000 East
3500 North
4444 West
4000 North

Output
YES

Input
2
15000 South
4000 East

Output
NO

Input
5
20000 South
1000 North
1000000 West
9000 North
10000 North

Output
YES

Input
3
20000 South
10 East
20000 North

Output
NO

Input
2
1000 North
1000 South

Output
NO

Input
4
50 South
50 North
15000 South
15000 North

Output
YES



-----Note-----

Drawings below show how Limak's journey would look like in first two samples. In the second sample the answer is ""NO"" because he doesn't end on the North Pole. [Image]
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    position = 0
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        if position == 0 and direction != ""South"":
            print(""NO"")
            return
        if position == 20000 and direction != ""North"":
            print(""NO"")
            return
        if direction == ""North"":
            position -= t
        elif direction == ""South"":
            position += t
        if position < 0 or position > 20000:
            print(""NO"")
            return
    if position == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    
    current_position = 0
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        
        if current_position == 0 and direction == ""North"":
            print(""NO"")
            return
        if current_position == 20000 and direction == ""South"":
            print(""NO"")
            return
        if direction == ""North"":
            current_position -= t
        elif direction == ""South"":
            current_position += t
    
    if current_position == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    position = 0
    valid_move = True

    for _ in range(n):
        t, direction = input().split()
        t = int(t)

        if position == 0 and direction != ""South"":
            valid_move = False
        elif position == 20000 and direction != ""North"":
            valid_move = False
        
        if direction == ""North"":
            position += t
        elif direction == ""South"":
            position -= t
        
        if position < 0 or position > 20000:
            valid_move = False
    
    if position == 0 and valid_move:
        print(""YES"")
    else:
        print(""NO"")

# Example usage:
solve()
","
def solve():
    n = int(input())
    position = 0
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        if (position == 0 and direction != ""South"") or (position == 20000 and direction != ""North""):
            print(""NO"")
            return
        if direction == ""South"":
            position += t
            if position > 20000:
                print(""NO"")
                return
        elif direction == ""North"":
            position -= t
            if position < 0:
                print(""NO"")
                return
    
    if position == 20000:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    position = 0  # 0 for North Pole, 1 for South Pole
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        if position == 0 and direction == ""South"":
            position = 1
        elif position == 1 and direction == ""North"":
            position = 0
        else:
            print(""NO"")
            return
    if position == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    position = 0
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        if (position == 0 and direction != ""South"") or (position == 20000 and direction != ""North""):
            print(""NO"")
            return
        if direction == ""South"":
            position -= t
        elif direction == ""North"":
            position += t
        if position < 0 or position > 20000:
            print(""NO"")
            return
    if position == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    start = 0
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        if start == 0 and direction != ""South"":
            print(""NO"")
            return
        if start == 20000 and direction != ""North"":
            print(""NO"")
            return
        if direction == ""North"":
            start -= t
            if start < 0:
                print(""NO"")
                return
        elif direction == ""South"":
            start += t
            if start > 20000:
                print(""NO"")
                return
    if start == 0:
        print(""YES"")
    else:
        print(""NO"")


solve()
  ","
def solve():
    n = int(input())
    current_pos = 0
    
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        
        if current_pos == 0 and direction != ""South"":
            print(""NO"")
            return
        elif current_pos == 20000 and direction != ""North"":
            print(""NO"")
            return
        elif current_pos + t < 0 or current_pos + t > 20000:
            print(""NO"")
            return
        else:
            current_pos += t
    
    if current_pos == 20000:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n = int(input())
    current_position = 0
    
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        
        if (current_position == 0 and direction != ""South"") or (current_position == 20000 and direction != ""North""):
            print(""NO"")
            return
        
        if direction == ""North"":
            current_position -= t
        elif direction == ""South"":
            current_position += t
        
    if current_position == 20000:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    position = 0
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        if position == 0 and direction != ""South"":
            print(""NO"")
            return
        if position == 20000 and direction != ""North"":
            print(""NO"")
            return
        if direction == ""South"":
            position += t
            if position > 20000:
                print(""NO"")
                return
        elif direction == ""North"":
            position -= t
            if position < 0:
                print(""NO"")
                return
    if position == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    position = 0

    for _ in range(n):
        t, direction = input().split()
        t = int(t)

        if position == 0 and direction != ""South"":
            print(""NO"")
            return
        if position == 20000 and direction != ""North"":
            print(""NO"")
            return

        if direction == ""South"":
            position += t
        elif direction == ""North"":
            position -= t

        if position < 0 or position > 20000:
            print(""NO"")
            return

    if position == 0:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n = int(input())
    poles = []
    poles.append(""North"")

    for _ in range(n):
        t, direction = input().split()
        t = int(t)

        if poles[-1] == ""North"" and direction == ""North"":
            poles.append(""South"")
        elif poles[-1] == ""South"" and direction == ""South"":
            poles.append(""North"")
        else:
            poles.append(poles[-1])

    if poles[-1] == ""North"":
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    current_position = ""North""
    
    for _ in range(n):
        t, direction = input().split()
        if current_position == ""North"" and direction != ""South"":
            print(""NO"")
            return
        if current_position == ""South"" and direction != ""North"":
            print(""NO"")
            return
            
        current_position = ""North"" if direction == ""North"" else ""South""
    
    if current_position == ""North"":
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    on_pole = ""North""
    
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        
        if on_pole == ""North"" and direction != ""South"":
            on_pole = ""South""
        elif on_pole == ""South"" and direction != ""North"":
            on_pole = ""North""
    
    if on_pole == ""North"":
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    current_lat = 20000  # North Pole represented as latitude 20000
    valid = True

    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        
        if current_lat == 20000 and direction != ""South"":
            valid = False
        elif current_lat == 0 and direction != ""North"":
            valid = False
        
        if direction == ""North"":
            current_lat -= t
        elif direction == ""South"":
            current_lat += t
        
        if current_lat < 0 or current_lat > 20000:
            valid = False

    if current_lat != 20000:
        valid = False

    if valid:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    current_lat = 0
    for _ in range(n):
        t, direction = input().split()
        t = int(t)
        if current_lat == 20000 and direction != ""North"":
            print(""NO"")
            return
        if current_lat == 0 and direction != ""South"":
            print(""NO"")
            return
        if direction == ""North"":
            current_lat += t
        elif direction == ""South"":
            current_lat -= t
        if current_lat < 0 or current_lat > 20000:
            print(""NO"")
            return
    if current_lat == 20000:
        print(""YES"")
    else:
        print(""NO"")

solve()
","100.0","73.33333333333333","80.0","80.0","80.0","80.0","100.0","80.0","80.0","100.0","100.0","13.333333333333334","80.0","33.33333333333333","80.0","80.0","","","","","","","","","","","","","","","",""
"APPS/33","
QUESTION:
You are given two arithmetic progressions: a_1k + b_1 and a_2l + b_2. Find the number of integers x such that L ≤ x ≤ R and x = a_1k' + b_1 = a_2l' + b_2, for some integers k', l' ≥ 0.


-----Input-----

The only line contains six integers a_1, b_1, a_2, b_2, L, R (0 < a_1, a_2 ≤ 2·10^9,  - 2·10^9 ≤ b_1, b_2, L, R ≤ 2·10^9, L ≤ R).


-----Output-----

Print the desired number of integers x.


-----Examples-----
Input
2 0 3 3 5 21

Output
3

Input
2 4 3 0 6 17

Output
2
Use user-input-Based format and function signature solve()","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    def extended_gcd(a, b):
        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = extended_gcd(b % a, a)
            return (g, x - (b // a) * y, y)
    
    def find_solution(a, b, c):
        g = gcd(a, b)
        if c % g != 0:
            return 0, 0
        a //= g
        b //= g
        c //= g
        g, x, y = extended_gcd(a, b)
        x *= c
        y *= c
        return x, y
    
    x1, y1 = find_solution(a1, -a2, b2 - b1)
    if x1 < 0:
        k1 = (-x1 + a2 - 1) // a2
    else:
        k1 = x1 // a2
    if y1 < 0:
        l1 = (-y1 + a1 - 1) // a1
    else:
        l1 = y1 // a1
    
    x2, y2 = find_solution(a1, a2, b2 - b1)
    if x2 < 0:
        k2 = (-x2 + a2 - 1) // a2
    else:
        k2 = x2 // a2
    if y2 < 0:
        l2 = (-y2 + a1 - 1) // a1
    else:
        l2 = y2 // a1
    
    ans = max(0, min(R // a1 - k1, R // a2 - l1) - max((L - 1) // a1 - k2, (L - 1) // a2 - l2) + 1)
    print(ans)

solve()
","
def solve():
    from math import gcd
    
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    if b1 < b2:
        a1, b1, a2, b2 = a2, b2, a1, b1
    
    if a1 == a2:
        if b1 == b2:
            return R - L + 1
        else:
            return 0
    
    diff_b = b1 - b2
    g = gcd(a1, a2)
    
    if diff_b % g != 0:
        return 0
    
    l = max(L, (-diff_b) // g + 1)
    r = min(R, (-diff_b) // g + 1 + (R - L) // g * g)
    
    return max(0, (r - l) // g + 1)

solve()
","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    if b1 > b2:
        a1, b1, a2, b2 = a2, b2, a1, b1

    g = gcd(a1, a2)
    if (b2 - b1) % g != 0:
        print(0)
        return

    low = max((b1 - b2) // g, 0)
    high = (R - L - b2 + b1) // g
    
    result = max(high - low + 1, 0)
    print(result)

solve()
  ","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    def gcd_extended(a, b):
        if a == 0:
            return b, 0, 1
        else:
            g, x, y = gcd_extended(b % a, a)
            return g, y - (b // a) * x, x
    
    def generate_sequence(a, b, n):
        gcd, x, y = gcd_extended(a, n)
        return x * (b // gcd) % n
    
    gcd_val, b_diff = gcd_extended(a1, a2)
    if (b1 - b2) % gcd_val != 0:
        print(0)
    else:
        val = generate_sequence(a2 // gcd_val, (b1 - b2) // gcd_val, a1 // gcd_val)
        count = (R - val) // a2 + 1
        if val < L:
            count -= (L - val - 1) // a2
        print(max(count, 0))

solve()
  ","
def solve():
    a_1, b_1, a_2, b_2, L, R = map(int, input().split())
    
    if a_1 == a_2:
        if (b_2 - b_1) % a_1 == 0:
            if L <= (b_2 - b_1) // a_1 + b_1 <= R:
                return R - L + 1
            else:
                return 0
        else:
            return 0
    else:
        g = a_1 - a_2
        f = b_2 - b_1
        
        if f % g == 0:
            x0 = f // g
            if (L - x0) % a_1 == 0:
                k0 = (L - x0) // a_1
            else:
                k0 = (L - x0) // a_1 + 1
                
            if (R - x0) % a_1 == 0:
                k1 = (R - x0) // a_1
            else:
                k1 = (R - x0) // a_1 - 1
                
            return max(0, k1 - k0 + 1)
        else:
            return 0
  
solve()","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    if b1 < b2:
        a1, b1, a2, b2 = a2, b2, a1, b1
    
    g = gcd(a1, a2)
    
    if (b2 - b1) % g != 0:
        print(0)
        return
    
    lower = max((L - b1) // a1, (L - b2) // a2)
    upper = min((R - b1) // a1, (R - b2) // a2)
    
    count = (upper - lower) // (g // abs(a2))
    
    print(max(0, count + 1))

solve()
","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    gcd = abs(a1 - a2)
    diff = b2 - b1
    if diff % gcd != 0:
        print(0)
    else:
        min_x = max(L, (diff // gcd * a1 + b1 + gcd - 1) // gcd)
        max_x = min(R, (diff // gcd * a1 + b1 - 1) // gcd)
        print(max(0, max_x - min_x + 1))

solve()
","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())

    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)

    def extended_gcd(a, b):
        if b == 0:
            return (1, 0, a)
        else:
            x, y, g = extended_gcd(b, a % b)
            return y, x - (a // b) * y, g

    g = gcd(a1, a2)
    if (b2 - b1) % g != 0:
        print(0)
        return

    a2 //= g
    b2 = (b2 - b1) // g
    x, y, g = extended_gcd(a1 // g, a2)

    if b2 % g != 0:
        print(0)
    else:
        x *= b2 // g
        l, r = max(0, -x), (R - L - x) // abs(a2) + 1
        print(r - l)

# Needed import for user-input
import sys
input = sys.stdin.readline

solve()
  ","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)
    
    g = gcd(a1, a2)
    if (b2 - b1) % g != 0:
        print(0)
        return
    
    L_new = max(L, min(b1, b2) + (L - min(b1, b2) + g - 1) // g * g)
    R_new = min(R, max(b1, b2) + (R - max(b1, b2)) // g * g)
    
    print((R_new - L_new) // g + 1)
  
solve()","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    if (b2 - b1) % gcd(a1, a2) != 0:
        print(0)
        return

    L = max(L, min(b1, b2))
    R = min(R, max(b1, b2))

    g = gcd(a1, a2)
    diff_ab = b2 - b1

    if diff_ab % g == 0:
        x_min = max((L - b1) // a1, (L - b2) // a2)
        x_max = min((R - b1) // a1, (R - b2) // a2)
        print(max(0, x_max - x_min + 1))
    else:
        print(0)

solve()
","
def solve():
    a_1, b_1, a_2, b_2, L, R = map(int, input().split())
    g = math.gcd(a_1, a_2)
    if (b_2 - b_1) % g != 0:
        print(0)
        return
    x = (b_2 - b_1) // g
    low = max(0, (L - b_1 + a_1) // a_1, (L - b_2 + a_2) // a_2)
    high = max(0, (R - b_1 + a_1) // a_1, (R - b_2 + a_2) // a_2)
    answer = max(0, high - low + 1)
    print(answer)

import math
solve()
  ","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    if (b2 - b1) % gcd(a1, a2) != 0:
        print(0)
    else:
        y_max = (R - b1) // a1
        y_min = (L - b1 - 1) // a1
        x_max = (y_max - b2) // a2
        x_min = (y_min - b2 + 1) // a2
        print(max(0, x_max - x_min + 1))

solve()
","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    g = gcd(a1, a2)

    if (b2 - b1) % g != 0:
        print(0)
        return
    
    low = max(L, max(b1, b2))
    high = min(R, min(a1+a2, a1+a2-b1+b2))

    if low > high:
        print(0)
    else:
        print((high - low) // g + 1)

solve()
","
def solve():
    a1, b1, a2, b2, L, R = map(int, input().split())
    
    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)
    
    g = gcd(a1, a2)
    if (b2 - b1) % g != 0:
        print(0)
        return
    
    z = (b2 - b1) // g
    x0 = ((L - b1) // a1) * a1 + b1
    d = a2 // g
    k = (x0 - b2) // d
    
    if x0 < L:
        x0 += a1
        k += 1
    
    if x0 > R:
        print(0)
        return
    
    ans = (R - x0) // a1 // d - (L - x0) // a1 // d + 1
    if ans < 0:
        ans = 0
    
    print(ans)

solve()
","
def solve():
    from math import gcd

    def lcm(a, b):
        return abs(a * b) // gcd(a, b)

    a1, b1, a2, b2, L, R = map(int, input().split())
    d = gcd(a1, a2)

    if (b2 - b1) % d != 0:
        print(0)
        return

    d = abs(d)
    b = b2 - b1
    t = b // d
    t *= pow(a1//d, -1, a2//d)  # modular inverse
    t %= a2//d

    l = lcm(a1//d, a2//d)
    ans = (R - L + l) // l

    x1 = max(a1 * t + b1, L)
    x2 = min(a2 * t + b2, R)

    if x1 <= x2:
        ans -= (x2 - x1) // l + 1

  
    print(max(0, ans))


solve()
","
def solve():
    a_1, b_1, a_2, b_2, L, R = map(int, input().split())

    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a%b)

    d = gcd(a_1, a_2)

    if (b_2 - b_1) % d != 0:
        print(0)
        return
    
    x0 = (b_2 - b_1) // d
    lower_bound = max((L - b_1 + x0*a_1 + d - 1) // d, 0)
    upper_bound = (R - b_1 + x0*a_1) // d

    print(upper_bound - lower_bound + 1)

solve()
","13.333333333333334","0.0","0.0","0.0","0.0","13.333333333333334","13.333333333333334","6.666666666666667","0.0","13.333333333333334","0.0","6.666666666666667","13.333333333333334","6.666666666666667","20.0","0.0","","","","","","","","","","","","","","","",""
"APPS/34","
QUESTION:
It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into a pieces, and the second one — into b pieces.

Ivan knows that there will be n people at the celebration (including himself), so Ivan has set n plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:  Each piece of each cake is put on some plate;  Each plate contains at least one piece of cake;  No plate contains pieces of both cakes. 

To make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number x such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least x pieces of cake.

Help Ivan to calculate this number x!


-----Input-----

The first line contains three integers n, a and b (1 ≤ a, b ≤ 100, 2 ≤ n ≤ a + b) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.


-----Output-----

Print the maximum possible number x such that Ivan can distribute the cake in such a way that each plate will contain at least x pieces of cake.


-----Examples-----
Input
5 2 3

Output
1

Input
4 7 10

Output
3



-----Note-----

In the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.

In the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.
Use user-input-Based format and function signature solve()","
def solve():
    n, a, b = map(int, input().split())
    print(min(a // (n - 1), b // (n - 1)))

solve()
","
def solve():
    n, a, b = map(int, input().split())
    print(min(a//n, b//n))

solve()
","
def solve():
    n, a, b = map(int, input().split())
    
    x = max(min(a // n, b // (n - 1)), min(a // (n - 1), b // n))
    
    print(x)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    x = max(a // n, b // (n - 1), b // n, a // (n - 1))
    print(x)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    low = 1
    high = min(a, b)
    mid = (low + high + 1) // 2
    while low < high:
        if (a // mid) + (b // mid) >= n and (a // (mid - 1)) + (b // (mid - 1)) < n:
            return mid
        elif (a // mid) + (b // mid) >= n:
            low = mid
        else:
            high = mid - 1
        mid = (low + high + 1) // 2
    return mid
  
solve()","
def solve():
    n, a, b = map(int, input().split())
    print(min(a // n, b // (n - 1)))

solve()
","
def solve():
    n, a, b = map(int, input().split())
    min_pieces = max(a//n, b//n)
    for i in range(1, n):
        min_pieces = max(min(min(a//i, b//(n-i)), min_pieces))
    print(min_pieces)

solve()","
def solve():
    n, a, b = map(int, input().split())
    x = max(a // n, b // (n - 1), b // n, a // (n - 1))
    print(x)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    min_pieces = min(a // n, b // n)
    max_pieces = max(min_pieces, (a + b) // n)
    for x in range(max_pieces, 0, -1):
        if a // x + b // x >= n:
            print(x)
            break

solve()
","
def solve():
    n, a, b = map(int, input().split())
    x = min(a // n, b // (n - 1))
    print(x)

solve()
  ","
def solve():
    n, a, b = map(int, input().split())
    x = min(a // (n-1), b // (n-1))
    while a // x + b // x < n:
        x -= 1
    print(x)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    x = max(min(a // (n - 1), b // (n - 1)), max(a, b) // n)
    print(x)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    x = min(a//n, b//n)
    print(x)

solve()
  ","
def solve():
    n, a, b = map(int, input().split())
    
    min_pieces = (a + b) // n
    while min(a // min_pieces + b // min_pieces < n):
        min_pieces -= 1
    
    print(min_pieces)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    x = max(min(a // n, b // (n - 1)), min(a // (n - 1), b // n))
    print(x)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    min_cakes_per_plate = max(a//n, b//n)
    print(min_cakes_per_plate)

solve()
","20.0","0.0","6.666666666666667","40.0","0.0","0.0","0.0","40.0","86.66666666666667","0.0","20.0","20.0","0.0","0.0","6.666666666666667","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/35","
QUESTION:
The flag of Berland is such rectangular field n × m that satisfies following conditions:

  Flag consists of three colors which correspond to letters 'R', 'G' and 'B'.  Flag consists of three equal in width and height stripes, parralel to each other and to sides of the flag. Each stripe has exactly one color.  Each color should be used in exactly one stripe. 

You are given a field n × m, consisting of characters 'R', 'G' and 'B'. Output ""YES"" (without quotes) if this field corresponds to correct flag of Berland. Otherwise, print ""NO"" (without quotes).


-----Input-----

The first line contains two integer numbers n and m (1 ≤ n, m ≤ 100) — the sizes of the field.

Each of the following n lines consisting of m characters 'R', 'G' and 'B' — the description of the field.


-----Output-----

Print ""YES"" (without quotes) if the given field corresponds to correct flag of Berland . Otherwise, print ""NO"" (without quotes).


-----Examples-----
Input
6 5
RRRRR
RRRRR
BBBBB
BBBBB
GGGGG
GGGGG

Output
YES

Input
4 3
BRG
BRG
BRG
BRG

Output
YES

Input
6 7
RRRGGGG
RRRGGGG
RRRGGGG
RRRBBBB
RRRBBBB
RRRBBBB

Output
NO

Input
4 4
RRRR
RRRR
BBBB
GGGG

Output
NO



-----Note-----

The field in the third example doesn't have three parralel stripes.

Rows of the field in the fourth example are parralel to each other and to borders. But they have different heights — 2, 1 and 1.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    colors = set()
    stripes = []

    for i in range(n):
        if field[i][0] in colors:
            return ""NO""
        colors.add(field[i][0])
        if len(set(field[i])) != 1:
            return ""NO""
        stripes.append(len(field[i]))

    if len(colors) != 3 or len(set(stripes)) != 1:
        return ""NO""

    return ""YES""

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    colors = {'R', 'G', 'B'}
    stripe_height = n // 3

    stripe_colors = set()
    stripe_heights = [0, 0, 0]

    for i in range(n):
        stripe_idx = i // stripe_height
        stripe_colors.update(set(field[i]))
        stripe_heights[stripe_idx] += 1

    if stripe_colors != colors or stripe_heights != [stripe_height]*3:
        print(""NO"")
    else:
        print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    colors = set()
    for i in range(n):
        colors.update(set(field[i]))

    if len(colors) != 3:
        print(""NO"")
        return

    if n % 3 != 0 or m % 3 != 0:
        print(""NO"")
        return

    stripe_height = n // 3
    stripe_width = m // 3

    for i in range(3):
        row = field[i * stripe_height]
        for j in range(1, 3):
            if field[i * stripe_height + j] != row:
                print(""NO"")
                return

    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    colors = set()
    heights = [0, 0, 0]

    for i in range(n):
        for j in range(m):
            if field[i][j] not in colors:
                colors.add(field[i][j])
            heights[j % 3] += 1

    if len(colors) != 3 or len(set(heights)) > 1:
        print(""NO"")
    else:
        print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    flag_colors = set(['R', 'G', 'B'])
    stripe_height = n // 3

    # Check if each stripe has only one color
    first_stripe = field[:stripe_height]
    second_stripe = field[stripe_height:2*stripe_height]
    third_stripe = field[2*stripe_height:]

    if set(first_stripe) == flag_colors and set(second_stripe) == flag_colors and set(third_stripe) == flag_colors:
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    colors = {'R': 0, 'G': 0, 'B': 0}
    valid_height = n // 3
    
    for i in range(n):
        for j in range(m):
            colors[field[i][j]] += 1
    
    if all(value == valid_height * m for value in colors.values()) and n % 3 == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    flag = [input() for _ in range(n)]
    
    colors = ['R', 'G', 'B']
    stripe_height = n // 3
    
    if n % 3 != 0 or any(len(set(flag[i*stripe_height:(i+1)*stripe_height])) != 1 or set(flag[i*stripe_height:(i+1)*stripe_height][0]) != set(colors) for i in range(3)):
        print(""NO"")
    else:
        print(""YES"")

solve()
","
from typing import List

def solve() -> None:
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    colors = set()
    for i in range(n):
        for j in range(m):
            colors.add(field[i][j])

    if len(colors) != 3:
        print(""NO"")
        return

    stripes = ["""".join(row) for row in field[:n//3]] + ["""".join(row) for row in field[n-n//3:]]
    
    if len(set(stripes)) == 3 and stripes[0] != stripes[-1]:
        print(""YES"")
    else:
        print(""NO"")


solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    # Check if three parallel stripes with equal width exist
    if n % 3 != 0:
        print(""NO"")
        return
    stripe_length = n // 3

    colors = set(""RGB"")
    stripe1 = field[:stripe_length]
    stripe2 = field[stripe_length:2*stripe_length]
    stripe3 = field[2*stripe_length:]

    # Check if each stripe has exactly one color
    if set(stripe1[0]) != colors or set(stripe2[0]) != colors or set(stripe3[0]) != colors:
        print(""NO"")
        return

    # Check if each color is used exactly once in the flag
    colors_count = {color: 0 for color in colors}
    for i in range(stripe_length):
        for j in range(m):
            colors_count[field[i][j]] += 1

    if all(count == m for count in colors_count.values()):
        print(""YES"")
    else:
        print(""NO"")


solve()
","
def solve():
    n, m = map(int, input().split())
    flag = [input() for _ in range(n)]

    colors = set()
    for i in range(n // 3):
        for j in range(m):
            colors.add(flag[i][j])
            colors.add(flag[i + n//3][j])
            colors.add(flag[i + 2 * n//3][j])
    if len(colors) != 3:
        print(""NO"")
        return

    if len(set(flag[:n//3])) == 1 and len(set(flag[n//3:2*n//3])) == 1 and len(set(flag[2*n//3:])) == 1:
        if len(set(flag[:n//3][0])) == 1 and len(set(flag[n//3:2*n//3][0])) == 1 and len(set(flag[2*n//3:][0])) == 1:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    
    flag = [input() for _ in range(n)]
    
    colors = {'R', 'G', 'B'}
    
    if n % 3 != 0 or m % 3 != 0:
        print(""NO"")
        return
    
    stripe_size = n // 3
    
    stripes = [set(flag[i * stripe_size: (i+1) * stripe_size]) for i in range(3)]
    
    if len(stripes[0]) == 1 and len(stripes[1]) == 1 and len(stripes[2]) == 1 \
        and stripes[0].union(stripes[1]).union(stripes[2]) == colors:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    colors = set()
    for i in range(n):
        colors.update(set(field[i]))

    if len(colors) != 3:
        print(""NO"")
        return

    stripe_len = n // 3
    stripe1 = field[:stripe_len]
    stripe2 = field[stripe_len:2*stripe_len]
    stripe3 = field[2*stripe_len:]

    if len(set(''.join(stripe1))) == 1 and len(set(''.join(stripe2))) == 1 and len(set(''.join(stripe3))) == 1:
        if stripe1[0][0] != stripe2[0][0] and stripe1[0][0] != stripe3[0][0] and stripe2[0][0] != stripe3[0][0]:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n, m = map(int, input().split())
    flag = [input() for _ in range(n)]

    colors = {'R': 0, 'G': 0, 'B': 0}
    heights = [0, 0, 0]

    for i in range(n):
        for j in range(m):
            colors[flag[i][j]] += 1
            heights[j % 3] += 1

    if all(count == n * m // 3 for count in colors.values()) and all(height == n // 3 for height in heights):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    colors = set()
    for row in field:
        for char in row:
            colors.add(char)

    if len(colors) != 3:
        print(""NO"")
        return

    R, G, B = colors

    def check_stripe(stripe):
        return len(stripe) == m and stripe.count(R) == stripe.count(G) == stripe.count(B) == len(stripe)//3

    stripe1 = field[0]
    stripe2 = field[n//3]
    stripe3 = field[2 * n // 3]

    if check_stripe(stripe1) and check_stripe(stripe2) and check_stripe(stripe3):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    colors = set()
    stripes = set()
    
    for i in range(n):
        colors.update(set(field[i]))
        if len(set(field[i])) != 1:
            print(""NO"")
            return
    
    for j in range(m):
        stripes.add(''.join(field[i][j] for i in range(n)))
        if len(stripes) > 3:
            print(""NO"")
            return
    
    if len(colors) == 3 and len(stripes) == 3:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    colors = set()

    for row in field:
        for char in row:
            colors.add(char)

    if len(colors) != 3:
        print(""NO"")
    else:
        color_counts = {}
        for color in colors:
            color_counts[color] = 0

        for row in field:
            for char in row:
                color_counts[char] += 1

        if len(set(color_counts.values())) != 1:
            print(""NO"")
        else:
            stripe_height = n // 3
            stripe_width = m

            stripe_colors = []
            for i in range(0, n, stripe_height):
                stripe = ''.join(field[i][0:stripe_width])
                stripe_colors.append(stripe)

            if stripe_colors[0] != stripe_colors[1] and stripe_colors[1] != stripe_colors[2] and stripe_colors[0] != stripe_colors[2]:
                print(""YES"")
            else:
                print(""NO"")

solve()
","0.0","40.0","73.33333333333333","66.66666666666666","73.33333333333333","80.0","73.33333333333333","73.33333333333333","73.33333333333333","86.66666666666667","73.33333333333333","86.66666666666667","73.33333333333333","66.66666666666666","73.33333333333333","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/36","
QUESTION:
Ayrat is looking for the perfect code. He decided to start his search from an infinite field tiled by hexagons. For convenience the coordinate system is introduced, take a look at the picture to see how the coordinates of hexagon are defined: 

[Image] [Image] Ayrat is searching through the field. He started at point (0, 0) and is moving along the spiral (see second picture). Sometimes he forgets where he is now. Help Ayrat determine his location after n moves.


-----Input-----

The only line of the input contains integer n (0 ≤ n ≤ 10^18) — the number of Ayrat's moves.


-----Output-----

Print two integers x and y — current coordinates of Ayrat coordinates.


-----Examples-----
Input
3

Output
-2 0

Input
7

Output
3 2
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    x, y = 0, 0
    k = 1
    while k * k < n:
        k += 2
    k -= 2
    n -= k * k
    if n <= k:
        x += n
    elif n <= 2 * k:
        x += k
        y += n - k
    elif n <= 3 * k:
        x += k - (n - 2 * k)
        y += k
    elif n <= 4 * k:
        y += k - (n - 3 * k)
    elif n <= 5 * k:
        y -= n - 4 * k
    else:
        x -= n - 5 * k
    print(x, y)

solve()
","
def solve():
    n = int(input())
    k = int((n ** 0.5) // 1)
    if k % 2 == 0:
        x = k // 2
        y = -k // 2
        shift = n - k ** 2
        if shift <= k:
            x -= shift
        else:
            x -= k
            y += shift - k
    else:
        x = -k // 2
        y = k // 2
        shift = n - k ** 2
        if shift <= k:
            y += shift
        else:
            y += k
            x -= shift - k
    print(x, y)

solve()
","
def solve():
    n = int(input())
    if n == 0:
        print(""0 0"")
    else:
        k = ((n * 3) ** 0.5 - 0.5) // 1
        x = n - (k * (k + 1) // 2) * 3
        y = k
        if k % 2 == 1:
            x, y = -y, -x
        print(f""{x} {y}"")

solve()","
def solve():
    n = int(input())
    x, y = 0, 0
    k = 1
    while k*k < n:
        k += 1
    s = (k-1)*(k)//2
    d = (n-s)//k
    n %= k
    if d % 6 == 0:
        x, y = d//6, -d//3
    elif d % 6 == 1:
        x, y = -k//2+d//6, -d//3
    elif d % 6 == 2:
        x, y = -k//2+d//6, d//3
    elif d % 6 == 3:
        x, y = d//6, d//3
    elif d % 6 == 4:
        x, y = k//2-d//6, d//3
    else:
        x, y = k//2-d//6, -d//3
    if n < k:
        if d % 6 == 0:
            y -= n
        elif d % 6 == 1:
            x += n
            y -= k-n
        elif d % 6 == 2:
            x += n
        elif d % 6 == 3:
            y += n
        elif d % 6 == 4:
            x -= n
            y += k-n
        else:
            x -= n
    else:
        if d % 6 == 0:
            y -= k
            x -= n-k
        elif d % 6 == 1:
            x += n-k
            y -= 2*k-n
        elif d % 6 == 2:
            x += n-k
            y += n-k
        elif d % 6 == 3:
            y += n-k
        elif d % 6 == 4:
            x -= n-k
            y += k-n
        else:
            x -= n-k
            y -= n-k
    return x, y

solve()","
from math import sqrt

def solve():
    def get_ring_count(n):
        return int((sqrt(12 * n + 9) - 3) / 6)

    def get_coords(n, ring_count):
        x, y = 0, 0
        for i in range(ring_count):
            x += 1
            y -= 1
            n -= 1
        for i in range(ring_count):
            x += 1
            n -= 1
        for i in range(ring_count):
            y += 1
            n -= 1
        for i in range(ring_count):
            x -= 1
            y += 1
            n -= 1
        for i in range(ring_count):
            x -= 1
            n -= 1
        for i in range(ring_count):
            y -= 1
            n -= 1
        return x, y

    n = int(input())
    ring_count = get_ring_count(n)
    x, y = get_coords(n, ring_count)
    print(x, y)

solve()
","
def solve():
    n = int(input())
    if n == 0:
        print(""0 0"")
    else:
        k = (int(((1 + 4*(3*n + 1))**0.5) - 1) // 2) + 1
        x = 3*k*(k-1)
        y = 0
        steps = n - k*(k-1)//2
        for i in range(6):
            if steps <= k-1:
                x += steps
                break
            x += k-1
            steps -= k-1
            x -= 1
            y += 1
        print(x, y)

solve()
  ","
def solve():
    n = int(input())
    
    def find_odd_layer(val):
        layer = int((val ** 0.5 - 1) / 2) + 1
        start = (2 * layer - 1) ** 2 + 1
        side_length = 2 * layer
        offset = val - start
        side_position = offset % (side_length * 6) // side_length
        
        if side_position == 0:
            return -layer + offset % side_length, -layer
        elif side_position == 1:
            return layer, -layer + offset % side_length
        elif side_position == 2:
            return layer - offset % side_length, offset % side_length
        elif side_position == 3:
            return -layer, layer - offset % side_length
        elif side_position == 4:
            return -layer + offset % side_length, layer
        else:
            return -layer, -layer + offset % side_length
    
    x, y = find_odd_layer(n)
    print(x, y)

solve()
","
def solve():
    n = int(input())
    if n == 0:
        print(""0 0"")
    else:
        k = int((n * 2) ** 0.5)
        x, y = 0, 0
        if k * (k + 1) < n * 2:
            x, y = k, 1
            n -= k * (k + 1) // 2
        else:
            x, y = 1 - k, 0
            n -= (k - 1) * k // 2
        x += n if k % 2 == 0 else -n
        y += k - n if k % 2 == 0 else n
        print(f""{x} {y}"")

solve()
","
# Function to determine Ayrat's location after n moves
def solve():
    n = int(input())
    x, y = 0, 0
    k = 1
    while n >= k * 6:
        n -= k * 6
        k += 1
    for i in range(n):
        if i < k:
            x += 1
        elif i < 2 * k:
            y += 1
        elif i < 3 * k:
            x -= 1
        elif i < 4 * k:
            x -= 1
            y -= 1
        elif i < 5 * k:
            y -= 1
        else:
            x += 1
    print(x, y)

# Call the function to solve the problem
solve()
  ","
def solve():
    import math

    def get_hexagon_coordinates(n):
        k = math.ceil((math.sqrt(12*n + 9) - 3) / 6)
        current_layer = 3*k*(k - 1) + 1
        if current_layer == n:
            return (k-1, 0)
        
        diff = n - current_layer
        x, y = -k, k-1
        for i in range(6):
            if diff <= 0:
                break
            steps = min(k if i < 3 else k-1, diff)
            if i == 0:
                x -= steps
            elif i == 1:
                y += steps
            elif i == 2:
                x += steps
            elif i == 3:
                x += steps
                y -= steps
            elif i == 4:
                y -= steps
            elif i == 5:
                x -= steps
            diff -= steps

        return (x, y)

    n = int(input())
    result = get_hexagon_coordinates(n)
    print(result[0], result[1])

solve()
","
from math import sqrt, ceil

def solve():
    def get_ring(n):
        ring = ceil((sqrt(12 * n + 9) - 3) / 6)
        return ring, 3 * ring * (ring - 1)

    def find_coordinates(n):
        if n == 0:
            return 0, 0
        ring, prev_ring_max = get_ring(n)
        n -= prev_ring_max
        dx, dy = ring, 0
        for _ in range(0, ring):
            if n == 0:
                break
            dx -= 1
            dy += 1
            n -= 1
        for _ in range(0, ring):
            if n == 0:
                break
            dy += 1
            n -= 1
        for _ in range(0, ring):
            if n == 0:
                break
            dx -= 1
            n -= 1
        return dx, dy

    n = int(input())
    x, y = find_coordinates(n)
    return x, y
  
solve()","
def solve():
    n = int(input())
    k = n//6
    r = n%6
    
    if r == 0:
        x, y = 3*k, 2*k
    elif r == 1:
        x, y = 3*k, 2*k-r
    elif r == 2:
        x, y = 3*k-r-1, 2*k-r
    elif r == 3:
        x, y = -1-k, -k
    elif r == 4:
        x, y = -1-k, -k+r
    else:
        x, y = -1-k+r, -k+r
    
    print(x, y)

solve()","
def solve():
    n = int(input())
    x, y = 0, 0
    k, p = 0, 0

    while p <= n:
        k += 1
        p += k

    p -= k
    n -= p
    x += 2 * k

    if n <= k - 1:
        y += n
    else:
        y += k
        n -= k
        x -= n

    if k % 2 == 0:
        x, y = -x, -y

    print(x, y)

solve()
","
from math import sqrt, ceil

def solve():
    def get_hexagon_coordinates(n):
        k = ceil((-3 + sqrt(9 + 3 * n)) / 6)
        d = n - 3 * k * (k - 1)
        x = max(0, min(d, 2 * k)) - k
        y = max(0, min(d - k, 2 * k)) - k
        return (x, y)

    n = int(input())
    result = get_hexagon_coordinates(n)
    return f""{result[0]} {result[1]}""
  
solve()","
def solve():
    n = int(input())
    x = y = 0
    i = 0
    while n >= 1 + 3 * i * (i + 1):
        n -= 1 + 3 * i * (i + 1)
        i += 1

    if n <= i:
        x -= n
    elif n <= 2 * i:
        x -= i
        y += n - i
    elif n <= 3 * i:
        y += i
        x -= 2 * i - n
    elif n <= 4 * i:
        y += i - (n - 3 * i)
    else:
        x += 2 * i
        y -= n - 4 * i

    print(x, y)

solve()
  ","
def solve():
    n = int(input())
    x, y = 0, 0
    for i in range(1, n+1):
        if i % 6 == 1:
            x -= 1
        elif i % 6 == 2:
            y += 1
        elif i % 6 == 3:
            x -= 1
        elif i % 6 == 4:
            y -= 1
        elif i % 6 == 5:
            x += 1
        elif i % 6 == 0:
            y -= 1
    print(x, y)
  
solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/37","
QUESTION:
Dante is engaged in a fight with ""The Savior"". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.

For every bullet that hits the shield, Ebony deals a units of damage while Ivory deals b units of damage. In order to break the shield Dante has to deal exactly c units of damage. Find out if this is possible.


-----Input-----

The first line of the input contains three integers a, b, c (1 ≤ a, b ≤ 100, 1 ≤ c ≤ 10 000) — the number of units of damage dealt by Ebony gun and Ivory gun, and the total number of damage required to break the shield, respectively.


-----Output-----

Print ""Yes"" (without quotes) if Dante can deal exactly c damage to the shield and ""No"" (without quotes) otherwise.


-----Examples-----
Input
4 6 15

Output
No

Input
3 2 7

Output
Yes

Input
6 11 6

Output
Yes



-----Note-----

In the second sample, Dante can fire 1 bullet from Ebony and 2 from Ivory to deal exactly 1·3 + 2·2 = 7 damage. In the third sample, Dante can fire 1 bullet from ebony and no bullets from ivory to do 1·6 + 0·11 = 6 damage.
Use user-input-Based format and function signature solve()","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c // a + 1):
        if (c - i * a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c//a + 1):
        if (c - i*a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()
","
# Function signature
def solve():
    a, b, c = map(int, input().split())
    
    for i in range(c // a + 1):
        for j in range(c // b + 1):
            if a*i + b*j == c:
                print(""Yes"")
                return
    print(""No"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c//a + 1):
        if (c - i*a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c//a + 1):
        if (c - i*a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c // a + 1):
        if (c - i * a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c // a + 1):
        if (c - i * a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c//a + 1):
        if (c - i*a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c // a + 1):
        if (c - i * a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c//a+1):
        if (c - i*a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c // a + 1):
        if (c - i * a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    
    for shots_ebony in range(c // a + 1):
        if (c - shots_ebony * a) % b == 0:
            print(""Yes"")
            return
    
    print(""No"")

solve()
  ","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c // a + 1):
        if (c - i * a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    if c % a == 0 or c % b == 0 or (c - a) % b == 0 or (c - b) % a == 0 or a + b == c:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    for i in range(c // a + 1):
        if (c - i * a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    
    for i in range(c//a + 1):
        if (c - i*a) % b == 0:
            print(""Yes"")
            return
    print(""No"")

solve()","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/38","
QUESTION:
Running with barriers on the circle track is very popular in the country where Dasha lives, so no wonder that on her way to classes she saw the following situation:

The track is the circle with length L, in distinct points of which there are n barriers. Athlete always run the track in counterclockwise direction if you look on him from above. All barriers are located at integer distance from each other along the track. 

Her friends the parrot Kefa and the leopard Sasha participated in competitions and each of them ran one lap. Each of the friends started from some integral point on the track. Both friends wrote the distance from their start along the track to each of the n barriers. Thus, each of them wrote n integers in the ascending order, each of them was between 0 and L - 1, inclusively. [Image] Consider an example. Let L = 8, blue points are barriers, and green points are Kefa's start (A) and Sasha's start (B). Then Kefa writes down the sequence [2, 4, 6], and Sasha writes down [1, 5, 7]. 

There are several tracks in the country, all of them have same length and same number of barriers, but the positions of the barriers can differ among different tracks. Now Dasha is interested if it is possible that Kefa and Sasha ran the same track or they participated on different tracks. 

Write the program which will check that Kefa's and Sasha's tracks coincide (it means that one can be obtained from the other by changing the start position). Note that they always run the track in one direction — counterclockwise, if you look on a track from above. 


-----Input-----

The first line contains two integers n and L (1 ≤ n ≤ 50, n ≤ L ≤ 100) — the number of barriers on a track and its length. 

The second line contains n distinct integers in the ascending order — the distance from Kefa's start to each barrier in the order of its appearance. All integers are in the range from 0 to L - 1 inclusively.

The second line contains n distinct integers in the ascending order — the distance from Sasha's start to each barrier in the order of its overcoming. All integers are in the range from 0 to L - 1 inclusively.


-----Output-----

Print ""YES"" (without quotes), if Kefa and Sasha ran the coinciding tracks (it means that the position of all barriers coincides, if they start running from the same points on the track). Otherwise print ""NO"" (without quotes).


-----Examples-----
Input
3 8
2 4 6
1 5 7

Output
YES

Input
4 9
2 3 5 8
0 1 3 6

Output
YES

Input
2 4
1 3
1 2

Output
NO



-----Note-----

The first test is analyzed in the statement.
Use user-input-Based format and function signature solve()","
def solve():
    n, L = map(int, input().split())
    kefa_distances = list(map(int, input().split()))
    sasha_distances = list(map(int, input().split()))

    for i in range(n):
        if all((kefa_distances[j] == sasha_distances[(j + i) % n]) for j in range(n)):
            print(""YES"")
            return

    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    def check_circular_distance(arr1, arr2, L):
        diff = arr1[0] - arr2[0]
        for i in range(n):
            if (arr1[i] - arr2[i]) % L != diff:
                return False
        return True

    if check_circular_distance(kefa, sasha, L):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    for i in range(L):
        if kefa == sasha:
            print(""YES"")
            return
        kefa = [(x + 1) % L for x in kefa]

    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa_distances = list(map(int, input().split()))
    sasha_distances = list(map(int, input().split()))

    for i in range(n):
        if kefa_distances == sasha_distances:
            print(""YES"")
            return
        kefa_distances = kefa_distances[1:] + [kefa_distances[0]]

    print(""NO"")

solve()","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    for i in range(n):
        if kefa == sasha:
            print(""YES"")
            return
        kefa = kefa[1:] + [kefa[0]]

    print(""NO"")

solve()
  ","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    kefa_diff = [kefa[i] - kefa[i - 1] for i in range(1, n)] + [L + kefa[0] - kefa[-1]]
    sasha_diff = [sasha[i] - sasha[i - 1] for i in range(1, n)] + [L + sasha[0] - sasha[-1]

    for _ in range(n):
        if kefa_diff == sasha_diff:
            print(""YES"")
            return
        sasha_diff = sasha_diff[1:] + [sasha_diff[0]]

    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa_distances = list(map(int, input().split()))
    sasha_distances = list(map(int, input().split()))

    for i in range(n):
        if kefa_distances == sasha_distances:
            print(""YES"")
            return

        kefa_distances = kefa_distances[1:] + [kefa_distances[0]]

    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa_distances = list(map(int, input().split()))
    sasha_distances = list(map(int, input().split()))
    
    difference_kefa = [(kefa_distances[i]-kefa_distances[i-1]) % L for i in range(n)]
    difference_sasha = [(sasha_distances[i]-sasha_distances[i-1]) % L for i in range(n)]
    
    for i in range(n):
        if difference_kefa == difference_sasha:
            print(""YES"")
            return
        difference_kefa = difference_kefa[1:] + [difference_kefa[0]]
    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    differences_kefa = [kefa[i] - kefa[i-1] if i != 0 else kefa[i] for i in range(n)]
    differences_sasha = [sasha[i] - sasha[i-1] if i != 0 else sasha[i] for i in range(n)]

    for _ in range(n):
        if differences_kefa == differences_sasha:
            print(""YES"")
            return
        kefa = [(x+1) % L for x in kefa]
        differences_kefa = [(kefa[i] - kefa[i-1]) if i != 0 else kefa[i] for i in range(n)]
    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    def check_track_match(start1, start2):
        kefa_shifted = [(barrier - start1) % L for barrier in kefa]
        sasha_shifted = [(barrier - start2) % L for barrier in sasha]
        return sorted(kefa_shifted) == sorted(sasha_shifted)

    for start1 in kefa:
        for start2 in sasha:
            if check_track_match(start1, start2):
                print(""YES"")
                return

    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa_distances = list(map(int, input().split()))
    sasha_distances = list(map(int, input().split()))

    kefa_relative_positions = [kefa_distances[i] - kefa_distances[i-1] for i in range(n)]
    kefa_relative_positions.append(L - kefa_distances[-1] + kefa_distances[0])

    for i in range(n):
        if kefa_relative_positions == sasha_distances:
            print(""YES"")
            return

        kefa_relative_positions = kefa_relative_positions[1:] + [kefa_relative_positions[0]]

    print(""NO"")

solve()
","
def solve() -> None:
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    for i in range(n):
        if kefa == [(kefa[j] - kefa[0]) % L for j in range(n)]:
            print(""YES"")
            return
        kefa = kefa[1:] + [kefa[0]]

    print(""NO"")

solve()","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    kefa_diffs = [kefa[i+1] - kefa[i] if i < n-1 else L - kefa[i] + kefa[0] for i in range(n)]
    sasha_diffs = [sasha[i+1] - sasha[i] if i < n-1 else L - sasha[i] + sasha[0] for i in range(n)]

    for i in range(n):
        if kefa_diffs == sasha_diffs:
            print(""YES"")
            return

        kefa_diffs = kefa_diffs[1:] + [kefa_diffs[0]]

    print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa = list(map(int, input().split()))
    sasha = list(map(int, input().split()))

    diff_kefa = [(kefa[i] - kefa[i-1]) % L for i in range(1, n)]
    diff_sasha = [(sasha[i] - sasha[i-1]) % L for i in range(1, n)]
    
    if sorted(diff_kefa) == sorted(diff_sasha):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, L = map(int, input().split())
    kefas_distances = list(map(int, input().split()))
    sashas_distances = list(map(int, input().split()))
    
    def shifts_match(barriers, distances):
        for i in range(n):
            if all((distances[(j+i) % n] == barriers[j]) for j in range(n)):
                return True
        return False
    
    if shifts_match(kefas_distances, sashas_distances) or shifts_match(sashas_distances, kefas_distances):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, L = map(int, input().split())
    kefa_distances = list(map(int, input().split()))
    sasha_distances = list(map(int, input().split()))

    for i in range(n):
        is_same_track = True
        for j in range(n):
            if kefa_distances[(i+j) % n] != sasha_distances[j]:
                is_same_track = False
                break
        if is_same_track:
            print(""YES"")
            return

    print(""NO"")

solve()
","40.0","53.333333333333336","73.33333333333333","40.0","40.0","0.0","40.0","100.0","53.333333333333336","100.0","20.0","60.0","100.0","86.66666666666667","40.0","40.0","","","","","","","","","","","","","","","",""
"APPS/39","
QUESTION:
A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1 \leq l \leq r \leq |s|$) of a string $s = s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l + 1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?


-----Input-----

The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.


-----Output-----

If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.


-----Examples-----
Input
mew

Output
3

Input
wuffuw

Output
5

Input
qqqqqqqq

Output
0



-----Note-----

""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    n = len(s)
    if s != s[::-1]:
        print(n)
    else:
        print(0)

solve()
","
def solve():
    s = input()
    n = len(s)
    
    def is_palindrome(sub):
        return sub == sub[::-1]

    max_len = 0
    for i in range(n):
        for j in range(i, n):
            sub = s[i:j+1]
            if not is_palindrome(sub):
                max_len = max(max_len, len(sub))
    
    return max_len

solve()","
def solve():
    s = input().strip()
    
    def is_palindrome(sub):
        return sub == sub[::-1]

    max_length_non_palindrome = 0
    
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            substr = s[i:j]
            if not is_palindrome(substr) and len(substr) > max_length_non_palindrome:
                max_length_non_palindrome = len(substr)
    
    print(max_length_non_palindrome)

solve()
","
def solve():
    s = input().strip()
    
    def is_palindrome(sub):
        return sub == sub[::-1]
    
    def longest_non_palindrome(s):
        n = len(s)
        max_len = 0
        
        for i in range(n):
            for j in range(i + max_len + 1, n + 1):
                if not is_palindrome(s[i:j]):
                    max_len = max(max_len, j - i)
        
        return max_len
    
    result = longest_non_palindrome(s)
    print(result)
    
solve()
","
def solve():
    s = input().strip()
    
    def is_palindrome(sub):
        return sub == sub[::-1]
    
    max_len_non_palindrome = 0
    
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            if not is_palindrome(s[i:j]):
                max_len_non_palindrome = max(max_len_non_palindrome, j-i)
    
    print(max_len_non_palindrome)

solve()
","
def solve():
    s = input().strip()
    max_length = 0
    
    for i in range(len(s)):
        for j in range(i, len(s)):
            substring = s[i:j+1]
            if substring != substring[::-1]:
                max_length = max(max_length, len(substring))
    
    print(max_length)

solve()
","
def solve():
    s = input().strip()
    
    def is_palindrome(sub):
        return sub == sub[::-1]

    max_length = 0
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substring = s[i:j]
            if not is_palindrome(substring) and len(substring) > max_length:
                max_length = len(substring)
    
    print(max_length)

solve()
","
def solve():
    s = input().strip()

    def is_palindrome(sub):
        return sub == sub[::-1]

    max_length = 0

    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            if not is_palindrome(s[i:j]):
                max_length = max(max_length, j - i)

    print(max_length)

solve()
","
def solve():
    s = input().strip()
    
    def is_palindrome(sub):
        return sub == sub[::-1]
    
    max_length = 0
    for i in range(len(s)):
        for j in range(i+1, len(s)+1):
            if not is_palindrome(s[i:j]):
                max_length = max(max_length, j-i)
                
    print(max_length)

solve()
","
def solve():
    s = input().strip()
    
    def is_palindrome(substring):
        return substring == substring[::-1]
    
    def find_longest_non_palindrome_substring(word):
        max_length = 0
        for i in range(len(word)):
            for j in range(i+1, len(word)+1):
                if not is_palindrome(word[i:j]):
                    max_length = max(max_length, j-i)
        return max_length
    
    result = find_longest_non_palindrome_substring(s)
    
    print(result)

solve()
","
def solve():
    s = input().strip()
    n = len(s)

    if s == s[::-1]:
        print(0)
    else:
        print(n)

solve()
","
def solve():
    s = input().strip()
    
    def is_palindrome(sub):
        return sub == sub[::-1]
    
    max_non_palindrome_length = 0
    
    for l in range(len(s)):
        for r in range(l, len(s)):
            if not is_palindrome(s[l:r+1]):
                max_non_palindrome_length = max(max_non_palindrome_length, r - l + 1)
    
    print(max_non_palindrome_length)

if __name__ == ""__main__"":
    solve()
","
def solve():
    s = input()
    
    def is_palindrome(substring):
        return substring == substring[::-1]
    
    max_length = 0
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            substring = s[i:j]
            if not is_palindrome(substring) and len(substring) > max_length:
                max_length = len(substring)
    
    print(max_length)

solve()
","
def solve():
    s = input()
    
    def is_palindrome(sub):
        return sub == sub[::-1]
    
    max_len = 0
    n = len(s)
    
    for i in range(n):
        for j in range(i+1, n+1):
            sub = s[i:j]
            if not is_palindrome(sub):
                max_len = max(max_len, len(sub))
    
    print(max_len)

solve()
","
def solve():
    s = input().strip()
    n = len(s)
    
    def is_palindrome(sub):
        return sub == sub[::-1]
    
    def longest_non_palindrome():
        max_len = 0
        for i in range(n):
            for j in range(i + 1, n + 1):
                sub = s[i: j]
                if not is_palindrome(sub) and len(sub) > max_len:
                    max_len = len(sub)
        return max_len
    
    result = longest_non_palindrome()
    print(result)

solve()
  ","
def solve():
    s = input().strip()
    
    def is_palindrome(word):
        return word == word[::-1]
    
    def get_longest_non_palindrome_substring(word):
        n = len(word)
        for i in range(n, 0, -1):
            for j in range(n - i + 1):
                substring = word[j:j+i]
                if not is_palindrome(substring):
                    return i
        return 0
    
    print(get_longest_non_palindrome_substring(s))

solve()
","66.66666666666666","0.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","66.66666666666666","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/40","
QUESTION:
Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.


-----Input-----

The first line contains a single integer n (2 ≤ n ≤ 1000) — the number of round participants.

Each of the next n lines contains two integers a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ 4126) — the rating of the i-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.


-----Output-----

If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".


-----Examples-----
Input
6
3060 3060
2194 2194
2876 2903
2624 2624
3007 2991
2884 2884

Output
rated

Input
4
1500 1500
1300 1300
1200 1200
1400 1400

Output
unrated

Input
5
3123 3123
2777 2777
2246 2246
2246 2246
1699 1699

Output
maybe



-----Note-----

In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    ratings = []
    for _ in range(n):
        a, b = map(int, input().split())
        ratings.append((a, b))

    rated = False
    for i in range(n):
        if ratings[i][0] != ratings[i][1]:
            rated = True
            break

    if rated:
        for i in range(1, n):
            if ratings[i][0] > ratings[i-1][0]:
                print(""rated"")
                return

        print(""unrated"")
    else:
        print(""maybe"")

solve()
","
def solve():
    n = int(input())
    participants = [list(map(int, input().split())) for _ in range(n)]

    rated = False
    for i in range(n):
        if participants[i][0] != participants[i][1]:
            rated = True
            break

    if rated:
        for i in range(1, n):
            if participants[i][0] > participants[i-1][0]:
                print(""rated"")
                return

        print(""maybe"")
    else:
        print(""unrated"")

solve()
","
def solve():
    n = int(input())
    ratings = []
    
    for _ in range(n):
        a, b = map(int, input().split())
        ratings.append((a, b))
    
    rated = unrated = maybe = False
    for i in range(n):
        if ratings[i][0] != ratings[i][1]:
            rated = True
            break
    
    if not rated:
        for i in range(1, n):
            if ratings[i][0] > ratings[i-1][0]:
                maybe = True
                break
        if not maybe:
            unrated = True
    
    if rated:
        print(""rated"")
    elif unrated:
        print(""unrated"")
    else:
        print(""maybe"")

solve()
","
def solve():
    n = int(input())
    ratings = [tuple(map(int, input().split())) for _ in range(n)]
    
    rated = False
    changed = False
    for i in range(n):
        if ratings[i][0] != ratings[i][1]:
            rated = True
        for j in range(i+1, n):
            if ratings[i][0] < ratings[j][0] and ratings[i][1] > ratings[j][1]:
                changed = True
                
    if rated:
        return ""rated""
    elif changed:
        return ""maybe""
    else:
        return ""unrated""

solve()","
def solve():
    n = int(input())
    participants = []
    
    for _ in range(n):
        a, b = map(int, input().split())
        participants.append((a, b))
    
    rated = False
    for i in range(n):
        if participants[i][0] != participants[i][1]:
            rated = True
            break
    
    if rated:
        for j in range(1, n):
            if participants[j][0] > participants[j-1][0]:
                print(""rated"")
                return
    
        print(""maybe"")
    else:
        print(""unrated"")
  
solve()","
def solve():
    n = int(input())
    ratings = []
    for _ in range(n):
        a, b = map(int, input().split())
        ratings.append((a, b))
    
    rated_count = 0
    for i in range(1, n):
        if ratings[i][0] != ratings[i][1]:
            rated_count += 1

    if rated_count > 0:
        print(""rated"")
    else:
        better_place = False
        for i in range(1, n):
            if ratings[i][0] < ratings[i-1][0]:
                better_place = True
                break
        
        if better_place:
            print(""rated"")
        else:
            print(""maybe"")

# Call the function to run
solve()
","
def solve():
    n = int(input())
    ratings = []
    for _ in range(n):
        a, b = map(int, input().split())
        ratings.append((a, b))

    rated = False
    for i in range(1, n):
        if ratings[i][0] != ratings[i][1]:
            rated = True
            break

    if rated:
        for i in range(1, n):
            if ratings[i][0] > ratings[i-1][0]:
                print(""rated"")
                return

        print(""unrated"")
    else:
        print(""maybe"")

solve()
","
def solve():
    n = int(input())
    ratings = [tuple(map(int, input().split())) for _ in range(n)]
    
    rating_changed = False
    rating_unchanged_but_order_changed = False
    
    for i in range(n):
        if ratings[i][0] != ratings[i][1]:
            rating_changed = True
        if i > 0 and ratings[i][0] < ratings[i-1][0]:
            rating_unchanged_but_order_changed = True
        
    if rating_changed:
        print(""rated"")
    elif rating_unchanged_but_order_changed:
        print(""maybe"")
    else:
        print(""unrated"")

solve()","
def solve():
    n = int(input())
    
    ratings = []
    unchanged = True
    change_detected = False
    
    for _ in range(n):
        a, b = map(int, input().split())
        ratings.append((a, b))
        
        if a != b:
            unchanged = False
        if len(ratings) > 1 and ratings[-1][0] < ratings[-2][0]:
            change_detected = True
        
    if unchanged:
        print(""unrated"")
    elif change_detected:
        print(""rated"")
    else:
        print(""maybe"")
  
solve()","
def solve():
    n = int(input())
    ratings_before = []
    ratings_after = []
    for _ in range(n):
        a, b = map(int, input().split())
        ratings_before.append(a)
        ratings_after.append(b)
    
    round_rated = False
    for i in range(n):
        if ratings_before[i] != ratings_after[i]:
            round_rated = True
            break
    
    if round_rated:
        for i in range(1, n):
            if ratings_before[i] > ratings_before[i-1]:
                print(""rated"")
                return
        print(""unrated"")
    else:
        print(""maybe"")

solve()
  ","
def solve():
    n = int(input())
    participants = []
    for _ in range(n):
        a, b = map(int, input().split())
        participants.append((a, b))

    rated = False
    for i in range(n):
        if participants[i][0] != participants[i][1]:
            rated = True
            break

    if rated:
        for j in range(n-1):
            if participants[j][0] < participants[j+1][0]:
                print(""rated"")
                return

    print(""unrated"" if rated else ""maybe"")

solve()","
def solve():
    n = int(input())
    participants = []
    order_changed = False
    rating_changed = False

    for _ in range(n):
        a, b = map(int, input().split())
        participants.append((a, b))

        if a != b:
            rating_changed = True

    for i in range(1, n):
        if participants[i][0] > participants[i - 1][0]:
            order_changed = True
            break

    if rating_changed:
        print(""rated"")
    elif order_changed:
        print(""unrated"")
    else:
        print(""maybe"")

# Uncomment the below lines for testing the function
# solve()
","
def solve():
    n = int(input())
    ratings = []
    
    rated = False
    for _ in range(n):
        a, b = map(int, input().split())
        ratings.append((a, b))
        if a != b:
            rated = True
    
    if not rated:
        for i in range(1, n):
            if ratings[i][0] > ratings[i-1][0]:
                print(""unrated"")
                return
    
    print(""rated"" if rated else ""maybe"")

solve()","
def solve():
    n = int(input())
    ratings = []
    changed = False
    better_place = False
    
    for _ in range(n):
        a, b = map(int, input().split())
        if a != b:
            changed = True
        ratings.append(a)
        
    if not changed:
        for i in range(1, n):
            if ratings[i] > ratings[i-1]:
                better_place = True
                break
        
    if changed:
        print(""rated"")
    elif better_place:
        print(""unrated"")
    else:
        print(""maybe"")


solve()","
def solve():
    n = int(input())
    participants = []
    for _ in range(n):
        a, b = map(int, input().split())
        participants.append((a, b))

    rated = False
    unrated = False
    changing_ratings = False

    for i in range(n):
        if participants[i][0] != participants[i][1]:
            rated = True
            changing_ratings = True
            break

    if not changing_ratings:
        for i in range(1, n):
            if participants[i][0] > participants[i-1][0]:
                unrated = True
                break

    if rated:
        print(""rated"")
    elif unrated:
        print(""unrated"")
    else:
        print(""maybe"")

solve()
","
def solve():
    n = int(input())
    participants = []
    for _ in range(n):
        a, b = map(int, input().split())
        participants.append((a, b))

    rated = False
    for i in range(n):
        if participants[i][0] != participants[i][1]:
            rated = True
            break

    if rated:
        for i in range(1, n):
            if participants[i][0] > participants[i-1][0]:
                print(""rated"")
                return

    print(""unrated"" if rated else ""maybe"")

solve()","60.0","46.666666666666664","20.0","0.0","46.666666666666664","33.33333333333333","60.0","73.33333333333333","53.333333333333336","60.0","60.0","0.0","100.0","100.0","100.0","60.0","","","","","","","","","","","","","","","",""
"APPS/41","
QUESTION:
You are given the array of integer numbers a_0, a_1, ..., a_{n} - 1. For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 2·10^5) — length of the array a. The second line contains integer elements of the array separated by single spaces ( - 10^9 ≤ a_{i} ≤ 10^9).


-----Output-----

Print the sequence d_0, d_1, ..., d_{n} - 1, where d_{i} is the difference of indices between i and nearest j such that a_{j} = 0. It is possible that i = j.


-----Examples-----
Input
9
2 1 0 3 0 0 3 2 4

Output
2 1 0 1 0 0 1 2 3 
Input
5
0 1 2 3 4

Output
0 1 2 3 4 
Input
7
5 6 0 1 -2 3 4

Output
2 1 0 1 2 3 4
Use user-input-Based format and function signature solve()","
from typing import List

def solve() -> None:
    n = int(input())
    a = list(map(int, input().split()))
    
    left_zero = [float('inf')] * n
    right_zero = [float('inf')] * n
    
    zero_index = -1
    for i in range(n):
        if a[i] == 0:
            zero_index = i
        if zero_index != -1:
            left_zero[i] = i - zero_index
    
    zero_index = -1
    for i in range(n-1, -1, -1):
        if a[i] == 0:
            zero_index = i
        if zero_index != -1:
            right_zero[i] = zero_index - i
    
    result = [min(left_zero[i], right_zero[i]) for i in range(n)]
    print(' '.join(map(str, result)))

solve()
","
def solve():
    import sys
  
    n = int(sys.stdin.readline())
    a = list(map(int, sys.stdin.readline().split()))
  
    left_zero = [float('-inf')] * n
    right_zero = [float('inf')] * n
  
    for i in range(n):
        if a[i] == 0:
            left_zero[i] = i
        elif i > 0:
            left_zero[i] = left_zero[i - 1]
  
    for i in range(n - 1, -1, -1):
        if a[i] == 0:
            right_zero[i] = i
        elif i < n - 1:
            right_zero[i] = right_zero[i + 1]
  
    res = [min(i - left_zero[i], right_zero[i] - i) for i in range(n)]
    print(*res)



solve()","
def solve():
    import sys
    
    n = int(sys.stdin.readline().strip())
    a = list(map(int, sys.stdin.readline().strip().split()))
    
    ans = [0] * n
    last_zero = -n
    
    for i in range(n):
        if a[i] == 0:
            last_zero = i
        ans[i] = abs(i - last_zero)
    
    print(*ans)

solve()
","
from typing import List

def solve() -> None:
    n = int(input())
    a = list(map(int, input().split()))
    
    zero_indices = [i for i in range(n) if a[i] == 0]
    result = []
    
    for i in range(n):
        min_distance = min([abs(i - j) for j in zero_indices])
        result.append(min_distance)
    
    print(' '.join(map(str, result)))

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    zeros = [i for i in range(n) if a[i] == 0]
    
    res = []
    for i in range(n):
        if a[i] == 0:
            res.append(0)
        else:
            res.append(min([abs(i - z) for z in zeros]))
    
    print(*res)

solve()","
def solve():
    import sys
    n = int(sys.stdin.readline().strip())
    a = list(map(int, sys.stdin.readline().strip().split()))

    zeros = [i for i in range(n) if a[i] == 0]
    result = []
    for i in range(n):
        if a[i] == 0:
            result.append(0)
        else:
            result.append(min(abs(i - z) for z in zeros))
    
    print("" "".join(map(str, result)))

solve()
","
from typing import List

def solve():
    n = int(input())
    a = list(map(int, input().split()))

    zeroes = [i for i in range(n) if a[i] == 0]
    distances = []

    for i in range(n):
        if a[i] == 0:
            distances.append(0)
        else:
            min_dist = min([abs(i - z) for z in zeroes])
            distances.append(min_dist)

    print(*distances)

solve()","
def solve():
    import sys
    n = int(input())
    a = list(map(int, input().split()))

    prev_zero = -1
    for i in range(n):
        if a[i] == 0:
            prev_zero = i
        print(i - prev_zero, end="" "")

solve()
","
from typing import List

def solve() -> None:
    n = int(input())
    a = list(map(int, input().split()))
    zeros = [i for i in range(n) if a[i] == 0]
    distances = []
    
    for i in range(n):
        if a[i] == 0:
            distances.append(0)
        else:
            distances.append(min(abs(z - i) for z in zeros))
    
    print(*distances)

solve()","
from typing import List

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    zeros = [i for i in range(n) if a[i] == 0]

    distances = []
    for i in range(n):
        if a[i] == 0:
            distances.append(0)
        else:
            distances.append(min(abs(i - z) for z in zeros))

    print(*distances)

solve()
","
from typing import List

def solve() -> None:
    n = int(input())
    a = list(map(int, input().split()))
    
    nearest_zeros = [-1] * n
    nearest_zero_idx = -1
    
    for i in range(n):
        if a[i] == 0:
            nearest_zero_idx = i
        nearest_zeros[i] = abs(i - nearest_zero_idx)
    
    print(*nearest_zeros)

solve()
","
from typing import List

def solve() -> None:
    n = int(input())
    a = list(map(int, input().split()))

    distances = [0] * n
    last_zero_idx = float('-inf')

    for i in range(n):
        if a[i] == 0:
            last_zero_idx = i
        distances[i] = i - last_zero_idx

    last_zero_idx = float('inf')

    for i in range(n-1, -1, -1):
        if a[i] == 0:
            last_zero_idx = i
        distances[i] = min(distances[i], last_zero_idx - i)

    print("" "".join(map(str, distances)))

solve()
","
from typing import List

def solve() -> None:
    n = int(input())
    a = list(map(int, input().split()))
    
    zeros = [i for i in range(n) if a[i] == 0]
    
    distances = []
    for i in range(n):
        if a[i] == 0:
            distances.append(0)
        else:
            nearest_zero_idx = min(zeros, key=lambda x: abs(x - i))
            distances.append(abs(i - nearest_zero_idx))
    
    print(*distances)


solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    indices_zeros = [i for i in range(n) if arr[i] == 0]
    result = []
    
    for i in range(n):
        min_dist = n
        for index in indices_zeros:
            dist = abs(index - i)
            if dist < min_dist:
                min_dist = dist
        result.append(min_dist)
    
    print(*result)

solve()
","
from typing import List

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    left_zeros = [float('-inf')] * n
    right_zeros = [float('inf')] * n
    
    last_zero_index = float('-inf')
    for i in range(n):
        if a[i] == 0:
            last_zero_index = i
        left_zeros[i] = i - last_zero_index
    
    last_zero_index = float('inf')
    for i in range(n-1, -1, -1):
        if a[i] == 0:
            last_zero_index = i
        right_zeros[i] = last_zero_index - i
    
    print(*[min(left, right) for left, right in zip(left_zeros, right_zeros)])

solve()
","
from typing import List

def solve() -> None:
    n = int(input())
    arr = list(map(int, input().split()))

    zeros_indices = [i for i, num in enumerate(arr) if num == 0]
    
    output = []
    for i in range(n):
        if arr[i] == 0:
            output.append(0)
        else:
            output.append(min([abs(i - z) for z in zeros_indices]))

    print("" "".join(map(str, output)))

solve()","100.0","100.0","46.666666666666664","100.0","100.0","100.0","100.0","53.333333333333336","100.0","100.0","53.333333333333336","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/42","
QUESTION:
You are given a binary string $s$.

Find the number of distinct cyclical binary strings of length $n$ which contain $s$ as a substring.

The cyclical string $t$ contains $s$ as a substring if there is some cyclical shift of string $t$, such that $s$ is a substring of this cyclical shift of $t$.

For example, the cyclical string ""000111"" contains substrings ""001"", ""01110"" and ""10"", but doesn't contain ""0110"" and ""10110"".

Two cyclical strings are called different if they differ from each other as strings. For example, two different strings, which differ from each other by a cyclical shift, are still considered different cyclical strings.


-----Input-----

The first line contains a single integer $n$ ($1 \le n \le 40$) — the length of the target string $t$.

The next line contains the string $s$ ($1 \le |s| \le n$) — the string which must be a substring of cyclical string $t$. String $s$ contains only characters '0' and '1'.


-----Output-----

Print the only integer — the number of distinct cyclical binary strings $t$, which contain $s$ as a substring.


-----Examples-----
Input
2
0

Output
3
Input
4
1010

Output
2
Input
20
10101010101010

Output
962


-----Note-----

In the first example, there are three cyclical strings, which contain ""0"" — ""00"", ""01"" and ""10"".

In the second example, there are only two such strings — ""1010"", ""0101"".
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input().strip()
    
    m = len(s)
    s += s
    z = [0] * (2 * m)
    l, r = 0, 0
    for i in range(1, 2 * m):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < 2 * m and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    
    ans = 0
    for i in range(m, 2 * m):
        if z[i] >= m:
            ans += 1
    
    print(ans)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    m = len(s)
    s += s
    
    z = [0] * (2 * m)
    l = r = 0
    for i in range(1, 2 * m):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < 2 * m and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    
    ans = 0
    for i in range(m):
        if z[i] >= m:
            ans += 1

    for i in range(m):
        if z[i] >= m:
            if z[2 * m - i] < m:
                ans += 1

    print(ans)

import sys

if __name__ == ""__main__"":
    sys.setrecursionlimit(10**6)
    solve()
","
def solve():
    import math
    
    n = int(input())
    s = input().strip()
    m = len(s)
    
    if s.count('0') == m or s.count('1') == m:
        print(1)
    else:
        kmp = [0] * m
        j = 0
        for i in range(1, m):
            while j > 0 and s[j] != s[i]:
                j = kmp[j - 1]
            if s[j] == s[i]:
                j += 1
            kmp[i] = j
        
        res = n - m + 1
        cycle = m - kmp[-1]
        if m % cycle == 0:
            res //= (m // cycle)
        print(math.gcd(res, m))

solve()
  ","
def solve():
    n = int(input())
    s = input().strip()
    
    m = len(s)
    cnt = 0
    for i in range(n):
        fail = [0] * m
        j = 0
        for k in range(1, m):
            while j > 0 and s[j] != s[k]:
                j = fail[j - 1]
            if s[j] == s[k]:
                j += 1
            fail[k] = j
        cnt += m - fail[-1]
    
    print(cnt)

if __name__ == ""__main__"":
    solve()
  ","
def solve():
    n = int(input())
    s = input()

    m = len(s)
    kmp = [0] * m
    k = 0
    for q in range(1, m):
        while k > 0 and s[k] != s[q]:
            k = kmp[k - 1]
        if s[k] == s[q]:
            k = k + 1
        kmp[q] = k

    dp = [[0] * m for _ in range(n)]
    for q in range(m):
        dp[0][kmp[q]] += 1

    for i in range(1, n):
        for j in range(m):
            dp[i][j] += dp[i-1][j]

        for q in range(m):
            dp[i][kmp[q]] += dp[i - 1][q]

    ans = sum(dp[n-1])
    print(ans)

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    m = len(s)
    s += s
    
    kmp = [-1] * (2*m + 1)
    j = -1
    for i in range(1, 2*m+1):
        while j >= 0 and s[j] != s[i-1]:
            j = kmp[j]
        j += 1
        kmp[i] = j
    
    dp = [0] * (2*m + 1)
    dp[0] = 1
    for i in range(1, n+1):
        new_dp = [0] * (2*m + 1)
        for j in range(2*m + 1):
            if dp[j] == 0:
                continue
            for c in ['0', '1']:
                nxt = j
                while nxt >= 0 and s[nxt] != c:
                    nxt = kmp[nxt]
                nxt += 1
                if nxt == 2*m:
                    new_dp[2*m] += dp[j]
                else:
                    new_dp[nxt] += dp[j]
        dp = new_dp
    
    return sum(dp[m:n+1])

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    def count_distinct_cyclical_strings(n, s):
        m = len(s)
        count = 1 << n
        for i in range(1, m):
            prefix = s[:i]
            suffix = s[-(m - i):]
            count -= (1 << (n - len(prefix))) - (prefix == suffix)        
        return count
    
    result = count_distinct_cyclical_strings(n, s)
    print(result)

solve()
","
def solve():
    import itertools
    
    n = int(input())
    s = input()
    m = len(s)
    s += s
    z = [0]*(2*m)
    L = 0
    R = 0
    for i in range(1, 2*m):
        if i <= R:
            z[i] = min(R-i+1, z[i-L])
        while i+z[i] < 2*m and s[z[i]] == s[i+z[i]]:
            z[i] += 1
        if i+z[i]-1 > R:
            L = i
            R = i+z[i]-1
    ans = 0
    for i in range(2*m):
        if z[i] >= m:
            ans += 1
    cyclic_strings = ['0', '1']
    for i in range(2, n+1):
        cyclic_strings = [x + y for x in cyclic_strings for y in ['0', '1']]
    ans = 0
    for t in cyclic_strings:
        for i in range(len(t)-m+1):
            if t[i:i+m] == s:
                ans += 1
                break
    print(ans)

solve()
  ","
def solve():
    n = int(input())
    s = input().strip()
    
    m = len(s)
    
    if m == 1:
        print(2 ** n)
    else:
        ans = 1
        for i in range(1, m):
            prefix = s[:i]
            suffix = s[i:]
            if prefix == suffix:
                ans = max(ans, m - i + 1)
        print(ans)

solve()
","
def solve():
    n = int(input())
    s = input()

    m = len(s)
    kmp = [0] * m
    j = 0

    for i in range(1, m):
        while j and s[i] != s[j]:
            j = kmp[j - 1]
        if s[i] == s[j]:
            j += 1
        kmp[i] = j

    ans = 1
    j = 0

    for i in range(1, n):
        while j and s[j] != '0':
            j = kmp[j - 1]
        if s[j] == '0':
            j += 1
        ans += 2 if j == m else 1

    print(ans)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    m = len(s)
    kmp = [0] * m
    j = 0
    for i in range(1, m):
        while j > 0 and s[j] != s[i]:
            j = kmp[j - 1]
        if s[j] == s[i]:
            j += 1
        kmp[i] = j
    
    dp = [0] * (m + 1)
    dp[0] = 1
    for i in range(n):
        new_dp = [0] * (m + 1)
        for j in range(m + 1):
            for ch in ""01"":
                k = j
                while k > 0 and s[k] != ch:
                    k = kmp[k - 1]
                if s[k] == ch:
                    k += 1
                new_dp[k] += dp[j]
        dp = new_dp
    
    total = sum(dp)
    for i in range(1, m):
        j = m - kmp[m - 1]
        if i % j == 0:
            total -= dp[m - 1]
    
    print(total)

solve()
","
def solve():
    n = int(input())
    s = input()

    m = len(s)
    dp = [0]*(m+1)
    dp[0] = -1
    j = -1

    for i in range(1, m):
        while j >= 0 and s[j] != s[i-1]:
            j = dp[j]

        j += 1
        dp[i+1] = j

    ans = n
    for i in range(1, m):
        k = n - i
        while k > 0:
            k = dp[k]
            if k >= m - i:
                ans += 1

    print(ans)

solve()

","
def solve():
    n = int(input())
    s = input().strip()
    
    m = len(s)
    s += s
    
    z = [0]*m
    l, r = 0, 0
    
    for i in range(1, m):
        if i <= r:
            z[i] = min(r-i+1, z[i-l])
        while i + z[i] < m and s[z[i]] == s[i+z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i+z[i]-1
    
    ans = 0
    for i in range(m):
        if z[i] == m:
            ans += 1
    
    result = (n//m) - ans
    print(result)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    m = len(s)
    s += '#' + s
    kmp = [-1] * (2 * m + 1)
    j = -1
    for i in range(1, 2 * m + 1):
        while j != -1 and s[j + 1] != s[i]:
            j = kmp[j]
        if i < m:
            kmp[i] = j
        if s[j + 1] == s[i]:
            j += 1
    
    ans = 0
    for i in range(1, n + 1):
        x = i
        while x != -1:
            ans += 1
            x = kmp[x % m + 1]
    
    print(ans)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    m = len(s)
    
    cnt = [0] * m
    j = 0
    for i in range(1, m):
        while j > 0 and s[i] != s[j]:
            j = cnt[j - 1]
        if s[i] == s[j]:
            j += 1
        cnt[i] = j
    
    if m % (m - cnt[m - 1]) == 0:
        k = m - cnt[m - 1]
    else:
        k = m
        
    ans = 0
    for i in range(k):
        if k % (k - cnt[k - 1]) == 0:
            ans += 1
        k -= cnt[k - 1]
    
    total = pow(2, n) - 1
    result = total // ans
    
    print(result)

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    m = len(s)
    s += s
    
    dp = [0] * m
    
    for i in range(1, m):
        k = dp[i - 1]
        while k > 0 and s[k] != s[i]:
            k = dp[k - 1]
        dp[i] = k + (s[k] == s[i])
    
    answer = 0
    for i in range(1, n - m + 1):
        k = 0
        for j in range(m):
            while k > 0 and s[k] != s[j]:
                k = dp[k - 1]
            k += (s[k] == s[j])
        if k == m:
            answer += 1
    
    print(answer)
  
solve()","6.666666666666667","6.666666666666667","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","33.33333333333333","0.0","26.666666666666668","6.666666666666667","13.333333333333334","6.666666666666667","0.0","","","","","","","","","","","","","","","",""
"APPS/43","
QUESTION:
You are given the set of vectors on the plane, each of them starting at the origin. Your task is to find a pair of vectors with the minimal non-oriented angle between them.

Non-oriented angle is non-negative value, minimal between clockwise and counterclockwise direction angles. Non-oriented angle is always between 0 and π. For example, opposite directions vectors have angle equals to π.


-----Input-----

First line of the input contains a single integer n (2 ≤ n ≤ 100 000) — the number of vectors.

The i-th of the following n lines contains two integers x_{i} and y_{i} (|x|, |y| ≤ 10 000, x^2 + y^2 > 0) — the coordinates of the i-th vector. Vectors are numbered from 1 to n in order of appearing in the input. It is guaranteed that no two vectors in the input share the same direction (but they still can have opposite directions).


-----Output-----

Print two integer numbers a and b (a ≠ b) — a pair of indices of vectors with the minimal non-oriented angle. You can print the numbers in any order. If there are many possible answers, print any.


-----Examples-----
Input
4
-1 0
0 -1
1 0
1 1

Output
3 4

Input
6
-1 0
0 -1
1 0
1 1
-4 -5
-4 -6

Output
6 5
Use user-input-Based format and function signature solve()","
from math import atan2, pi

def solve():
    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = pi
    min_indices = (0, 1)

    for i in range(n):
        for j in range(i+1, n):
            angle = abs(atan2(vectors[i][1], vectors[i][0]) - atan2(vectors[j][1], vectors[j][0]))
            angle = min(angle, 2*pi - angle)
            if angle < min_angle:
                min_angle = angle
                min_indices = (i+1, j+1)

    print(min_indices[0], min_indices[1])

solve()
","
def solve():
    import math

    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = math.pi
    min_indices = None
    
    for i in range(n):
        for j in range(i+1, n):
            angle = abs(math.atan2(vectors[i][1], vectors[i][0]) - math.atan2(vectors[j][1], vectors[j][0]))
            if min_angle > min(angle, 2*math.pi - angle):
                min_angle = min(angle, 2*math.pi - angle)
                min_indices = (i+1, j+1)
                
    print(min_indices[0], min_indices[1])

solve()","
def solve():
    import math

    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = float('inf')
    indices = (0, 1)
    
    for i in range(n):
        for j in range(i + 1, n):
            angle = math.acos((vectors[i][0]*vectors[j][0] + vectors[i][1]*vectors[j][1]) / 
                                (math.sqrt(vectors[i][0]**2 + vectors[i][1]**2) * 
                                 math.sqrt(vectors[j][0]**2 + vectors[j][1]**2)))
            if angle < min_angle:
                min_angle = angle
                indices = (i+1, j+1)

    print(indices[0], indices[1])

solve()
","
def solve():
    import math

    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = math.pi
    min_indices = None

    for i in range(n):
        for j in range(i + 1, n):
            angle = math.acos((vectors[i][0] * vectors[j][0] + vectors[i][1] * vectors[j][1]) / (math.sqrt(vectors[i][0] ** 2 + vectors[i][1] ** 2) * math.sqrt(vectors[j][0] ** 2 + vectors[j][1] ** 2)))
            if angle < min_angle:
                min_angle = angle
                min_indices = (i + 1, j + 1)

    print(min_indices[0], min_indices[1])


solve()
","
from math import atan2

def solve():
    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = float('inf')
    pair = None
    for i in range(n):
        angle_i = atan2(vectors[i][1], vectors[i][0])
        prev_i = n - 1 if i == 0 else i - 1
        next_i = 0 if i == n - 1 else i + 1

        angle_prev = atan2(vectors[prev_i][1], vectors[prev_i][0])
        angle_next = atan2(vectors[next_i][1], vectors[next_i][0])

        diff_i = abs(angle_next - angle_i)
        diff_prev = abs(angle_prev - angle_i)

        if diff_i < min_angle:
            min_angle = diff_i
            pair = (i, next_i)
        if diff_prev < min_angle:
            min_angle = diff_prev
            pair = (prev_i, i)

    print(pair[0] + 1, pair[1] + 1)

solve()
  ","
from math import atan2, sqrt

def solve():
    n = int(input())
    vectors = [tuple(map(int, input().split())) for _ in range(n)]
    
    min_angle = float('inf')
    result = ()
    
    for i in range(n):
        for j in range(i+1, n):
            angle = atan2(vectors[j][1], vectors[j][0]) - atan2(vectors[i][1], vectors[i][0])
            if angle < 0:
                angle += 2*3.141592653589793
            if angle < min_angle:
                min_angle = angle
                result = (i+1, j+1)
    
    return result
  
solve()","
from math import atan2, pi

def solve():
    n = int(input())
    vectors = [tuple(map(int, input().split())) for _ in range(n)]
    
    min_angle = float('inf')
    min_indices = None
    
    for i in range(n):
        for j in range(i + 1, n):
            angle = abs(atan2(vectors[i][1], vectors[i][0]) - atan2(vectors[j][1], vectors[j][0]))
            angle = min(angle, 2 * pi - angle)
            if angle < min_angle:
                min_angle = angle
                min_indices = (i+1, j+1)
    
    print(min_indices[0], min_indices[1])

solve()","
from math import atan2, pi

def solve():
    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = pi
    pair_indices = (0, 1)

    for i in range(n):
        x1, y1 = vectors[i]
        for j in range(i+1, n):
            x2, y2 = vectors[j]
            angle = abs(atan2(y2, x2) - atan2(y1, x1))
            if angle > pi:
                angle = 2*pi - angle
            if angle < min_angle:
                min_angle = angle
                pair_indices = (i+1, j+1)

    print(pair_indices[0], pair_indices[1])

solve()
","
from math import acos, sqrt, degrees

def solve():
    n = int(input())
    vectors = []
    
    for _ in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))
    
    min_angle = float('inf')
    pair_indices = None
    
    for i in range(n):
        for j in range(i+1, n):
            dot_product = vectors[i][0] * vectors[j][0] + vectors[i][1] * vectors[j][1]
            norm_i = sqrt(vectors[i][0] ** 2 + vectors[i][1] ** 2)
            norm_j = sqrt(vectors[j][0] ** 2 + vectors[j][1] ** 2)
            
            angle = acos(dot_product / (norm_i * norm_j))
            angle_degrees = degrees(angle)
            non_oriented_angle = min(angle_degrees, 360 - angle_degrees)
            
            if non_oriented_angle < min_angle:
                min_angle = non_oriented_angle
                pair_indices = (i+1, j+1)
    
    return pair_indices

solve()","
from math import atan2, pi

def solve():
    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))
    
    min_angle = pi
    min_indices = ()
    
    for i in range(n):
        for j in range(i+1, n):
            angle = abs(atan2(vectors[i][1], vectors[i][0]) - atan2(vectors[j][1], vectors[j][0]))
            angle = min(angle, 2*pi - angle)
            if angle < min_angle:
                min_angle = angle
                min_indices = (i+1, j+1)
    
    print(min_indices[0], min_indices[1])


solve()","
def solve():
    import math

    n = int(input())
    vectors = []
    min_angle = math.pi

    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_idx1 = 0
    min_idx2 = 1

    for i in range(n):
        j = (i + 1) % n
        angle = math.acos((vectors[i][0]*vectors[j][0] + vectors[i][1]*vectors[j][1]) / 
                          (math.sqrt(vectors[i][0]**2 + vectors[i][1]**2) * math.sqrt(vectors[j][0]**2 + vectors[j][1]**2)))
        if angle < min_angle:
            min_angle = angle
            min_idx1 = i
            min_idx2 = j

    print(min_idx1 + 1, min_idx2 + 1)

solve()
","
from math import atan2

def solve():
    n = int(input())
    vectors = [tuple(map(int, input().split())) for _ in range(n)]
    
    min_angle = float('inf')
    min_pair = None
    
    for i in range(n):
        for j in range(i+1, n):
            angle = abs(atan2(vectors[j][1], vectors[j][0]) - atan2(vectors[i][1], vectors[i][0]))
            angle = min(angle, 2 * 3.14159265359 - angle)
            if angle < min_angle:
                min_angle = angle
                min_pair = (i+1, j+1)
    
    print(min_pair[0], min_pair[1])

solve()
","
from math import atan2

def solve():
    n = int(input())
    vectors = [list(map(int, input().split())) for _ in range(n)]
    min_angle = float('inf')
    indices = None
    
    for i in range(n):
        for j in range(i+1, n):
            angle = abs(atan2(vectors[j][1], vectors[j][0]) - atan2(vectors[i][1], vectors[i][0]))
            if angle > 3.14159:  # Pi
                angle = 2*3.14159 - angle
            if angle < min_angle:
                min_angle = angle
                indices = (i+1, j+1)
    
    print(indices[0], indices[1])


solve()
","
from math import atan2

def solve():
    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = float('inf')
    min_indices = None

    for i in range(n):
        for j in range(i+1, n):
            angle = abs(atan2(vectors[i][1], vectors[i][0]) - atan2(vectors[j][1], vectors[j][0]))
            angle = min(angle, 2 * 3.141592653589793 - angle)
            if angle < min_angle:
                min_angle = angle
                min_indices = (i+1, j+1)

    return min_indices

solve()","
from math import atan2

def solve():
    n = int(input())
    vectors = [list(map(int, input().split())) for _ in range(n)]
    angles = []
    
    for i in range(n):
        x1, y1 = vectors[i]
        x2, y2 = vectors[(i + 1) % n]
        
        angle = abs(atan2(y1, x1) - atan2(y2, x2))
        angles.append((angle, i + 1, (i + 1) % n + 1))
        
    angles.sort()
    print(angles[0][1], angles[0][2])

solve()
","
def solve():
    import math

    n = int(input())
    vectors = []
    for i in range(n):
        x, y = map(int, input().split())
        vectors.append((x, y))

    min_angle = math.pi
    min_indices = (0, 0)

    for i in range(n):
        for j in range(i+1, n):
            dot_product = vectors[i][0] * vectors[j][0] + vectors[i][1] * vectors[j][1]
            norm_product = math.sqrt((vectors[i][0]**2 + vectors[i][1]**2) * (vectors[j][0]**2 + vectors[j][1]**2))
            angle = math.acos(dot_product / norm_product)
            if angle < min_angle:
                min_angle = angle
                min_indices = (i+1, j+1)

    print(min_indices[0], min_indices[1])

solve()
","73.33333333333333","73.33333333333333","86.66666666666667","73.33333333333333","46.666666666666664","0.0","86.66666666666667","73.33333333333333","0.0","73.33333333333333","46.666666666666664","86.66666666666667","86.66666666666667","0.0","46.666666666666664","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/44","
QUESTION:
Vasiliy has a car and he wants to get from home to the post office. The distance which he needs to pass equals to d kilometers.

Vasiliy's car is not new — it breaks after driven every k kilometers and Vasiliy needs t seconds to repair it. After repairing his car Vasiliy can drive again (but after k kilometers it will break again, and so on). In the beginning of the trip the car is just from repair station.

To drive one kilometer on car Vasiliy spends a seconds, to walk one kilometer on foot he needs b seconds (a < b).

Your task is to find minimal time after which Vasiliy will be able to reach the post office. Consider that in every moment of time Vasiliy can left his car and start to go on foot.


-----Input-----

The first line contains 5 positive integers d, k, a, b, t (1 ≤ d ≤ 10^12; 1 ≤ k, a, b, t ≤ 10^6; a < b), where:  d — the distance from home to the post office;  k — the distance, which car is able to drive before breaking;  a — the time, which Vasiliy spends to drive 1 kilometer on his car;  b — the time, which Vasiliy spends to walk 1 kilometer on foot;  t — the time, which Vasiliy spends to repair his car. 


-----Output-----

Print the minimal time after which Vasiliy will be able to reach the post office.


-----Examples-----
Input
5 2 1 4 10

Output
14

Input
5 2 1 4 5

Output
13



-----Note-----

In the first example Vasiliy needs to drive the first 2 kilometers on the car (in 2 seconds) and then to walk on foot 3 kilometers (in 12 seconds). So the answer equals to 14 seconds.

In the second example Vasiliy needs to drive the first 2 kilometers on the car (in 2 seconds), then repair his car (in 5 seconds) and drive 2 kilometers more on the car (in 2 seconds). After that he needs to walk on foot 1 kilometer (in 4 seconds). So the answer equals to 13 seconds.
Use user-input-Based format and function signature solve()","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d * a)
    else:
        full_trips = d // k
        remaining_distance = d % k
        
        time_to_drive_full_trips = full_trips * k * a
        time_to_walk_remaining_distance = remaining_distance * b
        
        time_to_repair = (full_trips - 1) * t
        
        total_time = time_to_drive_full_trips + time_to_walk_remaining_distance + time_to_repair
        
        print(min(total_time, (full_trips * k * a) + (remaining_distance * a)))

solve()","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    full_round = d // k
    distance_left = d % k
    
    time_to_drive = min(distance_left * a, t + distance_left * a)  # Time to drive remaining distance
    time_to_walk = distance_left * b  # Time to walk remaining distance
    
    repair_time = t * (full_round - 1) if full_round > 1 else 0  # Time to repair car for full rounds beyond the first
    
    total_time = full_round * t + full_round * k * a - t  # Total time to repair car while driving k kilometers each round
    
    if full_round > 0:
        total_time += min(time_to_drive, time_to_walk)
    else:
        total_time = min(d * a, d * b)
    
    print(total_time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d * a)
    else:
        full_drive = k * a + (d // k) * min(t, (b - a) * k)
        rest_distance = d % k

        if t < (b - a) * k:
            rest_time = min(t + rest_distance * a, t + rest_distance * b)
        else:
            rest_time = t + rest_distance * a

        total_time = full_drive + rest_time
        print(total_time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d * a)
        return
    
    distance_remaining = d
    time = 0
    
    while distance_remaining > 0:
        if distance_remaining <= k:
            time += distance_remaining * a
            break
        
        if (distance_remaining - k) * a <= t:
            time += t + (distance_remaining - k) * a
            break
        
        time += min(k * a, t + k * a + (distance_remaining - k) * b)
        distance_remaining -= k
    
    print(time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d * a)
    else:
        full = d // k
        remain = d % k
        
        time_drive_full = k * a
        time_drive_remain = min(remain * a, remain * b)
        
        repair_time = (full - 1) * t
        
        total_time = full * (time_drive_full + t) + repair_time + time_drive_remain
        print(total_time)

solve()","
def solve():
    d, k, a, b, t = map(int, input().split())

    if d <= k:
        print(d * a)
    else:
        full_trips = d // k
        remaining_distance = d % k
        time_to_drive = k * a

        total_time = min(full_trips * (k * a + t) + remaining_distance * a, 
                         full_trips * (k * a + t) + remaining_distance * b + (remaining_distance - k) * a)
        
        print(total_time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d * a)
        return
    
    full_trips = d // k
    remain_distance = d % k
    
    time_car = full_trips * (k * a + t)
    
    if remain_distance != 0:
        time_walk = remain_distance * b
        time_repair = t
        
        total_time = time_car + min(remain_distance * a, time_walk + time_repair)
        print(total_time)
    else:
        print(time_car)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())

    if d <= k:
        print(d*a)
        return

    total_time = 0

    distance_left = d
    while distance_left > 0:
        if distance_left > k:
            drive_time = min(k*a, t + a*k + b*(distance_left-k))
            total_time += drive_time
            distance_left -= k
        else:
            total_time += a*distance_left
            break

    print(total_time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d * a)
    else:
        full_stretch = d // k
        remaining_distance = d % k
        
        time_on_car = full_stretch * (k * a + t) + min(remaining_distance * a, t + remaining_distance * b)
        time_on_foot = d * b
        
        print(min(time_on_car, time_on_foot))

solve()","
def solve():
    d, k, a, b, t = map(int, input().split())

    if d <= k:
        print(d * a)
    else:
        full_broken_cycles = (d - k) // k
        remaining_distance = (d - k) % k

        time_to_drive_k = a * k
        time_to_walk_k = b * k

        repair_time = min(t, (time_to_drive_k + t) - time_to_walk_k)

        time_to_drive_full_broken_cycles = time_to_drive_k + full_broken_cycles * (time_to_drive_k + repair_time)
        time_to_walk_remaining_distance = remaining_distance * b

        total_time = time_to_drive_k + full_broken_cycles * (time_to_drive_k + repair_time) + max(repair_time, time_to_walk_remaining_distance)

        print(total_time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    if k >= d:
        print(d * a)
    else:
        n = d // k
        time = n * t + ((k - 1) * a + b) * n
        remaining = d - n * k
        time += min(remaining * a, t + remaining * b)
        print(time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d * a)
        return
    
    full_dist = d // k
    remain_dist = d % k
    
    time_to_drive_full = full_dist * (k * a + t)
    time_to_drive_remain = min(remain_dist * a, t + remain_dist * b)
    
    total_time = time_to_drive_full + time_to_drive_remain
    print(total_time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    walks = (d - 1) // k
    time = walks * (k * a + t) + (d - 1) % k * a
    
    walk_time = walks * t + (d - 1) * b
    
    print(min(time, walk_time + t))

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(a * d)
    else:
        full_drives, remaining_distance = divmod(d, k)
        full_drive_time = full_drives * (a * k + t)
        
        additional_time = 0
        if remaining_distance == 0:
            additional_time = -t
        elif remaining_distance <= k:
            additional_time = a * remaining_distance
        else:
            additional_time = min((remaining_distance - k) * a, t + b * (remaining_distance - k))
        
        print(full_drive_time + additional_time)

solve()
  ","
def solve():
    d, k, a, b, t = map(int, input().split())

    if d <= k:
        print(d * a)
    else:
        full_distance = k + (d // k - 1) * k
        full_time = a * k + t
        remaining_distance = d - full_distance

        walk_time = remaining_distance * b
        repair_time = t if walk_time >= t else t - (t - walk_time) % t

        total_time = full_time + repair_time + walk_time
        print(total_time)

solve()
","
def solve():
    d, k, a, b, t = map(int, input().split())
    
    if d <= k:
        print(d*a)
    else:
        full_breaks = d // k
        remainder = d % k
        time_to_drive_full = full_breaks * k * a
        time_to_walk_remainder = remainder * b
        time_to_repair = (full_breaks - 1) * t
        
        total_time = time_to_drive_full + time_to_walk_remainder + time_to_repair
        print(min(total_time, d*a + (d-1)*t))

# Input example (uncomment to test)
# solve()
","6.666666666666667","13.333333333333334","6.666666666666667","6.666666666666667","6.666666666666667","46.666666666666664","80.0","6.666666666666667","80.0","6.666666666666667","6.666666666666667","80.0","0.0","86.66666666666667","6.666666666666667","0.0","","","","","","","","","","","","","","","",""
"APPS/45","
QUESTION:
You are given positive integer number n. You should create such strictly increasing sequence of k positive numbers a_1, a_2, ..., a_{k}, that their sum is equal to n and greatest common divisor is maximal.

Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them.

If there is no possible sequence then output -1.


-----Input-----

The first line consists of two numbers n and k (1 ≤ n, k ≤ 10^10).


-----Output-----

If the answer exists then output k numbers — resulting sequence. Otherwise output -1. If there are multiple answers, print any of them.


-----Examples-----
Input
6 3

Output
1 2 3

Input
8 2

Output
2 6

Input
5 3

Output
-1
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k > n or k * (k + 1) // 2 > n:
        print(-1)
        return
    
    res = [i for i in range(1, k)]
    res.append(n - sum(res))
    
    print(*res)

solve()","
import math

def solve():
    n, k = map(int, input().split())
    
    if n < sum(range(1, k+1)):
        print(-1)
        return
    
    res = [0] * k
    for i in range(k):
        res[i] = i+1
        
    remaining_sum = n - sum(res)
    for i in range(k-1, -1, -1):
        add_value = min(remaining_sum // (k-i), res[i])
        res[i] += add_value
        remaining_sum -= add_value * (k-i)
        
    print(' '.join(map(str, res)))

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k > n:
        print(-1)
    else:
        res = [1] * k
        remain = n - k
        
        for i in range(k):
            add = min(remain, res[i] - 1)
            res[i] += add
            remain -= add
        
        if remain > 0:
            print(-1)
        else:
            print(*res)

solve()","
import math

def solve():
    n, k = map(int, input().split())
    if n < k or k * (k + 1) // 2 > n:
        print(-1)
    else:
        first = n // k
        remain = n % k
        sequence = [first] * k
        for i in range(k):
            addition = min(k - 1 - i, remain)
            sequence[i] += addition
            remain -= addition
        print(*sequence)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if n < k*(k+1)//2:
        print(-1)
    else:
        start = n//k
        extra = n % k
        seq = [start] * k
        for i in range(extra):
            seq[i] += i+1
        print(*seq)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k > n:
        print(-1)
        return

    nums = [1] * k
    remaining_sum = n - k

    for i in range(k):
        increment = min(remaining_sum, nums[i])
        nums[i] += increment
        remaining_sum -= increment

    print(' '.join(map(str, nums)))

solve()
","
import math

def solve():
    n, k = map(int, input().split())
    
    if k > n or n // k == 0:
        return -1
    
    rem = n % k
    quotient = n // k
    
    result = [quotient] * k
    
    for i in range(k):
        if rem > 0:
            result[i] += 1
            rem -= 1
    
    return result

solve()","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k > n or (k == 1 and n > 1):
        print(-1)
    else:
        d = n // k
        rem = n % k
        res = [d for _ in range(k)]
        for i in range(1, rem+1):
            res[i-1] += i
        
        print(' '.join(map(str, res)))

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if n < k * (k + 1) // 2:
        print(-1)
        return
    
    a = [i for i in range(1, k+1)]
    remaining_sum = n - k*(k+1)//2
    
    for i in range(1, k+1):
        add_to_each = min(remaining_sum // i, k-i) 
        a[i-1] += add_to_each*i
        remaining_sum -= i*add_to_each
        
    print(*a)

solve()
","
import math

def solve():
    n, k = map(int, input().split())
    
    if k % 2 == 0:
        if n % 2 != 0:
            print(""-1"")
            return
        if n < 2*k:
            print(""-1"")
            return
        print(""2 "" * (k-1) + str(n - 2*(k-1)))
    else:
        if n < k:
            print(""-1"")
            return
        print(str(n - k + 1) + "" "" + ""1 "" * (k-1))

solve()
  ","
import math

def solve():
    n, k = map(int, input().split())
    
    if k > n:
        print(-1)
        return
    
    # creating a sequence starting from 1 up to k
    result = list(range(1, k + 1))

    # adding the remaining sum to the last element
    result[-1] += (n - sum(result))

    print(*result)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    
    if k > n or (k == 1 and n != 1):
        print(-1)
    else:
        a = [1] * k
        rem = n - k
        for i in range(k-1, -1, -1):
            add = min(rem, a[i] * (2**(k-i-1) - 1))
            a[i] += add
            rem -= add
        print(*a)

solve()","
from math import gcd

def solve():
    n, k = map(int, input().split())
    if k > n:
        print(-1)
    else:
        factor = n // k
        output = [factor]*k
        remaining = n - factor*k
        for i in range(remaining):
            output[i] += i + 1
        print(*output)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    if k * (k + 1) // 2 > n:
        print(-1)
    else:
        x = n // k
        rem = n % k
        seq = [x] * k
        for i in range(1, rem + 1):
            seq[-i] += i
        print(*seq)

solve()
","
import math

def solve():
    n, k = map(int, input().split())
    
    if k*(k+1)//2 > n:
        print(-1)
    else:
        first_num = n // k
        remainder = n % k
        
        result = [first_num + i for i in range(k)]
        for i in range(remainder):
            result[-i-1] += 1
        
        print(*result)

solve()","
import math

def solve():
    n, k = map(int, input().split())

    if k * (k + 1) // 2 > n:
        print(-1)
    else:
        prefix_sum = k * (k + 1) // 2
        remainder = n - prefix_sum
        output = [i for i in range(1, k + 1)]
        for i in range(k):
            to_add = remainder // (k - i)
            output[i] += to_add
            remainder -= to_add * (k - i)
        print(*output)

solve()
","53.333333333333336","35.714285714285715","26.666666666666668","40.0","40.0","26.666666666666668","0.0","20.0","33.33333333333333","46.666666666666664","46.666666666666664","20.0","33.33333333333333","40.0","40.0","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/46","
QUESTION:
After finishing eating her bun, Alyona came up with two integers n and m. She decided to write down two columns of integers — the first column containing integers from 1 to n and the second containing integers from 1 to m. Now the girl wants to count how many pairs of integers she can choose, one from the first column and the other from the second column, such that their sum is divisible by 5.

Formally, Alyona wants to count the number of pairs of integers (x, y) such that 1 ≤ x ≤ n, 1 ≤ y ≤ m and $(x + y) \operatorname{mod} 5$ equals 0.

As usual, Alyona has some troubles and asks you to help.


-----Input-----

The only line of the input contains two integers n and m (1 ≤ n, m ≤ 1 000 000).


-----Output-----

Print the only integer — the number of pairs of integers (x, y) such that 1 ≤ x ≤ n, 1 ≤ y ≤ m and (x + y) is divisible by 5.


-----Examples-----
Input
6 12

Output
14

Input
11 14

Output
31

Input
1 5

Output
1

Input
3 8

Output
5

Input
5 7

Output
7

Input
21 21

Output
88



-----Note-----

Following pairs are suitable in the first sample case:   for x = 1 fits y equal to 4 or 9;  for x = 2 fits y equal to 3 or 8;  for x = 3 fits y equal to 2, 7 or 12;  for x = 4 fits y equal to 1, 6 or 11;  for x = 5 fits y equal to 5 or 10;  for x = 6 fits y equal to 4 or 9. 

Only the pair (1, 4) is suitable in the third sample case.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        count += m // 5
        if (x + m) % 5 == 0:
            count += 1
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        count += (m - (x % 5)) // 5 + 1
    print(count)

solve()
","
python
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n + 1):
        for y in range(1, m + 1):
            if (x + y) % 5 == 0:
                count += 1
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        count += (m // 5) + (m % 5 >= (5 - x % 5))
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n + 1):
        count += (m - (-x % 5)) // 5
    return count

solve()","
from typing import Tuple

def solve() -> None:
    def count_pairs(n: int, m: int) -> int:
        count = 0
        for x in range(1, n + 1):
            for y in range(1, m + 1):
                if (x + y) % 5 == 0:
                    count += 1
        return count

    n, m = map(int, input().split())
    print(count_pairs(n, m))

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n + 1):
        for y in range(1, m + 1):
            if (x + y) % 5 == 0:
                count += 1
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        for y in range(1, m+1):
            if (x + y) % 5 == 0:
                count += 1
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        count += m // 5
        if (m % 5) + x >= 5:
            count += 1
    print(count)

solve()","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        count += m - (x % 5) // 2 if m >= x % 5 else 0
    print(count)

solve()
","
from typing import Tuple

def solve(n: int, m: int) -> int:
    count = 0
    for x in range(1, n+1):
        for y in range(1, m+1):
            if (x + y) % 5 == 0:
                count += 1
    return count

solve()","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        count += (m // 5) + (m % 5 >= 5 - x % 5)
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        count += (m - (x % 5)) // 5 + 1
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n + 1):
        count += m // 5
        if (x + m) % 5 == 0:
            count += 1
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    count = 0
    for x in range(1, n + 1):
        for y in range(1, m + 1):
            if (x + y) % 5 == 0:
                count += 1
    print(count)

solve()","
def solve():
    n, m = map(int, input().split())
    mod_counts = [0] * 5
    for i in range(1, n+1):
        mod_counts[i % 5] += m // 5
        for j in range(1, m % 5 + 1):
            if (i + j) % 5 == 0:
                mod_counts[i % 5] += 1

    result = mod_counts[0] + mod_counts[1] + mod_counts[2]*2 + mod_counts[3]*2 + mod_counts[4]*2
    print(result)

solve()
  ","33.33333333333333","13.333333333333334","0.0","100.0","0.0","100.0","100.0","100.0","26.666666666666668","0.0","0.0","100.0","13.333333333333334","33.33333333333333","100.0","20.0","","","","","","","","","","","","","","","",""
"APPS/47","
QUESTION:
You are given an array $a$ consisting of $n$ integers. Beauty of array is the maximum sum of some consecutive subarray of this array (this subarray may be empty). For example, the beauty of the array [10, -5, 10, -4, 1] is 15, and the beauty of the array [-3, -5, -1] is 0.

You may choose at most one consecutive subarray of $a$ and multiply all values contained in this subarray by $x$. You want to maximize the beauty of array after applying at most one such operation.


-----Input-----

The first line contains two integers $n$ and $x$ ($1 \le n \le 3 \cdot 10^5, -100 \le x \le 100$) — the length of array $a$ and the integer $x$ respectively.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($-10^9 \le a_i \le 10^9$) — the array $a$.


-----Output-----

Print one integer — the maximum possible beauty of array $a$ after multiplying all values belonging to some consecutive subarray $x$.


-----Examples-----
Input
5 -2
-3 8 -2 1 -6

Output
22

Input
12 -3
1 3 3 7 1 3 3 7 1 3 3 7

Output
42

Input
5 10
-1 -2 -3 -4 -5

Output
0



-----Note-----

In the first test case we need to multiply the subarray [-2, 1, -6], and the array becomes [-3, 8, 4, -2, 12] with beauty 22 ([-3, 8, 4, -2, 12]).

In the second test case we don't need to multiply any subarray at all.

In the third test case no matter which subarray we multiply, the beauty of array will be equal to 0.
Use user-input-Based format and function signature solve()","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    max_sum = current_sum = 0
    prefix_max = [0]
    for num in a:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
        prefix_max.append(max_sum)
    
    suffix_max = [0]
    max_sum = current_sum = 0
    for num in reversed(a):
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
        suffix_max.append(max_sum)
    suffix_max = list(reversed(suffix_max))
    
    result = max(max(a[i] * x + prefix_max[i-1] + suffix_max[i+1] for i in range(n)), max(a))
    
    print(result)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_max = [0]
    suffix_max = [0]
    
    curr_max = 0
    max_sum = 0
    for num in a:
        curr_max = max(0, curr_max) + num
        max_sum = max(max_sum, curr_max)
        prefix_max.append(max_sum)
    
    curr_max = max_sum = 0
    for num in reversed(a):
        curr_max = max(0, curr_max) + num
        max_sum = max(max_sum, curr_max)
        suffix_max.append(max_sum)
    suffix_max = list(reversed(suffix_max))
    
    max_beauty = max(max(a), max(prefix_max[-1] + x * max(a[i] for i in range(1, len(a))),
                      prefix_max[i] + x * suffix_max[i+1] for i in range(len(a)))
    
    return max_beauty

solve()","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))

    max_sum = 0
    curr_sum = 0

    normal_sum = 0
    modified_sum = 0
    for num in a:
        curr_sum = max(num, curr_sum + num)
        max_sum = max(max_sum, curr_sum)

        normal_sum += num
        modified_sum = max(modified_sum, normal_sum, normal_sum - x)

    result = max(max_sum, modified_sum)
    print(result)

solve()
","
def solve():
    import sys
    input = sys.stdin.readline

    n, x = map(int, input().split())
    a = list(map(int, input().split()))

    if x < 0:
        max_sum = 0
        curr_max = 0
        prefix_sum = []
        for num in a:
            curr_max = max(num, curr_max + num)
            max_sum = max(max_sum, curr_max)
            prefix_sum.append(max_sum)

        suffix_max = 0
        max_sum = 0
        suffix_sum = []
        for i in range(n - 1, -1, -1):
            suffix_max = max(a[i], suffix_max + a[i])
            max_sum = max(max_sum, suffix_max)
            suffix_sum.append(max_sum)

        ans = max(max_sum, suffix_sum[0])
        for i in range(1, n-1):
            curr_sum = max(0, prefix_sum[i-1]) + x*a[i] + suffix_sum[i+1]
            ans = max(ans, curr_sum)

    else:
        max_sum = 0
        curr_max = 0
        prefix_sum = []
        for num in a:
            curr_max = max(num, curr_max + num)
            max_sum = max(max_sum, curr_max)
            prefix_sum.append(max_sum)

        ans = 0
        for i in range(n):
            for j in range(i, n):
                curr_sum = 0
                for k in range(i, j+1):
                    if i == k == j:
                        curr_sum += x * a[k]
                    else:
                        curr_sum += a[k]
                ans = max(ans, curr_sum)

    print(ans)

solve()","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    original_beauty = max_prefix_sum = max_suffix_sum = beauty = 0
    
    for num in a:
        original_beauty += num
        max_prefix_sum = max(num, max_prefix_sum + num)
        max_suffix_sum = max(num, max_suffix_sum + num)
        beauty = max(beauty, max_prefix_sum, max_suffix_sum)
    
    subarray_sum = 0
    for num in reversed(a):
        subarray_sum = max(subarray_sum + num, num)
        beauty = max(beauty, original_beauty + x * subarray_sum)
    
    print(beauty)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    max_sum = max_prefix_sum = max_suffix_sum = current_sum = 0
    max_subarray_sum = max_subarray_prefix_sum = max_subarray_suffix_sum = 0
    
    for num in a:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
        
        max_prefix_sum = max(num, max_prefix_sum + num)
        max_subarray_prefix_sum = max(max_subarray_prefix_sum, max_prefix_sum)
        
        max_suffix_sum = max(num, max_suffix_sum + num)
        max_subarray_suffix_sum = max(max_subarray_suffix_sum, max_suffix_sum)
    
    beauty = max(max_sum, max_subarray_prefix_sum + max_subarray_suffix_sum + x * (max_subarray_sum - max_subarray_prefix_sum - max_subarray_suffix_sum))
    
    print(beauty)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    # Calculate the maximum sum without multiplying any subarray
    max_sum = 0
    current_sum = 0
    for i in range(n):
        current_sum = max(a[i], current_sum + a[i])
        max_sum = max(max_sum, current_sum)
    
    # Calculate the maximum beauty after multiplying one subarray
    max_result = 0
    current_sum = 0
    for i in range(n):
        current_sum = max(a[i]*x, current_sum + a[i]*x)
        max_result = max(max_result, current_sum)
    
    result = max(max_sum, max_result)
    print(result)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))

    def max_sum_after_multiplication(a, x):
        max_so_far = 0
        max_ending_here1 = 0
        max_ending_here2 = 0
        for num in a:
            max_ending_here1 = max(0, max_ending_here1 + num)
            max_ending_here2 = max(max_ending_here2 + num * x, max_ending_here1)
            max_so_far = max(max_so_far, max_ending_here2, max_ending_here1)
        return max_so_far

    print(max_sum_after_multiplication(a, x))

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    def max_sum(arr):
        current_sum = 0
        max_sum = 0
        prefix_sum = []
        for num in arr:
            current_sum = max(num, current_sum + num)
            max_sum = max(max_sum, current_sum)
            prefix_sum.append(current_sum)
        suffix_sum = []
        current_sum = 0
        max_sum = 0
        for num in reversed(arr):
            current_sum = max(num, current_sum + num)
            max_sum = max(max_sum, current_sum)
            suffix_sum.append(current_sum)
        suffix_sum = list(reversed(suffix_sum))
        
        result = max(max_sum, 0)
        
        for i in range(n):
            for j in range(i, n):
                result = max(result, prefix_sum[i] + x * (sum(arr[i:j+1]) - (prefix_sum[j] - prefix_sum[i]) + suffix_sum[j]))
        
        return result
    
    print(max_sum(a))

# Provide the necessary inputs using the format mentioned in the question to test the function

solve()","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    max_sum = cur_sum = 0
    max_annihilate_sum = 0
    
    for num in a:
        cur_sum = max(num, cur_sum + num)
        max_sum = max(max_sum, cur_sum)
        max_annihilate_sum = max(max_annihilate_sum, max(0, cur_sum - num * x))
    
    result = max(max_sum, max_annihilate_sum)
    
    print(result)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))

    # Calculate the maximum beauty without multiplying any subarray
    beauty = max_sum = total = 0
    for num in a:
        total = max(num, total + num)
        max_sum = max(max_sum, total)
        beauty = max(beauty, max_sum)

    # Check if multiplying a subarray enhances beauty
    total = 0
    for num in a:
        total = max(num, total + num * x)
        max_sum = max(max_sum, total)
        beauty = max(beauty, max_sum)

    print(beauty)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_sum = [0] + a[:]
    for i in range(1, n+1):
        prefix_sum[i] += prefix_sum[i-1]
    
    best = 0
    for i in range(1, n+1):
        for j in range(i, n+1):
            beauty = prefix_sum[j] - prefix_sum[i-1]
            if beauty > best:
                best = beauty
    
    for i in range(1, n+1):
        for j in range(i, n+1):
            beauty = prefix_sum[j] - prefix_sum[i-1]
            best = max(best, prefix_sum[n] - (prefix_sum[j] - prefix_sum[i-1]) + (beauty * x))
    
    print(best)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_max = [0]
    sum_a = 0
    for num in a:
        sum_a += num
        prefix_max.append(max(prefix_max[-1], 0) + num)
    
    suffix_max = [0] * (n + 1)
    sum_a = 0
    for i in range(n - 1, -1, -1):
        sum_a += a[i]
        suffix_max[i] = max(suffix_max[i + 1], 0) + a[i]
    
    total_sum = sum(a)
    max_beauty = max(total_sum, max(max(prefix_max), max(suffix_max)))
    for i in range(1, n):
        for j in range(i, n):
            total = total_sum - (prefix_max[i] + suffix_max[j])
            total += prefix_max[i] * x
            max_beauty = max(max_beauty, total)
    
    print(max_beauty)

solve()
","
from typing import List

def solve(n: int, x: int, a: List[int]) -> int:
    prefix_sum = [0]
    for num in a:
        prefix_sum.append(prefix_sum[-1] + num)
    
    max_beauty = 0
    for i in range(1, n+1):
        for j in range(i, n+1):
            total = prefix_sum[j] - prefix_sum[i-1]
            beauty = prefix_sum[n] - total
            beauty += x * total
            max_beauty = max(max_beauty, beauty)
    
    return max(max_beauty, prefix_sum[n])

solve()","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))
    
    ans = 0
    s1 = [0] * (n + 1)
    s2 = [0] * (n + 2)
    
    for i in range(1, n + 1):
        s1[i] = max(0, s1[i-1] + a[i-1])
    
    for i in range(n, 0, -1):
        s2[i] = max(0, s2[i+1] + a[i-1])
    
    for i in range(1, n + 1):
        ans = max(ans, s1[i] + x * a[i-1] + s2[i+1])
    
    print(ans)

solve()
","
def solve():
    n, x = map(int, input().split())
    a = list(map(int, input().split()))

    ans = max(0, max(sum(a) * x, max(a), max(a[0] + a[-1], 0)))
    pre, suf, m1, su = 0, 0, 0, 0
    for i in range(n):
        su += a[i]
        m1 = max(m1, a[i])
        pre = max(pre, su)
        suf = min(suf, su)
        ans = max(ans, pre + x * (n - i - 1) * max(0, suf))
        ans = max(ans, m1 + x * max(0, su))
    
    return ans

solve()
","20.0","0.0","6.666666666666667","20.0","13.333333333333334","6.666666666666667","20.0","33.33333333333333","13.333333333333334","0.0","33.33333333333333","53.333333333333336","13.333333333333334","0.0","6.666666666666667","0.0","","","","","","","","","","","","","","","",""
"APPS/48","
QUESTION:
Bizon the Champion isn't just charming, he also is very smart.

While some of us were learning the multiplication table, Bizon the Champion had fun in his own manner. Bizon the Champion painted an n × m multiplication table, where the element on the intersection of the i-th row and j-th column equals i·j (the rows and columns of the table are numbered starting from 1). Then he was asked: what number in the table is the k-th largest number? Bizon the Champion always answered correctly and immediately. Can you repeat his success?

Consider the given multiplication table. If you write out all n·m numbers from the table in the non-decreasing order, then the k-th number you write out is called the k-th largest number.


-----Input-----

The single line contains integers n, m and k (1 ≤ n, m ≤ 5·10^5; 1 ≤ k ≤ n·m).


-----Output-----

Print the k-th largest number in a n × m multiplication table.


-----Examples-----
Input
2 2 2

Output
2

Input
2 3 4

Output
3

Input
1 10 5

Output
5



-----Note-----

A 2 × 3 multiplication table looks like this:

1 2 3

2 4 6
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k = map(int, input().split())
    low, high = 1, n*m
    
    while low < high:
        mid = (low + high) // 2
        count = sum(min(mid // i, n) for i in range(1, m+1))
        
        if count < k:
            low = mid + 1
        else:
            high = mid
    
    print(low)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    def count_less_equal(x):
        cnt = 0
        for i in range(1, n + 1):
            cnt += min(x // i, m)
        return cnt
    
    l, r = 1, n * m
    while l < r:
        mid = (l + r) // 2
        if count_less_equal(mid) < k:
            l = mid + 1
        else:
            r = mid
    
    return l

solve()","
def solve():
    import heapq
    
    n, m, k = map(int, input().split())
    left, right = 1, n*m
    
    while left < right:
        mid = (left + right) // 2
        cnt = sum(min(mid // i, n) for i in range(1, m+1))
        
        if cnt < k:
            left = mid + 1
        else:
            right = mid
    
    print(left)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    left, right = 1, n*m
    while left < right:
        mid = (left + right) // 2
        count = sum(min(mid // i, n) for i in range(1, m+1))
        if count < k:
            left = mid + 1
        else:
            right = mid
    return left

solve()","
def solve():
    import math
    
    n, m, k = map(int, input().split())
    
    def count_elements(x):
        count = 0
        for i in range(1, n + 1):
            count += min(m, x // i)
        return count
    
    left = 1
    right = n * m
    
    while left < right:
        mid = (left + right) // 2
        if count_elements(mid) < k:
            left = mid + 1
        else:
            right = mid
    
    return left



solve()","
def solve():
    n, m, k = map(int, input().split())
    
    low, high = 1, n*m
    
    while low < high:
        mid = (low + high) // 2
        cnt = sum(min(mid // i, n) for i in range(1, m+1))
        if cnt < k:
            low = mid + 1
        else:
            high = mid
    
    return low

solve()
","
def solve():
    import bisect

    n, m, k = map(int, input().split())

    left, right = 1, n*m
    while left < right:
        mid = (left + right) // 2
        count = sum(min(mid // i, n) for i in range(1, m+1))
        if count < k:
            left = mid + 1
        else:
            right = mid

    print(left)

solve()
","
def solve():
    import math
    
    n, m, k = map(int, input().split())
    
    left, right = 1, n * m
    
    while left < right:
        mid = (left + right) // 2
        
        count = sum(min(mid // i, n) for i in range(1, m + 1))
        
        if count < k:
            left = mid + 1
        else:
            right = mid
    
    return left

solve()","
def solve():
    import numpy as np
    
    n, m, k = map(int, input().split())
    
    lo, hi = 1, n*m
    
    while lo < hi:
        mid = (lo + hi) // 2
        cnt = np.count_nonzero(np.minimum(mid//np.arange(1, n+1), n) * np.arange(1, m+1) >= mid)
        if cnt < k:
            lo = mid + 1
        else:
            hi = mid
    
    print(lo)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    def count_less_equal(x):
        count = 0
        for i in range(1, n+1):
            count += min(x // i, m)
        return count

    low, high = 1, n*m
    while low < high:
        mid = (low + high) // 2
        if count_less_equal(mid) < k:
            low = mid + 1
        else:
            high = mid
    
    return low


solve()","
def solve():
    import sys
    
    n, m, k = map(int, sys.stdin.readline().split())
    
    low, high = 1, n * m
    
    while low < high:
        mid = (low + high) // 2
        cnt = sum(min(mid // i, m) for i in range(1, n+1))
        if cnt < k:
            low = mid + 1
        else:
            high = mid

    return low

solve()","
def solve():
    import math
    n, m, k = map(int, input().split())
    left, right = 1, n * m
    
    while left < right:
        mid = (left + right) // 2
        cnt = 0
        for i in range(1, n+1):
            cnt += min(mid // i, m)
        if cnt < k:
            left = mid + 1
        else:
            right = mid
    
    print(left)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    left, right = 1, n * m
    while left < right:
        mid = (left + right) // 2
        count = 0
        for i in range(1, n+1):
            count += min(mid // i, m)
        if count < k:
            left = mid + 1
        else:
            right = mid
    print(left)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    left, right = 1, n*m

    while left < right:
        mid = (left + right) // 2
        count = sum(min(mid // i, n) for i in range(1, m+1))
        if count < k:
            left = mid + 1
        else:
            right = mid

    return left

solve()","
def solve():
    n, m, k = map(int, input().split())
    left, right = 1, n*m
    
    while left < right:
        mid = (left + right) // 2
        cnt = sum(min(mid // i, n) for i in range(1, m+1))
        if cnt < k:
            left = mid + 1
        else:
            right = mid
    
    return left

solve()","
def solve():
    n, m, k = map(int, input().split())
    left, right = 1, n*m
    
    while left < right:
        mid = (left + right) // 2
        count = sum(min(mid // i, n) for i in range(1, n+1))
        
        if count < k:
            left = mid + 1
        else:
            right = mid
    
    print(left)

import sys
if __name__ == ""__main__"":
    sys.setrecursionlimit(10**6)
    solve()
","100.0","0.0","100.0","0.0","0.0","0.0","100.0","0.0","26.666666666666668","0.0","0.0","100.0","100.0","0.0","0.0","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/49","
QUESTION:
Let's write all the positive integer numbers one after another from $1$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...

Your task is to print the $k$-th digit of this sequence.


-----Input-----

The first and only line contains integer $k$ ($1 \le k \le 10^{12}$) — the position to process ($1$-based index).


-----Output-----

Print the $k$-th digit of the resulting infinite sequence.


-----Examples-----
Input
7

Output
7

Input
21

Output
5
Use user-input-Based format and function signature solve()","
def solve():
    k = int(input())
    k -= 1
    n = 1
    while k > 9 * n * 10 ** (n - 1):
        k -= 9 * n * 10 ** (n - 1)
        n += 1
    num = 10 ** (n - 1) + k // n
    digit = str(num)[k % n]
    print(digit)

solve()
","
def solve():
    k = int(input())
    n = 1
    while k > 0:
        length = len(str(n))
        if k <= length:
            print(str(n)[k-1])
            break
        k -= length
        n += 1

solve()
","
# Define the function to solve the problem
def solve():
    # Import the math library
    import math
    
    # Input the value of k from the user
    k = int(input())
    
    # Define a variable for the current position
    current_position = 1
    
    # Define a variable for the current number
    current_number = 1

    # While the current position plus the number of digits in the current number is less than k
    while current_position + len(str(current_number)) < k:
        current_position += len(str(current_number))
        current_number += 1
    
    # Calculate the position of the digit within the current number
    digit_position = k - current_position
    
    # Get the digit at the calculated position
    result = int(str(current_number)[digit_position - 1])
    
    # Output the resulting digit
    print(result)

# Call the function to solve the problem
solve()
","
def solve():
    k = int(input())
    
    def get_digit(k):
        n = 1
        while k > 9 * n * 10 ** (n - 1):
            k -= 9 * n * 10 ** (n - 1)
            n += 1
        num = 10 ** (n - 1) + (k - 1) // n
        idx = (k - 1) % n
        return int(str(num)[idx])

    print(get_digit(k))

solve()
","
def solve():
    k = int(input())
    k -= 1

    num_digits = 1
    count = 9
    while k >= count * num_digits:
        k -= count * num_digits
        num_digits += 1
        count *= 10

    target_num = count // 9 + k // num_digits
    target_str = str(target_num)
    return target_str[k % num_digits]

solve()
","
def solve():
    k = int(input().strip())
    digits = []
    current_num = 1

    while k > len(digits):
        digits.extend(list(str(current_num)))
        current_num += 1

    print(digits[k - 1])

solve()
","
def solve():
    k = int(input())
    def find_digit(k):
        n = 1
        while k > 9 * n * 10 ** (n - 1):
            k -= 9 * n * 10 ** (n - 1)
            n += 1
        num = 10 ** (n - 1) + (k - 1) // n
        digit = str(num)[(k - 1) % n]
        return digit

    print(find_digit(k))
    
solve()
","
def solve():
    k = int(input())
    k -= 1
    length = 1
    while k > 9 * 10**(length - 1) * length:
        k -= 9 * 10**(length - 1) * length
        length += 1
    num = 10**(length - 1) + k // length
    digit = str(num)[k % length]
    print(digit)

solve()
","
def solve():
    k = int(input())
    
    def find_digit(k):
        i = 1
        while k > 0:
            if k <= len(str(i)):
                return int(str(i)[k-1])
            k -= len(str(i))
            i += 1
    
    print(find_digit(k))

solve()
","
def solve():
    k = int(input())
    
    num = 1
    while k > len(str(num)):
        k -= len(str(num))
        num += 1
    
    return int(str(num)[k-1])

solve()
","
def solve():
    k = int(input())

    def get_digit_at(k):
        n = 1
        while True:
            digits = len(str(n))
            if k <= digits:
                return int(str(n)[k-1])
            k -= digits
            n += 1

    print(get_digit_at(k))

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    num = 1
    while k > len(str(num)):
        k -= len(str(num))
        num += 1
    print(str(num)[k-1])

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    
    def find_kth_digit(k):
        num = 1
        curr_len = 1
        while True:
            if k <= curr_len:
                return int(str(num)[k-1])
            curr_len += len(str(num))
            num += 1
    
    print(find_kth_digit(k))

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    i = 1
    while True:
        str_i = str(i)
        if k <= len(str_i):
            print(str_i[k - 1])
            break
        k -= len(str_i)
        i += 1

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    current_length = 0
    start = 1

    while True:
        num_length = len(str(start))
        if current_length + num_length < k:
            current_length += num_length
            start += 1
        else:
            return str(start)[k - current_length - 1]


if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())

    def find_kth_digit(k):
        curr_num = 1
        while True:
            num_str = str(curr_num)
            if k <= len(num_str):
                return int(num_str[k-1])
            k -= len(num_str)
            curr_num += 1

    result = find_kth_digit(k)
    print(result)

solve()
","100.0","100.0","13.333333333333334","100.0","0.0","100.0","100.0","100.0","100.0","0.0","100.0","100.0","6.666666666666667","100.0","0.0","100.0","","","","","","","","","","","","","","","",""
"APPS/50","
QUESTION:
Welcome to Codeforces Stock Exchange! We're pretty limited now as we currently allow trading on one stock, Codeforces Ltd. We hope you'll still be able to make profit from the market!

In the morning, there are $n$ opportunities to buy shares. The $i$-th of them allows to buy as many shares as you want, each at the price of $s_i$ bourles.

In the evening, there are $m$ opportunities to sell shares. The $i$-th of them allows to sell as many shares as you want, each at the price of $b_i$ bourles. You can't sell more shares than you have.

It's morning now and you possess $r$ bourles and no shares.

What is the maximum number of bourles you can hold after the evening?


-----Input-----

The first line of the input contains three integers $n, m, r$ ($1 \leq n \leq 30$, $1 \leq m \leq 30$, $1 \leq r \leq 1000$) — the number of ways to buy the shares on the market, the number of ways to sell the shares on the market, and the number of bourles you hold now.

The next line contains $n$ integers $s_1, s_2, \dots, s_n$ ($1 \leq s_i \leq 1000$); $s_i$ indicates the opportunity to buy shares at the price of $s_i$ bourles.

The following line contains $m$ integers $b_1, b_2, \dots, b_m$ ($1 \leq b_i \leq 1000$); $b_i$ indicates the opportunity to sell shares at the price of $b_i$ bourles.


-----Output-----

Output a single integer — the maximum number of bourles you can hold after the evening.


-----Examples-----
Input
3 4 11
4 2 5
4 4 5 4

Output
26

Input
2 2 50
5 7
4 2

Output
50



-----Note-----

In the first example test, you have $11$ bourles in the morning. It's optimal to buy $5$ shares of a stock at the price of $2$ bourles in the morning, and then to sell all of them at the price of $5$ bourles in the evening. It's easy to verify that you'll have $26$ bourles after the evening.

In the second example test, it's optimal not to take any action.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_bourles = r
    max_buy_price = max(buy_prices)
    min_sell_price = min(sell_prices)

    if max_buy_price >= min_sell_price:
        shares = r // max_buy_price
        max_bourles += (r - shares * max_buy_price) + shares * min_sell_price

    print(max_bourles)

solve()
","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_stock_price = max(buy_prices)
    min_sell_price = min(sell_prices)

    num_stocks_buyable = r // max_stock_price
    remaining_balance = r - num_stocks_buyable * max_stock_price
    total_balance_after_selling = num_stocks_buyable * min_sell_price + remaining_balance

    if total_balance_after_selling > r:
        print(total_balance_after_selling)
    else:
        print(r)

solve()","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_buy_price = max(buy_prices)
    min_sell_price = min(sell_prices)

    max_shares_buyable = r // max_buy_price
    remaining_amount = r - max_shares_buyable * max_buy_price

    total_bourles = max_shares_buyable * min_sell_price + remaining_amount

    if total_bourles > r:
        print(total_bourles)
    else:
        print(r)

solve()
","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))
    
    max_bourles = max(buy_prices)
    min_price = min(sell_prices)
    
    shares_bought = r // max_bourles
    remaining_bourles = r % max_bourles
    
    total_bourles = max(remaining_bourles + (shares_bought * min_price), r)
    
    print(total_bourles)

solve()","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_bourles = r
    min_buy_price = min(buy_prices)
    max_sell_price = max(sell_prices)

    shares_purchased = r // min_buy_price
    remaining_bourles = r % min_buy_price
    available_bourles = shares_purchased * max_sell_price + remaining_bourles

    max_bourles = max(max_bourles, available_bourles)
    
    print(max_bourles)

solve()
","
def solve():
    n, m, r = map(int, input().split())
    s = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    max_share_price = max(s)
    min_sell_price = min(b)
    
    shares_in_hand = r // max_share_price
    remaining_bourles = r - shares_in_hand * max_share_price
    
    total_bourles = shares_in_hand * min_sell_price + remaining_bourles
    
    print(max(total_bourles, r))

solve()","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))
    
    max_bourles = r
    max_buy_price = max(buy_prices)
    min_sell_price = min(sell_prices)
    
    shares_bought = (r // max_buy_price) * max_buy_price
    max_bourles += (r - shares_bought) + (shares_bought // max_buy_price) * min_sell_price
    
    print(max_bourles)

solve()
","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))
    
    max_buy_price = max(buy_prices)
    min_sell_price = min(sell_prices)
    
    stocks_owned = r // max_buy_price
    remaining_money = r - stocks_owned * max_buy_price
    
    total_money_after_sell = stocks_owned * min_sell_price + remaining_money
    
    if min_sell_price > max_buy_price:
        return total_money_after_sell
    else:
        return r

# Example usage:
# solve()
","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_bourles = 0
    shares_owned = 0

    while r > 0:
        shares_bought = r // buy_prices[min(buy_prices)]
        r += shares_bought * max(sell_prices) - shares_bought * buy_prices[min(buy_prices)]
        max_bourles = max(max_bourles, r)
        shares_owned += shares_bought

        buy_prices.remove(min(buy_prices))

    return max_bourles

solve()","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))
    
    max_selling_price = max(sell_prices)
    min_buying_price = min(buy_prices)
    
    shares_can_buy = r // min_buying_price
    remaining_bourles = r % min_buying_price
    
    total_bourles = max_selling_price * shares_can_buy + remaining_bourles
    
    if total_bourles > r:
        return total_bourles
    else:
        return r

solve()
","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_bourles = 0

    for i in range(n):
        stocks = r // buy_prices[i]
        remaining_bourles = r - (stocks * buy_prices[i])

        for j in range(m):
            new_bourles = stocks * sell_prices[j] + remaining_bourles
            if new_bourles > max_bourles:
                max_bourles = new_bourles

    print(max_bourles)

solve()
","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    min_buy_price = min(buy_prices)
    max_sell_price = max(sell_prices)

    stocks_bought = r // min_buy_price
    remaining_bourles = r % min_buy_price

    if max_sell_price > min_buy_price:
        total_bourles = stocks_bought * max_sell_price + remaining_bourles
    else:
        total_bourles = r

    print(total_bourles)

solve()
  ","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_bourles = r
    max_buy_price = max(buy_prices)
    min_sell_price = min(sell_prices)

    max_shares_buyable = max_bourles // max_buy_price
    remaining_bourles = max_bourles - max_shares_buyable * max_buy_price
    max_bourles_after_sell = remaining_bourles + max_shares_buyable * min_sell_price

    if max_bourles_after_sell > max_bourles:
        return max_bourles_after_sell
    else:
        return max_bourles

solve()","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))
    
    max_buy_price = max(buy_prices)
    min_sell_price = min(sell_prices)
    
    shares_bought = r // max_buy_price
    remaining_bourles = r % max_buy_price
    
    if min_sell_price > max_buy_price:
        remaining_bourles += shares_bought * (min_sell_price - max_buy_price)
    
    return remaining_bourles + shares_bought * min_sell_price

solve()
","
def solve():
    n, m, r = map(int, input().split())
    s = list(map(int, input().split()))
    b = list(map(int, input().split()))

    min_buy = min(s)
    max_sell = max(b)

    shares_bought = r // min_buy
    remaining_money = r - (shares_bought * min_buy)

    total_money = remaining_money + (shares_bought * max_sell)

    print(max(total_money, r))

solve()
","
def solve():
    n, m, r = map(int, input().split())
    buy_prices = list(map(int, input().split()))
    sell_prices = list(map(int, input().split()))

    max_buy = max(buy_prices)
    min_sell = min(sell_prices)

    shares_owned = r // max_buy
    remaining_balance = r % max_buy

    total_value = shares_owned * min_sell + remaining_balance

    if min_sell > max_buy:
        return total_value
    else:
        return r

solve()
  ","6.666666666666667","53.333333333333336","53.333333333333336","53.333333333333336","100.0","53.333333333333336","0.0","0.0","0.0","0.0","86.66666666666667","100.0","0.0","0.0","100.0","0.0","","","","","","","","","","","","","","","",""
"APPS/51","
QUESTION:
В Берляндском государственном университете локальная сеть между серверами не всегда работает без ошибок. При передаче двух одинаковых сообщений подряд возможна ошибка, в результате которой эти два сообщения сливаются в одно. При таком слиянии конец первого сообщения совмещается с началом второго. Конечно, совмещение может происходить только по одинаковым символам. Длина совмещения должна быть положительным числом, меньшим длины текста сообщения. 

Например, при передаче двух сообщений «abrakadabra» подряд возможно, что оно будет передано с ошибкой описанного вида, и тогда будет получено сообщение вида «abrakadabrabrakadabra» или «abrakadabrakadabra» (в первом случае совмещение произошло по одному символу, а во втором — по четырем).

По полученному сообщению t определите, возможно ли, что это результат ошибки описанного вида работы локальной сети, и если возможно, определите возможное значение s. 

Не следует считать ошибкой ситуацию полного наложения друга на друга двух сообщений. К примеру, если получено сообщение «abcd», следует считать, что в нём ошибки нет. Аналогично, простое дописывание одного сообщения вслед за другим не является признаком ошибки. Например, если получено сообщение «abcabc», следует считать, что в нём ошибки нет.


-----Входные данные-----

В единственной строке выходных данных следует непустая строка t, состоящая из строчных букв латинского алфавита. Длина строки t не превосходит 100 символов.


-----Выходные данные-----

Если сообщение t не может содержать ошибки, выведите «NO» (без кавычек) в единственную строку выходных данных.

В противном случае в первой строке выведите «YES» (без кавычек), а в следующей строке выведите строку s — возможное сообщение, которое могло привести к ошибке. Если возможных ответов несколько, разрешается вывести любой из них.


-----Примеры-----
Входные данные
abrakadabrabrakadabra

Выходные данные
YES
abrakadabra

Входные данные
acacacaca

Выходные данные
YES
acaca

Входные данные
abcabc

Выходные данные
NO

Входные данные
abababab

Выходные данные
YES
ababab

Входные данные
tatbt

Выходные данные
NO



-----Примечание-----

Во втором примере подходящим ответом также является строка acacaca.
Use user-input-Based format and function signature solve()","
def solve():
    t = input()
    n = len(t)
    
    for i in range(1, n):
        if t[:i] == t[i:2*i]:
            print(""YES"")
            print(t[:i])
            return
    
    print(""NO"")

solve()","
def solve():
    t = input()
    
    for i in range(1, len(t)):
        if t[i:] == t[:len(t)-i]:
            print(""YES"")
            print(t[:len(t)-i])
            return
    
    print(""NO"")

solve()
","
def solve():
    t = input()
    n = len(t)
    
    for i in range(1, n):
        if t[:i] == t[i:i*2]:
            print(""YES"")
            print(t[:i])
            return
    
    print(""NO"")
    
solve()
","
def solve():
    t = input()
    n = len(t)
    for i in range(1, n):
        prefix = t[:i]
        suffix = t[i:]
        if suffix[:len(prefix)] == prefix and len(suffix) == n - len(prefix):
            print(""YES"")
            print(prefix)
            return
    print(""NO"")

solve()
","
def solve():
    t = input()
    
    for i in range(1, len(t)):
        prefix = t[:i]
        suffix = t[i:]
        if suffix.startswith(prefix):
            return ""YES\n"" + prefix
    
    return ""NO""
  
solve()","
def solve():
    t = input()
    n = len(t)
    
    for i in range(1, n):
        if t[:i] == t[n-i:]:
            print(""YES"")
            print(t[:i])
            return
    
    print(""NO"")

solve()","
def solve():
    t = input()
    n = len(t)
    
    for i in range(1, n):
        if t[:i] == t[i:2*i]:
            print(""YES"")
            print(t[:i])
            return
            
    print(""NO"")

solve()
","
def solve():
    t = input()
    n = len(t)
    
    if n % 2 == 0 and t[:n//2] == t[n//2:]:
        print(""NO"")
    else:
        for i in range(1, n//2 + 1):
            if t[:i] == t[i:2*i]:
                print(""YES"")
                print(t[:i])
                break

solve()
","
def solve():
    t = input()
    n = len(t)
    
    for i in range(1, n):
        if t[:i] == t[i:i*2]:
            return ""YES\n"" + t[:i]
    
    return ""NO""

solve()
","
def solve():
    t = input()
    n = len(t)
    
    def check(s):
        m = len(s)
        for i in range(1, m):
            if s[i:] == s[:m-i]:
                return True
        return False
    
    if check(t):
        for i in range(1, n):
            if t[i:] == t[:n-i]:
                print(""YES"")
                print(t[:n-i])
                return
    
    print(""NO"")

solve()","
def solve():
    t = input().strip()

    def check_error_message(t, len_t, i):
        if len_t % 2 == 0 and t[:len_t // 2] == t[len_t // 2:]:
            return True
        for j in range(1, len_t):
            s = t[j:] + t[:j]
            if t == s:
                continue
            if s[:len_t // 2] == s[len_t // 2:]:
                return True
        return False

    len_t = len(t)
    if check_error_message(t, len_t, 0):
        print(""YES"")
        for i in range(1, len_t):
            s = t[i:] + t[:i]
            if t == s:
                continue
            if s[:len_t // 2] == s[len_t // 2:]:
                print(s)
                break
    else:
        print(""NO"")

solve()","
def solve():
    t = input().strip()
    
    for i in range(1, len(t)):
        prefix = t[:i]
        suffix = t[i:]
        if prefix == suffix:
            print(""YES"")
            print(prefix)
            return
    
    print(""NO"")

solve()
","
def solve():
    t = input().strip()
    
    for i in range(1, len(t) // 2 + 1):
        s = t[:i]
        double_s = s + s
        if double_s in t:
            error_message = t[len(double_s):]
            if error_message.startswith(s):
                print(""YES"")
                print(s)
                return
    
    print(""NO"")

solve()","
def solve():
    message = input()

    n = len(message)

    for i in range(1, n):
        if message[:i] == message[i:i*2]:
            print(""YES"")
            print(message[:i])
            return
    
    print(""NO"")

solve()
","
def solve():
    t = input()

    for i in range(1, len(t)):
        if t[:i] == t[i:i*2]:
            print(""YES"")
            print(t[:i])
            return

    print(""NO"")

solve()
","
def solve():
    t = input()
    n = len(t)
    
    for i in range(1, n):
        if t[:i] == t[i:i+i]:
            print(""YES"")
            print(t[:i])
            return
    
    print(""NO"")

solve()
  ","20.0","46.666666666666664","20.0","20.0","0.0","6.666666666666667","20.0","20.0","0.0","46.666666666666664","20.0","20.0","40.0","20.0","20.0","20.0","","","","","","","","","","","","","","","",""
"APPS/52","
QUESTION:
Daniel is organizing a football tournament. He has come up with the following tournament format:   In the first several (possibly zero) stages, while the number of teams is even, they split in pairs and play one game for each pair. At each stage the loser of each pair is eliminated (there are no draws). Such stages are held while the number of teams is even.  Eventually there will be an odd number of teams remaining. If there is one team remaining, it will be declared the winner, and the tournament ends. Otherwise each of the remaining teams will play with each other remaining team once in round robin tournament (if there are x teams, there will be $\frac{x \cdot(x - 1)}{2}$ games), and the tournament ends. 

For example, if there were 20 teams initially, they would begin by playing 10 games. So, 10 teams would be eliminated, and the remaining 10 would play 5 games. Then the remaining 5 teams would play 10 games in a round robin tournament. In total there would be 10+5+10=25 games.

Daniel has already booked the stadium for n games. Help him to determine how many teams he should invite so that the tournament needs exactly n games. You should print all possible numbers of teams that will yield exactly n games in ascending order, or -1 if there are no such numbers.


-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 10^18), the number of games that should be played.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.


-----Output-----

Print all possible numbers of invited teams in ascending order, one per line. If exactly n games cannot be played, output one number: -1.


-----Examples-----
Input
3

Output
3
4

Input
25

Output
20

Input
2

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    teams = set()
    
    for i in range(1, int((2 * n) ** 0.5) + 1):
        if (2 * n) % i == 0:
            x = (2 * n) // i
            if (x - i + 1) % 2 == 0 and (x - i + 1) // 2 > 0:
                teams.add((x - i + 1) // 2)
    
    if not teams:
        print(-1)
    else:
        for team in sorted(teams):
            print(team)

solve()
","
from math import isqrt

def solve():
    def possible_teams(games):
        if games == 1:
            return [1]
        result = []
        for k in range(2, isqrt(games * 2) + 1):
            if games % k == 0:
                rem = games // k
                if rem % 2 == 0:
                    if (k + rem) * (k // 2) == games:
                        result.append(k + rem)
        return result or [-1]

    n = int(input())
    result = possible_teams(n)
    for teams in result:
        print(teams)

# Testing the function
solve()
","
def solve():
    n = int(input().strip())
    teams = set()
    
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            a = i
            b = n // i
            
            if (a+b-1) % 2 == 0 and (b-a) % 4 == 0:
                k = (a+b-1) // 2
                teams.add(k)
    
    if len(teams) == 0:
        print(-1)
    else:
        teams = sorted(teams)
        for team in teams:
            print(team)

solve()","
def solve():
    n = int(input())
    
    factors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            factors.append(i)
            if i != n // i:
                factors.append(n // i)
    
    nums = []
    for f in factors:
        if f % 2 == 0:
            teams = f // 2
            games_count = teams * (teams + 1)
            if n == games_count:
                nums.append(f)
    
    if len(nums) == 0:
        print(-1)
    else:
        nums.sort()
        for num in nums:
            print(num)

solve()","
def solve():
    n = int(input())
    
    possible_teams = set()
    
    for teams in range(1, n+1):
        games = teams * (teams - 1) // 2 + (teams // 2)
        remaining_teams = teams
        while remaining_teams % 2 == 0 and games < n:
            games += remaining_teams // 2
            remaining_teams //= 2
        if games == n:
            possible_teams.add(teams)
    
    if not possible_teams:
        print(-1)
    else:
        for team in sorted(possible_teams):
            print(team)

solve()
","
def solve():
    n = int(input().strip())
    possible_teams = []
    
    for i in range(1, n + 1):
        total_games = 0
        teams_left = i
        while teams_left > 1:
            if teams_left % 2 == 0:
                total_games += teams_left // 2
                teams_left //= 2
            else:
                total_games += teams_left * (teams_left - 1) // 2
                teams_left = 1
        
        if total_games == n:
            possible_teams.append(i)
    
    if not possible_teams:
        print(-1)
    else:
        for team in possible_teams:
            print(team)

solve()
","
def solve():
    n = int(input())
    num_teams = []
    
    for i in range(1, n+1):
        total_games = i*(i-1)//2 + i//2
        if total_games == n:
            num_teams.append(i)
    
    if len(num_teams) == 0:
        print(-1)
    else:
        for team in num_teams:
            print(team)

solve()
","
def solve():
    n = int(input())
    teams = []
    
    for i in range(1, int((n ** 0.5) * 2) + 1):
        if n % i == 0:
            if n // i % 2 != i % 2:
                if i % 2 == 0:
                    teams.append(i // 2)
                else:
                    teams.append(i)
    
    teams.sort()
    
    if not teams:
        print(-1)
    else:
        for team in teams:
            print(team)

solve()
","
def solve():
    n = int(input())
    possible_teams = []

    for teams in range(1, int(((8 * n + 1) ** 0.5 - 1) / 2) + 1):
        if (teams * (teams - 1)) // 2 + teams == n:
            possible_teams.append(teams)

    if not possible_teams:
        print(-1)
    else:
        for teams in possible_teams:
            print(teams)

solve()
","
def solve():
    n = int(input())
    teams = set()
    for i in range(1, int((n*2)**0.5) + 1):
        if n % i == 0:
            rem = n // i
            if (i*(i-1)//2) + (rem*(rem-1)//2) == n:
                teams.add(i)
            if i != rem and (rem*(rem-1)//2) + (i*(i-1)//2) == n:
                teams.add(rem)
    if not teams:
        print(-1)
    else:
        for team in sorted(teams):
            print(team)

solve()
","
def solve():
    n = int(input())

    possible_teams = set()

    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            if (n // i % 2 == 1 and i % 2 == 0) or (i % 2 == 1 and (n // i) % 2 == 0):
                possible_teams.add(i)
            if (n // i % 2 == 1 and i % 2 == 0 and n // i != i) or (i % 2 == 1 and (n // i) % 2 == 0 and n // i != i):
                possible_teams.add(n // i)

    if not possible_teams:
        print(-1)
    else:
        for team in sorted(possible_teams):
            print(team)

solve()
","
def solve():
    n = int(input())
    teams = set()
    
    for i in range(1, n + 1):
        total_games = 0
        games = i
        
        while games % 2 == 0:
            total_games += games // 2
            games //= 2
        
        remaining_teams = i - (games // 2)
        if total_games + (remaining_teams * (remaining_teams - 1)) // 2 == n:
            teams.add(i)
    
    if not teams:
        teams.add(-1)
    
    for team in sorted(teams):
        print(team)

solve()
","
def solve():
    n = int(input().strip())
    
    teams = []
    
    for i in range(1, n):
        remaining_games = n
        current_teams = i
        while current_teams > 1 and remaining_games % 2 == 0:
            remaining_games /= 2
            current_teams /= 2
        if current_teams == 1 and int(remaining_games) == 1:
            teams.append(i)
    
    if not teams:
        print(-1)
    else:
        for team in teams:
            print(team)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    teams = set()
    
    for i in range(1, int(n ** 0.5) + 1):
        if (n - i*(i+1)//2) % i == 0:
            teams.add((n - i*(i+1)//2) // i + i)
            
    if not teams:
        print(-1)
    else:
        for team in sorted(teams):
            print(team)

solve()","
def solve():
    n = int(input())
    
    teams = []
    
    for x in range(1, 10**6):  # upper bound can be adjusted
        games = x * (x - 1) // 2 + x * (x // 2)
        
        if games == n:
            teams.append(x)
    
    if not teams:
        print(-1)
    else:
        teams.sort()
        for team in teams:
            print(team)

solve()
","
def solve():
    n = int(input())
    results = []
    
    for m in range(1, int((2 * n) ** 0.5) + 1):
        x = 2 * n // m - m + 1
        if x > 0 and x % 2 == 0:
            results.append(x // 2)
    
    if not results:
        print(-1)
    else:
        results.sort()
        for num_teams in results:
            print(num_teams)

solve()
","0.0","38.46153846153847","46.15384615384615","38.46153846153847","16.666666666666664","66.66666666666666","16.666666666666664","8.333333333333332","41.66666666666667","46.15384615384615","7.6923076923076925","33.33333333333333","41.66666666666667","8.333333333333332","46.666666666666664","0.0","","","","","","","","","","","","","","","",""
"APPS/53","
QUESTION:
A string a of length m is called antipalindromic iff m is even, and for each i (1 ≤ i ≤ m) a_{i} ≠ a_{m} - i + 1.

Ivan has a string s consisting of n lowercase Latin letters; n is even. He wants to form some string t that will be an antipalindromic permutation of s. Also Ivan has denoted the beauty of index i as b_{i}, and the beauty of t as the sum of b_{i} among all indices i such that s_{i} = t_{i}.

Help Ivan to determine maximum possible beauty of t he can get.


-----Input-----

The first line contains one integer n (2 ≤ n ≤ 100, n is even) — the number of characters in s.

The second line contains the string s itself. It consists of only lowercase Latin letters, and it is guaranteed that its letters can be reordered to form an antipalindromic string.

The third line contains n integer numbers b_1, b_2, ..., b_{n} (1 ≤ b_{i} ≤ 100), where b_{i} is the beauty of index i.


-----Output-----

Print one number — the maximum possible beauty of t.


-----Examples-----
Input
8
abacabac
1 1 1 1 1 1 1 1

Output
8

Input
8
abaccaba
1 2 3 4 5 6 7 8

Output
26

Input
8
abacabca
1 2 3 4 4 3 2 1

Output
17
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))

    s_dict = {}
    for char in s:
        if char in s_dict:
            s_dict[char] += 1
        else:
            s_dict[char] = 1

    max_beauty = 0
    for char, count in s_dict.items():
        max_beauty += min(count, 2) * b.count(char)

    print(max_beauty)

solve()
","
from itertools import permutations

def solve():
    n = int(input())
    s = input().strip()
    beauties = list(map(int, input().split()))
    
    max_beauty = 0
    for perm in permutations(sorted(set(s))):
        t = list(perm)
        for i in range(len(s) // 2):
            if t[i] == t[-(i+1)]:
                max_beauty = max_beauty
                break
            else:
                max_beauty += beauties[s.index(t[i])] + beauties[s.index(t[-(i+1)])]
    
    print(max_beauty)

solve()
","
def solve():
    import itertools
    
    n = int(input())
    s = input()
    b = list(map(int, input().split()))

    ans = 0
    for perm in itertools.permutations(s, n):
        flag = True
        for i in range(n//2):
            if perm[i] == perm[n-i-1]:
                flag = False
                break
        if flag:
            total_beauty = sum([b[i] for i in range(n) if perm[i] == s[i]])
            ans = max(ans, total_beauty)

    print(ans)

solve()
","
def solve():
    n = int(input())
    s = input()

    beauty = list(map(int, input().split()))

    beauty_sum = 0
    for i in range(n//2):
        if s[i] != s[n-1-i]:
            beauty_sum += max(beauty[i], beauty[n-1-i])

    print(beauty_sum)

solve()
","
from collections import defaultdict

def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))
    
    beauty_dict = defaultdict(int)
    for i, char in enumerate(s):
        beauty_dict[char] += b[i]
    
    max_beauty = sum(b)
    for char, beauty in beauty_dict.items():
        max_beauty -= max(0, beauty - beauty_dict[char[::-1]])
    
    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    s = input()
    beauties = list(map(int, input().split()))

    mid = n // 2
    indices_odd = [i for i in range(n) if i % 2 == 0]
    indices_even = [i for i in range(n) if i % 2 == 1]

    beauty_sum = sum([beauties[i] for i in indices_odd])
    max_beauty = beauty_sum

    for i in range(mid):
        if s[i] == s[n - i - 1]:
            max_beauty = max(max_beauty, beauty_sum - beauties[indices_odd[i]] + beauties[indices_even[i]])

    print(max_beauty)

solve()","
def solve():
    n = int(input())
    s = input()
    beauties = list(map(int, input().split()))

    beauty_total = 0
    for i in range(n // 2):
        if s[i] != s[n - i - 1]:
            beauty_total += max(beauties[i], beauties[n - i - 1])

    print(beauty_total)

solve()
","
def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))
    
    beauty = 0
    for i in range(n//2):
        if s[i] == s[n-1-i]:
            beauty += max(b[i], b[n-1-i])
        else:
            beauty += b[i] + b[n-1-i]
    
    print(beauty)

solve()
","
from itertools import permutations

def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))
    
    max_beauty = 0
    for perm in permutations(s):
        for i in range(n//2):
            if perm[i] == perm[n-i-1]:
                break
        else:
            beauty = sum(b[j] for j in range(n) if perm[j] == s[j])
            max_beauty = max(max_beauty, beauty)
    
    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    s = input()
    beauties = list(map(int, input().split()))
    
    beauties_dict = {}
    max_beauty = 0
    
    for i in range(n):
        if s[i] not in beauties_dict:
            beauties_dict[s[i]] = []
        beauties_dict[s[i]].append(beauties[i])
    
    for k, v in beauties_dict.items():
        v.sort(reverse=True)
    
    for i in range(n//2):
        max_beauty += max(beauties_dict[s[i]][0], beauties_dict[s[n-1-i]][0])
        beauties_dict[s[i]].pop(0)
        beauties_dict[s[n-1-i]].pop(0)
    
    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    s = input()
    beauties = list(map(int, input().split()))
    
    half_n = n // 2
    beauty_sum = 0
    
    for i in range(half_n):
        if s[i] == s[n - i - 1]:
            beauty_sum += max(beauties[i], beauties[n - i - 1])
        else:
            beauty_sum += beauties[i] + beauties[n - i - 1]
    
    print(beauty_sum)

solve()
","
def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))

    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1

    max_beauty = 0
    for char, beauty in zip(freq.keys(), sorted(b, reverse=True)):
        max_beauty += beauty * freq[char]

    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))
    
    s_set = set(s)
    beauty = 0
    for char in s_set:
        indices = [i for i, c in enumerate(s) if c == char]
        half_len = len(indices) // 2
        for i in range(half_len):
            beauty += max(b[indices[i]], b[indices[-i-1]])
    
    print(beauty)

solve()
","
def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))
    
    beauty = 0
    odd_letters = []
    even_letters = []
    
    for i in range(n):
        if i % 2 == 0:
            even_letters.append(b[i])
        else:
            odd_letters.append(b[i])
    
    beauty = sum(even_letters)
    
    print(beauty)


solve()
","
def solve():
    n = int(input())
    s = input()
    b = list(map(int, input().split()))
    
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1
    
    max_beauty = 0
    for char, count in freq.items():
        max_beauty += min(count, 2) * b[n // 2 - 1]
    
    print(max_beauty)

solve()
","
def solve():
    n = int(input())
    s = input()
    beauties = list(map(int, input().split()))

    s_dict = {}
    for char in s:
        if char in s_dict:
            s_dict[char] += 1
        else:
            s_dict[char] = 1

    max_beauty = 0
    for char, beauty in zip(s_dict.keys(), sorted(beauties, reverse=True)):
        max_beauty += beauty * s_dict[char]

    print(max_beauty)


solve()
","0.0","0.0","100.0","0.0","13.333333333333334","0.0","0.0","66.66666666666666","100.0","0.0","66.66666666666666","6.666666666666667","6.666666666666667","0.0","0.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/54","
QUESTION:
Vanya has a scales for weighing loads and weights of masses w^0, w^1, w^2, ..., w^100 grams where w is some integer not less than 2 (exactly one weight of each nominal value). Vanya wonders whether he can weight an item with mass m using the given weights, if the weights can be put on both pans of the scales. Formally speaking, your task is to determine whether it is possible to place an item of mass m and some weights on the left pan of the scales, and some weights on the right pan of the scales so that the pans of the scales were in balance.


-----Input-----

The first line contains two integers w, m (2 ≤ w ≤ 10^9, 1 ≤ m ≤ 10^9) — the number defining the masses of the weights and the mass of the item.


-----Output-----

Print word 'YES' if the item can be weighted and 'NO' if it cannot.


-----Examples-----
Input
3 7

Output
YES

Input
100 99

Output
YES

Input
100 50

Output
NO



-----Note-----

Note to the first sample test. One pan can have an item of mass 7 and a weight of mass 3, and the second pan can have two weights of masses 9 and 1, correspondingly. Then 7 + 3 = 9 + 1.

Note to the second sample test. One pan of the scales can have an item of mass 99 and the weight of mass 1, and the second pan can have the weight of mass 100.

Note to the third sample test. It is impossible to measure the weight of the item in the manner described in the input.
Use user-input-Based format and function signature solve()","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0 or m % w == 1:
            m //= w
        elif (m + 1) % w == 0:
            m = (m + 1) // w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        rem = m % w
        if rem == 1:
            m -= 1
        elif rem == 0:
            m //= w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()","
def solve():
    w, m = map(int, input().split())

    while m > 0:
        if m % w == 0:
            m //= w
        elif (m - 1) % w == 0:
            m = (m - 1) // w
        else:
            print(""NO"")
            return

    print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0 or m % w == 1:
            m //= w
        elif (m + 1) % w == 0:
            m = (m + 1) // w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0 or m % w == 1:
            m //= w
        elif m % w == w - 1:
            m = (m + 1) // w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0:
            m //= w
        elif (m - 1) % w == 0:
            m = (m - 1) // w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    if m == 1:
        print(""YES"")
    else:
        while m > 0:
            if m % w == 0:
                m //= w
            elif (m - 1) % w == 0:
                m = (m - 1) // w
            else:
                print(""NO"")
                return
        print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0 or m % w == 1:
            m //= w
        else:
            m = (m - 1) // w
    print(""YES"" if m == 0 else ""NO"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0 or m % w == 1:
            m = (m // w)
        elif m % w == w - 1:
            m = (m // w) + 1
        else:
            print('NO')
            return
    print('YES')

solve()
","
def solve():
    w, m = map(int, input().split())
    
    while m > 0:
        if m % w == 0:
            m //= w
        elif m % w == 1:
            m = (m - 1) // w
        else:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    w, m = map(int, input().split())
    
    while m > 0:
        if m % w == 1:
            m -= 1
        elif m % w == 0:
            m //= w
        else:
            print(""NO"")
            return

    print(""YES"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    w, m = map(int, input().split())
    if m == 1:
        print(""YES"")
    else:
        while m > 0:
            if m % w == 0 or m % w == 1:
                m //= w
            elif (m + 1) % w == 0:
                m = (m + 1) // w
            else:
                print(""NO"")
                return
        print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0 or m % w == 1:
            m //= w
        elif m % w == w - 1:
            m = (m + 1) // w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0:
            m /= w
        elif (m - 1) % w == 0:
            m = (m - 1) // w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m != 0:
        if m % w == 0 or m % w == 1:
            m //= w
        elif m % w == w - 1:
            m = (m + 1) // w
        else:
            print(""NO"")
            return
    print(""YES"")

solve()
","
def solve():
    w, m = map(int, input().split())
    while m > 0:
        if m % w == 0 or m % w == 1:
            m //= w
        elif w == 2:
            print(""NO"")
            return
        else:
            m = (m - 1) // w
    print(""YES"")

solve()","100.0","73.33333333333333","73.33333333333333","100.0","100.0","73.33333333333333","73.33333333333333","46.666666666666664","100.0","73.33333333333333","73.33333333333333","100.0","100.0","73.33333333333333","100.0","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/55","
QUESTION:
Jamie is preparing a Codeforces round. He has got an idea for a problem, but does not know how to solve it. Help him write a solution to the following problem:

Find k integers such that the sum of two to the power of each number equals to the number n and the largest integer in the answer is as small as possible. As there may be multiple answers, you are asked to output the lexicographically largest one. 

To be more clear, consider all integer sequence with length k (a_1, a_2, ..., a_{k}) with $\sum_{i = 1}^{k} 2^{a_{i}} = n$. Give a value $y = \operatorname{max}_{1 \leq i \leq k} a_{i}$ to each sequence. Among all sequence(s) that have the minimum y value, output the one that is the lexicographically largest.

For definitions of powers and lexicographical order see notes.


-----Input-----

The first line consists of two integers n and k (1 ≤ n ≤ 10^18, 1 ≤ k ≤ 10^5) — the required sum and the length of the sequence.


-----Output-----

Output ""No"" (without quotes) in a single line if there does not exist such sequence. Otherwise, output ""Yes"" (without quotes) in the first line, and k numbers separated by space in the second line — the required sequence.

It is guaranteed that the integers in the answer sequence fit the range [ - 10^18, 10^18].


-----Examples-----
Input
23 5

Output
Yes
3 3 2 1 0 

Input
13 2

Output
No

Input
1 2

Output
Yes
-1 -1 



-----Note-----

Sample 1:

2^3 + 2^3 + 2^2 + 2^1 + 2^0 = 8 + 8 + 4 + 2 + 1 = 23

Answers like (3, 3, 2, 0, 1) or (0, 1, 2, 3, 3) are not lexicographically largest.

Answers like (4, 1, 1, 1, 0) do not have the minimum y value.

Sample 2:

It can be shown there does not exist a sequence with length 2.

Sample 3:

$2^{-1} + 2^{-1} = \frac{1}{2} + \frac{1}{2} = 1$

Powers of 2:

If x > 0, then 2^{x} = 2·2·2·...·2 (x times).

If x = 0, then 2^{x} = 1.

If x < 0, then $2^{x} = \frac{1}{2^{-x}}$.

Lexicographical order:

Given two different sequences of the same length, (a_1, a_2, ... , a_{k}) and (b_1, b_2, ... , b_{k}), the first one is smaller than the second one for the lexicographical order, if and only if a_{i} < b_{i}, for the first i where a_{i} and b_{i} differ.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    if n % 2 == 1 and k == 1:
        print(""Yes"")
        print(n // 2)
    elif n % 2 == 0 and k == 1:
        print(""No"")
    else:
        if n % 2 == 1:
            print(""Yes"")
            print(""1 "" * (k - 1) + str(n - 2**(k-1)))
        else:
            if n < 2**k:
                print(""No"")
            else:
                binary = bin(n)[2:]
                if binary.count('1') > k:
                    print(""No"")
                else:
                    ans = [0] * k
                    for i in range(len(binary)):
                        if binary[-i-1] == '1':
                            ans.pop()
                            ans.append(i)
                    print(""Yes"")
                    print(*ans)

solve()","
def solve():
    n, k = map(int, input().split())
    if n % 2 == 0 and n // 2 >= 2**(k-1):
        ans = [0] * k
        curr = 2**(k-1)
        for i in range(k):
            while curr > n // 2:
                curr //= 2
            ans[i] = curr
            n -= curr
            curr *= 2
        if n == 0:
            print(""Yes"")
            print("" "".join(map(str, ans)))
        else:
            print(""No"")
    else:
        print(""No"")

solve()
","
python
from math import log2

def solve(n, k):
    if n == 1:
        if k == 1:
            print(""Yes"")
            print(0)
        else:
            print(""No"")
    else:
        max_power = int(log2(n))
        if max_power + 1 <= k:
            answer = [max_power] * k
            for i in range(k):
                if i < max_power:
                    answer[i] = i
            total = sum([2**x for x in answer])
            if total == n:
                print(""Yes"")
                print(*answer)
            else:
                print(""No"")
        else:
            print(""No"")

# Example function call
solve(23, 5)


solve()","
def solve(n: int, k: int) -> str:
    ans = []
    while n:
        p = n.bit_length() - 1
        ans.append(p)
        if p > k - 1:
            return ""No""
        n -= 2**p
        k -= 1
    if k < 0:
        return ""No""
    while len(ans) < k:
        ans.append(0)
    return ""Yes\n"" + "" "".join(map(str, ans[::-1]))

solve()","
def solve(n, k):
    if n < 2**k:
        return ""No""
    else:
        ans = [0] * k
        for i in range(k-1, -1, -1):
            cur = min(n - (2 ** i), 2 ** (k-1-i) - 1)
            ans[i] = cur
            n -= cur
        if n == 0:
            return ""Yes\n"" + ' '.join(map(str, ans))
        else:
            return ""No""

solve()","
def solve(n, k):
    ans = [0]*k
    for i in range(k):
        ans[i] = min(n, 2**(k-i)-1)
        n -= ans[i]
    
    if n == 0:
        print(""Yes"")
        print("" "".join(map(str, ans)))
    else:
        print(""No"")

# Example usage:
# solve(23, 5)

solve()","
def solve():
    n, k = map(int, input().split())
    
    if n < 2**k:
        print(""No"")
    else:
        result = [0] * k
        remaining_sum = n - k
        for i in range(k-1, -1, -1):
            for j in range(remaining_sum, -1, -1):
                if j + 2**i <= remaining_sum:
                    result[i] = i
                    remaining_sum -= 2**i
                    break
        print(""Yes"")
        print(*result)

solve()","
def solve(n, k):
    result = [0] * k
    remaining = n - k
    
    if remaining < 0 or bin(remaining).count('1') > k:
        print(""No"")
        return
    print(""Yes"")

    ones = bin(remaining)[2:]
    for i in range(len(ones)):
        if ones[i] == '1':
            result[k - i - 1] = i

    print(*result)

solve()","
def solve():
    from math import log2
    
    n, k = map(int, input().split())
    
    if n < k or k > int(log2(n)) + 1:
        print(""No"")
    else:
        print(""Yes"")
        res = [0] * k
        
        for i in range(k):
            res[i] = max(0, min(int(log2(n - (k - i - 1) * 2**i)), i))
        
        print(*res)

solve()
","
def solve():
    n, k = map(int, input().split())
    res = []
    while n > 0 and len(res) < k:
        max_pow = n.bit_length() - 1
        if (1 << max_pow) > n:
            max_pow -= 1
        res.append(max_pow)
        n -= 1 << max_pow
    if n == 0 and len(res) == k:
        print(""Yes"")
        print(*res)
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    result = [0] * k
    i = 0
    
    while n > 0 and i < k:
        next_power = 2 ** (n.bit_length() - 1)
        if next_power > n:
            next_power //= 2
        if next_power > n or next_power > (1 << i):
            print(""No"")
            return
        result[i] = n.bit_length() - 1
        n -= next_power
        i += 1
    
    if n == 0 and i == k:
        print(""Yes"")
        print("" "".join(map(str, result)))
    else:
        print(""No"")

solve()","
def solve(n, k):
    if n % 2 == 0:
        answer = [0] * k
        for i in range(k):
            exp = min(n.bit_length() - 1, k - i - 1)
            answer[i] = exp
            n -= 2**exp
        if n == 0:
            return ""Yes\n"" + "" "".join(map(str, answer))
    return ""No""
  
solve()","
def solve():
    import sys
    
    n, k = map(int, input().split())
    
    if n == 1:
        if k == 1:
            print(""Yes"")
            print(1)
        else:
            print(""No"")
    else:
        ans = []
        while n > 0:
            x = n.bit_length() - 1
            if x > k:
                print(""No"")
                sys.exit()
            n -= 2 ** x
            k -= 1
            ans.append(x)
        
        if k == 0:
            print(""Yes"")
            print(*[a for a in ans[::-1]])
        else:
            print(""No"")

solve()
","
from typing import List

def solve(n: int, k: int) -> List[int]:
    if n < 2**k:
        return [""No""]
    
    ans = [0] * k
    n -= k
    
    for i in range(k):
        p = min(n, k-i-1)
        ans[i] = 2**p
        n -= p
        
    return [""Yes"", ans[::-1]]

solve()","
def solve():
    n, k = map(int, input().split())

    if n == 1:
        if k == 1:
            print(""Yes"")
            print(0)
        else:
            print(""No"")
    else:
        powers = []
        i = 0
        while n > 0:
            if n % 2 == 1:
                powers.append(i)
            n //= 2
            i += 1

        if len(powers) > k:
            print(""No"")
        else:
            res = [0] * k
            for p in powers:
                res[p] = 1

            print(""Yes"")
            print("" "".join(str(x) for x in res[::-1]))

solve()
","
def solve():
    n, k = map(int, input().split())
    if n % 2 == 1 and k == 1:
        print(""Yes"")
        print(n - 1)
    elif 2**(k - 1) <= n < 2**k:
        a = [0] * k
        for i in range(k - 1, -1, -1):
            if n >= 2**i:
                n -= 2**i
                a[i] = i
        if n == 0:
            print(""Yes"")
            print(*a)
        else:
            print(""No"")
    else:
        print(""No"")
  
solve()","13.333333333333334","26.666666666666668","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","46.666666666666664","33.33333333333333","0.0","26.666666666666668","0.0","33.33333333333333","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/56","
QUESTION:
Mary has just graduated from one well-known University and is now attending celebration party. Students like to dream of a beautiful life, so they used champagne glasses to construct a small pyramid. The height of the pyramid is n. The top level consists of only 1 glass, that stands on 2 glasses on the second level (counting from the top), then 3 glasses on the third level and so on.The bottom level consists of n glasses.

Vlad has seen in the movies many times how the champagne beautifully flows from top levels to bottom ones, filling all the glasses simultaneously. So he took a bottle and started to pour it in the glass located at the top of the pyramid.

Each second, Vlad pours to the top glass the amount of champagne equal to the size of exactly one glass. If the glass is already full, but there is some champagne flowing in it, then it pours over the edge of the glass and is equally distributed over two glasses standing under. If the overflowed glass is at the bottom level, then the champagne pours on the table. For the purpose of this problem we consider that champagne is distributed among pyramid glasses immediately. Vlad is interested in the number of completely full glasses if he stops pouring champagne in t seconds.

Pictures below illustrate the pyramid consisting of three levels. [Image] [Image] 


-----Input-----

The only line of the input contains two integers n and t (1 ≤ n ≤ 10, 0 ≤ t ≤ 10 000) — the height of the pyramid and the number of seconds Vlad will be pouring champagne from the bottle.


-----Output-----

Print the single integer — the number of completely full glasses after t seconds.


-----Examples-----
Input
3 5

Output
4

Input
4 8

Output
6



-----Note-----

In the first sample, the glasses full after 5 seconds are: the top glass, both glasses on the second level and the middle glass at the bottom level. Left and right glasses of the bottom level will be half-empty.
Use user-input-Based format and function signature solve()","
def solve():
    n, t = map(int, input().split())
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    full_glasses = 0
    
    for i in range(n):
        for j in range(i + 1):
            overflow = max(0, glasses[i * (i + 1) // 2 + j] - 1)
            overflow /= 2
            glasses[i * (i + 1) // 2 + j] = 1
            glasses[(i + 1) * (i + 2) // 2 + j] += overflow
            glasses[(i + 1) * (i + 2) // 2 + j + 1] += overflow
            if i == n - 1 or glasses[i * (i + 1) // 2 + j] > 1:
                full_glasses += 1
    
    print(full_glasses)

solve()
","
def solve():
    n, t = map(int, input().split())
    
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    
    i = 0
    for _ in range(t):
        glasses_next = [0] * (n * (n + 1) // 2)
        for j in range(i + 1):
            if glasses[j] > 1:
                overflow = glasses[j] - 1
                excess = overflow / 2
                glasses_next[j] += excess
                glasses_next[j + i + 1] += excess
                glasses[j] = 1
        glasses = glasses_next
        i += 1
    
    result = glasses.count(1)
    print(result)

solve()
","
def solve():
    n, t = map(int, input().split())
    
    filled_glasses = 0
    pyramid = [[0] * i for i in range(1, n+1)]
    pyramid[0][0] = t
    
    for i in range(n-1):
        for j in range(len(pyramid[i])):
            overflow = max(0, pyramid[i][j] - 1)
            pyramid[i][j] -= overflow
            
            pyramid[i+1][j] += overflow / 2
            pyramid[i+1][j+1] += overflow / 2
            
    for i in range(n):
        for j in range(len(pyramid[i])):
            if pyramid[i][j] >= 1:
                filled_glasses += 1
    
    print(filled_glasses)

# Call the function to run the program
solve()
","
def solve():
    n, t = map(int, input().split())
    
    glasses = [0] * (n*(n+1)//2)
    glasses[0] = t
    
    changed = True
    while changed:
        changed = False
        for i in range(n*(n+1)//2):
            if glasses[i] > 1:
                overflow = glasses[i] - 1
                glasses[i] = 1
                if i + n < n*(n+1)//2:
                    glasses[i + n] += overflow / 2
                    glasses[i + n + 1] += overflow / 2
                changed = True
    
    return glasses.count(1)

solve()
","
def solve():
    n, t = map(int, input().split())
    
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    
    for i in range(n):
        temp = [0] * len(glasses)
        for j in range(len(glasses)):
            if glasses[j] > 1:
                overflow = glasses[j] - 1
                poured = overflow / 2
                temp[j] += poured
                temp[j + i + 1] += poured
                glasses[j] -= overflow
        glasses = temp
    
    full_glasses = sum(1 for x in glasses if x >= 1)
    print(full_glasses)

solve()
","
def solve():
    n, t = map(int, input().split())
    glasses = [0] * (n * (n+1) // 2)
    glasses[0] = t
    for i in range(n):
        for j in range(i + 1):
            extra = (glasses[i * (i+1) // 2 + j] - 1) / 2
            if extra > 0:
                glasses[i * (i+1) // 2 + j] = 1
                glasses[(i + 1) * (i + 2) // 2 + j] += extra
                glasses[(i + 1) * (i + 2) // 2 + j + 1] += extra
    return sum(1 for amount in glasses if amount >= 1)

solve()
  ","
def solve():
    n, t = map(int, input().split())

    pyramid = [[0] * n for _ in range(n)]
    pyramid[0][0] = t
    
    for i in range(n-1):
        for j in range(len(pyramid[i])):
            extra = (pyramid[i][j] - 1) / 2
            if extra > 0:
                pyramid[i+1][j] += extra
                pyramid[i+1][j+1] += extra

    result = sum(glass >= 1 for row in pyramid for glass in row)

    print(result)

solve()
","
def solve():
    n, t = map(int, input().split())
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    full_glasses = 0
    
    for i in range(n):
        for j in range(i + 1):
            overflow = max(glasses[i * (i + 1) // 2 + j] - 1, 0)
            half_overflow = overflow / 2
            glasses[i * (i + 1) // 2 + j] = 1
            if i + 1 < n:
                glasses[(i + 1) * (i + 2) // 2 + j] += half_overflow
                glasses[(i + 1) * (i + 2) // 2 + j + 1] += half_overflow
            else:
                full_glasses += 1
    
    print(full_glasses)

solve()","
def solve():
    n, t = map(int, input().split())

    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    full_glasses = 0

    for i in range(n):
        for j in range(i + 1):
            champagne = (glasses[i * (i + 1) // 2 + j] - 1) / 2
            if champagne > 0:
                glasses[i * (i + 1) // 2 + j] -= 2 * champagne
                glasses[(i + 1) * (i + 2) // 2 + j] += champagne
                glasses[(i + 1) * (i + 2) // 2 + j + 1] += champagne
                if glasses[i * (i + 1) // 2 + j] >= 1:
                    full_glasses += 1

    print(full_glasses)

solve()
","
def solve():
    n, t = map(int, input().split())
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    idx = 0
    for i in range(1, n):
        for j in range(i+1):
            x = max(0, (glasses[idx] - 1) / 2)
            glasses[idx] = 1 if glasses[idx] >= 1 else glasses[idx]
            glasses[idx + i] += x
            glasses[idx + i + 1] += x
            idx += 1
    return sum(1 for glass in glasses if glass >= 1)

solve()
","
def solve():
    n, t = map(int, input().split())

    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t  # First glass gets all the champagne

    for i in range(n):
        for j in range(i + 1):
            flow = (glasses[i * (i + 1) // 2 + j] - 1) / 2
            if flow > 0:
                glasses[i * (i + 1) // 2 + j] = 1
                glasses[(i + 1) * (i + 2) // 2 + j] += flow
                glasses[(i + 1) * (i + 2) // 2 + j + 1] += flow

    return sum(1 for x in glasses if x >= 1)


solve()
","
def solve():
    n, t = map(int, input().split())
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    i = 0
    
    for _ in range(t):
        for j in range(i + 1):
            overflow = max(glasses[i] - 1, 0)
            glasses[i] = max(glasses[i] - 1, 0)
            glasses[i + j] += overflow / 2
            glasses[i + j + 1] += overflow / 2
        
        i += 1
    
    full_glasses = sum(1 for glass in glasses if glass >= 1)
    print(full_glasses)

solve()
","
def solve():
    n, t = map(int, input().split())
    
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    full_glasses_count = 0
    
    for i in range(n):
        for j in range(i + 1):
            champagne_to_overflow = max(0, glasses[i*(i+1)//2 + j] - 1)
            overflow_champagne = champagne_to_overflow / 2
            glasses[i*(i+1)//2 + j] -= champagne_to_overflow
            glasses[(i+1)*(i+2)//2 + j] += overflow_champagne
            glasses[(i+1)*(i+2)//2 + j + 1] += overflow_champagne
            if champagne_to_overflow > 0:
                full_glasses_count += 1
        
    print(full_glasses_count)

solve()
","
def solve():
    n, t = map(int, input().split())
    glasses = min(t * (t + 1) / 2, n * (n + 1) / 2)
    for i in range(1, t + 1):
        next_glasses = [0] * (n + 1)
        for j in range(i):
            for k in range(n):
                if glasses[j][k] > 1:
                    excess = glasses[j][k] - 1
                    next_glasses[j+1][k] += excess / 2
                    next_glasses[j+1][k+1] += excess / 2
                    glasses[j][k] = 1
        glasses = next_glasses
    full_glasses = sum(glass == 1 for row in glasses for glass in row)
    print(full_glasses)

solve()
","
def solve():
    n, t = map(int, input().split())
    
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    
    full_glasses = 0
    for i in range(n):
        for j in range(i + 1):
            current = i * (i + 1) // 2 + j
            spreading = (glasses[current] - 1) / 2
            if spreading > 0:
                glasses[current] = 1
                glasses[current + i + 1] += spreading
                glasses[current + i + 2] += spreading
                full_glasses += 1
    
    print(full_glasses)

solve()
","
def solve():
    n, t = map(int, input().split())
    glasses = [0] * (n * (n + 1) // 2)
    glasses[0] = t
    for i in range(n):
        for j in range(i+1):
            overflow = max(0, glasses[i * (i + 1) // 2 + j] - 1)
            glasses[i * (i + 1) // 2 + j] = 1
            if overflow > 0:
                glasses[(i + 1) * (i + 2) // 2 + j] += overflow / 2
                glasses[(i + 1) * (i + 2) // 2 + j + 1] += overflow / 2
    return sum(1 for glass in glasses if glass >= 1)

solve()
","0.0","13.333333333333334","100.0","0.0","13.333333333333334","0.0","100.0","26.666666666666668","20.0","0.0","0.0","13.333333333333334","0.0","0.0","20.0","0.0","","","","","","","","","","","","","","","",""
"APPS/57","
QUESTION:
After making bad dives into swimming pools, Wilbur wants to build a swimming pool in the shape of a rectangle in his backyard. He has set up coordinate axes, and he wants the sides of the rectangle to be parallel to them. Of course, the area of the rectangle must be positive. Wilbur had all four vertices of the planned pool written on a paper, until his friend came along and erased some of the vertices.

Now Wilbur is wondering, if the remaining n vertices of the initial rectangle give enough information to restore the area of the planned swimming pool.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 4) — the number of vertices that were not erased by Wilbur's friend.

Each of the following n lines contains two integers x_{i} and y_{i} ( - 1000 ≤ x_{i}, y_{i} ≤ 1000) —the coordinates of the i-th vertex that remains. Vertices are given in an arbitrary order.

It's guaranteed that these points are distinct vertices of some rectangle, that has positive area and which sides are parallel to the coordinate axes.


-----Output-----

Print the area of the initial rectangle if it could be uniquely determined by the points remaining. Otherwise, print  - 1. 


-----Examples-----
Input
2
0 0
1 1

Output
1

Input
1
1 1

Output
-1



-----Note-----

In the first sample, two opposite corners of the initial rectangle are given, and that gives enough information to say that the rectangle is actually a unit square.

In the second sample there is only one vertex left and this is definitely not enough to uniquely define the area.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]
    
    if n == 1:
        print(-1)
    else:
        x_values = [point[0] for point in points]
        y_values = [point[1] for point in points]
        
        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)
        
        side1 = abs(max_x - min_x)
        side2 = abs(max_y - min_y)
        
        area = side1 * side2
        print(area if area > 0 else -1)

solve()","
def solve():
    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]
    
    if n == 1:
        print(-1)
        return
    
    x_values = set()
    y_values = set()
    for x, y in points:
        x_values.add(x)
        y_values.add(y)
    
    if n == 2:
        print((max(x_values) - min(x_values)) * (max(y_values) - min(y_values)))
    else:
        side1 = max(x_values) - min(x_values)
        side2 = max(y_values) - min(y_values)
        print(side1 * side2)

solve()
","
def solve():
    n = int(input())
    vertices = [list(map(int, input().split())) for _ in range(n)]

    if n == 1:
        print(-1)
    else:
        x_values = set()
        y_values = set()
        for vertex in vertices:
            x_values.add(vertex[0])
            y_values.add(vertex[1])

        if n == 2:
            print((max(x_values) - min(x_values)) * (max(y_values) - min(y_values)))
        else:
            print(-1)

if __name__ == ""__main__"":
    solve()
","
def solve():
    import itertools
    
    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]
    
    possible_sides = set()
    for pair in itertools.combinations(points, 2):
        possible_sides.add(abs(pair[0][0] - pair[1][0]))
        possible_sides.add(abs(pair[0][1] - pair[1][1]))
    
    if len(possible_sides) == 1:
        area = list(possible_sides)[0] ** 2
        print(area)
    else:
        print(-1)


solve()","
def solve():
    import math

    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]

    if n == 1:
        print(-1)
    else:
        x_values = sorted([p[0] for p in points])
        y_values = sorted([p[1] for p in points])

        length = abs(x_values[0] - x_values[-1])
        width = abs(y_values[0] - y_values[-1])

        area = length * width
        print(area)

solve()
","
def solve():
    import itertools

    n = int(input())
    vertices = [list(map(int, input().split())) for _ in range(n)]

    possible_combinations = itertools.combinations(vertices, 2)

    areas = set()
    for combination in possible_combinations:
        x1, y1 = combination[0]
        x2, y2 = combination[1]

        if x1 != x2 and y1 != y2:
            area = abs(x1 - x2) * abs(y1 - y2)
            areas.add(area)

    if len(areas) == 1:
        print(areas.pop())
    else:
        print(-1)

solve()","
def solve():
    from itertools import combinations

    n = int(input())
    vertices = []
    for _ in range(n):
        x, y = map(int, input().split())
        vertices.append((x, y))

    areas = set()
    for p1, p2 in combinations(vertices, 2):
        areas.add(abs(p1[0] - p2[0]) * abs(p1[1] - p2[1]))

    if len(areas) == 1:
        print(areas.pop())
    else:
        print(-1)

solve()","
def solve():
    from itertools import combinations

    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]

    areas = set()
    for perm in combinations(points, 2):
        areas.add(abs(perm[0][0] - perm[1][0]) * abs(perm[0][1] - perm[1][1]))

    if len(areas) == 1:
        print(areas.pop())
    else:
        print(-1)
  
solve()","
def solve():
    n = int(input())
    vertices = []
    
    for _ in range(n):
        x, y = map(int, input().split())
        vertices.append((x, y))
    
    if n == 1:
        print(-1)
    else:
        x_values = [x for x, y in vertices]
        y_values = [y for x, y in vertices]
        side_length_x = max(x_values) - min(x_values)
        side_length_y = max(y_values) - min(y_values)
        
        print(side_length_x * side_length_y)

solve()","
def solve():
    import itertools

    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]

    if n == 1:
        print(-1)
    else:
        possible_combinations = list(itertools.combinations(points, 2))
        distances = [(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) for p1, p2 in possible_combinations]
        if distances[0] == distances[1]:
            print(distances[0][0] * distances[0][1])
        else:
            print(-1)

solve()
","
def solve():
    import sys
    n = int(input())
    vertices = [tuple(map(int, input().split())) for _ in range(n)]

    if n == 1:
        print(-1)
    else:
        x_values = set()
        y_values = set()
        for x, y in vertices:
            x_values.add(x)
            y_values.add(y)
        
        if len(x_values) == 2 and len(y_values) == 2:
            side_1 = max(x_values) - min(x_values)
            side_2 = max(y_values) - min(y_values)
            print(side_1 * side_2)
        else:
            print(-1)

solve()
","
def solve():
    n = int(input())
    points = []
    for _ in range(n):
        x, y = map(int, input().split())
        points.append((x, y))
    
    if n == 1:
        print(-1)
    else:
        x_values = [point[0] for point in points]
        y_values = [point[1] for point in points]
        side1 = max(x_values) - min(x_values)
        side2 = max(y_values) - min(y_values)
        area = side1 * side2
        print(area if area > 0 else -1)

solve()
","
def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    
    if n == 1:
        print(-1)
    else:
        x_coords = set()
        y_coords = set()
        for x, y in points:
            x_coords.add(x)
            y_coords.add(y)
        
        if len(x_coords) == 2 and len(y_coords) == 2:
            side1 = abs(max(x_coords) - min(x_coords))
            side2 = abs(max(y_coords) - min(y_coords))
            print(side1 * side2)
        else:
            print(-1)

solve()
","
def solve():
    n = int(input())
    points = []
    for _ in range(n):
        x, y = map(int, input().split())
        points.append((x, y))
    
    if n == 1:
        print(""-1"")
    elif n == 2:
        print(abs(points[0][0] - points[1][0]) * abs(points[0][1] - points[1][1]))
    else:
        x_values = sorted([point[0] for point in points])
        y_values = sorted([point[1] for point in points])
        area = abs(x_values[0] - x_values[1]) * abs(y_values[0] - y_values[1])
        print(area)

solve()
","
def solve():
    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]

    if len(points) == 1:
        print(-1)
    else:
        x_coords = [point[0] for point in points]
        y_coords = [point[1] for point in points]
        side_length_x = max(x_coords) - min(x_coords)
        side_length_y = max(y_coords) - min(y_coords)
        area = side_length_x * side_length_y
        print(area if area > 0 else -1)

solve()","
def solve():
    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]
    
    if n == 1:
        print(-1)
    else:
        xs = sorted([point[0] for point in points])
        ys = sorted([point[1] for point in points])
        area = (xs[-1] - xs[0]) * (ys[-1] - ys[0])
        print(area)

solve()
","100.0","86.66666666666667","66.66666666666666","46.666666666666664","86.66666666666667","100.0","66.66666666666666","66.66666666666666","86.66666666666667","26.666666666666668","100.0","100.0","100.0","66.66666666666666","100.0","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/58","
QUESTION:
Petya has equal wooden bars of length n. He wants to make a frame for two equal doors. Each frame has two vertical (left and right) sides of length a and one top side of length b. A solid (i.e. continuous without breaks) piece of bar is needed for each side.

Determine a minimal number of wooden bars which are needed to make the frames for two doors. Petya can cut the wooden bars into any parts, but each side of each door should be a solid piece of a wooden bar (or a whole wooden bar).


-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 1 000) — the length of each wooden bar.

The second line contains a single integer a (1 ≤ a ≤ n) — the length of the vertical (left and right) sides of a door frame.

The third line contains a single integer b (1 ≤ b ≤ n) — the length of the upper side of a door frame.


-----Output-----

Print the minimal number of wooden bars with length n which are needed to make the frames for two doors.


-----Examples-----
Input
8
1
2

Output
1

Input
5
3
4

Output
6

Input
6
4
2

Output
4

Input
20
5
6

Output
2



-----Note-----

In the first example one wooden bar is enough, since the total length of all six sides of the frames for two doors is 8.

In the second example 6 wooden bars is enough, because for each side of the frames the new wooden bar is needed.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length = 2 * (a + b)
    bars_needed = total_length // n
    if total_length % n != 0:
        bars_needed += 1
    
    print(bars_needed)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length_needed = 4 * n - 2 * (a + b)
    
    if total_length_needed > 0:
        if total_length_needed % n == 0:
            return total_length_needed // n
        else:
            return total_length_needed // n + 1
    else:
        return 0
  
solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_sides_length = a * 4 + b * 2
    result = (total_sides_length + n - 1) // n
    
    print(result)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
	
    # Calculate the total length of all sides of two doors
    total_length = 2 * (a + b)
    
    # Calculate the minimal number of wooden bars needed
    bars_needed = total_length // n + (total_length % n > 0)
    
    print(bars_needed)

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length = 2 * a + 2 * b
    bars_needed = (2 * total_length + n - 1) // n
    
    print(bars_needed)
  
solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_sides = 12  # 6 sides per door
    needed_sides = 2 * (a + b)  # Total sides needed for 2 doors
    
    min_bars = (total_sides + needed_sides - 1) // n
    
    print(min_bars)

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    total_length = 2 * (2 * a + b)
    bars_needed = total_length // n
    if total_length % n != 0:
        bars_needed += 1

    print(bars_needed)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    min_bars = 0

    if n % a == 0 and n % b == 0:
        min_bars = (2 * (n // a)) + (n // b)
    else:
        if n >= a + b:
            min_bars = 2
        else:
            min_bars = n

    print(min_bars)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_sides_needed = 2 * ((a + b) // n) + 1 if (a + b) % n != 0 else 2 * ((a + b) // n)
    
    print(total_sides_needed)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length = 2 * a + 2 * b
    needed_bars = total_length // n
    if total_length % n != 0:
        needed_bars += 1
    
    print(needed_bars)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    total_length = 2 * (a + b)  # total length needed for 2 doors
    num_bars = total_length // n  # determine the minimal number of wooden bars required
    if total_length % n != 0:  # if there is a remainder, add an extra bar
        num_bars += 1

    print(num_bars)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length_per_door = 2*a + b
    total_length_for_both_doors = 2 * total_length_per_door
    
    bars_needed = total_length_for_both_doors // n
    if total_length_for_both_doors % n != 0:
        bars_needed += 1
    
    print(bars_needed)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length = 2 * n + 2 * a + 2 * b
    
    if total_length % n == 0:
        output = total_length // n
    else:
        output = total_length // n + 1
    
    return output

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length = 2 * n + 2 * a + b
    needed_bars = total_length // n
    if total_length % n != 0:
        needed_bars += 1
    
    print(needed_bars)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_length_sides = 2 * (n // a) + 2 * (n // b)
    
    if n % a != 0:
        total_length_sides += 2
    if n % b != 0:
        total_length_sides += 2
    
    print(total_length_sides // n)

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    total_sides = 8 * (a + b)
    
    bars_needed = total_sides // n
    if total_sides % n != 0:
        bars_needed += 1
    
    print(bars_needed)

solve()
","33.33333333333333","0.0","93.33333333333333","33.33333333333333","46.666666666666664","13.333333333333334","93.33333333333333","26.666666666666668","20.0","33.33333333333333","33.33333333333333","93.33333333333333","0.0","13.333333333333334","13.333333333333334","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/59","
QUESTION:
You have an array a consisting of n integers. Each integer from 1 to n appears exactly once in this array.

For some indices i (1 ≤ i ≤ n - 1) it is possible to swap i-th element with (i + 1)-th, for other indices it is not possible. You may perform any number of swapping operations any order. There is no limit on the number of times you swap i-th element with (i + 1)-th (if the position is not forbidden).

Can you make this array sorted in ascending order performing some sequence of swapping operations?


-----Input-----

The first line contains one integer n (2 ≤ n ≤ 200000) — the number of elements in the array.

The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 200000) — the elements of the array. Each integer from 1 to n appears exactly once.

The third line contains a string of n - 1 characters, each character is either 0 or 1. If i-th character is 1, then you can swap i-th element with (i + 1)-th any number of times, otherwise it is forbidden to swap i-th element with (i + 1)-th.


-----Output-----

If it is possible to sort the array in ascending order using any sequence of swaps you are allowed to make, print YES. Otherwise, print NO.


-----Examples-----
Input
6
1 2 5 3 4 6
01110

Output
YES

Input
6
1 2 5 3 4 6
01010

Output
NO



-----Note-----

In the first example you may swap a_3 and a_4, and then swap a_4 and a_5.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input().strip()

    for i in range(n - 1):
        if swaps[i] == '1' and a[i] > a[i + 1]:
            a[i], a[i + 1] = a[i + 1], a[i]

    if sorted(a) == a:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input()
    
    for i in range(n-1):
        if swaps[i] == '1' and a[i] > a[i+1]:
            a[i], a[i+1] = a[i+1], a[i]
    
    if sorted(a) == a:
        print(""YES"")
    else:
        print(""NO"")

solve()","
from collections import deque

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    s = input().strip()

    for i in range(len(s)):
        if s[i] == '1' and a[i] > a[i+1]:
            a[i], a[i+1] = a[i+1], a[i]

    sorted_a = deque(sorted(a))
    if all(x == y for x, y in zip(a, sorted_a)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input().strip()

    for i in range(n-1):
        if swaps[i] == '1' and a[i] > a[i+1]:
            a[i], a[i+1] = a[i+1], a[i]
    
    if a == sorted(a):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input().strip()
    
    for i in range(n-1):
        if a[i] > a[i+1] and swaps[i] == '0':
            print(""NO"")
            return
    
    print(""YES"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    s = input()
    
    for i in range(n-1):
        if s[i] == '1' and a[i] > a[i+1]:
            a[i], a[i+1] = a[i+1], a[i]
    
    if a == sorted(a):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swap_allowed = input().strip()

    for i in range(n-1):
        if swap_allowed[i] == '1' and a[i] > a[i+1]:
            a[i], a[i+1] = a[i+1], a[i]

    for i in range(n-1):
        if a[i] > a[i+1]:
            return 'NO'

    return 'YES'

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input().strip()

    for i in range(n - 1):
        if a[i] > a[i + 1] and swaps[i] == '0':
            print(""NO"")
            return

    print(""YES"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input()

    for i in range(n-1):
        if swaps[i] == '1' and a[i] > a[i+1]:
            a[i], a[i+1] = a[i+1], a[i]

    if sorted(a) == a:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    s = input()

    for i in range(n - 1):
        if s[i] == '1' and a[i] > a[i + 1]:
            a[i], a[i + 1] = a[i + 1], a[i]

    if sorted(a) == a:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
from typing import List

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    swaps = input().strip()

    for i in range(n - 1):
        if swaps[i] == '1' and arr[i] > arr[i + 1]:
            arr[i], arr[i + 1] = arr[i + 1], arr[i]

    if sorted(arr) == arr:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input()

    for i in range(n - 1):
        if swaps[i] == '1' and a[i] > a[i + 1]:
            a[i], a[i + 1] = a[i + 1], a[i]

    for i in range(n - 1):
        if a[i] > a[i + 1]:
            print(""NO"")
            return

    print(""YES"")

solve()
","
from collections import deque

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input().strip()

    visited = set()
    queue = deque([tuple(a)])

    while queue:
        current_arr = queue.popleft()
        if tuple(sorted(current_arr)) == tuple(range(1, n+1)):
            return ""YES""

        if current_arr in visited:
            continue

        visited.add(tuple(current_arr))

        for i in range(n - 1):
            if swaps[i] == '1' and current_arr[i] > current_arr[i + 1]:
                new_arr = current_arr[:]
                new_arr[i], new_arr[i + 1] = new_arr[i + 1], new_arr[i]
                queue.append(tuple(new_arr))

    return ""NO""

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    swaps = input().strip()

    for i in range(n - 1):
        if swaps[i] == '1' and a[i] > a[i + 1]:
            a[i], a[i + 1] = a[i + 1], a[i]

    if a == sorted(a):
        print('YES')
    else:
        print('NO')

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    s = input()

    for i in range(n-1):
        if s[i] == '1' and a[i] > a[i+1]:
            a[i], a[i+1] = a[i+1], a[i]

    if all(a[i] <= a[i + 1] for i in range(n - 1)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    operations = input().strip()
    
    for i in range(1, n):
        if operations[i-1] == '1':
            if a[i] < a[i-1]:
                a[i], a[i-1] = a[i-1], a[i]
    
    if sorted(a) == a:
        print(""YES"")
    else:
        print(""NO"")

solve()
","100.0","100.0","100.0","100.0","20.0","100.0","0.0","20.0","100.0","100.0","100.0","100.0","0.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/60","
QUESTION:
A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle.  [Image] 

 

It's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.

Flight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one — in seat 'c'. Assume that all seats are occupied.

Vasya has seat s in row n and wants to know how many seconds will pass before he gets his lunch.


-----Input-----

The only line of input contains a description of Vasya's seat in the format ns, where n (1 ≤ n ≤ 10^18) is the index of the row and s is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.


-----Output-----

Print one integer — the number of seconds Vasya has to wait until he gets his lunch.


-----Examples-----
Input
1f

Output
1

Input
2d

Output
10

Input
4a

Output
11

Input
5e

Output
18



-----Note-----

In the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.

In the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6 + 1 + 3 = 10.
Use user-input-Based format and function signature solve()","
def solve():
    seat = input()
    row = int(seat[:-1])
    seat_letter = seat[-1]

    row_time = (row - 1) // 2 * 6 + (row - 1) % 2
    seat_time = {'a': 4, 'b': 5, 'c': 6, 'd': 1, 'e': 2, 'f': 3}
    total_time = row_time + seat_time[seat_letter]

    print(total_time)

solve()","
def solve():
    seating = input()
    row = int(seating[:-1])
    seat = seating[-1]
    
    seconds = (row - 1) * 2 * 6
    
    if row % 2 == 0:
        seconds += 6
    if seat == 'e':
        seconds += 1
    elif seat == 'd':
        seconds += 2
    elif seat == 'c':
        seconds += 3
    print(seconds)

solve()","
def solve():
    seat_info = input()
    row_num = int(seat_info[:-1])
    seat_letter = seat_info[-1]
    
    seconds = (row_num - 1) // 2 * 6
    if row_num % 2 == 0:
        seconds += 4
    
    if seat_letter == 'b' or seat_letter == 'c':
        seconds += 1
    elif seat_letter == 'd' or seat_letter == 'e':
        seconds += 2
    elif seat_letter == 'f':
        seconds += 3
    
    print(seconds)

solve()
  ","
def solve():
    seat_map = {'a': 4, 'b': 5, 'c': 6, 'd': 1, 'e': 2, 'f': 3}
    
    seat_description = input().strip()
    row, seat = int(seat_description[:-1]), seat_description[-1]
    
    servings_per_group = 6 + 1
    group_num = (row - 1) // 2
    total_time = group_num * servings_per_group
    
    if (row % 2 == 0) and (seat in ['a', 'b', 'c']):
        total_time += 6
    else:
        total_time += seat_map[seat]
    
    print(total_time)

solve()
","
def solve():
    seat_desc = input()
    n, s = int(seat_desc[:-1]), seat_desc[-1]

    row_time = 4 * (n // 2) + (n % 2) - 2

    if n % 2 == 0:
        if s in 'abc':
            seat_time = 6
        elif s in 'def':
            seat_time = 1
        else:
            seat_time = 5 - ord(s) + 97
    else:
        if s in 'abc':
            seat_time = 1
        elif s in 'def':
            seat_time = 6
        else:
            seat_time = ord(s) - 99

    print(row_time + seat_time)

solve()
","
def solve():
    seat = input()
    row = int(seat[:-1])
    col = seat[-1]

    base = (row - 1) // 2 * 12
    pos_in_row = {'f': 1, 'e': 2, 'd': 3, 'a': 4, 'b': 5, 'c': 6}
    result = base + pos_in_row[col]
    result += 6 * ((row - 1) // 2)

    return result

solve()","
def solve():
    seat = input().strip()
    row = int(seat[:-1])
    seat_letter = seat[-1]

    rows_until_vasya = (row - 1) // 2
    total_seconds = (rows_until_vasya * 12)  # 6 seconds to serve each of the two rows
    total_seconds += rows_until_vasya  # 1 second to move one row forward for each pair of rows
    if row % 2 == 0:
        total_seconds += 6  # Extra 6 seconds if Vasya is in an even row
    total_seconds += (ord('c') - ord(seat_letter))  # Calculate the remaining seconds based on Vasya's seat
    print(total_seconds)

solve()
  ","
def solve():
    seat_description = input().strip()
    row, seat = int(seat_description[:-1]), seat_description[-1]

    time_to_first_attendant = row // 2 * 3 + (row % 2 == 0)
    serving_order = 'fedabc'
    time_to_vasya_seat = serving_order.index(seat) + 1

    total_time = time_to_first_attendant + 6 * (row // 2) + time_to_vasya_seat
    print(total_time)

solve()
","
def solve():
    seat_info = input()
    row_number, seat_letter = int(seat_info[:-1]), seat_info[-1]

    row_times = (row_number - 1) // 2
    seat_order = {'a': 6, 'b': 5, 'c': 4, 'd': 3, 'e': 2, 'f': 1}

    total_seconds = row_times * 6 + (row_times + 1) + seat_order[seat_letter]

    print(total_seconds)

solve()","
def solve():
    seat = input().strip()
    row = int(seat[:-1])
    seat_letter = seat[-1]

    position_in_row = {'a': 6, 'b': 5, 'c': 4, 'd': 3, 'e': 2, 'f': 1}

    total_seconds = (row - 1) // 2 * 7
    total_seconds += 1 + (position_in_row[seat_letter] - 1) + (row % 2)

    print(total_seconds)

solve()","
def solve():
    seat = input()
    n, s = int(seat[:-1]), seat[-1]
    
    row_number = (n + 1) // 2
    time_taken = (row_number - 1) * 3
    if n % 2 == 0:
        time_taken += 6 - (ord(s) - ord('a') + 1)
    else:
        time_taken += ord(s) - ord('a') + 1

    print(time_taken)

solve()
","
def solve():
    seat_code = input()
    row_index, seat_letter = int(seat_code[:-1]), seat_code[-1]
    
    row_offset = 2 * ((row_index - 1) // 3)
    seat_order = ['f', 'e', 'd', 'a', 'b', 'c']
    seat_index = seat_order.index(seat_letter)
    
    total_seconds = 6 * (row_index - 1) + row_offset + seat_index + 1
    print(total_seconds)

solve()","
def solve():
    seat_map = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
    row_map = {}
    for i in range(1, 7):
        row_map[i] = [1, 3]
    
    s = input().strip()
    n, s = int(s[:-1]), s[-1]
    
    target_row = row_map[seat_map[s]][0] + (n - 1) * 4
    target_seat = seat_map[s]
    
    time_passed = (target_row - 1) // 4 * 7
    time_passed += 2 if (target_row + 1) % 4 == 0 else 4
    time_passed += (target_seat - 1)
    
    print(time_passed)

solve()
","
def solve():
    seat = input()
    alphabet = ""abcdef""
    row, s = int(seat[:-1]), seat[-1]
    index = (row - 1) // 2

    if row % 2 == 0:
        idx = (alphabet.index(s) - alphabet.index('d')) + 1
        result = index * 12 + 6 + (3 - idx)
    else:
        idx = alphabet.index(s) + 1
        result = index * 12 + idx

    print(result)

solve()
","
def solve():
    seat = input()
    n, s = int(seat[:-1]), seat[-1]
    
    row_time = (n + 1) // 2
    seat_time = {'a': 4, 'b': 3, 'c': 2, 'd': 1, 'e': 0, 'f': 1}
    
    total_time = (row_time - 1) * 6 + seat_time[s] + (n % 2)
    
    print(total_time)

solve()","
def solve():
    seat = input()
    row, seat_letter = int(seat[:-1]), seat[-1]
    wait_time = ((row - 1) // 2) * 6
    if row % 2 == 0:
        wait_time += 3
    if seat_letter in ['e', 'd']:
        wait_time += 1
    elif seat_letter in ['c', 'b', 'a']:
        wait_time += 2
    print(wait_time)

solve()
","33.33333333333333","0.0","6.666666666666667","26.666666666666668","0.0","0.0","0.0","40.0","0.0","0.0","0.0","40.0","40.0","6.666666666666667","0.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/61","
QUESTION:
After seeing the ""ALL YOUR BASE ARE BELONG TO US"" meme for the first time, numbers X and Y realised that they have different bases, which complicated their relations.

You're given a number X represented in base b_{x} and a number Y represented in base b_{y}. Compare those two numbers.


-----Input-----

The first line of the input contains two space-separated integers n and b_{x} (1 ≤ n ≤ 10, 2 ≤ b_{x} ≤ 40), where n is the number of digits in the b_{x}-based representation of X. 

The second line contains n space-separated integers x_1, x_2, ..., x_{n} (0 ≤ x_{i} < b_{x}) — the digits of X. They are given in the order from the most significant digit to the least significant one.

The following two lines describe Y in the same way: the third line contains two space-separated integers m and b_{y} (1 ≤ m ≤ 10, 2 ≤ b_{y} ≤ 40, b_{x} ≠ b_{y}), where m is the number of digits in the b_{y}-based representation of Y, and the fourth line contains m space-separated integers y_1, y_2, ..., y_{m} (0 ≤ y_{i} < b_{y}) — the digits of Y.

There will be no leading zeroes. Both X and Y will be positive. All digits of both numbers are given in the standard decimal numeral system.


-----Output-----

Output a single character (quotes for clarity):   '<' if X < Y  '>' if X > Y  '=' if X = Y 


-----Examples-----
Input
6 2
1 0 1 1 1 1
2 10
4 7

Output
=

Input
3 3
1 0 2
2 5
2 4

Output
<

Input
7 16
15 15 4 0 0 7 10
7 9
4 8 0 3 1 5 0

Output
>



-----Note-----

In the first sample, X = 101111_2 = 47_10 = Y.

In the second sample, X = 102_3 = 21_5 and Y = 24_5 = 112_3, thus X < Y.

In the third sample, $X = FF 4007 A_{16}$ and Y = 4803150_9. We may notice that X starts with much larger digits and b_{x} is much larger than b_{y}, so X is clearly larger than Y.
Use user-input-Based format and function signature solve()","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    m, by = map(int, input().split())
    y = list(map(int, input().split()))

    X = sum([x[i] * (bx ** (n - i - 1)) for i in range(n)])
    Y = sum([y[i] * (by ** (m - i - 1)) for i in range(m)])

    if X < Y:
        print('<')
    elif X > Y:
        print('>')
    else:
        print('=')

solve()","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    x_val = sum(xi * (bx ** (n-i-1)) for i,xi in enumerate(x))

    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    y_val = sum(yi * (by ** (m-i-1)) for i,yi in enumerate(y))

    if x_val < y_val:
        return '<'
    elif x_val > y_val:
        return '>'
    else:
        return '='

solve()","
def solve():
    n, bx = map(int, input().split())
    X = int(''.join(input().split()), bx)
    m, by = map(int, input().split())
    Y = int(''.join(input().split()), by)
    
    if X < Y:
        print('<')
    elif X > Y:
        print('>')
    else:
        print('=')

solve()","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    
    val_x = 0
    for i in range(n):
        val_x += x[i] * (bx ** (n - i - 1))
    
    val_y = 0
    for i in range(m):
        val_y += y[i] * (by ** (m - i - 1))
    
    if val_x < val_y:
        return '<'
    elif val_x > val_y:
        return '>'
    else:
        return '='

solve()","
from typing import List

def solve() -> str:
    bx, x = map(int, input().split())
    digits_x = list(map(int, input().split()))
    
    by, y = map(int, input().split())
    digits_y = list(map(int, input().split()))
    
    def convert_to_decimal(digits: List[int], base: int) -> int:
        decimal_num = 0
        power = 1
        for digit in reversed(digits):
            decimal_num += digit * power
            power *= base
        return decimal_num
    
    decimal_x = convert_to_decimal(digits_x, bx)
    decimal_y = convert_to_decimal(digits_y, by)
    
    if decimal_x < decimal_y:
        return '<'
    elif decimal_x > decimal_y:
        return '>'
    else:
        return '='

# Example: 
# solve()
","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    m, by = map(int, input().split())
    y = list(map(int, input().split()))

    num_x = sum([x[i] * (bx ** (n - i - 1)) for i in range(n)])
    num_y = sum([y[i] * (by ** (m - i - 1)) for i in range(m)])

    if num_x < num_y:
        print('<')
    elif num_x > num_y:
        print('>')
    else:
        print('=')

solve()","
# Needed imports
from typing import List

# Function to compare numbers X and Y in different bases
def solve() -> str:
    # Input for X
    n, bx = map(int, input().split())
    digits_x = list(map(int, input().split()))

    # Input for Y
    m, by = map(int, input().split())
    digits_y = list(map(int, input().split()))

    # Convert X and Y to base 10
    x = sum(d * (bx**(n-i-1)) for i, d in enumerate(digits_x))
    y = sum(d * (by**(m-i-1)) for i, d in enumerate(digits_y))

    # Compare X and Y
    if x < y:
        return '<'
    elif x > y:
        return '>'
    else:
        return '='
  
solve()","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    
    val_x = sum([x[i] * bx**(n-i-1) for i in range(n)])
    val_y = sum([y[i] * by**(m-i-1) for i in range(m)])
    
    if val_x < val_y:
        return '<'
    elif val_x > val_y:
        return '>'
    else:
        return '='

solve()","
def solve():
    def convert_to_decimal(num_list, base):
        decimal_num = 0
        for i in range(len(num_list)):
            decimal_num += num_list[len(num_list)-1-i] * (base**i)
        return decimal_num
    
    n, bx = map(int, input().split())
    x_list = list(map(int, input().split()))
    m, by = map(int, input().split())
    y_list = list(map(int, input().split()))
    
    x_decimal = convert_to_decimal(x_list, bx)
    y_decimal = convert_to_decimal(y_list, by)
    
    if x_decimal < y_decimal:
        print('<')
    elif x_decimal > y_decimal:
        print('>')
    else:
        print('=')

solve()
","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    x_num = sum([x[i] * (bx ** (n - i - 1)) for i in range(n)])

    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    y_num = sum([y[i] * (by ** (m - i - 1)) for i in range(m)])

    if x_num < y_num:
        return '<'
    elif x_num > y_num:
        return '>'
    else:
        return '='

solve()
","
def solve():
    import sys
    input = sys.stdin.readline
    
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    x_val = sum(x[i] * (bx ** (n-1-i)) for i in range(n))
    
    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    y_val = sum(y[j] * (by ** (m-1-j)) for j in range(m))
    
    if x_val < y_val:
        return '<'
    elif x_val > y_val:
        return '>'
    else:
        return '='

solve()","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))

    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    
    x_value = sum(xi * (bx ** (n-i-1)) for i, xi in enumerate(x))
    y_value = sum(yi * (by ** (m-i-1)) for i, yi in enumerate(y))
    
    if x_value > y_value:
        print('>')
    elif x_value < y_value:
        print('<')
    else:
        print('=')

solve()
  ","
def solve():
    n, bx = map(int, input().split())
    X = sum([int(x) * (bx ** i) for i, x in enumerate(input().split()[::-1])])
    
    m, by = map(int, input().split())
    Y = sum([int(y) * (by ** i) for i, y in enumerate(input().split()[::-1])])
    
    if X < Y:
        print('<')
    elif X > Y:
        print('>')
    else:
        print('=')

solve()
","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    
    val_x = sum([x[i] * (bx ** (n - 1 - i)) for i in range(n)])
    val_y = sum([y[i] * (by ** (m - 1 - i)) for i in range(m)]
    
    if val_x < val_y:
        print('<')
    elif val_x > val_y:
        print('>')
    else:
        print('=')

solve()","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    
    m, by = map(int, input().split())
    y = list(map(int, input().split()))
    
    x_value = sum([x[i] * (bx ** (n - i - 1)) for i in range(n)])
    y_value = sum([y[i] * (by ** (m - i - 1)) for i in range(m)])
    
    if x_value < y_value:
        print('<')
    elif x_value > y_value:
        print('>')
    else:
        print('=')

solve()
","
def solve():
    n, bx = map(int, input().split())
    x = list(map(int, input().split()))
    m, by = map(int, input().split())
    y = list(map(int, input().split()))

    def convert_to_base_10(num, base):
        res = 0
        for i in range(len(num)):
            res += num[i] * base ** (len(num) - i - 1)
        return res

    X = convert_to_base_10(x, bx)
    Y = convert_to_base_10(y, by)

    if X < Y:
        print('<')
    elif X > Y:
        print('>')
    else:
        print('=')


solve()
  ","100.0","0.0","86.66666666666667","0.0","0.0","100.0","0.0","0.0","100.0","0.0","0.0","100.0","100.0","0.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/62","
QUESTION:
Since most contestants do not read this part, I have to repeat that Bitlandians are quite weird. They have their own jobs, their own working method, their own lives, their own sausages and their own games!

Since you are so curious about Bitland, I'll give you the chance of peeking at one of these games.

BitLGM and BitAryo are playing yet another of their crazy-looking genius-needed Bitlandish games. They've got a sequence of n non-negative integers a_1, a_2, ..., a_{n}. The players make moves in turns. BitLGM moves first. Each player can and must do one of the two following actions in his turn:

  Take one of the integers (we'll denote it as a_{i}). Choose integer x (1 ≤ x ≤ a_{i}). And then decrease a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x.  Choose integer x $(1 \leq x \leq \operatorname{min}_{i = 1} a_{i})$. And then decrease all a_{i} by x, that is, apply assignment: a_{i} = a_{i} - x, for all i. 

The player who cannot make a move loses.

You're given the initial sequence a_1, a_2, ..., a_{n}. Determine who wins, if both players plays optimally well and if BitLGM and BitAryo start playing the described game in this sequence.


-----Input-----

The first line contains an integer n (1 ≤ n ≤ 3).

The next line contains n integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} < 300).


-----Output-----

Write the name of the winner (provided that both players play optimally well). Either ""BitLGM"" or ""BitAryo"" (without the quotes).


-----Examples-----
Input
2
1 1

Output
BitLGM

Input
2
1 2

Output
BitAryo

Input
3
1 2 1

Output
BitLGM
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n == 1:
        if a[0] % 2 == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")
    else:
        xor_sum = 0
        for num in a:
            xor_sum ^= num
        
        if xor_sum == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n == 1:
        if a[0] % 2 == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")
    
    else:
        total_xor = 0
        for i in a:
            total_xor ^= i
        
        if total_xor == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    xor_sum = 0
    for num in a:
        xor_sum ^= num
    
    if xor_sum == 0 or n % 2 == 0:
        print(""BitAryo"")
    else:
        print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n == 1:
        if a[0] % 2 == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")
    else:
        if a[0] == 1 and a[1] == 1:
            print(""BitLGM"")
        else:
            print(""BitAryo"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    xor_sum = 0
    for i in range(len(a)):
        xor_sum ^= a[i]

    if xor_sum == 0:
        print(""BitAryo"")
    else:
        print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n == 1:
        if a[0] % 2 == 0:
            return ""BitAryo""
        else:
            return ""BitLGM""
    else:
        if min(a) % 2 == 0:
            return ""BitAryo""
        else:
            return ""BitLGM""

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    xor_sum = 0
    for num in a:
        xor_sum ^= num

    if xor_sum == 0 or n % 2 == 0:
        print(""BitAryo"")
    else:
        print(""BitLGM"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n == 1:
        if a[0] % 2 == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")
    else:
        if n == 2:
            if abs(a[0] - a[1]) % 2 == 0:
                print(""BitAryo"")
            else:
                print(""BitLGM"")
        else:
            if sum(a) % 2 == 0:
                print(""BitAryo"")
            else:
                print(""BitLGM"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n == 1:
        if a[0] % 2 == 0:
            return ""BitAryo""
        else:
            return ""BitLGM""
    else:
        if a[0] == a[1]:
            return ""BitAryo""
        else:
            return ""BitLGM""

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_xor = 0
    for num in a:
        total_xor ^= num
    
    if total_xor == 0 or n % 2 == 0:
        print(""BitAryo"")
    else:
        print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    xor_sum = 0
    for num in a:
        xor_sum ^= num

    if xor_sum == 0 or n % 2 == 0:
        print(""BitAryo"")
    else:
        print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n == 1:
        if a[0] == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")
    else:
        if min(a) % 2 == 0:
            print(""BitLGM"")
        else:
            print(""BitAryo"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n == 1:
        if a[0] % 2 == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")
    elif n == 2:
        if a[0] == a[1]:
            print(""BitLGM"")
        else:
            print(""BitAryo"")
    else:
        total_xor = 0
        for num in a:
            total_xor ^= num
        if total_xor != 0:
            print(""BitLGM"")
        else:
            print(""BitAryo"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n == 1:
        if a[0] % 2 == 0:
            print(""BitAryo"")
        else:
            print(""BitLGM"")
    else:
        if n % 2 == 0:
            print(""BitAryo"")
        else:
            xor = 0
            for num in a:
                xor ^= num
            if xor == 0:
                print(""BitAryo"")
            else:
                print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    xor_sum = 0
    for num in a:
        xor_sum ^= num
    
    if xor_sum == 0:
        print(""BitAryo"")
    else:
        print(""BitLGM"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n == 1:
        if a[0] % 2 == 0:
            return ""BitAryo""
        else:
            return ""BitLGM""
    else:
        total_sum = sum(a)
        max_num = max(a)
        
        if total_sum % 2 == 0:
            if max_num <= total_sum // 2:
                return ""BitLGM""
            else:
                return ""BitAryo""
        else:
            return ""BitLGM""

solve()","80.0","80.0","46.666666666666664","26.666666666666668","80.0","0.0","46.666666666666664","46.666666666666664","0.0","46.666666666666664","46.666666666666664","40.0","53.333333333333336","46.666666666666664","80.0","0.0","","","","","","","","","","","","","","","",""
"APPS/63","
QUESTION:
Vova again tries to play some computer card game.

The rules of deck creation in this game are simple. Vova is given an existing deck of n cards and a magic number k. The order of the cards in the deck is fixed. Each card has a number written on it; number a_{i} is written on the i-th card in the deck.

After receiving the deck and the magic number, Vova removes x (possibly x = 0) cards from the top of the deck, y (possibly y = 0) cards from the bottom of the deck, and the rest of the deck is his new deck (Vova has to leave at least one card in the deck after removing cards). So Vova's new deck actually contains cards x + 1, x + 2, ... n - y - 1, n - y from the original deck.

Vova's new deck is considered valid iff the product of all numbers written on the cards in his new deck is divisible by k. So Vova received a deck (possibly not a valid one) and a number k, and now he wonders, how many ways are there to choose x and y so the deck he will get after removing x cards from the top and y cards from the bottom is valid?


-----Input-----

The first line contains two integers n and k (1 ≤ n ≤ 100 000, 1 ≤ k ≤ 10^9).

The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the numbers written on the cards.


-----Output-----

Print the number of ways to choose x and y so the resulting deck is valid.


-----Examples-----
Input
3 4
6 2 8

Output
4

Input
3 6
9 1 14

Output
1



-----Note-----

In the first example the possible values of x and y are:

  x = 0, y = 0;  x = 1, y = 0;  x = 2, y = 0;  x = 0, y = 1.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    
    prefix_product = [1] * (n + 1)
    suffix_product = [1] * (n + 1)
    
    for i in range(1, n + 1):
        prefix_product[i] = prefix_product[i - 1] * cards[i - 1]
    
    for i in range(n - 1, -1, -1):
        suffix_product[i] = suffix_product[i + 1] * cards[i]
    
    count = 0
    for x in range(n + 1):
        for y in range(n + 1):
            if x + y <= n:
                if (prefix_product[x] * suffix_product[n - y]) % k == 0:
                    count += 1
    
    print(count)

solve()
","
def solve():
    from itertools import product

    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    count = 0
    for x, y in product(range(n + 1), range(n + 1)):
        if x + y < n and (x == 0 or y == 0):
            deck_product = 1
            for i in range(x, n - y):
                deck_product *= a[i]
            if deck_product % k == 0:
                count += 1

    print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_product = [1] * (n + 1)
    suffix_product = [1] * (n + 1)
    ans = 0
    
    for i in range(n):
        prefix_product[i + 1] = prefix_product[i] * a[i]
        
    for i in range(n, 0, -1):
        suffix_product[i - 1] = suffix_product[i] * a[i - 1]
        
    for x in range(n + 1):
        for y in range(n + 1):
            if x + y <= n:
                if (prefix_product[x] * suffix_product[n - y]) % k == 0:
                    ans += 1
                    
    print(ans)

solve()
","
def solve():
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    
    count_x = 0
    for i in range(n):
        if cards[i] % k == 0:
            count_x += 1
    
    prefix_mul = [1]
    for i in range(n):
        prefix_mul.append(prefix_mul[-1] * cards[i])
    
    suffix_mul = [1] * (n + 1)
    for i in range(n - 1, -1, -1):
        suffix_mul[i] = suffix_mul[i + 1] * cards[i]
    
    total_count = 0
    for x in range(n + 1):
        for y in range(n + 1):
            if x + y > n:
                break
            if (x > 0 and prefix_mul[x - 1] * suffix_mul[n - y] % k == 0) or (x == 0 and suffix_mul[n - y] % k == 0):
                total_count += 1
                
    print(total_count)

solve()
","
def solve():
    # Input handling
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))

    # Initialize count
    count = 0

    # Calculate cumulative product from left to right and right to left
    left_prod, right_prod = [1], [1]
    for num in cards:
        left_prod.append(left_prod[-1] * num)
    for num in reversed(cards):
        right_prod.append(right_prod[-1] * num)
    right_prod = list(reversed(right_prod))

    # Compute number of valid ways to choose x and y
    for x in range(n+1):
        for y in range(n+1):
            if x + y <= n:
                if (left_prod[x] * right_prod[y+n-x]) % k == 0:
                    count += 1

    # Output the result
    print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_prod = [1] * (n + 1)
    for i in range(1, n + 1):
        prefix_prod[i] = (prefix_prod[i - 1] * a[i - 1]) % k
    
    suffix_prod = 1
    valid_count = 0
    
    for i in range(n):
        suffix_prod = (suffix_prod * a[i]) % k
        if (prefix_prod[i] * suffix_prod) % k == 0:
            valid_count += 1
    
    print(valid_count)

solve()","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_prod = [1]
    current_prod = 1
    for num in a:
        current_prod *= num
        prefix_prod.append(current_prod)
    
    suffix_prod = [1]
    current_prod = 1
    for num in reversed(a):
        current_prod *= num
        suffix_prod.append(current_prod)
    suffix_prod = list(reversed(suffix_prod))
    
    valid_ways = 0
    for i in range(n):
        for j in range(i+1, n+1):
            if (prefix_prod[i] * suffix_prod[j]) % k == 0:
                valid_ways += 1
    
    print(valid_ways)

solve()","
def solve():
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    
    prefix_product = [1]
    suffix_product = [1]

    for c in cards:
        prefix_product.append((prefix_product[-1] * c) % k)

    for c in reversed(cards):
        suffix_product.insert(0, (suffix_product[0] * c) % k)

    count = 0

    for i in range(n):
        if (prefix_product[i] * suffix_product[i + 1]) % k == 0:
            count += 1

    print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix = [1]
    suffix = [1]
    for i in range(n):
        prefix.append(prefix[-1]*a[i])
        suffix.append(suffix[-1]*a[n-1-i])
    
    count = 0
    for x in range(n+1):
        for y in range(n+1):
            if x+y <= n:
                prod = prefix[x]*suffix[y]
                if prod % k == 0:
                    count += 1
    
    print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    res = 0
    prod = 1
    
    left_prods = [1]*n
    right_prods = [1]*n
    
    for i in range(n):
        prod = (prod * a[i]) % k
        left_prods[i] = prod

    prod = 1
    
    for i in range(n-1, -1, -1):
        prod = (prod * a[i]) % k
        right_prods[i] = prod
        
    for x in range(n):
        if left_prods[x] == 0:
            break
        for y in range(n):
            if x + y >= n:
                break
            right_prod = right_prods[x+y+1] if x+y+1 < n else 1
            if (left_prods[x]*right_prod) % k == 0:
                res += 1
                
    print(res)

solve()
","
def solve():
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    
    prefixes = [1]
    for card in cards:
        prefixes.append(prefixes[-1] * card)
    
    suffixes = [1]
    for card in cards[::-1]:
        suffixes.append(suffixes[-1] * card)
    suffixes = suffixes[::-1]
    
    count = 0
    for x in range(n+1):
        for y in range(n+1):
            if 0 <= x + 1 < len(prefixes) and 0 < len(suffixes) - y < len(prefixes):
                if prefixes[x] * suffixes[y] % k == 0:
                    count += 1
    
    print(count)

solve()
  ","
def solve():
    import math

    n, k = map(int, input().split())
    cards = list(map(int, input().split()))

    total_ways = 0
    product = 1

    right_prod = [0] * n
    left_prod = [0] * n

    for i in range(n):
        product *= cards[i]
        product %= k
        right_prod[i] = product

    product = 1
    for i in range(n - 1, -1, -1):
        product *= cards[i]
        product %= k
        left_prod[i] = product

    for i in range(n):
        if (i == 0):
            if (left_prod[i] % k == 0):
                total_ways += 1
        elif (right_prod[i - 1] % k == 0 or left_prod[i] % k == 0):
            total_ways += 1

    return total_ways


solve()","
def solve():
    import itertools
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    
    result = 0
    for x in range(n+1):
        for y in range(n+1):
            if x + y < n and (x != 0 or y != 0):
                prod = 1
                for num in itertools.islice(cards, x, n-y):
                    prod *= num
                if prod % k == 0:
                    result += 1
                
    print(result)

solve()
","
def solve():
    from collections import defaultdict
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    pref, suff = [1], [1]
    for x in a:
        pref.append(pref[-1]*x % k)
    for x in a[::-1]:
        suff.append(suff[-1]*x % k)
    suff = suff[::-1]
    cnt, res = defaultdict(int), 0
    for i in range(n):
        rem = i - suff[i]
        res += cnt[rem]
        cnt[pref[i]] += 1
    print(res)

solve()
","
def solve():
    # Input
    n, k = map(int, input().split())
    deck = list(map(int, input().split()))
    
    # Calculate the product of all numbers in the deck
    product = 1
    for num in deck:
        product *= num
    
    count = 0
    prefix_product = 1
    suffix_product = product
    
    # Check all possible ways to choose x and y
    for x in range(n):
        prefix_product *= (1 if x == 0 else deck[x-1])
        suffix_product = product // prefix_product
        
        while suffix_product % k == 0 and prefix_product % k == 0:
            count += 1
            suffix_product //= deck[n-1]
            n -= 1
            if n == x + 1:
                break
    
    print(count)

solve()","
def solve():
    import math

    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    prefix_product = [1] * (n + 1)
    for i in range(1, n + 1):
        prefix_product[i] = prefix_product[i - 1] * a[i - 1]

    ans = 0
    start_idx = 0
    end_idx = 0

    while end_idx <= n:
        curr_prod = prefix_product[end_idx] // prefix_product[start_idx]
        if curr_prod % k == 0:
            ans += n - end_idx
            start_idx += 1
        else:
            end_idx += 1

    print(ans)

solve()
","13.333333333333334","40.0","13.333333333333334","20.0","0.0","33.33333333333333","66.66666666666666","26.666666666666668","13.333333333333334","20.0","26.666666666666668","0.0","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/64","
QUESTION:
One day Kefa found n baloons. For convenience, we denote color of i-th baloon as s_{i} — lowercase letter of the Latin alphabet. Also Kefa has k friends. Friend will be upset, If he get two baloons of the same color. Kefa want to give out all baloons to his friends. Help Kefa to find out, can he give out all his baloons, such that no one of his friens will be upset — print «YES», if he can, and «NO», otherwise. Note, that Kefa's friend will not upset, if he doesn't get baloons at all.


-----Input-----

The first line contains two integers n and k (1 ≤ n, k ≤ 100) — the number of baloons and friends.

Next line contains string s — colors of baloons.


-----Output-----

Answer to the task — «YES» or «NO» in a single line.

You can choose the case (lower or upper) for each letter arbitrary.


-----Examples-----
Input
4 2
aabb

Output
YES

Input
6 3
aacaab

Output
NO



-----Note-----

In the first sample Kefa can give 1-st and 3-rd baloon to the first friend, and 2-nd and 4-th to the second.

In the second sample Kefa needs to give to all his friends baloons of color a, but one baloon will stay, thats why answer is «NO».
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    colors = input().strip()
    
    color_count = {}
    for color in colors:
        if color in color_count:
            color_count[color] += 1
        else:
            color_count[color] = 1
    
    for color in color_count:
        if color_count[color] > k:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    colors = input().strip()
    
    color_count = {}
    for color in colors:
        if color not in color_count:
            color_count[color] = 0
        color_count[color] += 1
    
    for count in color_count.values():
        if count > k:
            print(""NO"")
            return
    
    print(""YES"")

solve()
","
def solve():
    n, k = map(int, input().split())
    colors = input()
    
    color_count = {}
    for color in colors:
        if color in color_count:
            color_count[color] += 1
        else:
            color_count[color] = 1
    
    for count in color_count.values():
        if count > k:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    colors = input().strip()
    
    color_count = {}
    for color in colors:
        color_count[color] = color_count.get(color, 0) + 1
    
    max_baloons_per_color = max(color_count.values())
    
    if max_baloons_per_color > k:
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    colors = input()
    
    color_counts = {}
    for c in colors:
        if c in color_counts:
            color_counts[c] += 1
        else:
            color_counts[c] = 1
    
    max_baloon_per_friend = n // k
    for count in color_counts.values():
        if count > max_baloon_per_friend and count % k != 0:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    colors = input()
    
    color_count = {}
    for color in colors:
        if color in color_count:
            color_count[color] += 1
        else:
            color_count[color] = 1

    max_baloon_friends = 0
    for count in color_count.values():
        max_baloon_friends = max(max_baloon_friends, count)

    if max_baloon_friends <= k:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    s = input().strip()
    
    colors = {}
    for color in s:
        colors[color] = colors.get(color, 0) + 1
        
    max_baloons = max(colors.values())
    
    if max_baloons <= k:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    colors = input()
    
    color_counts = {}
    for color in colors:
        if color in color_counts:
            color_counts[color] += 1
        else:
            color_counts[color] = 1
    
    for color in color_counts:
        if color_counts[color] > k:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    colors = input()
    
    color_count = {}
    for color in colors:
        if color not in color_count:
            color_count[color] = 0
        color_count[color] += 1
    
    max_same_color_baloons = max(color_count.values())
    
    if max_same_color_baloons > k:
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    balloons = input()
    
    colors_count = {}
    for color in balloons:
        if color in colors_count:
            colors_count[color] += 1
        else:
            colors_count[color] = 1

    for count in colors_count.values():
        if count > k:
            print(""NO"")
            return
    
    print(""YES"")
  
solve()","
def solve():
    n, k = map(int, input().split())
    colors = input()
    
    color_freq = {}
    for color in colors:
        if color in color_freq:
            color_freq[color] += 1
        else:
            color_freq[color] = 1
    
    for freq in color_freq.values():
        if freq > k:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    colors = input()

    color_count = {}
    for color in colors:
        if color in color_count:
            color_count[color] += 1
        else:
            color_count[color] = 1

    for count in color_count.values():
        if count > k:
            print(""NO"")
            return

    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    s = input().strip()

    colors = {}
    for color in s:
        colors[color] = colors.get(color, 0) + 1

    for color, count in colors.items():
        if count > k:
            print(""NO"")
            return

    print(""YES"")

solve()
","
def solve():
    n, k = map(int, input().split())
    s = input().strip()
    
    colors = {}
    for color in s:
        if color in colors:
            colors[color] += 1
        else:
            colors[color] = 1
    
    for color, count in colors.items():
        if count > k:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    s = input().strip()
    
    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1

    for char in freq:
        if freq[char] > k:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    s = input()

    colors = {}
    for color in s:
        if color in colors:
            colors[color] += 1
        else:
            colors[color] = 1

    for color, count in colors.items():
        if count > k:
            print(""NO"")
            return

    print(""YES"")

solve()
","100.0","100.0","100.0","100.0","33.33333333333333","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/65","
QUESTION:
You are given an array of n integer numbers a_0, a_1, ..., a_{n} - 1. Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.


-----Input-----

The first line contains positive integer n (2 ≤ n ≤ 10^5) — size of the given array. The second line contains n integers a_0, a_1, ..., a_{n} - 1 (1 ≤ a_{i} ≤ 10^9) — elements of the array. It is guaranteed that in the array a minimum occurs at least two times.


-----Output-----

Print the only number — distance between two nearest minimums in the array.


-----Examples-----
Input
2
3 3

Output
1

Input
3
5 6 5

Output
2

Input
9
2 1 3 5 4 1 2 3 1

Output
3
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_val = min(arr)
    min_indices = [i for i, val in enumerate(arr) if val == min_val]
    
    min_dist = float('inf')
    for i in range(1, len(min_indices)):
        dist = min_indices[i] - min_indices[i-1]
        min_dist = min(min_dist, dist)
    
    print(min_dist)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_val = min(arr)
    min_indices = [i for i in range(n) if arr[i] == min_val]
    
    min_distance = float('inf')
    for i in range(1, len(min_indices)):
        min_distance = min(min_distance, min_indices[i] - min_indices[i-1])
    
    return min_distance

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    min_val = min(arr)
    min_indices = [i for i, x in enumerate(arr) if x == min_val]
    min_distances = [min_indices[i + 1] - min_indices[i] for i in range(len(min_indices) - 1)]
    print(min(min_distances))

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_val = min(a)
    min_indices = [i for i, val in enumerate(a) if val == min_val]
    
    min_distance = min_indices[-1] - min_indices[0]
    for i in range(len(min_indices) - 1):
        min_distance = min(min_distance, min_indices[i + 1] - min_indices[i])
    
    return min_distance

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_val = min(arr)
    min_indexes = [i for i, val in enumerate(arr) if val == min_val]
    
    min_distance = float('inf')
    for i in range(1, len(min_indexes)):
        min_distance = min(min_distance, min_indexes[i] - min_indexes[i-1])
    
    print(min_distance)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_val = min(arr)
    min_indices = [i for i, x in enumerate(arr) if x == min_val]
    
    min_distance = float('inf')
    for i in range(len(min_indices) - 1):
        distance = min_indices[i + 1] - min_indices[i]
        min_distance = min(min_distance, distance)
    
    print(min_distance)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_val = min(arr)
    min_indices = [i for i, x in enumerate(arr) if x == min_val]
    
    min_dist = float('inf')
    for i in range(1, len(min_indices)):
        min_dist = min(min_dist, min_indices[i] - min_indices[i-1])
    
    print(min_dist)

solve()
","
def solve():
    n = int(input())
    array = list(map(int, input().split()))
    min_indices = [i for i, num in enumerate(array) if num == min(array)]
    min_distances = [min_indices[i+1] - min_indices[i] for i in range(len(min_indices) - 1)]
    print(min(min_distances))

solve()
","
from collections import defaultdict

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_pos = defaultdict(list)
    min_dist = float('inf')

    for i in range(n):
        if arr[i] in min_pos:
            min_dist = min(min_dist, i - min_pos[arr[i]][-1])
            min_pos[arr[i]].append(i)
        else:
            min_pos[arr[i]] = [i]

    print(min_dist)

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_val = min(arr)
    min_index = [i for i, x in enumerate(arr) if x == min_val]
    
    min_distance = min(abs(min_index[i] - min_index[i+1]) for i in range(len(min_index)-1))
    
    print(min_distance)

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    min_val = min(arr)
    indices = [i for i, val in enumerate(arr) if val == min_val]
    min_distance = min(indices[i+1] - indices[i] for i in range(len(indices)-1))
    print(min_distance)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_val = float('inf')
    min_indices = []
    
    for i in range(n):
        if arr[i] < min_val:
            min_val = arr[i]
            min_indices = [i]
        elif arr[i] == min_val:
            min_indices.append(i)
            
    min_distance = float('inf')
    for i in range(len(min_indices) - 1):
        distance = min_indices[i+1] - min_indices[i]
        if distance < min_distance:
            min_distance = distance
            
    print(min_distance)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    min_val = min(arr)
    min_indices = [i for i, x in enumerate(arr) if x == min_val]

    min_dist = float('inf')
    for i in range(1, len(min_indices)):
        dist = min_indices[i] - min_indices[i-1]
        min_dist = min(min_dist, dist)
    
    print(min_dist)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    min_dist = float('inf')
    prev_min_idx = -1
    
    for i in range(n):
        if a[i] == min(a):
            if prev_min_idx != -1:
                min_dist = min(min_dist, i - prev_min_idx)
            prev_min_idx = i
    
    print(min_dist)

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    min_val = min(arr)
    min_indices = [i for i, x in enumerate(arr) if x == min_val]
    min_distances = [min_indices[i+1] - min_indices[i] for i in range(len(min_indices) - 1)]
    print(min(min_distances))

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_idx = [i for i, x in enumerate(arr) if x == min(arr)]
    
    min_dist = float('inf')
    for i in range(1, len(min_idx)):
        min_dist = min(min_dist, min_idx[i] - min_idx[i - 1])
    
    print(min_dist)

solve()","100.0","0.0","100.0","0.0","100.0","100.0","100.0","100.0","66.66666666666666","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/66","
QUESTION:
Vector Willman and Array Bolt are the two most famous athletes of Byteforces. They are going to compete in a race with a distance of L meters today.

 [Image] 

Willman and Bolt have exactly the same speed, so when they compete the result is always a tie. That is a problem for the organizers because they want a winner. 

While watching previous races the organizers have noticed that Willman can perform only steps of length equal to w meters, and Bolt can perform only steps of length equal to b meters. Organizers decided to slightly change the rules of the race. Now, at the end of the racetrack there will be an abyss, and the winner will be declared the athlete, who manages to run farther from the starting point of the the racetrack (which is not the subject to change by any of the athletes). 

Note that none of the athletes can run infinitely far, as they both will at some moment of time face the point, such that only one step further will cause them to fall in the abyss. In other words, the athlete will not fall into the abyss if the total length of all his steps will be less or equal to the chosen distance L.

Since the organizers are very fair, the are going to set the length of the racetrack as an integer chosen randomly and uniformly in range from 1 to t (both are included). What is the probability that Willman and Bolt tie again today?


-----Input-----

The first line of the input contains three integers t, w and b (1 ≤ t, w, b ≤ 5·10^18) — the maximum possible length of the racetrack, the length of Willman's steps and the length of Bolt's steps respectively.


-----Output-----

Print the answer to the problem as an irreducible fraction [Image]. Follow the format of the samples output.

The fraction [Image] (p and q are integers, and both p ≥ 0 and q > 0 holds) is called irreducible, if there is no such integer d > 1, that both p and q are divisible by d.


-----Examples-----
Input
10 3 2

Output
3/10

Input
7 1 2

Output
3/7



-----Note-----

In the first sample Willman and Bolt will tie in case 1, 6 or 7 are chosen as the length of the racetrack.
Use user-input-Based format and function signature solve()","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    
    lcm = w * b // math.gcd(w, b)
    total_possible_steps = t // lcm
    total_tie_steps = min(w, b) - 1
    total_tie_steps += total_possible_steps * min(w, b)
    
    gcd = math.gcd(total_tie_steps, t)
    result = Fraction(total_tie_steps // gcd, t // gcd)
    
    print(result)

solve()","
def solve():
    from fractions import Fraction

    t, w, b = map(int, input().split())

    gcd = w*b
    lcm = (w*b)//math.gcd(w, b)

    # The number of possible winning positions is the minimum between t and the distance both athletes can travel
    win_pos = min(t, lcm - 1)

    # Calculate the common winning positions for Willman and Bolt
    common_win_pos = t // lcm

    # Calculate the remainder positions for Bolt
    rem_pos_bolt = min(t % lcm, b - 1)

    # Calculate the remainder positions for Willman
    rem_pos_willman = min(t % lcm, w - 1)

    # Calculate the total winning positions for Bolt and Willman
    total_win_pos = common_win_pos * min(w, b) + rem_pos_bolt + rem_pos_willman

    # Calculate the probability of a tie
    probability = Fraction(total_win_pos, t)

    # Simplify the fraction
    probability = probability.limit_denominator()

    # Print the result
    print(probability)

solve()","
def solve():
    # Input
    t, w, b = map(int, input().split())
    
    # Find the least common multiple of w and b
    lcm = w * b
    for i in range(1, max(w, b)+1):
        if (lcm * i) % w == 0 and (lcm * i) % b == 0:
            lcm = lcm * i
            break
            
    # Calculate the number of intersections where they tie
    common_multiple = t // lcm
           
    # Output
    print(str(common_multiple * min(w,b) + min(t%lcm + 1, min(w,b))) + '/' + str(t))

solve()","
def solve():
    import fractions

    t, w, b = map(int, input().split())

    lcm = w * b // fractions.gcd(w, b)

    full_cycles = t // lcm
    result = full_cycles * min(w, b) + min(t % lcm + 1, min(w, b))

    common_divisor = fractions.gcd(result, t)
    result, t = result // common_divisor, t // common_divisor

    print(f""{result}/{t}"")

solve()
","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    
    lcm = (w * b) // math.gcd(w, b)
    common_divisor = t // lcm
    
    willman_steps = common_divisor * w
    bolt_steps = common_divisor * b
    
    max_steps = min(willman_steps + w - 1, bolt_steps + b - 1)
    min_steps = max(willman_steps, bolt_steps)
    
    if max_steps >= min_steps:
        total_steps = max_steps - min_steps + 1
    else:
        total_steps = 0
    
    total_possible_steps = t - lcm * common_divisor
    
    probability = Fraction(total_steps, total_possible_steps)
    
    print(probability.numerator, '/', probability.denominator)


solve()","
def solve():
    from fractions import Fraction

    t, w, b = map(int, input().split())

    gcd = w*b
    lcm = w*b // gcd

    min_steps = max(w, b)
    additional_steps = t // lcm

    total_steps = min_steps + min_steps * additional_steps
    common_divisor = total_steps // gcd

    result = Fraction(common_divisor, t)

    print(result)

solve()
","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    
    lcm = w*b // math.gcd(w, b)
    total_steps = t // lcm
    same_position = min(w, b) - 1
    result = min(t, total_steps*same_position + min(total_steps + 1, t % lcm))
    
    fraction = Fraction(result, t)
    print(f""{fraction.numerator}/{fraction.denominator}"")

solve()
","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    gcd = w * b
    lcm = (w*b)//gcd
    intervals = t//lcm
    common_length = min(w, b) + intervals * lcm
    remaining = min(t, common_length)
    
    numerator = 0
    if remaining >= max(w, b):
        numerator = min(remaining - min(w, b) + 1, max(w, b))
    
    denominator = t
    
    print(Fraction(numerator, denominator))

solve()
","
def solve():
    import math

    t, w, b = map(int, input().split())
    
    common_multiple = (w*b) // math.gcd(w, b)
    common_divisor = min(w, b)
    
    full_intervals = t // common_multiple
    remainder_w = min(t % w, w-(common_multiple % w))
    remainder_b = min(t % b, b-(common_multiple % b))
    
    total_ties = full_intervals*common_divisor + min(remainder_w, remainder_b) - 1
    
    gcd = math.gcd(total_ties, t)
    
    print(f'{total_ties // gcd}/{t // gcd}')

solve()","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    gcd_steps = w + b - 1
    lcm_steps = w * b // gcd_steps
    total_probable_steps = min(t // w, t // b)
    
    if w > b:
        w, b = b, w
    
    common_steps = t // (w + b)
    common_length = common_steps * (w + b)
    remaining_steps = total_probable_steps - 2 * common_steps
    
    if remaining_steps <= 0:
        repeat_intersect = 0
    else:
        repeat_intersect = min(remaining_steps, t - common_length - remaining_steps + 1)
    
    total_intersect = common_steps + repeat_intersect
    total_probable_length = total_probable_steps * (w + b)
    
    gcd_probability = total_probable_length // gcd_steps
    lcm_probabilty = total_probable_length // lcm_steps
    result_fraction = 1 - common_steps + total_intersect + gcd_probability - lcm_probabilty
    
    print(Fraction(result_fraction, total_probable_steps).limit_denominator())

solve()","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    
    gcd = t // (w * b)
    lcm = w * b
    lcm = lcm // gcd
    
    min_steps = min(w, b)
    
    max_steps = min(w, b) * (t // min(w, b))
    
    total_steps = min_steps * (t // min_steps)
    
    common_steps = min(max_steps, total_steps)
    
    if common_steps == 0:
        print(""0/1"")
    else:
        result = Fraction(common_steps, t)
        print(result.numerator, ""/"", result.denominator)


solve()
","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    
    gcd_steps = w // math.gcd(w, b) * b
    lcm_steps = w * b // math.gcd(w, b)
    
    total_ties = (t // lcm_steps) * min(w, b) + min(t % lcm_steps + 1, min(w, b))
    
    total_length = min(t, w, b)
    
    gcd_ties = total_length // gcd_steps + 1
    
    total_prob_ties = Fraction(total_ties, t) * gcd_ties
    
    print(total_prob_ties.numerator, '/', total_prob_ties.denominator)

solve()
","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    
    gcd_wb = w * b // math.gcd(w, b)
    
    max_possible_positions = t - min(w, b)
    
    num_positions = max_possible_positions // gcd_wb
    
    total_positions = max(t // w, t // b)
    
    if w > b:
        num_positions -= (t // w - num_positions)
    else:
        num_positions -= (t // b - num_positions)
    
    total_positions -= num_positions
    
    result = Fraction(num_positions, total_positions)
    
    print(result.numerator, '/', result.denominator)
  
solve()","
from fractions import Fraction

def solve(t: int, w: int, b: int) -> str:
    gcd = w * b
    lcm = w * b // gcd
    count_divisible = t // lcm
    common_divisible = count_divisible * gcd
    remaining_length = t - count_divisible * lcm
    common_remaining = min(t - common_divisible, remaining_length)
    result = common_divisible + common_remaining
    return f""{result}/{t}""

solve()","
from fractions import Fraction

def solve():
    t, w, b = map(int, input().split())
    
    # Find the least common multiple of w and b
    lcm = w * b // math.gcd(w, b)
    
    # Find the number of steps each athlete can take within range [1, t]
    steps_w = t // w
    steps_b = t // b
    
    # Find the number of common steps both athletes can take within range [1, t]
    common_steps = t // lcm
    
    # Calculate the probability of a tie
    probability = 1 - ((steps_w + steps_b - common_steps) / t)
    
    fraction = Fraction(probability).limit_denominator()
    
    print(f""{fraction.numerator}/{fraction.denominator}"")


solve()","
def solve():
    from fractions import Fraction
    
    t, w, b = map(int, input().split())
    
    gcd = w // (w, b)[w < b]
    lcm = w * b // gcd
    
    common_steps = t // lcm
    remaining_steps = min(w, b) - 1
    
    total_possible_steps = common_steps * min(w, b) + min(common_steps * lcm + remaining_steps, t) - common_steps * lcm
    
    total_possible_steps_gcd = total_possible_steps // gcd
    t_gcd = t // gcd
    
    tie_probability = Fraction(total_possible_steps_gcd, t_gcd)
    
    print(f'{tie_probability.numerator}/{tie_probability.denominator}')

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","0.0","80.0","","","","","","","","","","","","","","","",""
"APPS/67","
QUESTION:
Nauuo is a girl who loves writing comments.

One day, she posted a comment on Codeforces, wondering whether she would get upvotes or downvotes.

It's known that there were $x$ persons who would upvote, $y$ persons who would downvote, and there were also another $z$ persons who would vote, but you don't know whether they would upvote or downvote. Note that each of the $x+y+z$ people would vote exactly one time.

There are three different results: if there are more people upvote than downvote, the result will be ""+""; if there are more people downvote than upvote, the result will be ""-""; otherwise the result will be ""0"".

Because of the $z$ unknown persons, the result may be uncertain (i.e. there are more than one possible results). More formally, the result is uncertain if and only if there exist two different situations of how the $z$ persons vote, that the results are different in the two situations.

Tell Nauuo the result or report that the result is uncertain.


-----Input-----

The only line contains three integers $x$, $y$, $z$ ($0\le x,y,z\le100$), corresponding to the number of persons who would upvote, downvote or unknown.


-----Output-----

If there is only one possible result, print the result : ""+"", ""-"" or ""0"".

Otherwise, print ""?"" to report that the result is uncertain.


-----Examples-----
Input
3 7 0

Output
-
Input
2 0 1

Output
+
Input
1 1 0

Output
0
Input
0 0 1

Output
?


-----Note-----

In the first example, Nauuo would definitely get three upvotes and seven downvotes, so the only possible result is ""-"".

In the second example, no matter the person unknown downvotes or upvotes, Nauuo would get more upvotes than downvotes. So the only possible result is ""+"".

In the third example, Nauuo would definitely get one upvote and one downvote, so the only possible result is ""0"".

In the fourth example, if the only one person upvoted, the result would be ""+"", otherwise, the result would be ""-"". There are two possible results, so the result is uncertain.
Use user-input-Based format and function signature solve()","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()","
def solve():
    x, y, z = map(int, input().split())
    if x > y + z:
        print('+')
    elif y > x + z:
        print('-')
    elif x == y and z == 0:
        print('0')
    else:
        print('?')

solve()","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()","
def solve():
    x, y, z = map(int, input().split())
    diff = x - y

    if z == 0:
        if diff > 0:
            print(""+"")
        elif diff < 0:
            print(""-"")
        else:
            print(""0"")
    else:
        if diff + z > 0:
            print(""+"")
        elif diff + z < 0:
            print(""-"")
        else:
            print(""?"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    x, y, z = map(int, input().split())
    
    if x + z > y and y + z > x:
        print('?')
    elif x + z > y:
        print('+')
    elif y + z > x:
        print('-')
    else:
        print('0')

solve()","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")
    
# Main function to call the solve function
if __name__ == ""__main__"":
    solve()
","
def solve():
    x, y, z = map(int, input().split())
    if x > y + z:
        print('+')
    elif y > x + z:
        print('-')
    elif x == y and z == 0:
        print('0')
    else:
        print('?')

solve()
","
def solve():
    x, y, z = map(int, input().split())
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()","
def solve():
    x, y, z = map(int, input().split())
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")
   
solve()","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")
    
solve()
","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print('+')
    elif y > x + z:
        print('-')
    elif x == y and z == 0:
        print('0')
    else:
        print('?')

solve()","
def solve():
    x, y, z = map(int, input().split())
    
    if x > y + z:
        print(""+"")
    elif y > x + z:
        print(""-"")
    elif x == y and z == 0:
        print(""0"")
    else:
        print(""?"")

solve()","100.0","100.0","100.0","66.66666666666666","80.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/68","
QUESTION:
Vasya has got a robot which is situated on an infinite Cartesian plane, initially in the cell $(0, 0)$. Robot can perform the following four kinds of operations:   U — move from $(x, y)$ to $(x, y + 1)$;  D — move from $(x, y)$ to $(x, y - 1)$;  L — move from $(x, y)$ to $(x - 1, y)$;  R — move from $(x, y)$ to $(x + 1, y)$. 

Vasya also has got a sequence of $n$ operations. Vasya wants to modify this sequence so after performing it the robot will end up in $(x, y)$.

Vasya wants to change the sequence so the length of changed subsegment is minimum possible. This length can be calculated as follows: $maxID - minID + 1$, where $maxID$ is the maximum index of a changed operation, and $minID$ is the minimum index of a changed operation. For example, if Vasya changes RRRRRRR to RLRRLRL, then the operations with indices $2$, $5$ and $7$ are changed, so the length of changed subsegment is $7 - 2 + 1 = 6$. Another example: if Vasya changes DDDD to DDRD, then the length of changed subsegment is $1$. 

If there are no changes, then the length of changed subsegment is $0$. Changing an operation means replacing it with some operation (possibly the same); Vasya can't insert new operations into the sequence or remove them.

Help Vasya! Tell him the minimum length of subsegment that he needs to change so that the robot will go from $(0, 0)$ to $(x, y)$, or tell him that it's impossible.


-----Input-----

The first line contains one integer number $n~(1 \le n \le 2 \cdot 10^5)$ — the number of operations.

The second line contains the sequence of operations — a string of $n$ characters. Each character is either U, D, L or R.

The third line contains two integers $x, y~(-10^9 \le x, y \le 10^9)$ — the coordinates of the cell where the robot should end its path.


-----Output-----

Print one integer — the minimum possible length of subsegment that can be changed so the resulting sequence of operations moves the robot from $(0, 0)$ to $(x, y)$. If this change is impossible, print $-1$.


-----Examples-----
Input
5
RURUU
-2 3

Output
3

Input
4
RULR
1 1

Output
0

Input
3
UUU
100 100

Output
-1



-----Note-----

In the first example the sequence can be changed to LULUU. So the length of the changed subsegment is $3 - 1 + 1 = 3$.

In the second example the given sequence already leads the robot to $(x, y)$, so the length of the changed subsegment is $0$.

In the third example the robot can't end his path in the cell $(x, y)$.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())

    dx = dy = 0
    for op in operations:
        if op == 'U':
            dy += 1
        elif op == 'D':
            dy -= 1
        elif op == 'L':
            dx -= 1
        elif op == 'R':
            dx += 1

    if (x, y) == (dx, dy):
        print(0)
    else:
        min_len = float('inf')
        cx = cy = 0
        for i in range(n):
            if (x - cx, y - cy) == (dx, dy):
                min_len = min(min_len, i)
            if operations[i] == 'U':
                cy += 1
            elif operations[i] == 'D':
                cy -= 1
            elif operations[i] == 'L':
                cx -= 1
            elif operations[i] == 'R':
                cx += 1

        if min_len == float('inf'):
            print(-1)
        else:
            print(n - min_len)

solve()
","
def solve():
    n = int(input())
    sequence = input()
    x, y = map(int, input().split())

    dx = 0
    dy = 0

    for move in sequence:
        if move == 'U':
            dy += 1
        elif move == 'D':
            dy -= 1
        elif move == 'L':
            dx -= 1
        elif move == 'R':
            dx += 1

    if x == dx and y == dy:
        print(0)
    else:
        min_len = 10 ** 9
        cur_x = 0
        cur_y = 0

        for i in range(n):
            if sequence[i] == 'U':
                cur_y += 1
            elif sequence[i] == 'D':
                cur_y -= 1
            elif sequence[i] == 'L':
                cur_x -= 1
            elif sequence[i] == 'R':
                cur_x += 1

            horizontal_steps = abs(x - cur_x)
            vertical_steps = abs(y - cur_y)

            if (x - cur_x) * (x - dx) >= 0 and (y - cur_y) * (y - dy) >= 0 and horizontal_steps + vertical_steps <= i + 1:
                min_len = min(min_len, i + 1)

        if min_len == 10 ** 9:
            print(-1)
        else:
            print(min_len)

solve()
","
def solve():
    n = int(input())
    seq = input()
    x, y = map(int, input().split())

    cnt_U = seq.count('U')
    cnt_D = seq.count('D')
    cnt_L = seq.count('L')
    cnt_R = seq.count('R')

    if x >= 0 and cnt_R < x:
        print(-1)
        return

    if x < 0 and cnt_L < abs(x):
        print(-1)
        return

    if y >= 0 and cnt_U < y:
        print(-1)
        return

    if y < 0 and cnt_D < abs(y):
        print(-1)
        return

    min_change = abs(max(0, -cnt_L, x) - min(0, cnt_R, x)) + abs(max(0, -cnt_D, y) - min(0, cnt_U, y))
    
    print(min_change)

solve()
","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())

    if (abs(x) + abs(y) > n) or ((abs(x) + abs(y) - n) % 2 != 0):
        print(-1)
    else:
        num_changes = max(abs(x), abs(y))
        print(num_changes)

solve()
  ","
python
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())

    dx = x
    dy = y

    for op in operations:
        if op == 'U':
            dy += 1
        elif op == 'D':
            dy -= 1
        elif op == 'L':
            dx -= 1
        elif op == 'R':
            dx += 1

    if dx == 0 and dy == 0:
        print(0)
    elif (abs(dx) + abs(dy)) <= n and (n - (abs(dx) + abs(dy))) % 2 == 0:
        print(n - (abs(dx) + abs(dy)) // 2)
    else:
        print(-1)

solve()
","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())

    dx = dy = 0
    for op in operations:
        if op == 'U':
            dy += 1
        elif op == 'D':
            dy -= 1
        elif op == 'R':
            dx += 1
        else:
            dx -= 1

    if x == dx and y == dy:
        print(0)
    else:
        min_seg = n
        x_diff = x - dx
        y_diff = y - dy
        for i in range(n):
            if operations[i] == 'U':
                y_diff += 1
            elif operations[i] == 'D':
                y_diff -= 1
            elif operations[i] == 'R':
                x_diff += 1
            else:
                x_diff -= 1

            if x_diff == 0 and y_diff == 0:
                min_seg = min(min_seg, i + 1)

        if min_seg == n:
            print(-1)
        else:
            print(min_seg)

solve()","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())
    
    dist = abs(x) + abs(y)
    if dist > n or (dist - n) % 2 != 0:
        print(-1)
    else:
        changed_subsegment = 0
        x_changed, y_changed = 0, 0
        for i in range(n):
            if x > 0:
                x -= 1
                x_changed += 1
            elif x < 0:
                x += 1
                x_changed += 1
            if y > 0:
                y -= 1
                y_changed += 1
            elif y < 0:
                y += 1
                y_changed += 1
            
            if x == 0 and y == 0:
                changed_subsegment = i + 1
                break
        
        print(max(x_changed, y_changed))

solve()
","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())

    if abs(x) + abs(y) > n or (n % 2 != 0 and (x + y) % 2 == 0) or (n % 2 == 0 and (x + y) % 2 != 0):
        print(-1)
    else:
        min_changes = abs(abs(x) + abs(y) - n) // 2
        print(min_changes)

solve()
","
def solve():
    n = int(input())
    operations = input().strip()
    x, y = map(int, input().split())
    
    dx = 0
    dy = 0
    for op in operations:
        if op == 'U':
            dy += 1
        elif op == 'D':
            dy -= 1
        elif op == 'L':
            dx -= 1
        elif op == 'R':
            dx += 1
            
    if (x, y) == (dx, dy):
        print(0)
    else:
        ans = float('inf')
        cx, cy = 0, 0
        for i in range(n):
            if (dx, dy) == (cx, cy):
                ans = min(ans, i)
                break

            if operations[i] == 'U':
                cy += 1
            elif operations[i] == 'D':
                cy -= 1
            elif operations[i] == 'L':
                cx -= 1
            elif operations[i] == 'R':
                cx += 1
                
        cx, cy = 0, 0
        for i in range(n-1, -1, -1):
            if (dx, dy) == (cx, cy):
                ans = min(ans, n-1-i)
                break

            if operations[i] == 'U':
                cy += 1
            elif operations[i] == 'D':
                cy -= 1
            elif operations[i] == 'L':
                cx -= 1
            elif operations[i] == 'R':
                cx += 1

        print(ans if ans != float('inf') else -1)
  
solve()","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())
    
    dx = dy = 0
    for operation in operations:
        if operation == 'U':
            dy += 1
        elif operation == 'D':
            dy -= 1
        elif operation == 'L':
            dx -= 1
        elif operation == 'R':
            dx += 1
    
    if x == dx and y == dy:
        print(0)
    elif (x - dx) * (y - dy) >= 0 and abs(x - dx) + abs(y - dy) <= n:
        minID = maxID = -1
        changes = abs(x - dx) + abs(y - dy) - n
        for i in range(n):
            if (operations[i] == 'U' and y > dy) or (operations[i] == 'D' and y < dy):
                y += 1 if operations[i] == 'U' else -1
                changes -= 1
            elif (operations[i] == 'L' and x > dx) or (operations[i] == 'R' and x < dx):
                x += 1 if operations[i] == 'R' else -1
                changes -= 1
            if changes == 0:
                maxID = i
                break
        for i in range(n - 1, -1, -1):
            if (operations[i] == 'U' and y > dy) or (operations[i] == 'D' and y < dy):
                y += 1 if operations[i] == 'U' else -1
                changes -= 1
            elif (operations[i] == 'L' and x > dx) or (operations[i] == 'R' and x < dx):
                x += 1 if operations[i] == 'R' else -1
                changes -= 1
            if changes == 0:
                minID = i
                break
        print(maxID - minID + 1)
    else:
        print(-1)

solve()
","
def solve():
    n = int(input())
    sequence = input().strip()
    x, y = map(int, input().split())

    diff_x = sequence.count('R') - sequence.count('L')
    diff_y = sequence.count('U') - sequence.count('D')
    if (x, y) == (diff_x, diff_y):
        print(0)
        return

    if abs(x - diff_x) + abs(y - diff_y) > n:
        print(-1)
        return

    max_min_diff = n
    left, top, right, bottom = [0], [0], [0], [0]
    for i in range(n):
        left.append(left[-1] + (sequence[i] == ""L""))
        top.append(top[-1] + (sequence[i] == ""U""))
        right.append(right[-1] + (sequence[i] == ""R""))
        bottom.append(bottom[-1] + (sequence[i] == ""D""))
    
    for i in range(n+1):
        dx = abs(x - (diff_x + right[i] - left[i]))
        dy = abs(y - (diff_y + top[i] - bottom[i]))
        
        if dx + dy <= i:
            max_min_diff = min(max_min_diff, i)
    
    print(max_min_diff)

solve()","
def solve():
    n = int(input())
    sequence = input()
    x, y = map(int, input().split())

    dx = 0
    dy = 0
    for c in sequence:
        if c == 'U':
            dy += 1
        elif c == 'D':
            dy -= 1
        elif c == 'L':
            dx -= 1
        elif c == 'R':
            dx += 1

    if x == dx and y == dy:
        print(0)
        return

    min_dist = abs(x - dx) + abs(y - dy)
    if min_dist <= n and (n - min_dist) % 2 == 0:
        print(n - min_dist)
    else:
        print(-1)

solve()
","
def solve():
    n = int(input())
    sequence = input().strip()
    x, y = map(int, input().split())

    sumx, sumy, min_subseg, left, right = 0, 0, float('inf'), 0, 0

    for i in range(n):
        if sequence[i] == 'U':
            sumy += 1
        elif sequence[i] == 'D':
            sumy -= 1
        elif sequence[i] == 'L':
            sumx -= 1
        elif sequence[i] == 'R':
            sumx += 1

        if sumx == x and sumy == y:
            min_subseg = min(min_subseg, i + 1)
        elif sumx != 0 or sumy != 0:
            while left <= i and (abs(sumx) > abs(x) or abs(sumy) > abs(y)):
                if sequence[left] == 'U':
                    sumy -= 1
                elif sequence[left] == 'D':
                    sumy += 1
                elif sequence[left] == 'L':
                    sumx += 1
                elif sequence[left] == 'R':
                    sumx -= 1
                left += 1

            if abs(sumx) <= abs(x) and abs(sumy) <= abs(y):
                min_subseg = min(min_subseg, i - left + 1)

    if min_subseg == float('inf'):
        return -1
    else:
        return min_subseg

# Example usage:
# print(solve())
  
solve()","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())

    dx = 0
    dy = 0
    for op in operations:
        if op == 'U':
            dy += 1
        elif op == 'D':
            dy -= 1
        elif op == 'L':
            dx -= 1
        elif op == 'R':
            dx += 1

    if (abs(dx - x) + abs(dy - y)) > n or (dx - x + dy - y) % 2 != 0:
        print(-1)
    else:
        changes = max(abs(x) - abs(dx), abs(y) - abs(dy))
        print(changes)

solve()
","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())

    if (abs(x) + abs(y)) > n or (n % 2 != 0 and (x + y) % 2 == 0) or (n % 2 == 0 and (x + y) % 2 != 0):
        print(-1)
    else:
        r = operations.count('R')
        l = operations.count('L')
        u = operations.count('U')
        d = operations.count('D')

        dx = r - l
        dy = u - d

        changed = abs(dx - x) + abs(dy - y)
        print(changed if changed % 2 == n % 2 else changed + 2)

solve()","
def solve():
    n = int(input())
    operations = input()
    x, y = map(int, input().split())
    
    # Initialize current x, y coordinates
    cur_x, cur_y = 0, 0
    
    for operation in operations:
        if operation == 'U':
            cur_y += 1
        elif operation == 'D':
            cur_y -= 1
        elif operation == 'L':
            cur_x -= 1
        elif operation == 'R':
            cur_x += 1
        
    steps = abs(x - cur_x) + abs(y - cur_y)
    
    if steps > n or (n - steps) % 2 != 0: # Check if steps are greater than operations or difference is odd
        return -1
    
    return (n - steps) // 2 + steps


solve()","53.333333333333336","46.666666666666664","26.666666666666668","66.66666666666666","0.0","60.0","66.66666666666666","53.333333333333336","53.333333333333336","40.0","53.333333333333336","53.333333333333336","0.0","66.66666666666666","60.0","0.0","","","","","","","","","","","","","","","",""
"APPS/69","
QUESTION:
You are given string $s$ of length $n$ consisting of 0-s and 1-s. You build an infinite string $t$ as a concatenation of an infinite number of strings $s$, or $t = ssss \dots$ For example, if $s =$ 10010, then $t =$ 100101001010010...

Calculate the number of prefixes of $t$ with balance equal to $x$. The balance of some string $q$ is equal to $cnt_{0, q} - cnt_{1, q}$, where $cnt_{0, q}$ is the number of occurrences of 0 in $q$, and $cnt_{1, q}$ is the number of occurrences of 1 in $q$. The number of such prefixes can be infinite; if it is so, you must say that.

A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string ""abcd"" has 5 prefixes: empty string, ""a"", ""ab"", ""abc"" and ""abcd"".


-----Input-----

The first line contains the single integer $T$ ($1 \le T \le 100$) — the number of test cases.

Next $2T$ lines contain descriptions of test cases — two lines per test case. The first line contains two integers $n$ and $x$ ($1 \le n \le 10^5$, $-10^9 \le x \le 10^9$) — the length of string $s$ and the desired balance, respectively.

The second line contains the binary string $s$ ($|s| = n$, $s_i \in \{\text{0}, \text{1}\}$).

It's guaranteed that the total sum of $n$ doesn't exceed $10^5$.


-----Output-----

Print $T$ integers — one per test case. For each test case print the number of prefixes or $-1$ if there is an infinite number of such prefixes.


-----Example-----
Input
4
6 10
010010
5 3
10101
1 0
0
2 0
01

Output
3
0
1
-1



-----Note-----

In the first test case, there are 3 good prefixes of $t$: with length $28$, $30$ and $32$.
Use user-input-Based format and function signature solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        
        cnt_0 = s.count('0')
        cnt_1 = s.count('1')
        
        balance = 0
        ans = 0
        for i in range(n):
            if balance == x:
                ans = -1
                break
            if balance == x - (cnt_0 - cnt_1):
                ans += 1
            balance += 1 if s[i] == '0' else -1
        
        if balance == 0:
            ans = -1
        elif x == 0:
            ans += 1
        
        print(ans)

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        
        balance = s.count('0') - s.count('1')
        
        if balance == 0:
            if x == 0:
                print(-1)
            else:
                count = 0
                prefix_sum = 0
                for i in range(n):
                    prefix_sum += int(s[i])
                    if prefix_sum == x:
                        count += 1
                print(count)
        else:
            num_zeros = s.count('0')
            num_ones = s.count('1')
            if (x - balance) % balance == 0 and (x - balance) * balance >= 0:
                res = 0
                target = (x - balance) // balance
                if target > 0:
                    res += 1
                if x == 0:
                    res += 1
                res += min(n, 1 + (target - 1) * num_zeros + (target - 1) * num_ones)
                print(res)
            else:
                print(0)

solve()
  ","
def solve():
    from collections import defaultdict

    def count_prefixes(n, x, s):
        prefix_sum = [0]
        check_point = defaultdict(list)
        cnts = [0, 0]
        
        for c in s:
            cnts[int(c)] += 1
            prefix_sum.append(cnts[0] - cnts[1])

        for i, value in enumerate(prefix_sum):
            check_point[value].append(i)

        res = 0
        for val, indexes in check_point.items():
            for idx in indexes:
                if x == val:
                    res += max(0, n - idx + 1)
                if val:
                    if (x - val) % val == 0 and 0 <= (x - val) // val <= (n - idx):
                        res += 1
                
        if x == 0:
            res += 1
            
        if len(prefix_sum) == 1:
            return -1
        
        return res


    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        result = count_prefixes(n, x, s)
        print(result)

solve()","
def solve():
    from math import gcd

    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        bal = 0
        cnt = {0: 1, 1: 0}
        for char in s:
            cnt[int(char)] += 1
            bal = cnt[0] - cnt[1]
        
        pref_len = n
        for i in range(1, n + 1):
            if bal == 0 and x == 0:
                pref_len = i
                break
            if bal != 0 and (x - bal) % bal == 0 and (x - bal) // bal >= 0:
                pref_len = min(pref_len, n * ((x - bal) // bal) + i)
        
        if bal == 0 and x != 0:
            print(-1)
        elif bal != 0 and (x - bal) % bal == 0 and (x - bal) // bal >= 0:
            print(n * ((x - bal) // bal) + pref_len)
        else:
            print(pref_len)

solve()
","
from collections import defaultdict

def solve():
    T = int(input())
    
    def check_prefix(s, x):
        prefix_count = defaultdict(int)
        prefix_sum = 0
        balance = 0
        infinite_prefixes = False

        for i in range(len(s)):
            prefix_sum += int(s[i])
            prefix_count[prefix_sum] += 1

            balance = prefix_sum - i - 1
            if x == 0 and balance == 0:
                infinite_prefixes = True
            elif (x - prefix_sum) % balance == 0 and (x - prefix_sum) / balance >= -1:
                infinite_prefixes = True
        
        return -1 if infinite_prefixes else prefix_count[x] + (prefix_sum == x)

    outputs = []
    for _ in range(T):
        n, x = map(int, input().split())
        s = input()

        prefixes = check_prefix(s, x)
        outputs.append(prefixes)

    for output in outputs:
        print(output)

solve()
","
def solve():
    from sys import stdin, stdout

    def get_prefix_count(n, x, s):
        balance = [0]
        for i in range(n):
            balance.append(balance[-1] + (1 if s[i] == '1' else -1))

        prefix_count = 0
        total_balance = balance[-1]

        if total_balance == 0:
            if x == 0:
                prefix_count += -1
        else:
            diff = x - balance[-1]
            if diff % total_balance == 0 and diff // total_balance >= 0:
                prefix_count += 1

        for i in range(n):
            if total_balance == 0 and balance[i] == x:
                prefix_count += -1
            elif total_balance != 0:
                if (x - balance[i]) % total_balance == 0 and (x - balance[i]) // total_balance >= 0:
                    prefix_count += 1

        return prefix_count

    t = int(stdin.readline().strip())
    for _ in range(t):
        n, x = map(int, stdin.readline().strip().split())
        s = stdin.readline().strip()
        result = get_prefix_count(n, x, s)
        stdout.write(str(result) + '\n')

solve()
","
def solve():
    from sys import stdin, stdout

    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        
        balance = s.count('0') - s.count('1')
        total_zeros = s.count('0') * (x == 0)
        total_ones = s.count('1') * (x == 0)
        
        answer = 0
        if balance == 0 and x != 0:
            prefix_count = {0: 1}
            pref_sum = 0
            for i in range(1, n + 1):
                pref_sum += 1 if s[i - 1] == '0' else -1
                answer += prefix_count.get(pref_sum - x, 0)
                prefix_count[pref_sum] = prefix_count.get(pref_sum, 0) + 1
        elif x == 0:
            answer = 1 if balance == 0 else -1
        else:
            answer = (x * balance >= 0) * (x % balance == 0) * (x // balance >= 0)
        
        print(answer)

solve()
  ","
def solve():
    import sys
    
    T = int(input())
    
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        
        total_0 = s.count('0') * (n // len(s))
        total_1 = s.count('1') * (n // len(s))
        
        balance = 0
        result = 0
        infinite_prefixes = False
        
        for i in range(n):
            balance += 1 if s[i] == '1' else -1
            if balance == x:
                result += 1
            elif (x - balance) % (total_0 - total_1) == 0 and (x - balance) / (total_0 - total_1) > 0:
                infinite_prefixes = True
        
        if total_0 == total_1:
            if balance == 0:
                infinite_prefixes = result > 0
            else:
                infinite_prefixes = False
        
        if infinite_prefixes:
            print(-1)
        else:
            print(result)

solve()
","
def solve():
    from collections import defaultdict
    from itertools import accumulate

    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        
        cnt = defaultdict(int)
        cnt[0] = 1
        balance = [0] * (2*n + 1)
        
        for i in range(1, 2*n+1):
            cnt[i] = cnt[i-1] + (-1 if s[(i-1)%n] == '0' else 1)
            
        for i, c in enumerate(accumulate(cnt.values())):
            balance[i] = c
        
        ans = 0
        for i in range(1, n+1):
            if balance[2*n] == 0 and cnt[n] == 0:
                if x == 0:
                    ans = -1
                    break
            elif balance[2*n] == 0 and x%c == 0 and (x//c) >= 0:
                ans += 1

        print(ans)

solve()
  ","
def solve():
    import sys

    def check_infinite_prefix(n, x, s):
        cnt0, cnt1 = s.count('0'), s.count('1')
        balance = 0
        good_prefixes = 0

        for i in range(n):
            if balance == x:
                good_prefixes += 1

            balance += 1 if s[i] == '0' else -1

            if balance == x and cnt0 != cnt1:
                return -1

        if balance == 0:
            if x == 0:
                return -1
            return good_prefixes

        if (x - balance) % balance == 0:
            return good_prefixes

        if balance == 0:
            return -1

        return (x - balance) // balance > 0 and good_prefixes or -1

    t = int(input())
    for _ in range(t):
        n, x = map(int, input().split())
        s = input()

        result = check_infinite_prefix(n, x, s)
        print(result)

solve()
  ","
def solve():
    from math import gcd
    
    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input()
        
        cnt_0 = s.count('0')
        cnt_1 = n - cnt_0
        balance = cnt_0 - cnt_1
        
        pref_counts = []
        pref_balance = 0
        for i in range(n):
            if balance == 0 and pref_balance == x:
                pref_counts.append(i + 1)
            if balance != 0 and (x - pref_balance) % balance == 0 and (x - pref_balance) // balance >= 0:
                pref_counts.append(i + 1)
            pref_balance += 1 if s[i] == '0' else -1
        
        if balance == 0:
            if x == 0:
                print(-1)
            else:
                g = gcd(abs(x), n)
                print(pref_counts.count(n // g))
        else:
            print(pref_counts.count((x - pref_balance) // balance))

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        cnt_0 = s.count('0')
        cnt_1 = n - cnt_0
        balance = cnt_0 - cnt_1
        prefix_count = 0

        if x == 0:
            prefix_count = 1
        elif balance == 0:
            if x % cnt_0 == 0 and x // cnt_0 >= 0:
                prefix_count = -1
            else:
                prefix_count = 0
        elif (x - balance) % abs(balance) == 0 and (x - balance) // balance >= 0:
            prefix_count = 1

        print(prefix_count)
  
solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()

        balance = s.count('0') - s.count('1')
        
        if balance == 0:
            if x == 0:
                print(-1)
            else:
                print(0)
        else:
            diff = abs(x - balance)
            if diff % abs(balance) == 0 and diff // abs(balance) >= 0:
                print(1)
            else:
                print(0)

if __name__ == ""__main__"":
    solve()
","
def solve():
    from math import gcd

    def count_prefixes(n, x, s):
        n_first = s * (n // gcd(n, len(s)))
        cnt_0 = n_first.count('0')
        cnt_1 = n_first.count('1')

        balance = cnt_0 - cnt_1
        if balance == 0:
            if x == 0:
                return -1
            return 0

        if (x - balance) % balance == 0 and (x - balance) // balance >= 0:
            cnt = 1 if balance > 0 else 0
            return cnt + n_first.count(str((x - balance) // balance))

        return 0

    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input().strip()
        print(count_prefixes(n, x, s))

solve()
","
def solve():
    import sys

    T = int(sys.stdin.readline())
    for _ in range(T):
        n, x = map(int, sys.stdin.readline().split())
        s = sys.stdin.readline().strip()

        total_0 = s.count('0')
        total_1 = n - total_0
        pref_sum = [0]
        for c in s:
            if c == '0':
                pref_sum.append(pref_sum[-1] + 1)
            else:
                pref_sum.append(pref_sum[-1] - 1)

        if pref_sum[-1] == 0:
            if x == 0:
                print(-1)
            else:
                print(0)
        else:
            min_steps = (x - pref_sum[-1]) // pref_sum[-1]

            if min_steps < 0:
                min_steps = 0

            cnt = min_steps * n
            curr = pref_sum[-1] * min_steps

            for i in range(1, n + 1):
                if curr == x:
                    break
                curr += pref_sum[-1]
                cnt += 1

            print(cnt)

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, x = map(int, input().split())
        s = input()
        balance = s.count('0') - s.count('1')
        prefix_count = 0

        if balance == 0:
            if x == 0:
                prefix_count = -1
            else:
                prefix_count = -1 if x % balance != 0 else 1
        else:
            if (x - balance) % balance == 0 and (x - balance) // balance >= 0:
                prefix_count += 1
            for i in range(1, n):
                balance += 1 if s[i-1] == '0' else -1
                if (x - balance) % balance == 0 and (x - balance) // balance >= 0:
                    prefix_count += 1
        print(prefix_count)

solve()
","13.333333333333334","6.666666666666667","6.666666666666667","0.0","0.0","33.33333333333333","20.0","0.0","6.666666666666667","13.333333333333334","6.666666666666667","26.666666666666668","13.333333333333334","13.333333333333334","6.666666666666667","20.0","","","","","","","","","","","","","","","",""
"APPS/70","
QUESTION:
Polycarp is crazy about round numbers. He especially likes the numbers divisible by 10^{k}.

In the given number of n Polycarp wants to remove the least number of digits to get a number that is divisible by 10^{k}. For example, if k = 3, in the number 30020 it is enough to delete a single digit (2). In this case, the result is 3000 that is divisible by 10^3 = 1000.

Write a program that prints the minimum number of digits to be deleted from the given integer number n, so that the result is divisible by 10^{k}. The result should not start with the unnecessary leading zero (i.e., zero can start only the number 0, which is required to be written as exactly one digit).

It is guaranteed that the answer exists.


-----Input-----

The only line of the input contains two integer numbers n and k (0 ≤ n ≤ 2 000 000 000, 1 ≤ k ≤ 9).

It is guaranteed that the answer exists. All numbers in the input are written in traditional notation of integers, that is, without any extra leading zeros.


-----Output-----

Print w — the required minimal number of digits to erase. After removing the appropriate w digits from the number n, the result should have a value that is divisible by 10^{k}. The result can start with digit 0 in the single case (the result is zero and written by exactly the only digit 0).


-----Examples-----
Input
30020 3

Output
1

Input
100 9

Output
2

Input
10203049 2

Output
3



-----Note-----

In the example 2 you can remove two digits: 1 and any 0. The result is number 0 which is divisible by any number.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count = 0
    for i in range(len(n_str) - 1, -1, -1):
        if n_str[i] == '0':
            count += 1
        else:
            k -= 1
        if k == 0:
            break
    print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count = 0

    while k > 0:
        if n % 10 == 0:
            n //= 10
        else:
            count += 1
        k -= 1

    print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count = 0

    for i in range(len(n_str)):
        if n_str[i] == '0':
            count += 1
            if count == k:
                break

    if count < k:
        print(len(n_str) - 1)
    else:
        print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count = 0
    
    if k == 1:
        if n % 10 != 0:
            count = 1
    else:
        zeros = 0
        for i in range(len(n_str)-1, -1, -1):
            if n_str[i] == '0':
                zeros += 1
            else:
                count = min(k, zeros)
                break
    
    print(count)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    if k == 1:
        if n % 10 == 0:
            print(0)
        else:
            print(1)
    else:
        count = 0
        for digit in n_str[::-1]:
            if digit == '0':
                count += 1
            else:
                break
        if count >= k:
            print(k)
        else:
            print(k - 1)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    count = 0
    zeros_count = 0
    
    for digit in reversed(str(n)):
        if digit == '0':
            zeros_count += 1
            if zeros_count == k:
                break
        else:
            count += 1
    
    if n % (10 ** k) == 0:
        print(count)
    else:
        print(k - zeros_count)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    
    while k > 0:
        if n % 10 == 0:
            n //= 10
            k -= 1
        else:
            n -= 1
            k -= 1
    
    print(n)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    
    count_zeros = 0
    for i in range(len(n_str) - 1, -1, -1):
        if n_str[i] == '0':
            count_zeros += 1
        else:
            break
    
    if count_zeros >= k:
        print(k)
    else:
        print(count_zeros + sum(1 for digit in n_str[:len(n_str) - count_zeros] if digit != '0') - 1)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    
    count_zeros = 0
    for i in range(len(n_str) - 1, -1, -1):
        if n_str[i] == '0':
            count_zeros += 1
        else:
            break
    
    if count_zeros >= k:
        print(k)
    else:
        print(count_zeros + sum(1 for i in range(len(n_str)-count_zeros-1) if n_str[i] != '0'))

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    zeros_to_remove = 0
    
    for i in range(len(n_str)-1, -1, -1):
        if n_str[i] == '0':
            zeros_to_remove += 1
        else:
            if zeros_to_remove >= k:
                print(k)
                return
            else:
                print(zeros_to_remove)
                return

    print(len(n_str) - 1)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count = 0
    for i in range(len(n_str)-1, -1, -1):
        if n_str[i] == '0':
            count += 1
        else:
            count += 1
            break
    if count >= k:
        count = k - 1
    print(count)

solve()
","
def solve():
    n, k = input().split()
    n = str(n)
    k = int(k)
    w = 0
    cnt = 0
    for i in range(len(n)-1, -1, -1):
        if n[i] == '0':
            cnt += 1
            if cnt == k:
                break
        else:
            w += 1
    if cnt < k:
        w = len(n) - 1
    print(w)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count_zeros = 0
    for i in range(len(n_str)-1, -1, -1):
        if n_str[i] == '0':
            count_zeros += 1
        else:
            break
    if count_zeros >= k:
        print(k)
    else:
        if n == 0:
            print(0)
        else:
            print(count_zeros)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count = 0
    for digit in n_str[::-1]:
        if digit == '0':
            count += 1
        else:
            k -= 1
        if k == 0:
            break
    if k > 0:
        count = len(n_str) - 1
    print(count)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    
    while k > 0:
        if n % 10 == 0:
            n //= 10
            k -= 1
        else:
            n -= 1
    
    print(k)

solve()
","
def solve():
    n, k = map(int, input().split())
    n_str = str(n)
    count = 0
    while n_str.endswith('0') and count < k:
        n_str = n_str[:-1]
        count += 1
    print(count)

solve()
","26.666666666666668","53.333333333333336","40.0","60.0","33.33333333333333","46.666666666666664","13.333333333333334","40.0","33.33333333333333","46.666666666666664","40.0","100.0","40.0","40.0","40.0","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/71","
QUESTION:
On the Literature lesson Sergei noticed an awful injustice, it seems that some students are asked more often than others.

Seating in the class looks like a rectangle, where n rows with m pupils in each. 

The teacher asks pupils in the following order: at first, she asks all pupils from the first row in the order of their seating, then she continues to ask pupils from the next row. If the teacher asked the last row, then the direction of the poll changes, it means that she asks the previous row. The order of asking the rows looks as follows: the 1-st row, the 2-nd row, ..., the n - 1-st row, the n-th row, the n - 1-st row, ..., the 2-nd row, the 1-st row, the 2-nd row, ...

The order of asking of pupils on the same row is always the same: the 1-st pupil, the 2-nd pupil, ..., the m-th pupil.

During the lesson the teacher managed to ask exactly k questions from pupils in order described above. Sergei seats on the x-th row, on the y-th place in the row. Sergei decided to prove to the teacher that pupils are asked irregularly, help him count three values:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. 

If there is only one row in the class, then the teacher always asks children from this row.


-----Input-----

The first and the only line contains five integers n, m, k, x and y (1 ≤ n, m ≤ 100, 1 ≤ k ≤ 10^18, 1 ≤ x ≤ n, 1 ≤ y ≤ m).


-----Output-----

Print three integers:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. 


-----Examples-----
Input
1 3 8 1 1

Output
3 2 3
Input
4 2 9 4 2

Output
2 1 1
Input
5 5 25 4 3

Output
1 1 1
Input
100 100 1000000000000000000 100 100

Output
101010101010101 50505050505051 50505050505051


-----Note-----

The order of asking pupils in the first test:   the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table; 

The order of asking pupils in the second test:   the pupil from the first row who seats at the first table;  the pupil from the first row who seats at the second table;  the pupil from the second row who seats at the first table;  the pupil from the second row who seats at the second table;  the pupil from the third row who seats at the first table;  the pupil from the third row who seats at the second table;  the pupil from the fourth row who seats at the first table;  the pupil from the fourth row who seats at the second table, it means it is Sergei;  the pupil from the third row who seats at the first table;
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    if n == 1:
        max_questions = min(k // m, m)
        min_questions = max_questions - (k % m == 0)
        serg_questions = min(k, m)
    else:
        cycle_length = 2 * n - 2
        full_cycles = k // cycle_length
        remaining_questions = k % cycle_length
        
        max_questions = full_cycles * m
        min_questions = max_questions
        
        if remaining_questions > 0:
            if remaining_questions <= m:
                max_questions += 1
                min_questions += 1
            elif remaining_questions <= m + n - 2:
                max_questions += 1
            else:
                remaining_questions -= m + n - 2
                full_cycles = remaining_questions // (n - 1)
                remaining_questions %= n - 1
                
                max_questions += full_cycles * m + min(remaining_questions, m)
                min_questions += full_cycles * m + (remaining_questions > 0)
        
        serg_questions = full_cycles * n + (remaining_questions >= x) + (remaining_questions % n == x % n and remaining_questions > 0)
    
    print(max_questions, min_questions, serg_questions)

solve()
","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    total_pupils = n * m
    rounds = k // total_pupils
    remainder = k % total_pupils
    
    max_questions = rounds * 2
    if remainder > 0:
        max_questions += 1
        if remainder > (x - 1) * m + y:
            max_questions += 1
    
    min_questions = rounds * 2
    if remainder > 0:
        min_questions += 1
    
    serg_questions = rounds
    if remainder > 0:
        if remainder >= (x - 1) * m + y:
            serg_questions += 1
    
    print(max_questions, min_questions, serg_questions)

solve()
","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    cycles = k // (2*n*m - 2)
    remaining = k % (2*n*m - 2)
    
    max_questions = cycles * 2
    min_questions = 0 if remaining == 0 else 1 if remaining <= 2 else 2 if remaining <= 2*m else 3
    
    serg_questions = 1 if n == 1 else cycles if remaining == 0 else cycles + 1 if remaining <= 2*y - 1 else cycles + 2
    
    print(max_questions, min_questions, serg_questions)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    if n == 1:
        total_questions = k // m
        remainder = k % m
        max_questions = 0
        min_questions = total_questions
        
        if remainder > 0:
            max_questions = total_questions + 1
            min_questions += 1 if y <= remainder else 0
        if remainder == 0:
            min_questions -= 1 if y == m else 0
        
        serg_questions = total_questions + 1 if k % m >= y else total_questions
        print(max_questions, min_questions, serg_questions)
    
    else:
        total_questions = k // (2 * n * m)
        last_row_questions = k // (n * m)
        remainder = k % (n * m)
        serg_questions = 0
        
        if remainder >= ((n - x) * m + y):
            serg_questions += (total_questions + 1) if remainder > 0 else total_questions
        else:
            serg_questions += total_questions
        
        if n % 2 == 0:
            max_questions = last_row_questions
            min_questions = last_row_questions
        else:
            max_questions = total_questions + 1 if remainder > 0 else total_questions
            min_questions = total_questions
        
        print(max_questions, min_questions, serg_questions)

solve()
","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    if n == 1:
        max_questions = min(k // m, m) + (k % m > 0)
        min_questions = max_questions - (k % m == 0)
        serguei_count = min(k, m)
    else:
        cycle_len = 2 * n - 2
        full_cycles = k // cycle_len
        remaining_questions = k % cycle_len
        questions_in_full_cycles = full_cycles * (n * m)
        
        max_questions = full_cycles + (remaining_questions >= n * m) + (remaining_questions > n * (m - y))
        min_questions = full_cycles + (remaining_questions >= n * m) + (remaining_questions > n * (m - y)) - (remaining_questions == 0)
        
        serguei_count = questions_in_full_cycles // m
        serguei_count += remaining_questions // m + (remaining_questions % m >= y)
        
    print(max_questions, min_questions, serguei_count)

solve()
","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    rounds = (k - 1) // (2 * n * m) + 1
    remain = (k - 1) % (2 * n * m) + 1
    max_questions = rounds * 2
    min_questions = max(0, max_questions - 2)

    times_asked_sergei = 0
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if (i - 1) * m + j == x * m - m + y:
                times_asked_sergei += remain % 2

    print(max_questions, min_questions, times_asked_sergei)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())
    total_pupils = n * m
    cycles = k // total_pupils
    remaining_questions = k % total_pupils

    max_questions = cycles * 2
    min_questions = max_questions // 2

    if remaining_questions != 0:
        remaining_rows = remaining_questions // m
        remaining_cols = remaining_questions % m

        if remaining_rows >= n:
            remaining_rows = n - 1 if (n % 2 == 0) else n
        if remaining_cols != 0:
            remaining_cols -= 1

        if remaining_rows >= x:
            if (x - 1) % 2 == 0:
                extra_question = (x - 1) * m + y - 1
            else:
                extra_question = (x - 1) * m + m - y
            if remaining_rows == x:
                if remaining_cols >= y:
                    extra_question = min(extra_question, remaining_cols)
        else:
            extra_question = remaining_rows * m - 1

        max_questions += 1
        min_questions += 1

        if y == m and remaining_cols >= m:
            if (n % 2 == 0):
                extra_question = (n - 1) * m
            else:
                extra_question = n * m

        if (x - 1) * m + y - 1 <= remaining_questions:
            count_sergei = cycles + 1
        else:
            count_sergei = cycles

    print(max(max_questions, extra_question), min_questions, count_sergei)


solve()
","
def solve():
    n, m, k, x, y = map(int, input().split())

    if n == 1:
        min_questions = k // m
        max_questions = min_questions + (k % m > 0)
        serg_times = min(k, m) - (y > k % m)
    else:
        period = 2 * (n - 1) * m
        full_periods = k // period
        remaining_questions = k % period

        min_questions = full_periods * 2
        start_row = 1 if x == 1 else (n if x == n else 0)
        from_start = abs(start_row - 1)
        from_end = abs(start_row - n)
        if start_row == 1:
            additional = max(0, min(remaining_questions, m * 2) - y // 2 - (y % 2 > 0) + (x > 2) * (remaining_questions // m - from_start))
        else:
            additional = max(0, min(remaining_questions, m * 2) - y // 2 - (y % 2 > 0) + (n - x > 1) * (remaining_questions // m - from_end))
        min_questions += additional

        max_questions = full_periods * 2
        remaining_questions = max(remaining_questions - additional, 0)
        from_start = min(from_start, remaining_questions // m)
        from_end = min(from_end, remaining_questions // m)
        if start_row == 1:
            additional = max(0, min(remaining_questions, m * 2) - y // 2 - (y % 2 > 0) + (x > 2) * from_start)
        else:
            additional = max(0, min(remaining_questions, m * 2) - y // 2 - (y % 2 > 0) + (n - x > 1) * from_end)
        max_questions += additional

        serg_times = full_periods
        if remaining_questions >= m * 2:
            serg_times += 1

    print(max_questions, min_questions, serg_times)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())
    if n == 1:
        max_questions = min(k // m + 1, m if k % m != 0 else m - 1)
        min_questions = max(k // m, 1)
        sergai_count = min(k, m)
    else:
        total_questions = n * m
        round_trip = total_questions * 2 - n
        full_rounds, remain_places = divmod(k, round_trip)
        remain_questions = max(0, remain_places - x * m + y)
        max_questions = full_rounds * 2 + (remain_questions + n * m - 1) // (n * m)
        min_questions = full_rounds * 2 + remain_questions // (n * m)
        sergai_count = full_rounds if remain_questions >= x * m - y + 1 else full_rounds - 1
    print(max_questions, min_questions, sergai_count)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())

    if n == 1:
        total_pupils = m
    else:
        total_pupils = m * 2 * n - 2

    times_sergei_asked = (k - 1) // total_pupils + 1

    max_questions = k // total_pupils
    if k % total_pupils != 0:
        max_questions += 1

    min_questions = (k - 1) // n // m + 1

    if x == 1:
        serg_pos = (y - 1)
    else:
        serg_pos = (x - 1) * m + (y - 1) + (x - 1)

    if serg_pos < k % total_pupils:
        times_sergei_asked -= 1
    
    print(max_questions, min_questions, times_sergei_asked)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    def calc_periods(n, m, k):
        per = (n * m * 2) - 2
        periods = k // per
        rem = k % per
        return per, periods, rem
    
    per, periods, rem = calc_periods(n, m, k)
    
    def calc_max_min_counts(x, y, periods, rem):
        max_count = periods * 2 if (x,y) != (1,1) else periods
        min_count = max_count - 1 if rem >= (x - 1) * m + y else max_count - 2
        serg_count = periods + 1 if (x,y) == (1,1) else periods
        print(max_count, min_count, serg_count)
    
    calc_max_min_counts(x, y, periods, rem)

solve()
  ","
python
def solve():
    n, m, k, x, y = map(int, input().split())

    if n == 1:
        min_questions = k // m
        max_questions = (k + m - 1) // m
        serg_count = min(k, m)
    else:
        period = 2 * (n - 1) * m
        full_periods = k // period
        remainder = k % period

        if full_periods % 2 == 0:
            serg_count = 0
            min_questions = m
            max_questions = 0
        else:
            serg_count = 1 if full_periods == 1 else 0
            min_questions = max(remainder - m * (n - 1), 0)
            max_questions = m - max(m - remainder, 0)

        if x == 1:
            serg_count += full_periods // 2
            if full_periods % 2 != 0:
                serg_count += 1
        elif x == n:
            serg_count += (full_periods + 1) // 2

    print(max_questions, min_questions, serg_count)

solve()

","
def solve():
    n, m, k, x, y = map(int, input().split())

    full_round = (n * m * 2) - 2
    extra_round = (k - 1) % full_round

    max_questions = k // full_round
    min_questions = max_questions

    if extra_round >= n * m:
        max_questions += 1
    if extra_round >= (n * m) - (y * n - n + x) or extra_round == 0:
        max_questions += 1
    if extra_round >= (n * m) - ((m - y + 1) * n + x - 1):
        min_questions += 1

    if extra_round >= (m - y) * n + x - 1:
        min_questions += 1

    if x == 1 and y == 1:
        serguei_count = max_questions
    elif x == 1 or x == n:
        serguei_count = min_questions
    else:
        serguei_count = max_questions // 2

    print(max_questions, min_questions, serguei_count)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())

    if n == 1:
        total_pupils = m
    else:
        total_pupils = 2 * (n-1) * m

    full_rounds = k // total_pupils
    remaining_questions = k % total_pupils

    max_questions = full_rounds * 2
    min_questions = full_rounds
    times_asked_sergei = 0

    if remaining_questions != 0:
        if remaining_questions <= m:
            min_questions += 1
        else:
            min_questions += 2

        max_questions += 1

        if x == 1:
            times_asked_sergei += remaining_questions // m
            if remaining_questions % m >= y:
                times_asked_sergei += 1
        elif x == n:
            times_asked_sergei += remaining_questions // m
            if remaining_questions % m >= m - y + 1:
                times_asked_sergei += 1
        else:
            times_asked_sergei += full_rounds * 2
            if x < n:
                times_asked_sergei += 1

    print(max_questions, min_questions, times_asked_sergei)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())
    
    if n == 1:
        total_questions = m * n
        questions_per_student = k // total_questions
        remaining_questions = k % total_questions
        
        max_questions = questions_per_student
        min_questions = questions_per_student
        
        if remaining_questions > 0:
            max_questions += 1
            if remaining_questions >= y:
                min_questions += 1
        
        times_asked_Sergei = min(remaining_questions, y)
        
    else:
        total_rows = (n * 2) - 2
        total_questions = total_rows * m
        questions_per_student = k // total_questions
        remaining_questions = k % total_questions
        
        max_questions = questions_per_student * 2
        min_questions = questions_per_student
        
        if remaining_questions > 0:
            max_questions += 1
            if remaining_questions >= m:
                min_questions += 1
        
        times_asked_Sergei = 0
        if remaining_questions > 0:
            if remaining_questions >= y:
                times_asked_Sergei += 1
                
            remaining_questions -= y
            times_asked_Sergei += (remaining_questions // m) * 2 + (remaining_questions % m != 0)
    
    print(max_questions, min_questions, times_asked_Sergei)

solve()","
def solve():
    n, m, k, x, y = map(int, input().split())
    if n == 1:
        max_questions = (k // m) + (k % m != 0)
        min_questions = k // m
        serg_count = min(k, m * n)
    else:
        cycle_length = n * m * 2 - 2
        full_cycles = k // cycle_length
        remaining_questions = k % cycle_length
        max_questions = full_cycles * 2 + 1
        if remaining_questions == 0:
            min_questions = (k - 1) // cycle_length
        else:
            if remaining_questions // (m * 2) == 0:
                if remaining_questions % m == 0:
                    min_questions = remaining_questions // m
                else:
                    min_questions = remaining_questions // m + 1
            else:
                min_questions = remaining_questions // m
        serg_count = full_cycles + 1 if y == m and x % 2 == 0 else full_cycles
    print(max_questions, min_questions, serg_count)
 
solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","13.333333333333334","13.333333333333334","13.333333333333334","0.0","0.0","0.0","0.0","0.0","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/72","
QUESTION:
After the big birthday party, Katie still wanted Shiro to have some more fun. Later, she came up with a game called treasure hunt. Of course, she invited her best friends Kuro and Shiro to play with her.

The three friends are very smart so they passed all the challenges very quickly and finally reached the destination. But the treasure can only belong to one cat so they started to think of something which can determine who is worthy of the treasure. Instantly, Kuro came up with some ribbons.

A random colorful ribbon is given to each of the cats. Each color of the ribbon can be represented as an uppercase or lowercase Latin letter. Let's call a consecutive subsequence of colors that appears in the ribbon a subribbon. The beauty of a ribbon is defined as the maximum number of times one of its subribbon appears in the ribbon. The more the subribbon appears, the more beautiful is the ribbon. For example, the ribbon aaaaaaa has the beauty of $7$ because its subribbon a appears $7$ times, and the ribbon abcdabc has the beauty of $2$ because its subribbon abc appears twice.

The rules are simple. The game will have $n$ turns. Every turn, each of the cats must change strictly one color (at one position) in his/her ribbon to an arbitrary color which is different from the unchanged one. For example, a ribbon aaab can be changed into acab in one turn. The one having the most beautiful ribbon after $n$ turns wins the treasure.

Could you find out who is going to be the winner if they all play optimally?


-----Input-----

The first line contains an integer $n$ ($0 \leq n \leq 10^{9}$) — the number of turns.

Next 3 lines contain 3 ribbons of Kuro, Shiro and Katie one per line, respectively. Each ribbon is a string which contains no more than $10^{5}$ uppercase and lowercase Latin letters and is not empty. It is guaranteed that the length of all ribbons are equal for the purpose of fairness. Note that uppercase and lowercase letters are considered different colors.


-----Output-----

Print the name of the winner (""Kuro"", ""Shiro"" or ""Katie""). If there are at least two cats that share the maximum beauty, print ""Draw"".


-----Examples-----
Input
3
Kuroo
Shiro
Katie

Output
Kuro

Input
7
treasurehunt
threefriends
hiCodeforces

Output
Shiro

Input
1
abcabc
cbabac
ababca

Output
Katie

Input
15
foPaErcvJ
mZaxowpbt
mkuOlaHRE

Output
Draw



-----Note-----

In the first example, after $3$ turns, Kuro can change his ribbon into ooooo, which has the beauty of $5$, while reaching such beauty for Shiro and Katie is impossible (both Shiro and Katie can reach the beauty of at most $4$, for example by changing Shiro's ribbon into SSiSS and changing Katie's ribbon into Kaaaa). Therefore, the winner is Kuro.

In the fourth example, since the length of each of the string is $9$ and the number of turn is $15$, everyone can change their ribbons in some way to reach the maximal beauty of $9$ by changing their strings into zzzzzzzzz after 9 turns, and repeatedly change their strings into azzzzzzzz and then into zzzzzzzzz thrice. Therefore, the game ends in a draw.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]
    
    max_beauty = max(ribbons.count(max(ribbons, key=ribbons.count)), key=ribbons.count)
    
    if ribbons.count(max_beauty) > 1:
        print(""Draw"")
    else:
        if ribbons.index(max_beauty) == 0:
            print(""Kuro"")
        elif ribbons.index(max_beauty) == 1:
            print(""Shiro"")
        else:
            print(""Katie"")

solve()","
def solve():
    n = int(input())
    Kuro = input()
    Shiro = input()
    Katie = input()

    lengths = [(Kuro.count(c), Shiro.count(c), Katie.count(c)) for c in set(Kuro)]
    beauty = max([min([l.count for l in lengths]) for c in set(Kuro)])
  
    if beauty == min(lengths): 
        print(""Draw"")
    elif beauty == Kuro.count(min(Kuro, Shiro, Katie)): 
        print(""Kuro"")
    elif beauty == Shiro.count(min(Kuro, Shiro, Katie)): 
        print(""Shiro"")
    else: 
        print(""Katie"")

solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]

    max_beauty = max(ribbons.count(max(ribbons, key=ribbons.count)), key=ribbons.count)

    if ribbons.count(max_beauty) > 1:
        print(""Draw"")
    else:
        print([""Kuro"", ""Shiro"", ""Katie""][ribbons.index(max_beauty)])

solve()","
def solve():
    n = int(input())
    kuro = input().strip()
    shiro = input().strip()
    katie = input().strip()

    def beauty(ribbon):
        max_beauty = 1
        curr_beauty = 1
        for i in range(1, len(ribbon)):
            if ribbon[i] == ribbon[i-1]:
                curr_beauty += 1
                max_beauty = max(max_beauty, curr_beauty)
            else:
                curr_beauty = 1
        return max_beauty

    max_beauty_kuro = beauty(kuro) + min(n, beauty(kuro)+1)
    max_beauty_shiro = beauty(shiro) + min(n, beauty(shiro)+1)
    max_beauty_katie = beauty(katie) + min(n, beauty(katie)+1)

    max_beauty = max(max_beauty_kuro, max_beauty_shiro, max_beauty_katie)

    if max_beauty_kuro == max_beauty_shiro == max_beauty_katie:
        print(""Draw"")
    elif max_beauty == max_beauty_kuro:
        print(""Kuro"")
    elif max_beauty == max_beauty_shiro:
        print(""Shiro"")
    else:
        print(""Katie"")

solve()
","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]
    
    beauty_scores = [0, 0, 0]

    for i in range(3):
        count = {}
        max_count = 0
        for j in range(len(ribbons[i])):
            if ribbons[i][j] not in count:
                count[ribbons[i][j]] = 1
            else:
                count[ribbons[i][j]] += 1
            max_count = max(max_count, count[ribbons[i][j]])
        beauty_scores[i] = max_count

    if beauty_scores.count(max(beauty_scores)) > 1:
        print(""Draw"")
    else:
        print([""Kuro"", ""Shiro"", ""Katie""][beauty_scores.index(max(beauty_scores))])

solve()","
def solve():
    n = int(input())
    Kuro = input()
    Shiro = input()
    Katie = input()
    
    length = len(Kuro)
    beauty = [0, 0, 0]
    
    for i in range(length):
        freq = [0]*6
        for j in range(3):
            for k in range(6):
                if ord(Kuro[i])-ord(""A"") == k or ord(Kuro[i])-ord(""a"")+3 == k:
                    freq[k] += 1
        max_freq = max(freq)
        beauty[0] += min(n*3, max_freq)
            
        freq = [0]*6
        for j in range(3):
            for k in range(6):
                if ord(Shiro[i])-ord(""A"") == k or ord(Shiro[i])-ord(""a"")+3 == k:
                    freq[k] += 1
        max_freq = max(freq)
        beauty[1] += min(n*3, max_freq)
            
        freq = [0]*6
        for j in range(3):
            for k in range(6):
                if ord(Katie[i])-ord(""A"") == k or ord(Katie[i])-ord(""a"")+3 == k:
                    freq[k] += 1
        max_freq = max(freq)
        beauty[2] += min(n*3, max_freq)
        
    max_beauty = max(beauty)
    if beauty.count(max_beauty) > 1:
        print(""Draw"")
    elif beauty[0] == max_beauty:
        print(""Kuro"")
    elif beauty[1] == max_beauty:
        print(""Shiro"")
    else:
        print(""Katie"")
  
solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]

    max_beauty = max(ribbons.count(ribbon) for ribbon in ribbons)

    if ribbons.count(ribbons[0]) == max_beauty:
        print(""Draw"")
    else:
        print([""Kuro"", ""Shiro"", ""Katie""][(ribbons.index(max(ribbons, key=ribbons.count)) + n) % 3])

solve()","
from collections import Counter

def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]
    
    max_beauty = 0
    winner = """"
    
    for i in range(3):
        max_freq = max(Counter(ribbons[i]).values())
        remaining_turns = n - max_freq
        max_freq += min(remaining_turns, len(ribbons[i]))
        
        if max_freq > max_beauty:
            max_beauty = max_freq
            winner = ""Kuro"" if i == 0 else ""Shiro"" if i == 1 else ""Katie""
        elif max_freq == max_beauty:
            winner = ""Draw""
    
    print(winner)


solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]
    
    max_beauty = max(ribbons.count(r) for r in ribbons)
    
    if max_beauty <= (n + 2) // 3:
        print(""Draw"")
    else:
        winner = ribbons.index(max(ribbons, key=lambda x: ribbons.count(x)))
        if winner == 0:
            print(""Kuro"")
        elif winner == 1:
            print(""Shiro"")
        else:
            print(""Katie"")

solve()","
def solve():
    n = int(input())
    Kuro = input()
    Shiro = input()
    Katie = input()

    max_beauty = max(Kuro.count(Kuro[0]), Shiro.count(Shiro[0]), Katie.count(Katie[0])

    if Kuro.count(Kuro[0]) == max_beauty and Shiro.count(Shiro[0]) == max_beauty and Katie.count(Katie[0]) == max_beauty:
        print(""Draw"")
    elif Kuro.count(Kuro[0]) == max_beauty:
        print(""Kuro"")
    elif Shiro.count(Shiro[0]) == max_beauty:
        print(""Shiro"")
    else:
        print(""Katie"")
  
solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]

    max_beauty = max(ribbons.count(ribbon) for ribbon in ribbons)
    winners = [index for index, ribbon in enumerate(ribbons) if ribbons.count(ribbon) == max_beauty]
    
    if len(winners) == 1:
        print([""Kuro"", ""Shiro"", ""Katie""][winners[0]])
    else:
        print(""Draw"")

solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]
    
    max_beauty = max([r.count(max(set(r), key=r.count)) + min(n, 1) for r in ribbons])
    winners = [i for i, r in enumerate(ribbons) if r.count(max(set(r), key=r.count)) + min(n, 1) == max_beauty]

    if len(winners) > 1:
        print(""Draw"")
    else:
        print([""Kuro"", ""Shiro"", ""Katie""][winners[0]])

solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]

    max_beauty = max(ribbons.count(ribbon) for ribbon in ribbons)
    if ribbons.count(ribbons[0])==max_beauty:
        print(""Draw"")
    else:
        print(max(ribbons, key=ribbons.count))

solve()
","
def solve():
    n = int(input())
    kuro = input()
    shiro = input()
    katie = input()

    len_rib = len(kuro)

    def max_beauty(rib):
        unique_colors = set(rib)
        max_freq = max(rib.count(color) for color in unique_colors)
        return max_freq

    max_beauties = [max_beauty(rib) for rib in [kuro, shiro, katie]]
    max_beauty_value = max(max_beauties)

    if max_beauties.count(max_beauty_value) > 1:
        print(""Draw"")
    else:
        winner = max_beauties.index(max_beauty_value)
        if winner == 0:
            print(""Kuro"")
        elif winner == 1:
            print(""Shiro"")
        else:
            print(""Katie"")

solve()
","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]

    max_beauty = max(ribbons.count(max(ribbons, key=ribbons.count)), key=ribbons.count)

    if ribbons.count(max_beauty) > 1:
        print(""Draw"")
    else:
        print([""Kuro"", ""Shiro"", ""Katie""][ribbons.index(max_beauty)])

solve()","
def solve():
    n = int(input())
    ribbons = [input() for _ in range(3)]
    max_beauty = max(ribbons.count(ribbon) for ribbon in set(ribbons))
    winners = [i for i, ribbon in enumerate(ribbons) if ribbons.count(ribbon) == max_beauty]
    
    if len(winners) == 1:
        print([""Kuro"", ""Shiro"", ""Katie""][winners[0]])
    else:
        print(""Draw"")

solve()","0.0","0.0","0.0","26.666666666666668","66.66666666666666","20.0","53.333333333333336","46.666666666666664","46.666666666666664","0.0","53.333333333333336","66.66666666666666","53.333333333333336","66.66666666666666","0.0","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/73","
QUESTION:
Mister B once received a gift: it was a book about aliens, which he started read immediately. This book had c pages.

At first day Mister B read v_0 pages, but after that he started to speed up. Every day, starting from the second, he read a pages more than on the previous day (at first day he read v_0 pages, at second — v_0 + a pages, at third — v_0 + 2a pages, and so on). But Mister B is just a human, so he physically wasn't able to read more than v_1 pages per day.

Also, to refresh his memory, every day, starting from the second, Mister B had to reread last l pages he read on the previous day. Mister B finished the book when he read the last page for the first time.

Help Mister B to calculate how many days he needed to finish the book.


-----Input-----

First and only line contains five space-separated integers: c, v_0, v_1, a and l (1 ≤ c ≤ 1000, 0 ≤ l < v_0 ≤ v_1 ≤ 1000, 0 ≤ a ≤ 1000) — the length of the book in pages, the initial reading speed, the maximum reading speed, the acceleration in reading speed and the number of pages for rereading.


-----Output-----

Print one integer — the number of days Mister B needed to finish the book.


-----Examples-----
Input
5 5 10 5 4

Output
1

Input
12 4 12 4 1

Output
3

Input
15 1 100 0 0

Output
15



-----Note-----

In the first sample test the book contains 5 pages, so Mister B read it right at the first day.

In the second sample test at first day Mister B read pages number 1 - 4, at second day — 4 - 11, at third day — 11 - 12 and finished the book.

In third sample test every day Mister B read 1 page of the book, so he finished in 15 days.
Use user-input-Based format and function signature solve()","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    days = 1
    pages_read = v0
    while pages_read < c:
        v = min(v0 + a * (days - 1), v1)
        pages_read += v - l
        days += 1
    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    day = 1
    pages_read = v0
    while pages_read < c:
        day += 1
        pages_read += min(v0 + (day - 1) * a, v1)
        if day > 1:
            pages_read -= l
    print(day)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())

    pages_read = 0
    days = 0
    current_speed = v0

    while pages_read < c:
        days += 1
        pages_read += current_speed
        if pages_read >= c:
            break
        pages_read -= l
        current_speed = min(v1, current_speed + a)

    print(days)

solve()
","
def solve():
    c, v_0, v_1, a, l = map(int, input().split())
    
    days = 1
    pages_read = v_0
    while pages_read < c:
        days += 1
        pages_to_read = min(v_1, v_0 + a*(days-1))
        pages_read += pages_to_read - l
    
    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    days = 1
    pages_read = v0
    while pages_read < c:
        pages_read += min(v0 + a*days, v1) - l
        days += 1
    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    days = 0
    pages_read = 0
    current_speed = v0

    while pages_read < c:
        days += 1
        pages_read += current_speed

        if pages_read >= c:
            break

        current_speed = min(v1, current_speed + a)
        pages_read -= l

    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    days = 0
    pages_read = 0
    current_speed = v0

    while pages_read < c:
        days += 1
        pages_read += current_speed - l
        if pages_read >= c:
            break
        current_speed = min(v1, current_speed + a)
        l = v0 + (days - 1) * a

    print(days)

solve()
","
def solve():
    c, v_0, v_1, a, l = map(int, input().split())
    
    days = 1
    pages_read = v_0
    while pages_read < c:
        v = min(v_0 + days * a, v_1)
        pages_read += v - l
        days += 1

    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    
    days = 0
    pages_read = 0
    current_speed = v0
    
    while pages_read < c:
        days += 1
        pages_read += current_speed
        if pages_read >= c:
            break
        current_speed = min(v1, current_speed + a)
        pages_read -= l

    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    
    days = 0
    pages_read = 0
    current_speed = v0
    
    while pages_read < c:
        days += 1
        pages_read += current_speed
        if pages_read >= c:
            break
        pages_read -= l
        current_speed = min(v1, current_speed + a)

    print(days)

solve()
","
def solve():
    c, v_0, v_1, a, l = map(int, input().split())
    
    days = 1
    pages_read = v_0
    while pages_read < c:
        v = min(v_0 + a * (days-1), v_1)
        pages_read += v - l
        days += 1
    
    print(days)

solve()","
def solve():
    c, v_0, v_1, a, l = map(int, input().split())
    
    days = 1
    pages_read = v_0
    while pages_read < c:
        v_today = min(v_0 + (days - 1) * a, v_1)
        pages_read += v_today - l
        days += 1
    
    print(days)

solve()
","
def solve():
    c, v_0, v_1, a, l = map(int, input().split())

    days = 0
    pages_read = 0
    current_speed = v_0

    while pages_read < c:
        pages_to_read_today = min(v_1, current_speed)

        pages_read += pages_to_read_today
        days += 1

        if days > 1:
            pages_read -= l

        current_speed = min(v_1, current_speed + a)

    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    days = 0
    pages_read = 0

    while pages_read < c:
        if days > 0:
            pages_read -= l
        pages_read += min(v0 + days * a, v1)
        days += 1

    print(days)

solve()","
def solve():
    c, v_0, v_1, a, l = map(int, input().split())
    days = 1
    pages_read = v_0
    while pages_read < c:
        v_current = min(v_0 + a * (days - 1), v_1)
        pages_read += v_current - l
        days += 1
    print(days)

solve()
","
def solve():
    c, v0, v1, a, l = map(int, input().split())
    curr_page = 0
    days = 0

    while curr_page < c:
        days += 1
        if days == 1:
            curr_page += v0
        else:
            curr_page += min(v1, v0 + days * a)
        if days > 1:
            curr_page -= l

    print(days)

solve()
","73.33333333333333","100.0","100.0","100.0","100.0","100.0","75.0","100.0","100.0","100.0","73.33333333333333","73.33333333333333","100.0","100.0","73.33333333333333","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/74","
QUESTION:
Dima loves representing an odd number as the sum of multiple primes, and Lisa loves it when there are at most three primes. Help them to represent the given number as the sum of at most than three primes.

More formally, you are given an odd numer n. Find a set of numbers p_{i} (1 ≤ i ≤ k), such that



 1 ≤ k ≤ 3

 p_{i} is a prime

 $\sum_{i = 1}^{k} p_{i} = n$

The numbers p_{i} do not necessarily have to be distinct. It is guaranteed that at least one possible solution exists.


-----Input-----

The single line contains an odd number n (3 ≤ n < 10^9).


-----Output-----

In the first line print k (1 ≤ k ≤ 3), showing how many numbers are in the representation you found.

In the second line print numbers p_{i} in any order. If there are multiple possible solutions, you can print any of them.


-----Examples-----
Input
27

Output
3
5 11 11



-----Note-----

A prime is an integer strictly larger than one that is divisible only by one and by itself.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    primes = [2]
    for i in range(3, n):
        if is_prime(i):
            primes.append(i)
    
    for i in range(len(primes)):
        for j in range(i, len(primes)):
            for k in range(j, len(primes)):
                if primes[i] + primes[j] + primes[k] == n:
                    print(3)
                    print(primes[i], primes[j], primes[k])
                    return

solve()
","
import math

def solve():
    n = int(input())
    
    if n % 2 == 0:
        k = 2
        print(k)
        print(""2"", n - 2)
    else:
        k = 3
        print(k)
        if n == 3:
            print(""1 1 1"")
        else:
            prime1 = 3
            prime2 = 3
            diff = n - 6
            if diff % 2 == 0:
                prime1 = 3
                prime2 = diff - 3
            else:
                prime1 = 3
                prime2 = 3
                prime3 = diff - 6
            print(f""{prime1} {prime2} {prime3}"")

solve()
  ","
def solve():
    n = int(input())
    
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    if n % 2 == 0:
        if is_prime(n - 2):
            print(2)
            print(""2 "" + str(n - 2))
        else:
            print(3)
            print(""3 "" + str(n // 2 - 1) + "" "" + str(n // 2 + 1))
    else:
        if is_prime(n):
            print(1)
            print(n)
        elif is_prime(n - 2):
            print(2)
            print(""2 "" + str(n - 2))
        else:
            print(3)
            for i in range(2, n // 2):
                if is_prime(i) and is_prime(n - i):
                    print(str(i) + "" "" + str(n - i))
                    break

solve()
","
# Create a Python function to find a set of prime numbers that sum up to the given odd number with at most 3 primes
def solve():
    import math

    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True

    n = int(input())
    for i in range(2, n):
        if is_prime(i) and is_prime(n - i):
            if i == n - i:
                print(2)
                print(i, i)
                break
            for j in range(2, n - i):
                if is_prime(j) and is_prime(n - i - j):
                    print(3)
                    print(i, j, n - i - j)
                    return

# Call the function to find the representation of the given odd number as the sum of at most 3 primes
solve()
  ","
def solve():
    n = int(input())
    
    if n % 2 == 0:
        prime_sum = [2, 2, n-4]
    else:
        if n == 3:
            prime_sum = [3]
        elif n == 5:
            prime_sum = [2, 3]
        else:
            prime_sum = [3, 2, n-5]
    
    print(len(prime_sum))
    print(' '.join(map(str, prime_sum)))

solve()
","
import math

def solve():
    n = int(input())
    
    # Function to check if a number is prime
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    # Find the representation of n as the sum of at most three primes
    if is_prime(n):
        print(1)
        print(n)
    else:
        for i in range(2, n):
            if is_prime(i) and is_prime(n - i):
                print(2)
                print(i, n-i)
                break


solve()","
def solve():
    n = int(input())
    
    if n % 2 == 0:
        k = 2
        print(k)
        print(""2"", n-2)
    else:
        k = 3
        print(k)
        print(""3"", *(n-3 if (n-3)%2 else n-2, 2))

solve()
","
def solve():
    n = int(input())
    
    if n % 2 == 0:
        print(""Invalid input. Please enter an odd number."")
        return
    
    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, int(i**0.5) + 1):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    
    for i in range(len(primes)):
        for j in range(i, len(primes)):
            for k in range(j, len(primes)):
                if primes[i] + primes[j] + primes[k] == n:
                    print(3)
                    print(primes[i], primes[j], primes[k])
                    return

solve()
  ","
from math import isqrt

def solve():
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, isqrt(num) + 1):
            if num % i == 0:
                return False
        return True

    n = int(input())
    k = 1
    for i in range(2, n//2 + 1):
        if is_prime(i) and is_prime(n-i):
            print(2)
            print(f""{i} {n-i}"")
            return
    for i in range(2, n//2 + 1):
        for j in range(2, n//2 + 1):
            if is_prime(i) and is_prime(j) and is_prime(n-i-j):
                print(3)
                print(f""{i} {j} {n-i-j}"")
                return

solve()
  ","
import sympy

def solve():
    n = int(input())
    primes = list(sympy.primerange(1, n + 1))
    k = 1
    for i in range(k, 4):
        for p1 in primes:
            if n - p1 in primes:
                print(i)
                print(p1, n - p1)
                return
    for p1 in primes:
        for p2 in primes:
            if n - p1 - p2 in primes:
                print(3)
                print(p1, p2, n - p1 - p2)
                return

solve()
  ","
from sympy import isprime

def solve():
    n = int(input())
    primes = []
    
    # Find the first three prime numbers that add up to n
    for i in range(2, n):
        if isprime(i):
            primes.append(i)
            if n - sum(primes) in primes:
                primes.append(n - sum(primes))
                break
    
    print(len(primes))
    print("" "".join(map(str, primes)))

solve()","
import math

def solve():
    n = int(input())
    
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    if n % 2 == 0:
        print(1)
        print(2)
    else:
        if is_prime(n - 2):
            print(2)
            print(2, n - 2)
        else:
            for i in range(3, n, 2):
                if is_prime(i) and is_prime(n - i):
                    print(2)
                    print(i, n - i)
                    break

solve()
","
from sympy import isprime

def solve():
    n = int(input())
    
    if n == 3:
        print(1)
        print(3)
    else:
        for i in range(2, n):
            if isprime(i) and isprime(n - i):
                print(2)
                print(i, n - i)
                break


solve()","
from sympy import isprime

def solve():
    n = int(input())
    
    primes = []
    for i in range(2, n):
        if isprime(i):
            primes.append(i)
    
    for p1 in primes:
        for p2 in primes:
            for p3 in primes:
                if p1 + p2 + p3 == n:
                    print(3)
                    print(p1, p2, p3)
                    return

solve()
","
from sympy import isprime

def solve():
    n = int(input())
    if isprime(n):
        print(1)
        print(n)
    elif isprime(n - 2):
        print(2)
        print(2, n-2)
    else:
        print(3)
        for i in range(2, n//2 + 1):
            if isprime(i) and isprime(n - i):
                print(i, n-i)
                break

solve()","
def solve():
    n = int(input())
    
    def is_prime(num):
        if num <= 1:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    def find_primes_sum(n):
        if is_prime(n):
            return 1, [n]
        
        primes = [2, 3]
        if n % 2 == 0:
            return 2, [2, n-2]
        
        for p in primes:
            if is_prime(n - p):
                return 2, [p, n-p]
        
        for p in primes:
            for q in primes:
                if is_prime(n - p - q):
                    return 3, [p, q, n-p-q]
    
    k, result = find_primes_sum(n)
    print(k)
    print(' '.join(map(str, result)))

solve()
","21.428571428571427","0.0","80.0","0.0","6.666666666666667","80.0","0.0","21.428571428571427","50.0","0.0","0.0","28.57142857142857","0.0","0.0","0.0","93.33333333333333","","","","","","","","","","","","","","","",""
"APPS/75","
QUESTION:
You are given a description of a depot. It is a rectangular checkered field of n × m size. Each cell in a field can be empty (""."") or it can be occupied by a wall (""*""). 

You have one bomb. If you lay the bomb at the cell (x, y), then after triggering it will wipe out all walls in the row x and all walls in the column y.

You are to determine if it is possible to wipe out all walls in the depot by placing and triggering exactly one bomb. The bomb can be laid both in an empty cell or in a cell occupied by a wall.


-----Input-----

The first line contains two positive integers n and m (1 ≤ n, m ≤ 1000) — the number of rows and columns in the depot field. 

The next n lines contain m symbols ""."" and ""*"" each — the description of the field. j-th symbol in i-th of them stands for cell (i, j). If the symbol is equal to ""."", then the corresponding cell is empty, otherwise it equals ""*"" and the corresponding cell is occupied by a wall.


-----Output-----

If it is impossible to wipe out all walls by placing and triggering exactly one bomb, then print ""NO"" in the first line (without quotes).

Otherwise print ""YES"" (without quotes) in the first line and two integers in the second line — the coordinates of the cell at which the bomb should be laid. If there are multiple answers, print any of them.


-----Examples-----
Input
3 4
.*..
....
.*..

Output
YES
1 2

Input
3 3
..*
.*.
*..

Output
NO

Input
6 5
..*..
..*..
*****
..*..
..*..
..*..

Output
YES
3 3
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    row_sums = [0] * n
    col_sums = [0] * m
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == '*':
                row_sums[i] += 1
                col_sums[j] += 1
    
    for i in range(n):
        for j in range(m):
            if row_sums[i] + col_sums[j] - (field[i][j] == '*') == max(row_sums) and field[i][j] == '.':
                print(""YES"")
                print(i+1, j+1)
                return
    
    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    rows = [0] * n
    cols = [0] * m
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == '*':
                rows[i] += 1
                cols[j] += 1
    
    for i in range(n):
        for j in range(m):
            if rows[i] + cols[j] - (field[i][j] == '*') == rows[i] + cols[j]:
                print(""YES"")
                print(i + 1, j + 1)
                return
    
    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    depot = [input() for _ in range(n)]

    rows = [0] * n
    cols = [0] * m

    for i in range(n):
        for j in range(m):
            if depot[i][j] == '*':
                rows[i] += 1
                cols[j] += 1

    for i in range(n):
        for j in range(m):
            if rows[i] + cols[j] - (depot[i][j] == '*') == max(rows) + max(cols):
                print(""YES"")
                print(i + 1, j + 1)
                return

    print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    grid = [list(input()) for _ in range(n)]

    row_walls = [0] * n
    col_walls = [0] * m
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '*':
                row_walls[i] += 1
                col_walls[j] += 1

    for i in range(n):
        for j in range(m):
            if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == max(row_walls) + max(col_walls):
                print(""YES"")
                print(i+1, j+1)
                return

    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    depot = [input() for _ in range(n)]
    row_walls = [0] * n
    col_walls = [0] * m
    
    for i in range(n):
        for j in range(m):
            if depot[i][j] == '*':
                row_walls[i] += 1
                col_walls[j] += 1
    
    for i in range(n):
        for j in range(m):
            if row_walls[i] + col_walls[j] - (depot[i][j] == '*') == max(row_walls) + max(col_walls):
                print(""YES"")
                print(i + 1, j + 1)
                return
    
    print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    rows = [0] * n
    cols = [0] * m

    for i in range(n):
        for j in range(m):
            if field[i][j] == ""*"":
                rows[i] += 1
                cols[j] += 1

    for i in range(n):
        for j in range(m):
            if rows[i] + cols[j] - (field[i][j] == ""*"") == max(rows) + max(cols):
                print(""YES"")
                print(i + 1, j + 1)
                return
    
    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]

    row_walls = [0] * n
    col_walls = [0] * m

    for i in range(n):
        for j in range(m):
            if grid[i][j] == '*':
                row_walls[i] += 1
                col_walls[j] += 1

    for i in range(n):
        for j in range(m):
            if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == max(row_walls) + max(col_walls):
                print(""YES"")
                print(f""{i + 1} {j + 1}"")
                return

    print(""NO"")

solve()","
def solve():
    rows, cols = map(int, input().split())
    depot = [input() for _ in range(rows)]
    
    row_counts = [0] * rows
    col_counts = [0] * cols
    
    for i in range(rows):
        for j in range(cols):
            if depot[i][j] == '*':
                row_counts[i] += 1
                col_counts[j] += 1
    
    for i in range(rows):
        for j in range(cols):
            if row_counts[i] + col_counts[j] - (depot[i][j] == '*') == max(row_counts) and row_counts[i] > 0 and col_counts[j] > 0:
                print(""YES"")
                print(i+1, j+1)
                return
    
    print(""NO"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    rows = [0] * n
    cols = [0] * m

    for i in range(n):
        for j in range(m):
            if field[i][j] == '*':
                rows[i] += 1
                cols[j] += 1

    for i in range(n):
        for j in range(m):
            if rows[i] + cols[j] - (field[i][j] == '*') == max(rows) + max(cols):
                return print(""YES\n{} {}"".format(i+1, j+1))
    
    print(""NO"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    rows, cols = [0] * n, [0] * m
    
    field = [input() for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == '*':
                rows[i] += 1
                cols[j] += 1
    
    for i in range(n):
        for j in range(m):
            if rows[i] + cols[j] - (field[i][j] == '*') == max(rows) + max(cols):
                print(""YES"")
                print(i + 1, j + 1)
                return
    
    print(""NO"")

import sys
solve()
  ","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    row_sums = [field[i].count(""*"") for i in range(n)]
    col_sums = [sum(1 for j in range(n) if field[j][i] == ""*"") for i in range(m)]
    
    possible = False
    bomb_coord = (-1, -1)
    
    for i in range(n):
        for j in range(m):
            total_walls = row_sums[i] + col_sums[j]
            if field[i][j] == ""*"":
                total_walls -= 1
                
            if total_walls == sum(row_sums) + sum(col_sums):
                possible = True
                bomb_coord = (i+1, j+1)
                break
        if possible:
            break
    
    if possible:
        print(""YES"")
        print(*bomb_coord)
    else:
        print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    rows = [0] * n
    cols = [0] * m
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == '*':
                rows[i] += 1
                cols[j] += 1
    
    for i in range(n):
        for j in range(m):
            if rows[i] + cols[j] - (field[i][j] == '*') == max(rows) + max(cols):
                print(""YES"")
                print(i + 1, j + 1)
                return
    
    print(""NO"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    row_sums = [0] * n
    col_sums = [0] * m
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == ""*"":
                row_sums[i] += 1
                col_sums[j] += 1
    
    for i in range(n):
        for j in range(m):
            if row_sums[i] + col_sums[j] - (field[i][j] == ""*"") == max(row_sums + col_sums):
                print(""YES"")
                print(i + 1, j + 1)
                return
    
    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    row_wall_count = [0] * n
    col_wall_count = [0] * m
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == '*':
                row_wall_count[i] += 1
                col_wall_count[j] += 1
                
    for i in range(n):
        for j in range(m):
            if row_wall_count[i] + col_wall_count[j] - (field[i][j] == '*') == max(row_wall_count) + max(col_wall_count):
                print(""YES"")
                print(i+1, j+1)
                return
    
    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    depot = [input() for _ in range(n)]

    rows_sum = [0] * n
    cols_sum = [0] * m

    for i in range(n):
        for j in range(m):
            if depot[i][j] == '*':
                rows_sum[i] += 1
                cols_sum[j] += 1

    for i in range(n):
        for j in range(m):
            if rows_sum[i] + cols_sum[j] - (depot[i][j] == '*') == 0:
                print(""YES"")
                print(i + 1, j + 1)
                return

    print(""NO"")


solve()
","
def solve():
    n, m = map(int, input().split())
    depot = [input() for _ in range(n)]

    row_walls = [0] * n
    col_walls = [0] * m

    for i in range(n):
        for j in range(m):
            if depot[i][j] == '*':
                row_walls[i] += 1
                col_walls[j] += 1

    for i in range(n):
        for j in range(m):
            if row_walls[i] + col_walls[j] - (depot[i][j] == '*') == max(row_walls) + max(col_walls):
                print(""YES"")
                print(f""{i + 1} {j + 1}"")
                return

    print(""NO"")

solve()
","13.333333333333334","6.666666666666667","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","20.0","13.333333333333334","13.333333333333334","26.666666666666668","13.333333333333334","46.666666666666664","13.333333333333334","13.333333333333334","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/76","
QUESTION:
Berland Football Cup starts really soon! Commentators from all over the world come to the event.

Organizers have already built $n$ commentary boxes. $m$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.

If $n$ is not divisible by $m$, it is impossible to distribute the boxes to the delegations at the moment.

Organizers can build a new commentary box paying $a$ burles and demolish a commentary box paying $b$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.

What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $m$)?


-----Input-----

The only line contains four integer numbers $n$, $m$, $a$ and $b$ ($1 \le n, m \le 10^{12}$, $1 \le a, b \le 100$), where $n$ is the initial number of the commentary boxes, $m$ is the number of delegations to come, $a$ is the fee to build a box and $b$ is the fee to demolish a box.


-----Output-----

Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $m$). It is allowed that the final number of the boxes is equal to $0$.


-----Examples-----
Input
9 7 3 8

Output
15

Input
2 7 3 7

Output
14

Input
30 6 17 19

Output
0



-----Note-----

In the first example organizers can build $5$ boxes to make the total of $14$ paying $3$ burles for the each of them.

In the second example organizers can demolish $2$ boxes to make the total of $0$ paying $7$ burles for the each of them.

In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $5$ boxes.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        print(0)
    else:
        min_cost = min((n % m) * a, (m - n % m) * b)
        print(min_cost)

solve()
","
def solve():
    n, m, a, b = map(int, input().split())

    if n % m == 0:
        print(0)
    elif n < m:
        print(min(a, n * a, (m - n) * b))
    else:
        x = n // m
        y = n % m
        print(min(y * a, (m - y) * b))

solve()","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        return 0
    else:
        mod = n % m
        build_cost = min(mod * a, (m - mod) * b)
        demolish_cost = (m - mod) * b
        return min(build_cost, demolish_cost)

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        return 0
    
    div = n // m
    cost = min((n - div * m) * a, (div + 1) * m - n * a, b)
    
    return cost

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    if n % m == 0:
        print(0)
    else:
        temp = n % m
        build_cost = (m - temp) * a
        demolish_cost = temp * b
        print(min(build_cost, demolish_cost))

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    if n % m == 0:
        print(0)
    else:
        rem = n % m
        add_cost = rem * a
        remove_cost = (m - rem) * b
        print(min(add_cost, remove_cost))

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    if n % m == 0:
        print(0)
    else:
        rem = n % m
        add_cost = min(rem * a, b * (m - rem))
        print(add_cost)

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    if n % m == 0:
        return 0
    else:
        if n < m:
            return min((n % m) * a, (m - n % m) * b)
        boxes_to_build = (m - n % m) * a
        boxes_to_demolish = (n % m) * b
        return min(boxes_to_build, boxes_to_demolish)

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        return 0
    elif n < m:
        return min((m - n) * a, n * b)
    else:
        x = n % m
        return min(x * a, (m - x) * b)

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        print(0)
    else:
        x = n % m
        cost_build = x * a
        cost_demolish = (m - x) * b
        
        print(min(cost_build, cost_demolish))

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    if n % m == 0:
        return 0
    num_extra_boxes = n % m
    num_missing_boxes = m - num_extra_boxes
    if a * num_missing_boxes <= b * num_extra_boxes:
        return num_missing_boxes * a
    else:
        min_cost = (num_extra_boxes * b) + ((num_missing_boxes // m) * a)
        return min_cost

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        print(0)
    else:
        min_cost = min((n % m) * a, (m - n % m) * b)
        print(min_cost)

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        return 0
    
    if n < m:
        return min(a * (m - n), b * n)
    
    rem = n % m
    build_cost = rem * a
    demolish_cost = (m - rem) * b
    
    return min(build_cost, demolish_cost)

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    if n % m == 0:
        print(0)
    else:
        print(min((m - n % m) * a, (n % m) * b))

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        print(0)
    elif n < m:
        print(min(a, n * b))
    else:
        print(min((n % m) * a, (m - (n % m)) * b))

solve()
","
def solve():
    n, m, a, b = map(int, input().split())
    
    if n % m == 0:
        print(0)
    else:
        min_cost = min((n % m) * a, (m - n % m) * b)
        print(min_cost)

solve()
","53.333333333333336","46.666666666666664","0.0","0.0","100.0","53.333333333333336","53.333333333333336","0.0","0.0","53.333333333333336","0.0","53.333333333333336","0.0","100.0","46.666666666666664","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/77","
QUESTION:
You are given sequence a_1, a_2, ..., a_{n} of integer numbers of length n. Your task is to find such subsequence that its sum is odd and maximum among all such subsequences. It's guaranteed that given sequence contains subsequence with odd sum.

Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.

You should write a program which finds sum of the best subsequence.


-----Input-----

The first line contains integer number n (1 ≤ n ≤ 10^5).

The second line contains n integer numbers a_1, a_2, ..., a_{n} ( - 10^4 ≤ a_{i} ≤ 10^4). The sequence contains at least one subsequence with odd sum.


-----Output-----

Print sum of resulting subseqeuence.


-----Examples-----
Input
4
-2 2 -3 1

Output
3

Input
3
2 -5 -3

Output
-1



-----Note-----

In the first example sum of the second and the fourth elements is 3.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    odd_sum = sum(x for x in a if x % 2 != 0)
    max_odd_sum = max(odd_sum, odd_sum - min(x for x in a if x % 2 != 0 and x < 0))
    
    print(max_odd_sum)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    sum_odd = []
    sum_even = []
    for num in arr:
        if num % 2 == 0:
            sum_even.append(num)
        else:
            sum_odd.append(num)

    if sum(sum_odd) % 2 != 0:
        print(sum(sum_odd))
    elif sum_odd:
        print(sum(sum_odd) - min([abs(num) for num in sum_odd if num < 0]))
    else:
        print(sum(sum_even))

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    nums = list(map(int, input().split()))

    odd_nums = [num for num in nums if num % 2 != 0]
    if sum(odd_nums) % 2 != 0:
        print(sum(odd_nums))
    else:
        print(sum(odd_nums) - min(odd_nums, key=lambda x: x % 2))


solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    total_sum = sum([i for i in arr if i % 2 != 0])
    
    if total_sum % 2 == 0:
        max_odd = max([i for i in arr if i % 2 != 0])
        total_sum -= max_odd
    
    print(total_sum)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    odd_numbers = [num for num in a if num % 2 != 0]
    if sum(odd_numbers) % 2 != 0:
        print(sum(odd_numbers))
    else:
        print(sum(odd_numbers) - min(odd_numbers))

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    odd_sum = max_sum = float('-inf')
    for num in a:
        if num % 2 != 0:
            odd_sum = max(odd_sum, num)
        elif num > 0:
            max_sum = max(max_sum, num)
    
    if odd_sum == float('-inf'):
        return max_sum
    return odd_sum

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    odd_nums = [num for num in a if num % 2 != 0]
    sum_odd_nums = sum(odd_nums)
    
    if sum_odd_nums % 2 == 0:
        max_odd_num = max(odd_nums)
        return sum_odd_nums - max_odd_num
    else:
        return sum_odd_nums

solve()","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))
    
    odd_sum = []
    for num in sequence:
        if num % 2 != 0:
            odd_sum.append(num)
    
    result = sum(odd_sum)
    print(result)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    odd_sum = sum(i for i in a if i % 2 != 0)
    max_odd_sum = max(odd_sum, odd_sum - min(i for i in a if i % 2 != 0 and i < 0))
    
    print(max_odd_sum)

solve()","
def solve():
    n = int(input())
    nums = list(map(int, input().split()))

    odd_sum = [num for num in nums if num % 2 != 0]
    return sum(odd_sum)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    # Initialize variables to store maximum even and odd sums
    max_odd_sum = 0
    max_even_sum = 0

    # Iterate over the array to find maximum odd and even sums
    for num in arr:
        if num % 2 == 0:
            max_even_sum += max_even_sum + num
        else:
            max_odd_sum += max_odd_sum + num

    # Print the maximum odd sum
    print(max_odd_sum)

solve()","
def solve():
    n = int(input())
    nums = list(map(int, input().split()))
    
    odd_sum = 0
    has_odd = False

    for num in nums:
        if num % 2 != 0:
            odd_sum += num
            has_odd = True

    if not has_odd:
        odd_sum = max(nums)

    print(odd_sum)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    odd_sum = sum(x for x in a if x % 2 != 0)
    return odd_sum if odd_sum % 2 != 0 else odd_sum - min(abs(x) for x in a if x % 2 != 0 and x < 0)

solve()","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))
    
    odd_numbers = [num for num in sequence if num % 2 == 1]
    odd_sum = sum(odd_numbers)
    
    if odd_sum % 2 == 0:
        odd_numbers.sort(reverse=True)
        for num in odd_numbers:
            if num % 2 != 0:
                odd_sum -= num
                break
    
    print(odd_sum)

solve()","
import sys

def solve():
    n = int(input())
    numbers = list(map(int, input().split()))
    
    odd_sum = max_sum = 0
    for num in numbers:
        if num % 2 != 0:
            odd_sum += num
        if num > 0:
            max_sum += num
    
    if odd_sum == 0:
        print(max_sum)
    else:
        print(max(odd_sum, max_sum))

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    odd_sum = sum(num for num in arr if num % 2 != 0)
    
    if odd_sum % 2 == 0:
        result = odd_sum
    else:
        result = odd_sum - min(num for num in arr if num % 2 != 0)
    
    print(result)

solve()
","13.333333333333334","20.0","26.666666666666668","20.0","33.33333333333333","0.0","0.0","20.0","13.333333333333334","0.0","13.333333333333334","20.0","0.0","20.0","53.333333333333336","0.0","","","","","","","","","","","","","","","",""
"APPS/78","
QUESTION:
The only difference between easy and hard versions is constraints.

Polycarp loves to listen to music, so he never leaves the player, even on the way home from the university. Polycarp overcomes the distance from the university to the house in exactly $T$ minutes.

In the player, Polycarp stores $n$ songs, each of which is characterized by two parameters: $t_i$ and $g_i$, where $t_i$ is the length of the song in minutes ($1 \le t_i \le 15$), $g_i$ is its genre ($1 \le g_i \le 3$).

Polycarp wants to create such a playlist so that he can listen to music all the time on the way from the university to his home, and at the time of his arrival home, the playlist is over. Polycarp never interrupts songs and always listens to them from beginning to end. Thus, if he started listening to the $i$-th song, he would spend exactly $t_i$ minutes on its listening. Polycarp also does not like when two songs of the same genre play in a row (i.e. successively/adjacently) or when the songs in his playlist are repeated.

Help Polycarpus count the number of different sequences of songs (their order matters), the total duration is exactly $T$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different.


-----Input-----

The first line of the input contains two integers $n$ and $T$ ($1 \le n \le 15, 1 \le T \le 225$) — the number of songs in the player and the required total duration, respectively.

Next, the $n$ lines contain descriptions of songs: the $i$-th line contains two integers $t_i$ and $g_i$ ($1 \le t_i \le 15, 1 \le g_i \le 3$) — the duration of the $i$-th song and its genre, respectively.


-----Output-----

Output one integer — the number of different sequences of songs, the total length of exactly $T$, such that there are no two consecutive songs of the same genre in them and all the songs in the playlist are different. Since the answer may be huge, output it modulo $10^9 + 7$ (that is, the remainder when dividing the quantity by $10^9 + 7$).


-----Examples-----
Input
3 3
1 1
1 2
1 3

Output
6

Input
3 3
1 1
1 1
1 3

Output
2

Input
4 10
5 3
2 1
3 2
5 1

Output
10



-----Note-----

In the first example, Polycarp can make any of the $6$ possible playlist by rearranging the available songs: $[1, 2, 3]$, $[1, 3, 2]$, $[2, 1, 3]$, $[2, 3, 1]$, $[3, 1, 2]$ and $[3, 2, 1]$ (indices of the songs are given).

In the second example, the first and second songs cannot go in succession (since they have the same genre). Thus, Polycarp can create a playlist in one of $2$ possible ways: $[1, 3, 2]$ and $[2, 3, 1]$ (indices of the songs are given).

In the third example, Polycarp can make the following playlists: $[1, 2, 3]$, $[1, 3, 2]$, $[2, 1, 3]$, $[2, 3, 1]$, $[3, 1, 2]$, $[3, 2, 1]$, $[1, 4]$, $[4, 1]$, $[2, 3, 4]$ and $[4, 3, 2]$ (indices of the songs are given).
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 10**9 + 7

    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]

    dp = [[0] * 3 for _ in range(T + 1)]
    dp[0] = [1, 1, 1]

    for i in range(1, T + 1):
        for j in range(3):
            for t, g in songs:
                if i - t >= 0 and dp[i - t][g - 1] > 0:
                    dp[i][j] = (dp[i][j] + dp[i - t][g - 1]) % MOD

    total = sum(dp[T]) % MOD
    print(total)

solve()
","
def solve():
    mod = 10**9 + 7
    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]
    
    dp = [[0] * 4 for _ in range(T + 1)]
    dp[0] = [1] * 4
    
    for i in range(1, T + 1):
        for j in range(1, 4):
            for t, g in songs:
                if t <= i and g != j:
                    dp[i][j] += dp[i - t][g]
                    dp[i][j] %= mod
    
    result = sum(dp[T]) % mod
    print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7

    n, T = map(int, input().split())
    songs = []
    for _ in range(n):
        t, g = map(int, input().split())
        songs.append((t, g))
    
    dp = [[[0 for _ in range(4)] for _ in range(T + 1)] for _ in range(1 << n)]
    
    dp[0][0][3] = 1
    
    for mask in range(1 << n):
        for time in range(T + 1):
            for prev_genre in range(4):
                for i in range(n):
                    if not (mask & (1 << i)):
                        t, g = songs[i]
                        if time + t <= T and prev_genre != g:
                            if prev_genre == 3:
                                dp[mask | (1 << i)][time + t][g] = (dp[mask | (1 << i)][time + t][g] + dp[mask][time][prev_genre]) % MOD
                            else:
                                dp[mask | (1 << i)][time + t][g] = (dp[mask | (1 << i)][time + t][g] + dp[mask][time][prev_genre]) % MOD

    ans = sum(dp[(1 << n) - 1][T]) % MOD

    print(ans)


solve()
","
from itertools import permutations

def solve():
    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]

    mod = 10**9 + 7
    ans = 0

    for perm in permutations(songs):
        if sum(song[0] for song in perm) == T and all(perm[i][1] != perm[i + 1][1] for i in range(len(perm) - 1)):
            ans += 1

    print(ans % mod)

solve()","
def solve():
    MOD = 1000000007

    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]

    dp = [[[0 for _ in range(4)] for _ in range(T + 1)] for _ in range(1 << n)]
    
    for i in range(n):
        dp[1 << i][songs[i][0]][1 << songs[i][1]] = 1

    for mask in range(1 << n):
        for t in range(T + 1):
            for last_genre in range(4):
                for i in range(n):
                    if not (mask & (1 << i)):
                        new_t = t + songs[i][0]
                        new_mask = mask | (1 << i)
                        new_genre = songs[i][1]
                        if new_t <= T and last_genre != new_genre:
                            dp[new_mask][new_t][new_genre] += dp[mask][t][last_genre]
                            dp[new_mask][new_t][new_genre] %= MOD

    total = 0
    for i in range(1 << n):
        for j in range(4):
            total += dp[i][T][j]
            total %= MOD

    print(total)

solve()
  ","
def solve():
    import itertools
    
    n, T = map(int, input().split())
    
    songs = []
    for _ in range(n):
        t, g = map(int, input().split())
        songs.append((t, g))
    
    mod = 10**9 + 7
    count = 0
    
    for perm in itertools.permutations(songs):
        total_time = 0
        valid = True
        for i in range(n):
            total_time += perm[i][0]
            if total_time > T:
                break
            if i > 0 and perm[i][1] == perm[i-1][1]:
                valid = False
                break
        if total_time == T and valid:
            count = (count + 1) % mod
    
    print(count)

solve()
","
def solve():
    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]

    MOD = 10**9 + 7

    dp = [[[0 for _ in range(4)] for _ in range(T+1)] for _ in range(1 << n)]
    dp[0][0][3] = 1

    for mask in range(1 << n):
        for t in range(T):
            for last_genre in range(4):
                for idx, (ti, gi) in enumerate(songs):
                    if not (mask & (1 << idx)) and t + ti <= T and last_genre != gi:
                        dp[mask ^ (1 << idx)][t+ti][gi] += dp[mask][t][last_genre]
                        dp[mask ^ (1 << idx)][t+ti][gi] %= MOD

    ans = 0
    for last_genre in range(4):
        ans += dp[(1 << n) - 1][T][last_genre]
        ans %= MOD

    print(ans)

solve()
","
def solve():
    MOD = 10 ** 9 + 7
    
    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]
    
    dp = [[0 for _ in range(1 << n)] for _ in range(T + 1)]
    dp[0][0] = 1
    
    for t in range(1, T + 1):
        for mask in range(1 << n):
            for i, (ti, gi) in enumerate(songs):
                if ti <= t and not (mask & (1 << i)):
                    new_mask = mask | (1 << i)
                    if bin(mask)[-1] != bin(new_mask)[-1] and t - ti >= 0:
                        dp[t][new_mask] += dp[t - ti][mask]
                        dp[t][new_mask] %= MOD
    
    total_ways = sum(dp[T])
    print(total_ways % MOD)

solve()
","
from itertools import permutations

def solve():
    n, T = map(int, input().split())
    songs = [tuple(map(int, input().split())) for _ in range(n)]
    
    mod = 10**9 + 7
    count = 0
    
    for perm in permutations(songs):
        valid = True
        duration = 0
        prev_genre = None
        
        for song in perm:
            duration += song[0]
            if duration > T:
                valid = False
                break
            
            if prev_genre == song[1]:
                valid = False
                break
                
            prev_genre = song[1]
        
        if valid and duration == T:
            count += 1
            
    print(count % mod)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]
    
    dp = [[[0] * 3 for _ in range(T + 1)] for _ in range(1 << n)]
    
    for i, (t, g) in enumerate(songs):
        dp[1 << i][t][g - 1] = 1
    
    for mask in range(1 << n):
        for t in range(T + 1):
            for prev_g in range(3):
                for i, (t_i, g_i) in enumerate(songs):
                    if mask & (1 << i):
                        continue
                    if t + t_i > T or g_i == prev_g + 1:
                        continue
                    dp[mask | (1 << i)][t + t_i][g_i - 1] = (dp[mask | (1 << i)][t + t_i][g_i - 1] + dp[mask][t][prev_g]) % MOD
    
    ans = 0
    for mask in range(1 << n):
        if bin(mask).count('1') == n:
            for g in range(3):
                ans = (ans + dp[mask][T][g]) % MOD
    
    print(ans)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    n, T = map(int, input().split())
    songs = []
    for _ in range(n):
        t, g = map(int, input().split())
        songs.append((t, g))

    dp = [[0] * 3 for _ in range(T+1)]
    dp[0][0] = dp[0][1] = dp[0][2] = 1
    for t in range(1, T+1):
        for i in range(n):
            for j in range(3):
                if t - songs[i][0] >= 0:
                    if j != songs[i][1] - 1:
                        dp[t][songs[i][1] - 1] += dp[t - songs[i][0]][j]
    
    total = 0
    for j in range(3):
        total = (total + dp[T][j]) % MOD
    
    print(total)

solve()
","
from itertools import permutations

def solve():
    n, T = map(int, input().split())
    songs = []
    for _ in range(n):
        t, g = map(int, input().split())
        songs.append((t, g))

    MOD = 10**9 + 7
    ans = 0
    for perm in permutations(range(n)):
        duration = 0
        prev_genre = -1
        valid = True
        for i in perm:
            if prev_genre == songs[i][1]:
                valid = False
                break
            duration += songs[i][0]
            prev_genre = songs[i][1]
            if duration > T:
                break
            if duration == T:
                ans = (ans + 1) % MOD
        if valid and duration == T:
            ans = (ans + 1) % MOD
    
    print(ans)

solve()
  ","
def solve():
    import itertools

    MOD = 10**9 + 7

    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]

    dp = [[0] * 4 for _ in range(T + 1)]
    dp[0][0] = 1

    for i in range(1, T + 1):
        for j in range(4):
            for t, g in songs:
                if i - t >= 0 and j != g:
                    dp[i][g] = (dp[i][g] + dp[i - t][j]) % MOD

    total = sum(dp[T])
    return total % MOD

solve()","
def solve():
    MOD = 10**9 + 7

    n, T = map(int, input().split())
    songs = [tuple(map(int, input().split())) for _ in range(n)]

    dp = [[[0 for _ in range(3)] for _ in range(1 << n)] for _ in range(T+1)]
    dp[0][0][0] = 1

    for t in range(1, T+1):
        for mask in range(1 << n):
            for last_genre in range(3):
                for i in range(n):
                    if not (mask & (1 << i)):
                        length, genre = songs[i]
                        if length <= t and genre != last_genre:
                            new_mask = mask | (1 << i)
                            dp[t][new_mask][genre] += dp[t - length][mask][last_genre]
                            dp[t][new_mask][genre] %= MOD

    total = sum(dp[T][mask].count(0) for mask in range(1 << n))
    print(total % MOD)

solve()
","
def solve():
    n, T = map(int, input().split())
    songs = [tuple(map(int, input().split())) for _ in range(n)]
    
    mod = 10**9 + 7
    dp = [[0] * 4 for _ in range(T + 1)]
    dp[0][3] = 1

    for i in range(1, T + 1):
        for j in range(1, 4):
            for t, g in songs:
                if t > i or g == j:
                    continue
                dp[i][j] += sum(dp[i - t][:g] + dp[i - t][g + 1:]) % mod

    return sum(dp[T]) % mod

solve()
  ","
def solve():
    MOD = 10**9 + 7

    n, T = map(int, input().split())
    songs = [list(map(int, input().split())) for _ in range(n)]

    dp = [[[0 for _ in range(3)] for _ in range(n)] for _ in range(T+1)]

    for i in range(n):
        for t in range(T+1):
            if t >= songs[i][0]:
                dp[t][i][songs[i][1]-1] = 1

    for i in range(n):
        for t in range(1, T+1):
            for g in range(3):
                dp[t][i][g] = (dp[t][i][g] + dp[t-1][i][g]) % MOD
                for j in range(n):
                    if j != i and songs[j][1] != g+1 and t >= songs[i][0]:
                        dp[t][i][g] = (dp[t][i][g] + dp[t-songs[i][0]][j][songs[j][1]-1]) % MOD

    result = 0
    for i in range(n):
        for j in range(3):
            result = (result + dp[T][i][j]) % MOD

    print(result)

# Input reading
solve()
","6.666666666666667","33.33333333333333","53.333333333333336","73.33333333333333","33.33333333333333","73.33333333333333","53.333333333333336","60.0","73.33333333333333","66.66666666666666","33.33333333333333","53.333333333333336","0.0","0.0","0.0","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/79","
QUESTION:
Vivek initially has an empty array $a$ and some integer constant $m$.

He performs the following algorithm:  Select a random integer $x$ uniformly in range from $1$ to $m$ and append it to the end of $a$.  Compute the greatest common divisor of integers in $a$.  In case it equals to $1$, break  Otherwise, return to step $1$. 

Find the expected length of $a$. It can be shown that it can be represented as $\frac{P}{Q}$ where $P$ and $Q$ are coprime integers and $Q\neq 0 \pmod{10^9+7}$. Print the value of $P \cdot Q^{-1} \pmod{10^9+7}$.


-----Input-----

The first and only line contains a single integer $m$ ($1 \leq m \leq 100000$).


-----Output-----

Print a single integer — the expected length of the array $a$ written as $P \cdot Q^{-1} \pmod{10^9+7}$.


-----Examples-----
Input
1

Output
1

Input
2

Output
2

Input
4

Output
333333338



-----Note-----

In the first example, since Vivek can choose only integers from $1$ to $1$, he will have $a=[1]$ after the first append operation, and after that quit the algorithm. Hence the length of $a$ is always $1$, so its expected value is $1$ as well.

In the second example, Vivek each time will append either $1$ or $2$, so after finishing the algorithm he will end up having some number of $2$'s (possibly zero), and a single $1$ in the end. The expected length of the list is $1\cdot \frac{1}{2} + 2\cdot \frac{1}{2^2} + 3\cdot \frac{1}{2^3} + \ldots = 2$.
Use user-input-Based format and function signature solve()","
from fractions import Fraction

def solve(m):
    MOD = 10**9 + 7
    inv_q = pow(2, MOD - 2, MOD)
    return (2 * inv_q) % MOD

solve()","
from math import gcd

def solve(m):
    mod = 10**9 + 7

    def mod_inverse(a, m):
        return pow(a, m-2, m)
    
    inv_m = mod_inverse(m, mod)
    ans = m
    for i in range(2, m+1):
        ans += (i-1) * inv_m
        ans %= mod
    
    return ans

solve()","
import math

def solve():
    m = int(input())
    MOD = 10**9 + 7
    inv_m = pow(m, MOD - 2, MOD)
    ans = (m * inv_m) % MOD
    print(ans)

solve()
","
from fractions import Fraction
from math import gcd

def solve(m):
    MOD = 10**9 + 7
    res = 1
    for i in range(2, m+1):
        res = (res + pow(i, MOD-2, MOD)) % MOD
    return res

m = int(input())
print(solve(m))

solve()","
import fractions

def solve(m):
    mod = 10**9 + 7
    result = 0
    for i in range(1, m+1):
        result = (result + pow(fractions.Fraction(1, i), mod-2, mod)) % mod

    return result

# Input
m = int(input())

# Output
print(solve(m))

solve()","
from fractions import Fraction

def solve(m):
    mod = 10**9 + 7
    res = Fraction(1, 1)
    for i in range(2, m+1):
        res += Fraction(m/i) ** i
    return int((res.numerator * pow(res.denominator, -1, mod)) % mod)

solve()","
from math import gcd

def solve(m):
    mod = 10**9 + 7
    total = 0
    for i in range(1, m + 1):
        total += (i * pow(2, mod-2, mod)) % mod
        total %= mod
    return total

m = int(input())
print(solve(m))
  
solve()","
from math import gcd

def solve(m):
    MOD = 10**9 + 7

    def modinv(a, m):
        m0, x0, x1 = m, 0, 1
        while a > 1:
            q = a // m
            m, a = a % m, m
            x0, x1 = x1 - q * x0, x0
        return x1 + m0 if x1 < 0 else x1

    inv_m = modinv(m, MOD)
    inv_m_power = 1
    result = 0
    for i in range(1, m + 1):
        result = (result + i * inv_m_power) % MOD
        inv_m_power = (inv_m_power * inv_m) % MOD
    return (result * inv_m) % MOD
  
solve()","
import math

def solve():
    MOD = 10**9 + 7
    m = int(input())
    
    def modinv(a, m):
        m0, x0, x1 = m, 0, 1
        while a > 1:
            q = a // m
            m, a = a % m, m
            x0, x1 = x1 - q * x0, x0
        return x1 + m0 if x1 < 0 else x1
    
    inv_m = modinv(m, MOD)
    result = (m * inv_m) % MOD
    print(result)

solve()
","
import math

def solve():
    m = int(input())
    MOD = 10**9 + 7
    
    inv_q = pow(6, MOD-2, MOD) # Calculate Q^(-1) mod (10^9 + 7)
    
    if m == 1:
        print(1)
    else:
        print((2 * (pow(m, MOD-2, MOD) - 1) % MOD * inv_q % MOD) % MOD)

solve()
","
import math

def solve(m):
    MOD = 10**9 + 7
    inv_q = pow(m, MOD - 2, MOD)
    return (m * inv_q) % MOD

solve()","
import math

def solve(m):
    MOD = 10**9 + 7
    inv_m = pow(m, MOD-2, MOD)
    return (m * inv_m) % MOD

solve()","
from math import gcd

def solve(m):
    MOD = 10**9 + 7
    ans = 0
    for i in range(1, m):
        ans += i * pow(i, MOD - 2, MOD) % MOD
        ans %= MOD
    return ans

solve()","
import math

def solve(m):
    MOD = 10**9 + 7
    def modInverse(a, m):
        m0 = m
        y = 0
        x = 1
        if m == 1:
            return 0
        while a > 1:
            q = a // m
            t = m
            m = a % m
            a = t
            t = y
            y = x - q * y
            x = t
        if x < 0:
            x = x + m0
        return x

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    inv = modInverse(m, MOD)
    result = pow(m, MOD-2, MOD)
    p = (inv * result) % MOD
    return p

# Example usage:
m = int(input())
print(solve(m))
  
solve()","
import math

def solve(m):
    mod = 10**9 + 7
    inv_m = pow(m, mod - 2, mod)
    return (m * inv_m) % mod

solve()","
from fractions import gcd

def solve(m):
    mod = 10**9 + 7
    p = 1
    q = 1
    for i in range(1, m + 1):
        p = (p + q) % mod
        q = (q * 2) % mod
    return (p * pow(q, mod - 2, mod)) % mod

solve()","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","6.666666666666667","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/80","
QUESTION:
Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.

We define a pair of integers (a, b) good, if GCD(a, b) = x and LCM(a, b) = y, where GCD(a, b) denotes the greatest common divisor of a and b, and LCM(a, b) denotes the least common multiple of a and b.

You are given two integers x and y. You are to find the number of good pairs of integers (a, b) such that l ≤ a, b ≤ r. Note that pairs (a, b) and (b, a) are considered different if a ≠ b.


-----Input-----

The only line contains four integers l, r, x, y (1 ≤ l ≤ r ≤ 10^9, 1 ≤ x ≤ y ≤ 10^9).


-----Output-----

In the only line print the only integer — the answer for the problem.


-----Examples-----
Input
1 2 1 2

Output
2

Input
1 12 1 12

Output
4

Input
50 100 3 30

Output
0



-----Note-----

In the first example there are two suitable good pairs of integers (a, b): (1, 2) and (2, 1).

In the second example there are four suitable good pairs of integers (a, b): (1, 12), (12, 1), (3, 4) and (4, 3).

In the third example there are good pairs of integers, for example, (3, 30), but none of them fits the condition l ≤ a, b ≤ r.
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    
    count = 0
    for a in range(l, r+1):
        if y % a == 0 and gcd(a, y//a) == x:
            count += 1
    
    print(count)

solve()
","
from math import gcd


def solve(l, r, x, y):
    def lcm(a, b):
        return a * b // gcd(a, b)

    count = 0
    for a in range(l, r + 1):
        if y % a == 0 and gcd(a, y // a) == x and lcm(a, y // a) == y:
            count += 1

    return count

solve()","
import math

def solve():
    l, r, x, y = map(int, input().split())

    count = 0
    for a in range(l, r+1):
        if y % a == 0 and math.gcd(a, y//a) == x and a*y // math.gcd(a, y//a) == y:
            count += 1

    print(count)

solve()","
def solve():
    from math import gcd, lcm

    l, r, x, y = map(int, input().split())

    count = 0
    for a in range(l, r+1):
        if y % a == 0 and gcd(a, y//a) == x:
            count += 1

    print(count)

solve()
","
def solve():
    l, r, x, y = map(int, input().split())
    ans = 0
    for i in range(1, int(y**0.5) + 1):
        if y % i == 0:
            a = i
            b = y // i
            if x <= a <= y and x <= b <= y and l <= a <= r and l <= b <= r:
                if a == b:
                    ans += 1
                else:
                    ans += 2
    print(ans)

solve()
","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    ans = 0

    for a in range(l, r + 1):
        if x <= a <= y and y % a == 0 and gcd(a, y // a) == x:
            ans += 1

    print(ans)

solve()
","
def solve():
    from math import gcd

    l, r, x, y = map(int, input().split())
    ans = 0

    for i in range(1, int(y**0.5) + 1):
        if y % i == 0 and i >= x and y // i >= x and gcd(i, y // i) == x:
            if i * i == y:
                ans += l <= i*i <= r
            else:
                ans += l <= i <= r
                ans += l <= y // i <= r

    print(ans)

solve()
  ","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    
    count = 0
    for a in range(l, r+1):
        if y % a == 0 and gcd(a, y//a) == x:
            count += 1
    
    print(count)

solve()","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    
    count = 0
    for a in range(l, r+1):
        if y % a == 0 and gcd(a, y//a) == x:
            count += 1
        
    print(count)

solve()
  ","
import math

def solve():
    l, r, x, y = map(int, input().split())
    
    count = 0
    for a in range(l, r+1):
        if x <= a <= y and y % a == 0 and math.gcd(a, y//a) == x:
            count += 1

    print(count)

solve()
","
import math

def solve():
    l, r, x, y = map(int, input().split())
    
    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)
    
    def lcm(a, b):
        return a * b // math.gcd(a, b)
    
    count = 0
    for a in range(l, r + 1):
        if x <= a <= y and y % a == 0 and math.gcd(y // a, a) == x:
            count += 1
            
    print(count)

solve()
","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    count = 0
    for a in range(l, r+1):
        if y % a == 0 and gcd(a, y // a) == x:
            count += 1
    print(count)

solve()
","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    
    count = 0
    for i in range(l, r+1):
        if x <= i <= y and y % i == 0 and gcd(i, y//i) == x:
            count += 1
    
    return count

solve()","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    count = 0
    
    for a in range(l, r+1):
        if y % a == 0 and gcd(a, y//a) == x:
            count += 1
    
    print(count)

solve()","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    
    count = 0
    for a in range(l, r + 1):
        if y % a == 0 and gcd(a, y // a) == x:
            count += 1
    
    print(count)

solve()
","
from math import gcd

def solve():
    l, r, x, y = map(int, input().split())
    count = 0
    for a in range(l, r+1):
        if y % a == 0 and gcd(a, y//a) == x and a <= y//a <= r:
            count += 1
    print(count)

solve()
","60.0","0.0","20.0","60.0","20.0","60.0","60.0","60.0","60.0","60.0","60.0","60.0","0.0","60.0","60.0","20.0","","","","","","","","","","","","","","","",""
"APPS/81","
QUESTION:
Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.

Neko has two integers $a$ and $b$. His goal is to find a non-negative integer $k$ such that the least common multiple of $a+k$ and $b+k$ is the smallest possible. If there are multiple optimal integers $k$, he needs to choose the smallest one.

Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?


-----Input-----

The only line contains two integers $a$ and $b$ ($1 \le a, b \le 10^9$).


-----Output-----

Print the smallest non-negative integer $k$ ($k \ge 0$) such that the lowest common multiple of $a+k$ and $b+k$ is the smallest possible.

If there are many possible integers $k$ giving the same value of the least common multiple, print the smallest one.


-----Examples-----
Input
6 10

Output
2
Input
21 31

Output
9
Input
5 10

Output
0


-----Note-----

In the first test, one should choose $k = 2$, as the least common multiple of $6 + 2$ and $10 + 2$ is $24$, which is the smallest least common multiple possible.
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    a, b = map(int, input().split())
    diff = b - a
    if diff == 0:
        return 0
    for k in range(diff):
        if (a + k) % gcd(a + k, b + k) == 0 and (b + k) % gcd(a + k, b + k) == 0:
            return k
    return diff

solve()","
import math

def solve():
    a, b = map(int, input().split())
    gcd = math.gcd(a, b)
    diff = abs(a - b)
    k = min(a % gcd, b % gcd, diff - a % gcd, diff - b % gcd)
    print(k)

solve()
","
from math import gcd

def solve():
    a, b = map(int, input().split())
    g = gcd(a, b)
    k = min(a % g, b % g)
    print(k)

solve()
","
import math

def solve():
    a, b = map(int, input().split())
    
    def gcd(x, y):
        while y:
            x, y = y, x % y
        return x
    
    def lcm(x, y):
        return x * y // gcd(x, y)
    
    res = 0
    lcm_min = math.inf
    for k in range(max(a, b), max(a, b) + min(a, b)):
        cur_lcm = lcm(a + k, b + k)
        if cur_lcm < lcm_min:
            lcm_min = cur_lcm
            res = k
    
    print(res)

solve()
","
import math

def solve():
    a, b = map(int, input().split())
    
    def gcd(x, y):
        if y == 0:
            return x
        return gcd(y, x % y)
    
    def lcm(x, y):
        return (x * y) // gcd(x, y)
    
    start = max(a, b) - min(a, b)
    k = 0
    min_lcm = lcm(a, b)
    
    for i in range(1, int(math.sqrt(start))+1):
        if start % i == 0:
            if i >= min_lcm and (a+i) % (b+i) == 0:
                k = i
                break
            if start // i >= min_lcm and (a+start//i) % (b+start//i) == 0:
                k = start // i
    
    return k

solve()","
from math import gcd

def solve():
    a, b = map(int, input().split())
    n = int(max(0, min(a, b)))
    for k in range(n, a*b):
        lcm = (a + k) * (b + k) // gcd(a + k, b + k)
        if k == n or lcm < min_lcm:
            min_lcm = lcm
            min_k = k
    print(min_k)

solve()
","
from math import gcd

def solve():
    a, b = map(int, input().split())
    
    d = gcd(a, b)
    diff = b - a
    
    if diff == 0:
        return 0
    
    k = (diff % d) * (pow(diff, -1, d) % d)
    return k % d

solve()
","
import math

def solve():
    a, b = map(int, input().split())
    diff = abs(a - b)
    for k in range(diff+1):
        if (a+k) % diff == 0 and (b+k) % diff == 0:
            return k

print(solve())

solve()","
import math

def solve():
    a, b = map(int, input().split())
    
    diff = abs(a - b)
    
    if diff == 0:
        print(0)
    else:
        k = min(a % diff, diff - a % diff)
        print(k)

solve()
","
from math import gcd

def solve():
    a, b = map(int, input().split())
    diff = b - a
    if diff == 0:
        return 0
    factors = [i for i in range(1, int(diff**0.5)+1) if diff % i == 0]
    factors += [diff // i for i in factors if i*i != diff]
    factors.append(diff)
    factors.sort()
    for k in factors:
        if (a + k) % gcd(a+k, b+k) == 0:
            return k

print(solve())
  
solve()","
from math import gcd

def solve():
    a, b = map(int, input().split())
    
    def lcm(x, y):
        return x * y // gcd(x, y)
    
    if a > b:
        a, b = b, a
    
    if a == b:
        print(0)
        return
    
    k = b - a
    for i in range(1, int(k ** 0.5) + 1):
        if k % i == 0:
            if lcm(a + i, b + i) < lcm(a + k // i, b + k // i):
                k = i
    
    print(k)

solve()
  ","
from math import gcd

def solve():
    a, b = map(int, input().split())
    
    diff = abs(a - b)
    if diff == 0:
        print(0)
    else:
        g = gcd(a, b)
        ans = min(a % g, b % g)
        print(g - ans)

solve()
","
import math

def solve():
    a, b = map(int, input().split())
    
    def lcm(x, y):
        return x * y // math.gcd(x, y)
    
    diff = abs(a - b)
    
    if a == b:
        print(0)
    else:
        k = min(a % diff, diff - a % diff)
        lcm1 = lcm(a + k, b + k)
        k2 = diff - k
        lcm2 = lcm(a + k2, b + k2)

        if lcm1 < lcm2:
            print(k)
        else:
            print(k2)

  
solve()","
import math

def solve():
    a, b = map(int, input().split())
    
    diff = abs(a - b)
    res = 0
    
    if diff == 0:
        res = a
    else:
        for k in range(1, diff):
            x = math.lcm(a+k, b+k)
            y = math.lcm(a+res, b+res)
            if x < y:
                res = k
    
    print(res)

solve()
","
from math import gcd

def solve():
    a, b = map(int, input().split())
    
    def lcm(x, y):
        return x // gcd(x, y) * y
    
    k = 0
    if abs(a - b) >= 2:
        k = min(a, b) - 1
    print(k)

solve()
","
from math import gcd

def solve():
    a, b = map(int, input().split())
    diff = b - a
    
    if diff == 0:
        return 0
    else:
        ans = 0
        for i in range(1, int(diff**0.5)+1):
            if diff % i == 0:
                if gcd(i + a, i + b) == i:
                    ans = max(ans, i)
                if gcd(diff // i + a, diff // i + b) == diff // i:
                    ans = max(ans, diff // i)
        return diff - ans

print(solve())

solve()","0.0","20.0","20.0","0.0","0.0","14.285714285714285","0.0","0.0","26.666666666666668","0.0","13.333333333333334","20.0","60.0","77.77777777777779","13.333333333333334","0.0","","","","","","","","","","","","","","","",""
"APPS/82","
QUESTION:
Noora is a student of one famous high school. It's her final year in school — she is going to study in university next year. However, she has to get an «A» graduation certificate in order to apply to a prestigious one.

In school, where Noora is studying, teachers are putting down marks to the online class register, which are integers from 1 to k. The worst mark is 1, the best is k. Mark that is going to the certificate, is calculated as an average of all the marks, rounded to the closest integer. If several answers are possible, rounding up is produced. For example, 7.3 is rounded to 7, but 7.5 and 7.8784 — to 8. 

For instance, if Noora has marks [8, 9], then the mark to the certificate is 9, because the average is equal to 8.5 and rounded to 9, but if the marks are [8, 8, 9], Noora will have graduation certificate with 8.

To graduate with «A» certificate, Noora has to have mark k.

Noora got n marks in register this year. However, she is afraid that her marks are not enough to get final mark k. Noora decided to ask for help in the internet, where hacker Leha immediately responded to her request. He is ready to hack class register for Noora and to add Noora any number of additional marks from 1 to k. At the same time, Leha want his hack be unseen to everyone, so he decided to add as less as possible additional marks. Please help Leha to calculate the minimal number of marks he has to add, so that final Noora's mark will become equal to k.


-----Input-----

The first line contains two integers n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 100) denoting the number of marks, received by Noora and the value of highest possible mark.

The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ k) denoting marks received by Noora before Leha's hack.


-----Output-----

Print a single integer — minimal number of additional marks, that Leha has to add in order to change Noora's final mark to k.


-----Examples-----
Input
2 10
8 9

Output
4
Input
3 5
4 4 4

Output
3


-----Note-----

Consider the first example testcase.

Maximal mark is 10, Noora received two marks — 8 and 9, so current final mark is 9. To fix it, Leha can add marks [10, 10, 10, 10] (4 marks in total) to the registry, achieving Noora having average mark equal to $\frac{8 + 9 + 10 + 10 + 10 + 10}{6} = \frac{57}{6} = 9.5$. Consequently, new final mark is 10. Less number of marks won't fix the situation.

In the second example Leha can add [5, 5, 5] to the registry, so that making average mark equal to 4.5, which is enough to have 5 in the certificate.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_sum = sum(marks)
    target_sum = k * (n + 1)
    
    additional_marks = max(0, target_sum - current_sum)
    
    print(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_avg = sum(marks) / n
    if current_avg >= k:
        print(0)
    else:
        additional_marks = ((k * (n + 1)) - sum(marks)) // n
        print(max(0, additional_marks))

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_sum = sum(marks)
    total_marks = n
    
    while (current_sum + total_marks) / (n + total_marks) < k:
        total_marks += 1
    
    print(total_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))

    current_sum = sum(marks)
    total_marks_needed = k * (n + 1)
    additional_marks = max(total_marks_needed - current_sum, 0)

    print(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_sum = sum(marks)
    current_num = len(marks)
    
    target_sum = k * (current_num + 1)
    additional_marks = max(0, target_sum - current_sum)
    
    print(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_sum = sum(marks)
    current_avg = current_sum / n
    required_avg = k - 0.5
    
    if current_avg >= required_avg:
        return 0
    
    additional_marks = ((required_avg * (n + 1)) - current_sum)
    return int(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_avg = sum(marks) / n
    min_additional_marks = 0
    
    while round(current_avg) < k:
        marks.append(k)
        n += 1
        current_avg = sum(marks) / n
        min_additional_marks += 1
        
    print(min_additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_avg = sum(marks) / n
    needed_avg = (sum(marks) + (n * k) - sum(marks)) / (n + len(marks))
    
    if needed_avg.is_integer():
        print(0)
    else:
        print(int(needed_avg.ceil() * (n + len(marks)) - sum(marks)))

solve()","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))

    current_sum = sum(marks)
    total_marks_needed = n * k
    additional_marks = max(0, ((n + 1) * k) - current_sum)

    print(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_sum = sum(marks)
    target_sum = k * (n + 1)
    
    additional_marks = max(0, target_sum - current_sum)

    print(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))

    total_marks = sum(marks)
    required_marks = n * k
    additional_marks = max(0, ((n + 1) * k) - total_marks)
    
    print(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))

    current_total = sum(marks)
    current_average = current_total / n

    needed_total = k * (n+1)
    additional_marks = max(0, needed_total - current_total)

    print((additional_marks + n - 1) // n)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_avg = sum(marks) / n
    additional_marks = max(0, ((n * k) + n - 1) // k - n)
    
    print(additional_marks)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    current_sum = sum(marks)
    target_sum = n * k
    
    additional_marks = max(0, -(-(target_sum - current_sum) // k))
    
    print(additional_marks)

solve()
","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    total_marks = sum(marks)
    desired_total = n * k
    additional_marks = max(0, (desired_total - total_marks + n - 1) // n)
    
    print(additional_marks)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    marks = list(map(int, input().split()))
    
    total_marks = sum(marks)
    expected_marks = k * (n + 1)
    
    add_marks = max(0, expected_marks - total_marks)
    
    print(add_marks)

solve()
","0.0","6.666666666666667","0","0.0","0.0","0.0","73.33333333333333","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","","","All tests timed out","","","","","","","","","","","","",""
"APPS/83","
QUESTION:
You are given an array of $n$ integers: $a_1, a_2, \ldots, a_n$. Your task is to find some non-zero integer $d$ ($-10^3 \leq d \leq 10^3$) such that, after each number in the array is divided by $d$, the number of positive numbers that are presented in the array is greater than or equal to half of the array size (i.e., at least $\lceil\frac{n}{2}\rceil$). Note that those positive numbers do not need to be an integer (e.g., a $2.5$ counts as a positive number). If there are multiple values of $d$ that satisfy the condition, you may print any of them. In case that there is no such $d$, print a single integer $0$.

Recall that $\lceil x \rceil$ represents the smallest integer that is not less than $x$ and that zero ($0$) is neither positive nor negative.


-----Input-----

The first line contains one integer $n$ ($1 \le n \le 100$) — the number of elements in the array.

The second line contains $n$ space-separated integers $a_1, a_2, \ldots, a_n$ ($-10^3 \le a_i \le 10^3$).


-----Output-----

Print one integer $d$ ($-10^3 \leq d \leq 10^3$ and $d \neq 0$) that satisfies the given condition. If there are multiple values of $d$ that satisfy the condition, you may print any of them. In case that there is no such $d$, print a single integer $0$.


-----Examples-----
Input
5
10 0 -7 2 6
Output
4
Input
7
0 0 1 -1 0 0 2

Output
0


-----Note-----

In the first sample, $n = 5$, so we need at least $\lceil\frac{5}{2}\rceil = 3$ positive numbers after division. If $d = 4$, the array after division is $[2.5, 0, -1.75, 0.5, 1.5]$, in which there are $3$ positive numbers (namely: $2.5$, $0.5$, and $1.5$).

In the second sample, there is no valid $d$, so $0$ should be printed.
Use user-input-Based format and function signature solve()","
def solve():
    import math
    
    n = int(input())
    arr = list(map(int, input().split()))
    
    pos_count = sum(1 for num in arr if num > 0)
    
    if pos_count >= math.ceil(n / 2):
        for d in range(-1000, 1001):
            if d != 0:
                new_arr = [num / d for num in arr]
                new_pos_count = sum(1 for num in new_arr if num > 0)
                if new_pos_count >= math.ceil(n / 2):
                    print(d)
                    return
    print(0)

solve()
","
def solve():
    import math
    
    n = int(input())
    a = list(map(int, input().split()))
    
    positive_count = sum(1 for num in a if num > 0)
    
    if positive_count >= math.ceil(n / 2):
        for d in range(-10**3, 10**3+1):
            if d != 0:
                new_array = [num / d for num in a]
                new_positive_count = sum(1 for num in new_array if num > 0)
                if new_positive_count >= math.ceil(n / 2):
                    print(d)
                    return
        print(0)
    else:
        print(0)

solve()
","
import math

def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    pos_count = sum(1 for num in arr if num > 0)
    
    if pos_count >= math.ceil(n/2):
        for d in range(-1000, 1001):
            if d != 0:
                new_arr = [num/d for num in arr]
                new_pos_count = sum(1 for num in new_arr if num > 0)
                if new_pos_count >= math.ceil(n/2):
                    print(d)
                    return
    print(0)

solve()","
def solve():
    import math

    n = int(input())
    arr = list(map(int, input().split()))

    pos_count = sum([1 for num in arr if num > 0])

    if pos_count >= math.ceil(n / 2):
        for d in range(-1000, 1001):
            if d != 0 and all((num % d == 0) for num in arr):
                print(d)
                return

    print(0)

solve()","
def solve():
    import math
    
    n = int(input())
    numbers = list(map(int, input().split()))
    
    positive_count = sum(1 for num in numbers if num > 0)
    
    if positive_count >= math.ceil(n / 2):
        d = 1
    else:
        d = 0
    
    while d == 0:
        d += 1
        if positive_count >= math.ceil(n / 2):
            break
  
    print(d)
  
solve()","
from math import ceil

def solve():
    n = int(input())
    a = list(map(int, input().split()))

    positive_count = sum(1 for x in a if x > 0)
    
    if positive_count >= ceil(n / 2):
        print(1)
    else:
        print(0)

solve()
  ","
from math import ceil

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    pos_count = sum(1 for num in arr if num > 0)
    neg_count = sum(1 for num in arr if num < 0)
    
    if pos_count >= ceil(n / 2):
        print(1)
    elif neg_count >= ceil(n / 2):
        print(-1)
    else:
        print(0)

solve()","
def solve():
    import math

    n = int(input())
    a = list(map(int, input().split()))

    positives = sum(1 for x in a if x > 0)
    negatives = sum(1 for x in a if x < 0)
    
    if positives >= math.ceil(n/2):
        print(1)
    elif positives < math.ceil(n/2) and n - negatives >= math.ceil(n/2):
        print(-1)
    else:
        print(0)

solve()","
import math

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    pos_count = sum(1 for num in arr if num > 0)
    
    if pos_count >= math.ceil(n / 2):
        print(1)
    else:
        print(0)

solve()","
def solve():
    import math
    
    n = int(input())
    a = list(map(int, input().split()))
    
    positives = sum(1 for i in a if i > 0)
    
    if positives >= math.ceil(n / 2):
        d = 1
    else:
        d = 0
    
    while d == 0:
        for i in range(1, 1001):
            valid = sum(1 for j in a if j % i > 0)
            if valid >= math.ceil(n / 2):
                d = i
                break
    
    print(d)

solve()
","
from math import ceil

def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    pos_count = sum(1 for a in arr if a > 0)
    neg_count = sum(1 for a in arr if a < 0)

    if pos_count >= ceil(n/2):
        d = 1
    elif neg_count >= ceil(n/2):
        d = -1
    else:
        d = 0

    print(d)
  
solve()","
def solve():
    import math

    n = int(input())
    a = list(map(int, input().split()))

    pos_count = sum(x > 0 for x in a)
    neg_count = sum(x < 0 for x in a)

    if pos_count >= math.ceil(n / 2):
        d = 1
    elif neg_count >= math.ceil(n / 2):
        d = -1
    else:
        d = 0

    print(d)

solve()
","
def solve():
    import math
    
    n = int(input())
    array = list(map(int, input().split()))
    
    positive_count = sum(1 for num in array if num > 0)
    
    if positive_count >= math.ceil(n / 2):
        d = 1
        while True:
            division_array = [num / d for num in array]
            division_positive_count = sum(1 for num in division_array if num > 0)
            if division_positive_count >= math.ceil(n / 2):
                break
            d += 1
        print(d)
    else:
        print(0)

solve()
","
import math

def solve():
    n = int(input())
    A = list(map(int, input().split()))
    
    pos_count = len([num for num in A if num > 0])
    
    if pos_count >= math.ceil(n / 2):
        d = 1
        while (pos_count < math.ceil(n / 2)):
            d *= 2
            pos_count = len([num for num in A if num / d > 0])
        print(d)
    else:
        print(0)

solve()","
import math

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    positive_count = sum(1 for num in arr if num > 0)
    
    if positive_count >= math.ceil(n/2):
        print(1)
    else:
        print(0)

solve()","
from math import ceil

def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    num_positives = sum(1 for num in arr if num > 0)
    if num_positives >= ceil(n / 2):
        d = 1
    else:
        d = 0
    
    print(d)

solve()
    ","60.0","60.0","60.0","13.333333333333334","53.333333333333336","66.66666666666666","100.0","66.66666666666666","66.66666666666666","61.53846153846154","100.0","100.0","66.66666666666666","66.66666666666666","66.66666666666666","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/84","
QUESTION:
There are n shovels in Polycarp's shop. The i-th shovel costs i burles, that is, the first shovel costs 1 burle, the second shovel costs 2 burles, the third shovel costs 3 burles, and so on. Polycarps wants to sell shovels in pairs.

Visitors are more likely to buy a pair of shovels if their total cost ends with several 9s. Because of this, Polycarp wants to choose a pair of shovels to sell in such a way that the sum of their costs ends with maximum possible number of nines. For example, if he chooses shovels with costs 12345 and 37454, their total cost is 49799, it ends with two nines.

You are to compute the number of pairs of shovels such that their total cost ends with maximum possible number of nines. Two pairs are considered different if there is a shovel presented in one pair, but not in the other.


-----Input-----

The first line contains a single integer n (2 ≤ n ≤ 10^9) — the number of shovels in Polycarp's shop.


-----Output-----

Print the number of pairs of shovels such that their total cost ends with maximum possible number of nines. 

Note that it is possible that the largest number of 9s at the end is 0, then you should count all such ways.

It is guaranteed that for every n ≤ 10^9 the answer doesn't exceed 2·10^9.


-----Examples-----
Input
7

Output
3

Input
14

Output
9

Input
50

Output
1



-----Note-----

In the first example the maximum possible number of nines at the end is one. Polycarp cah choose the following pairs of shovels for that purpose:  2 and 7;  3 and 6;  4 and 5. 

In the second example the maximum number of nines at the end of total cost of two shovels is one. The following pairs of shovels suit Polycarp:  1 and 8;  2 and 7;  3 and 6;  4 and 5;  5 and 14;  6 and 13;  7 and 12;  8 and 11;  9 and 10. 

In the third example it is necessary to choose shovels 49 and 50, because the sum of their cost is 99, that means that the total number of nines is equal to two, which is maximum possible for n = 50.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    if n % 2 == 0:
        print(1)
    else:
        print((n - 1) // 2)

solve()","
def solve():
    n = int(input())
    if n % 10 == 0:
        print(1)
    else:
        print(9)

solve()","
def solve():
    n = int(input())
    # Calculate the number of pairs to maximize the number of nines at the end of total cost
    if n % 2 == 0:
        print(""1"")
    else:
        print(min(n - 1, 9))

solve()
","
def solve():
    n = int(input())
    res = 0
    for i in range(1, n//2 + 1):
        temp = (i + n - i) % 10
        if temp == 9 or temp == 0:
            res += 1
    print(res)

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        print(1)
    else:
        print(n//2)

solve()","
def solve():
    import math

    n = int(input())

    if n % 2 == 0:
        print(n // 2 - 1)
        return

    res = int(math.sqrt(n))
    while n % res:
        res -= 1

    print((n - res) // res)

solve()","
def solve():
    n = int(input())
    ans = 0
    for i in range(1, n):
        j = n - i
        cost = i * j
        nines = 0
        while cost % 10 == 9:
            nines += 1
            cost //= 10
        ans = max(ans, nines)
    count = 0
    for i in range(1, n):
        j = n - i
        if i * j % 10 == 9 and i * j // 10 ** ans == 0:
            count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    res = 0

    for i in range(1, n // 2 + 1):
        if (i + n - i) % 10 == 9:
            res += 1

    print(res)

solve()
","
def solve():
    n = int(input())
    count = 0
    total_digits = len(str(n))
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            pair1 = i
            pair2 = n // i
            if pair1 + pair2 - 1 <= total_digits:
                count += 1
    return count

solve()
","
def solve():
    n = int(input())
    count = 0
    
    for i in range(1, n//2 + 1):
        j = n - i
        cost = str(i) + str(j)
        num_nines = 0
        for k in reversed(range(len(cost))):
            if cost[k] == '9':
                num_nines += 1
            else:
                break
        count = max(count, num_nines)
      
    print(count)

solve()
  ","
def solve():
    n = int(input())
    if n % 2 == 0:
        x = n // 2
        if x % 2 == 0:
            print(1)
        else:
            print(2)
    else:
        x = (n - 1) // 2
        y = (n + 1) // 2
        print(min(x, y) - 1)
  
solve()","
def solve():
    import math

    n = int(input())
    if n % 10 == 0:
        print(1)
    else:
        print(min(n % 10, 10 - n % 10))

solve()
","
def solve():
    n = int(input())
    max_nines = 0
    for i in range(1, n//2 + 1):
        total_cost = i + n - i
        nines_count = len(str(total_cost)) - len(str(int(str(total_cost)[::-1])))
        max_nines = max(max_nines, nines_count)
    pairs = 0
    for i in range(1, n//2 + 1):
        total_cost = i + n - i
        nines_count = len(str(total_cost)) - len(str(int(str(total_cost)[::-1]))
        if nines_count == max_nines:
            pairs += 1
    print(pairs)

solve()
","
def solve():
    n = int(input())
    ans = min(n - 1, 9)
    if n > 9:
        ans += 1
    print(ans)

solve()
","
def solve():
    n = int(input())
    a, b = divmod(n, 10)
    if b == 0:
        print(a)
    else:
        print(a + min(b, 10 - b))

solve()
","
def solve():
    n = int(input())
    result = 1 if n % 2 == 0 else n // 2
    print(result)

solve()
","26.666666666666668","13.333333333333334","6.666666666666667","14.285714285714285","26.666666666666668","6.666666666666667","0.0","7.142857142857142","0.0","7.142857142857142","6.666666666666667","20.0","0.0","0.0","13.333333333333334","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/85","
QUESTION:
Polycarpus likes giving presents to Paraskevi. He has bought two chocolate bars, each of them has the shape of a segmented rectangle. The first bar is a_1 × b_1 segments large and the second one is a_2 × b_2 segments large.

Polycarpus wants to give Paraskevi one of the bars at the lunch break and eat the other one himself. Besides, he wants to show that Polycarpus's mind and Paraskevi's beauty are equally matched, so the two bars must have the same number of squares.

To make the bars have the same number of squares, Polycarpus eats a little piece of chocolate each minute. Each minute he does the following:  he either breaks one bar exactly in half (vertically or horizontally) and eats exactly a half of the bar,  or he chips of exactly one third of a bar (vertically or horizontally) and eats exactly a third of the bar. 

In the first case he is left with a half, of the bar and in the second case he is left with two thirds of the bar.

Both variants aren't always possible, and sometimes Polycarpus cannot chip off a half nor a third. For example, if the bar is 16 × 23, then Polycarpus can chip off a half, but not a third. If the bar is 20 × 18, then Polycarpus can chip off both a half and a third. If the bar is 5 × 7, then Polycarpus cannot chip off a half nor a third.

What is the minimum number of minutes Polycarpus needs to make two bars consist of the same number of squares? Find not only the required minimum number of minutes, but also the possible sizes of the bars after the process.


-----Input-----

The first line of the input contains integers a_1, b_1 (1 ≤ a_1, b_1 ≤ 10^9) — the initial sizes of the first chocolate bar. The second line of the input contains integers a_2, b_2 (1 ≤ a_2, b_2 ≤ 10^9) — the initial sizes of the second bar.

You can use the data of type int64 (in Pascal), long long (in С++), long (in Java) to process large integers (exceeding 2^31 - 1).


-----Output-----

In the first line print m — the sought minimum number of minutes. In the second and third line print the possible sizes of the bars after they are leveled in m minutes. Print the sizes using the format identical to the input format. Print the sizes (the numbers in the printed pairs) in any order. The second line must correspond to the first bar and the third line must correspond to the second bar. If there are multiple solutions, print any of them.

If there is no solution, print a single line with integer -1.


-----Examples-----
Input
2 6
2 3

Output
1
1 6
2 3

Input
36 5
10 16

Output
3
16 5
5 16

Input
3 5
2 1

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    
    total_squares_1 = a1 * b1
    total_squares_2 = a2 * b2
    
    if total_squares_1 == total_squares_2:
        print(0)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif (a1 == a2 and b1 == b2) or (a1 == b2 and b1 == a2):
        print(1)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif total_squares_1 * 2 == total_squares_2 or total_squares_1 == total_squares_2 * 2:
        print(1)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif total_squares_1 * 3 == total_squares_2 or total_squares_1 == total_squares_2 * 3:
        print(1)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif total_squares_1 % 2 == 0 and total_squares_2 % 2 == 0:
        min_squares = min(total_squares_1, total_squares_2)
        max_squares = max(total_squares_1, total_squares_2)
        if max_squares % min_squares == 0:
            count = 0
            while max_squares % min_squares == 0:
                max_squares //= 2
                count += 1
            print(count)
            if total_squares_1 > total_squares_2:
                print(f""{a1} {b1}"")
                print(f""{max_squares} {min_squares}"")
            else:
                print(f""{max_squares} {min_squares}"")
                print(f""{a2} {b2}"")
        else:
            print(-1)
    else:
        print(-1)

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    total_squares_1 = a1 * b1
    total_squares_2 = a2 * b2

    if total_squares_1 == total_squares_2:
        print(0)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    else:
        min_squares = min(total_squares_1, total_squares_2)
        max_squares = max(total_squares_1, total_squares_2)

        for _ in range(1, 11):
            if min_squares * 2 == max_squares or min_squares * 3 == max_squares:
                print(_)
                print(f""{a1} {b1}"")
                print(f""{a2} {b2}"")
                return

            if min_squares < max_squares:
                min_squares *= 2
            else:
                min_squares *= 3

        print(-1)

solve()
","
def solve():
    from math import gcd
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    
    total_squares_1 = a1 * b1
    total_squares_2 = a2 * b2
    gcd_squares = gcd(total_squares_1, total_squares_2)
    
    if total_squares_1 // gcd_squares == a1 and total_squares_2 // gcd_squares == a2:
        bars = (total_squares_1 // gcd_squares, gcd_squares // b1), (total_squares_2 // gcd_squares, gcd_squares // b2)
        print(0)
        print(*[f'{size} {segment}' for size, segment in bars], sep='\n')
    else:
        possible_sizes = [(total_squares_1, total_squares_2), (total_squares_2, total_squares_1)]
        for size1, size2 in possible_sizes:
            if size1 % 2 == 0 and size2 % 2 == 0:
                half = (size1 // 2, size2), (size1 // 2, size2)
                print(1)
                print(*[f'{size} {segment}' for size, segment in half], sep='\n')
                return
            elif size1 % 3 == 0 and size2 % 3 == 0:
                third = (size1 * 2 // 3, size2), (size1 * 2 // 3, size2)
                print(1)
                print(*[f'{size} {segment}' for size, segment in third], sep='\n')
                return
        print(-1)
  
solve()","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    def count_squares(a, b):
        return a * b

    total_squares1 = count_squares(a1, b1)
    total_squares2 = count_squares(a2, b2)

    if total_squares1 != total_squares2:
        max_iterations = 6
        for i in range(max_iterations):
            if total_squares1 < total_squares2:
                if a1 < b1:
                    a1 *= 2
                else:
                    b1 *= 2
                total_squares1 = count_squares(a1, b1)
            elif total_squares1 > total_squares2:
                if a2 < b2:
                    a2 *= 2
                else:
                    b2 *= 2
                total_squares2 = count_squares(a2, b2)

            if total_squares1 == total_squares2:
                print(i+1)
                print(a1, b1)
                print(a2, b2)
                return

    print(-1)

solve()","
def solve():
    from math import gcd

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    total_squares_first = a1 * b1
    total_squares_second = a2 * b2

    common_squares = gcd(total_squares_first, total_squares_second)

    if common_squares != total_squares_first and common_squares != total_squares_second:
        factor_first = common_squares // total_squares_first
        factor_second = common_squares // total_squares_second
        
        if factor_first * a1 == a1 * factor_first:
            print(1)
            print(a1 * factor_first, b1)
            print(a2, b2 * factor_second)
        else:
            print(1)
            print(a1, b1 * factor_first)
            print(a2 * factor_second, b2)
    else:
        print(-1)

solve()
","
def solve():
    import math

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    def calculate(current, target):
        if current == target:
            return 0
        elif current < target:
            return math.inf
        elif current % 2 == 0 and current // 2 >= target:
            return 1
        elif current % 3 == 0 and current // 3 >= target:
            return 1
        else:
            return math.inf

    def min_moves(a, b):
        min_moves = math.inf
        min_a = 0
        min_b = 0
        for target_a in [a, a // 2, a // 3, a - 1]:
            for target_b in [b, b // 2, b // 3, b - 1]:
                moves = calculate(a, target_a) + calculate(b, target_b)
                if moves < min_moves:
                    min_moves = moves
                    min_a = target_a
                    min_b = target_b
        return min_moves, min_a, min_b

    moves1, new_a1, new_b1 = min_moves(a1 * b1, a2 * b2)
    moves2, new_a2, new_b2 = min_moves(a2 * b2, a1 * b1)

    if moves1 <= moves2:
        print(moves1)
        print(f""{new_a1 // b1} {b1}"")
        print(f""{new_a1 % b1} {b1}"")
    else:
        print(moves2)
        print(f""{a1} {new_b2 // a2}"")
        print(f""{a1} {new_b2 % a2}"")


solve()
","
def solve():
    from math import gcd

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    total_squares_1 = a1 * b1
    total_squares_2 = a2 * b2

    m = gcd(a1,b1) * gcd(a2,b2)

    if total_squares_1 // m == a1 and total_squares_2 // m == a2:
        print(m)
        print(a1, b1)
        print(a2, b2)
    else:
        print(-1)
  
solve()","
def solve():
    from math import gcd

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    s1 = a1 * b1
    s2 = a2 * b2

    if s1 < s2:
        a1, b1, a2, b2, s1, s2 = a2, b2, a1, b1, s2, s1

    g = gcd(a1, a2)
    if s1 != s2 and s1 // g * g != s1 and s2 // g * g != s2:
        print(-1)
    else:
        num_minutes = 0
        while a1 != a2 or b1 != b2:
            if a1 > a2 or b1 > b2:
                a1, b1, a2, b2 = a2, b2, a1, b1

            if a1 * b1 < a2 * b2:
                if a2 % 2 == 0 and a2 // 2 >= a1:
                    a2 //= 2
                    num_minutes += 1
                elif b2 % 2 == 0 and b2 // 2 >= b1:
                    b2 //= 2
                    num_minutes += 1
                else:
                    if a2 % 3 == 0 and a2 // 3 >= a1:
                        a2 = a2 // 3 * 2
                        num_minutes += 1
                    elif b2 % 3 == 0 and b2 // 3 >= b1:
                        b2 = b2 // 3 * 2
                        num_minutes += 1
                    else:
                        print(-1)
                        return
            else:
                a1, b1, a2, b2 = a2, b2, a1, b1

        print(num_minutes)
        print(str(a1) + "" "" + str(b1))
        print(str(a2) + "" "" + str(b2)

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    
    total_squares_1 = a1 * b1
    total_squares_2 = a2 * b2
    
    if total_squares_1 == total_squares_2:
        print(0)
        print(a1, b1)
        print(a2, b2)
    elif (total_squares_1 % 2 == 0 and total_squares_2 % 2 == 0) or (total_squares_1 % 3 == 0 and total_squares_2 % 3 == 0):
        min_minutes = 0
        while total_squares_1 != total_squares_2:
            if total_squares_1 < total_squares_2:
                if a1 % 2 == 0 and b1 % 2 == 0:
                    a1 //= 2
                    b1 //= 2
                elif a1 % 3 == 0 and b1 % 3 == 0:
                    a1 = 2 * a1 // 3
                    b1 = 2 * b1 // 3
            else:
                if a2 % 2 == 0 and b2 % 2 == 0:
                    a2 //= 2
                    b2 //= 2
                elif a2 % 3 == 0 and b2 % 3 == 0:
                    a2 = 2 * a2 // 3
                    b2 = 2 * b2 // 3
            total_squares_1 = a1 * b1
            total_squares_2 = a2 * b2
            min_minutes += 1
        print(min_minutes)
        print(a1, b1)
        print(a2, b2)
    else:
        print(-1)

solve()","
def solve():
    from math import gcd
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    
    if (a1*b1) != (a2*b2):
        print(-1)
        return
    
    k = gcd(a1, b1)
    v = a1//k
    u = b1//k
    if (a2 % v == 0 and b2 % u == 0) or (a2 % u == 0 and b2 % v == 0):
        print(0)
        print(a1, b1)
        print(a2, b2)
        return
    
    if (a2 % v == 0) or (b2 % v == 0):
        print(1)
        print(a1, b1)
        print(a2, b2)
        return
    
    if (a2 % u == 0) or (b2 % u == 0):
        print(1)
        print(a1, b1)
        print(a2, b2)
        return
    
    print(2)
    print(a1, b1)
    print(a2, b2)

solve()
  ","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    s1 = a1 * b1
    s2 = a2 * b2

    if s1 == s2:
        print(0)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif (a1 == a2 and b1 == b2) or (a1 == b2 and b1 == a2):
        print(1)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif s1 * 2 == s2 or s1 == s2 * 2:
        print(1)
        if s1 * 2 == s2:
            print(f""{a1 * 2} {b1}"")
            print(f""{a2} {b2}"")
        else:
            print(f""{a1} {b1}"")
            print(f""{a2 * 2} {b2}"")
    elif s1 * 3 == s2 or s1 == s2 * 3:
        print(1)
        if s1 * 3 == s2:
            print(f""{a1 * 3} {b1}"")
            print(f""{a2} {b2}"")
        else:
            print(f""{a1} {b1}"")
            print(f""{a2 * 3} {b2}"")
    else:
        diff = abs(s1 - s2)
        for w1, h1 in [(a1, b1), (b1, a1)]:
            for w2, h2 in [(a2, b2), (b2, a2)]:
                if w1 * h1 + diff == w2 * h2:
                    print(2)
                    print(f""{w1} {h1}"")
                    print(f""{w2} {h2}"")
                    return
        print(-1)

solve()
","
def solve():
    from math import gcd

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    total_squares_1 = a1 * b1
    total_squares_2 = a2 * b2

    if total_squares_1 > total_squares_2:
        a1, b1, a2, b2 = a2, b2, a1, b1
        total_squares_1, total_squares_2 = total_squares_2, total_squares_1

    if total_squares_2 % total_squares_1 != 0:
        print(-1)
        return

    ratio = total_squares_2 // total_squares_1

    a = a1 * (gcd(a1, b1)) * (gcd(a2, b2))
    b = total_squares_1 // a

    if a * b == total_squares_2:
        print(1)
        print(f""{a} {b}"")
        print(f""{a2} {b2}"")
    else:
        count = 0
        while a != a1:
            a *= 2 if a < a1 else 2 / 3
            count += 1
        while b != b1:
            b *= 2 if b < b1 else 2 / 3
            count += 1
        print(count)
        print(f""{a} {b}"")
        print(f""{a2} {b2}"")

solve()
  ","
def solve():
    from math import gcd

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    squares1 = a1 * b1
    squares2 = a2 * b2

    total_squares = squares1 + squares2

    if total_squares % gcd(a1, b1) != 0 or total_squares % gcd(a2, b2) != 0:
        print(-1)
        return

    min_minutes = abs(squares1 - squares2) // gcd(squares1, squares2)

    print(min_minutes)
    print(a1 + (squares1 - squares2) // 2, b1)
    print(a2, b2 + (squares2 - squares1) // 2)

solve()
  ","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    
    if a1 * b1 == a2 * b2:
        print(0)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif (a1, b1) == (a2, b2) or (a1, b1) == (b2, a2):
        print(1)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
    elif a1 * b1 % 2 == 0 and a2 * b2 % 2 == 0:
        if (a1 * b1) % 2 == 0 and (a2 * b2) % 2 == 0:
            print(2)
            print(f""{a1} {b1//2}"")
            print(f""{a2} {b2//2}"")
        else:
            print(2)
            if (a1 * b1) % 2 == 0:
                print(f""{a1} {b1//2}"")
                print(f""{a2} {b2}"")
            else:
                print(f""{a1} {b1}"")
                print(f""{a2} {b2//2}"")
    else:
        print(-1)

solve()","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    total_squares1 = a1 * b1
    total_squares2 = a2 * b2

    if total_squares1 != total_squares2:
        min_minutes = 0
        while total_squares1 != total_squares2:
            if total_squares1 > total_squares2:
                if a1 % 2 == 0 and a1 // 2 >= a2:
                    a1 //= 2
                elif b1 % 2 == 0 and b1 // 2 >= b2:
                    b1 //= 2
                else:
                    a1, b1 = b1, a1
            else:
                if a2 % 2 == 0 and a2 // 2 >= a1:
                    a2 //= 2
                elif b2 % 2 == 0 and b2 // 2 >= b1:
                    b2 //= 2
                else:
                    a2, b2 = b2, a2

            total_squares1 = a1 * b1
            total_squares2 = a2 * b2
            min_minutes += 1

        print(min_minutes)
        print(a1, b1)
        print(a2, b2)
    else:
        print(0)
        print(a1, b1)
        print(a2, b2)

solve()
","
def solve():
    import math

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())

    total_squares_1 = a1 * b1
    total_squares_2 = a2 * b2

    if total_squares_1 == total_squares_2:
        print(0)
        print(f""{a1} {b1}"")
        print(f""{a2} {b2}"")
        return

    total_squares_diff = abs(total_squares_1 - total_squares_2)

    for i in range(2):
        for j in range(2):
            divisor = 2 ** i * 3 ** j
            if total_squares_diff % divisor == 0:
                new_total_squares_1 = min(total_squares_1, total_squares_2) + total_squares_diff // divisor
                new_total_squares_2 = max(total_squares_1, total_squares_2)
                a1 = int(math.sqrt(new_total_squares_1))
                b1 = new_total_squares_1 // a1
                a2 = int(math.sqrt(new_total_squares_2))
                b2 = new_total_squares_2 // a2
                if a1 * b1 == new_total_squares_1 and a2 * b2 == new_total_squares_2:
                    print(i + j)
                    print(f""{a1} {b1}"")
                    print(f""{a2} {b2}"")
                    return

    print(-1)

solve()
","20.0","20.0","13.333333333333334","6.666666666666667","0.0","0.0","6.666666666666667","0.0","75.0","20.0","20.0","14.285714285714285","13.333333333333334","20.0","75.0","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/86","
QUESTION:
Polycarp and Vasiliy love simple logical games. Today they play a game with infinite chessboard and one pawn for each player. Polycarp and Vasiliy move in turns, Polycarp starts. In each turn Polycarp can move his pawn from cell (x, y) to (x - 1, y) or (x, y - 1). Vasiliy can move his pawn from (x, y) to one of cells: (x - 1, y), (x - 1, y - 1) and (x, y - 1). Both players are also allowed to skip move. 

There are some additional restrictions — a player is forbidden to move his pawn to a cell with negative x-coordinate or y-coordinate or to the cell containing opponent's pawn The winner is the first person to reach cell (0, 0). 

You are given the starting coordinates of both pawns. Determine who will win if both of them play optimally well.


-----Input-----

The first line contains four integers: x_{p}, y_{p}, x_{v}, y_{v} (0 ≤ x_{p}, y_{p}, x_{v}, y_{v} ≤ 10^5) — Polycarp's and Vasiliy's starting coordinates.

It is guaranteed that in the beginning the pawns are in different cells and none of them is in the cell (0, 0).


-----Output-----

Output the name of the winner: ""Polycarp"" or ""Vasiliy"".


-----Examples-----
Input
2 1 2 2

Output
Polycarp

Input
4 7 7 4

Output
Vasiliy



-----Note-----

In the first sample test Polycarp starts in (2, 1) and will move to (1, 1) in the first turn. No matter what his opponent is doing, in the second turn Polycarp can move to (1, 0) and finally to (0, 0) in the third turn.
Use user-input-Based format and function signature solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    
    polycarp_turns = min(xp, yp) + (xp > yp)
    vasiliy_turns = min(xv, yv, xp + yp)
    
    if polycarp_turns <= vasiliy_turns:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()
","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    
    turns_p = xp + yp  # number of turns for Polycarp
    turns_v = min(xv, yv)
    
    if turns_p <= turns_v:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()
","
def solve():
    xp, yp, xv, yv = map(int, input().split())

    diff_x = xp - xv
    diff_y = yp - yv

    if diff_x <= diff_y:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()
","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    
    steps_p = xp + yp
    steps_v = max(xv, yv)

    if (steps_p - 1) // 2 <= steps_v:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    distance_p = xp + yp
    distance_v = abs(xv - xp) + abs(yv - yp)

    if distance_p <= distance_v:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()
","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    
    x_diff = xp - xv
    y_diff = yp - yv
    
    if x_diff <= max(0, y_diff - 1) and y_diff <= max(0, x_diff - 1):
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()
","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    
    turns_polycarp_to_zero = max(xp, yp) - min(xp, yp) + min(xp, yp)
    turns_vasiliy_to_zero = 1 + max(xv, yv) - min(xv, yv) + min(xv, yv)
    
    if turns_polycarp_to_zero <= turns_vasiliy_to_zero:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    polycarp_moves = min(xp, yp)
    vasiliy_moves = min(xv, min(yv, yp))
    if polycarp_moves % 2 == 0:
        if vasiliy_moves % 2 == 1:
            print(""Polycarp"")
        else:
            print(""Vasiliy"")
    else:
        if vasiliy_moves % 2 == 1:
            print(""Vasiliy"")
        else:
            print(""Polycarp"")

solve()
  ","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    
    if (xp + yp) % 2 != (xv + yv) % 2:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    
    if xp + yp <= min(xv, yv) + 1:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())
   
    dist_p = xp + yp
    dist_v = min(xv, yv, xp+1)
    
    if dist_p <= dist_v:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    if xp + yp <= min(xv, yv) or xp == xv and yp == yv:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()
","
def solve():
    xp, yp, xv, yv = map(int, input().split())
    if xp + yp <= min(xv, yv) + 1:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())

    # Calculate the manhattan distance for both players
    dist_p = xp + yp
    dist_v = xv + yv

    # Check the winner based on the distance
    if dist_p <= dist_v:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()
","
def solve():
    xp, yp, xv, yv = map(int, input().split())

    polycarp_turns = 0
    vasiliy_turns = 0

    while xp + yp > 0:
        if xp - 1 >= yp and (xv < xp or yv < yp):
            xp -= 1
            polycarp_turns += 1
        elif yp - 1 >= xp and (xv < xp or yv < yp):
            yp -= 1
            polycarp_turns += 1
        elif xp >= yv and yp >= xv:
            xp -= 1
            yp -= 1
            vasiliy_turns += 1
        else:
            yp -= 1
            vasiliy_turns += 1

    winner = ""Polycarp"" if polycarp_turns % 2 == 1 else ""Vasiliy""
    return winner
  
solve()","
def solve():
    xp, yp, xv, yv = map(int, input().split())

    turns_p = (xp + yp) // 2
    turns_v = min(xv, yv)
    
    if (turns_p + (turns_p + 1) // 2) <= turns_v:
        print(""Polycarp"")
    else:
        print(""Vasiliy"")

solve()","80.0","46.666666666666664","40.0","66.66666666666666","66.66666666666666","80.0","73.33333333333333","40.0","80.0","73.33333333333333","46.666666666666664","46.666666666666664","73.33333333333333","73.33333333333333","0.0","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/87","
QUESTION:
Petr wants to make a calendar for current month. For this purpose he draws a table in which columns correspond to weeks (a week is seven consequent days from Monday to Sunday), rows correspond to weekdays, and cells contain dates. For example, a calendar for January 2017 should look like on the picture: $\left. \begin{array}{|r|r|r|r|r|r|} \hline & {2} & {9} & {16} & {23} & {30} \\ \hline & {3} & {10} & {17} & {24} & {31} \\ \hline & {4} & {11} & {18} & {25} & {} \\ \hline & {5} & {12} & {19} & {26} & {} \\ \hline & {6} & {13} & {20} & {27} & {} \\ \hline & {7} & {14} & {21} & {28} & {} \\ \hline 1 & {8} & {15} & {22} & {29} & {} \\ \hline \end{array} \right.$ 

Petr wants to know how many columns his table should have given the month and the weekday of the first date of that month? Assume that the year is non-leap.


-----Input-----

The only line contain two integers m and d (1 ≤ m ≤ 12, 1 ≤ d ≤ 7) — the number of month (January is the first month, December is the twelfth) and the weekday of the first date of this month (1 is Monday, 7 is Sunday).


-----Output-----

Print single integer: the number of columns the table should have.


-----Examples-----
Input
1 7

Output
6

Input
1 1

Output
5

Input
11 6

Output
5



-----Note-----

The first example corresponds to the January 2017 shown on the picture in the statements.

In the second example 1-st January is Monday, so the whole month fits into 5 columns.

In the third example 1-st November is Saturday and 5 columns is enough.
Use user-input-Based format and function signature solve()","
def solve():
    m, d = map(int, input().split())
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    columns = (days_in_month[m-1] + d - 1 + 6) // 7
    print(columns)

solve()
","
def solve():
    m, d = map(int, input().split())
    if m == 2:
        columns = 4 if d == 1 else 5
    elif m in [4, 6, 9, 11]:
        columns = 5
    else:
        columns = 6
    print(columns)

solve()","
from math import ceil

def solve():
    m, d = map(int, input().split())
    if m in {1, 3, 5, 7, 8, 10, 12}:
        print(ceil((d + 30) / 7))
    elif m == 2:
        print(ceil((d + 27) / 7))
    else:
        print(ceil((d + 29) / 7))

solve()","
def solve():
    m, d = map(int, input().split())
    if m in [1, 3, 5, 7, 8, 10, 12]:
        print(6 if d in [1, 2, 3, 4, 5, 6] else 5)
    elif m == 2:
        print(5)
    else:
        print(5 if d in [1, 2, 3, 4, 5] else 6)

solve()
","
def solve():
    m, d = map(int, input().split())

    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    columns = (days_in_month[m-1] + d - 1) // 7

    print(columns)
  
solve()","
def solve():
    m, d = map(int, input().split())
    if m in [1, 3, 5, 7, 8, 10, 12]:
        print((31 + (d - 1)) // 7 + 1)
    elif m == 2:
        print((28 + (d - 1)) // 7 + 1)
    else:
        print((30 + (d - 1)) // 7 + 1)

solve()","
def solve():
    m, d = map(int, input().split())
    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]  
    days_in_week = 7
    days_in_month = months[m - 1]
    
    offset = (days_in_week - d + 1) % days_in_week
    total_days = days_in_month + offset
    
    columns = (total_days + days_in_week - 1) // days_in_week
    
    print(columns)

solve()
  ","
def solve():
    m, d = map(int, input().split())
    
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    columns = (days_in_month[m-1] + d - 1 + 6) // 7
    
    print(columns)

solve()","
def solve():
    m, d = map(int, input().split())
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    return (days_in_month[m-1] + d + 5) // 7

solve()
","
def solve():
    m, d = map(int, input().split())
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    columns = (days_in_month[m-1] + d - 1 + 6) // 7
    print(columns)

solve()
","
def solve():
    m, d = map(int, input().split())
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    columns = (days_in_month[m-1] + d - 1) // 7
    if (days_in_month[m-1] + d - 1) % 7 != 0:
        columns += 1
    print(columns)

solve()
","
def solve():
    m, d = map(int, input().split())
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    columns = (days_in_month[m - 1] + d - 1) // 7 + 1
    print(columns)

solve()
","
def solve():
    month, weekday = map(int, input().split())
    
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    num_columns = (days_in_month[month-1] + weekday - 1) // 7 if (days_in_month[month-1] + weekday - 1) % 7 == 0 else (days_in_month[month-1] + weekday - 1) // 7 + 1
    
    print(num_columns)

solve()
","
def solve():
    m, d = map(int, input().split())
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    columns = (days_in_month[m-1] + d - 1) // 7 + 1
    print(columns)

solve()","
def solve():
    m, d = map(int, input().split())
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    cols = (days_in_month[m-1] + d - 1) // 7
    if ((days_in_month[m-1] + d - 1) % 7) > 0:
        cols += 1
    print(cols)

solve()
 ","
def solve():
    m, d = map(int, input().split())
    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    print((months[m-1] + d + 5) // 7)

solve()
","100.0","60.0","100.0","26.666666666666668","26.666666666666668","73.33333333333333","60.0","100.0","0.0","100.0","100.0","73.33333333333333","100.0","73.33333333333333","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/88","
QUESTION:
The year 2015 is almost over.

Limak is a little polar bear. He has recently learnt about the binary system. He noticed that the passing year has exactly one zero in its representation in the binary system — 2015_10 = 11111011111_2. Note that he doesn't care about the number of zeros in the decimal representation.

Limak chose some interval of years. He is going to count all years from this interval that have exactly one zero in the binary representation. Can you do it faster?

Assume that all positive integers are always written without leading zeros.


-----Input-----

The only line of the input contains two integers a and b (1 ≤ a ≤ b ≤ 10^18) — the first year and the last year in Limak's interval respectively.


-----Output-----

Print one integer – the number of years Limak will count in his chosen interval.


-----Examples-----
Input
5 10

Output
2

Input
2015 2015

Output
1

Input
100 105

Output
0

Input
72057594000000000 72057595000000000

Output
26



-----Note-----

In the first sample Limak's interval contains numbers 5_10 = 101_2, 6_10 = 110_2, 7_10 = 111_2, 8_10 = 1000_2, 9_10 = 1001_2 and 10_10 = 1010_2. Two of them (101_2 and 110_2) have the described property.
Use user-input-Based format and function signature solve()","
def solve():
    a, b = map(int, input().split())
    
    def count_years_with_one_zero(a, b):
        def count_zeros_in_binary(num):
            return bin(num).count('0') - 1
        
        count = 0
        for i in range(a, b+1):
            if count_zeros_in_binary(i) == 1:
                count += 1
        return count
    
    print(count_years_with_one_zero(a, b))

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_zeros(n):
        return bin(n).count('0') == 1
    
    total_years = sum(count_zeros(year) for year in range(a, b+1))
    
    print(total_years)

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_ones_in_binary(num):
        return bin(num).count('1')
    
    def is_one_zero_in_binary(num):
        binary_str = bin(num)[2:]
        return binary_str.count('0') == 1
    
    count = 0
    for i in range(a, b+1):
        if is_one_zero_in_binary(i):
            count += 1
    
    print(count)

solve()
   ","
def solve():
    a, b = map(int, input().split())
    
    def count_ones(n):
        return bin(n).count('1')
    
    ans = 0
    for i in range(a, b+1):
        if bin(i).count('0') == 1:
            ans += 1
            
    print(ans)

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_zeros(x):
        return bin(x)[2:].count('0') == 1
      
    result = sum(1 for year in range(a, b+1) if count_zeros(year))
    
    print(result)

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_ones(n):
        count = 0
        while n > 0:
            count += n % 2
            n //= 2
        return count
        
    def has_one_zero(n):
        binary_str = bin(n)[2:]
        return binary_str.count('0') == 1
        
    result = 0
    for i in range(a, b+1):
        if has_one_zero(i):
            result += 1
        
    print(result)

solve()","
def solve():
    a, b = map(int, input().split())
    
    def count_ones(n):
        count = 0
        while n > 0:
            count += n % 2
            n //= 2
        return count
    
    def has_one_zero(n):
        binary = bin(n)[2:]
        return binary.count('0') == 1
    
    answer = sum(1 for i in range(a, b + 1) if has_one_zero(i))
    
    print(answer)

solve()
","
def solve():
    a, b = map(int, input().split())
    num_years = 0
    for i in range(a, b+1):
        binary = bin(i)[2:]
        if binary.count('0') == 1:
            num_years += 1
    print(num_years)

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_zero_bits(num):
        count = 0
        while num > 0:
            if num % 2 == 0:
                count += 1
            num //= 2
        return count
    
    ans = 0
    for i in range(a, b + 1):
        if count_zero_bits(i) == 1:
            ans += 1
    
    print(ans)

solve()
","
def solve():
    a, b = map(int, input().split())
    count = 0
    for i in range(a, b+1):
        binary = bin(i)[2:]
        if binary.count('0') == 1:
            count += 1
    print(count)

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_one_zero_binary(num):
        binary = bin(num)[2:]
        return binary.count(""0"") == 1
    
    count = 0
    for i in range(a, b+1):
        if count_one_zero_binary(i):
            count += 1
    
    print(count)

solve()
","
def solve():
    a, b = map(int, input().split())
    count = 0
    while a <= b:
        binary = bin(a)[2:]
        if binary.count('0') == 1:
            count += 1
        a += 1
    print(count)

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_zeros(n):
        return bin(n)[2:].count('0') == 1
    
    count = 0
    for i in range(a, b+1):
        if count_zeros(i):
            count += 1
    
    print(count)

solve()
","
def solve():
    a, b = map(int, input().split())
    
    def count_zeros(num):
        binary = bin(num)[2:]
        return binary.count('0') == 1
    
    count = 0
    for i in range(a, b+1):
        if count_zeros(i):
            count += 1

    print(count)

solve()
","
def solve():
    a, b = map(int, input().split())
    count = 0
    for i in range(a, b+1):
        binary = bin(i)[2:]
        if binary.count('0') == 1:
            count += 1
    print(count)

solve()
","
def solve():
    a, b = map(int, input().split())
    count = 0
    for i in range(a, b + 1):
        binary_rep = bin(i)[2:]
        if binary_rep.count('0') == 1:
            count += 1
    print(count)

solve()
","100.0","38.46153846153847","100.0","38.46153846153847","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/89","
QUESTION:
You are given an integer N. Consider all possible segments on the coordinate axis with endpoints at integer points with coordinates between 0 and N, inclusive; there will be $\frac{n(n + 1)}{2}$ of them.

You want to draw these segments in several layers so that in each layer the segments don't overlap (they might touch at the endpoints though). You can not move the segments to a different location on the coordinate axis. 

Find the minimal number of layers you have to use for the given N.


-----Input-----

The only input line contains a single integer N (1 ≤ N ≤ 100).


-----Output-----

Output a single integer - the minimal number of layers required to draw the segments for the given N.


-----Examples-----
Input
2

Output
2

Input
3

Output
4

Input
4

Output
6



-----Note-----

As an example, here are the segments and their optimal arrangement into layers for N = 4. [Image]
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    layers = n*(n+1)//2
    print(layers)

solve()
","
def solve():
    import math

    N = int(input())
    layers = math.ceil(N * (N + 1) / 4)
    
    return layers

solve()","
def solve():
    n = int(input())
    layers = n * (n + 1) // 2
    print(layers)

solve()","
def solve():
    N = int(input())
    layers = N * (N + 1) // 2
    print(layers)

solve()
","
def solve():
    n = int(input())
    layers = n*(n+1)//2
    print(layers)

solve()
","
def solve():
    import math
    N = int(input())
    layers = math.ceil(N*(N+1)/4)
    return layers

solve()","
def solve():
    N = int(input())
    layers = 0
    for i in range(1, N+1):
        layers += i
    return layers

solve()
","
from math import ceil

def solve():
    n = int(input())
    layers = ceil(n * (n + 1) / 4)
    return layers

solve()","
def solve():
    N = int(input())
    layers = N*(N + 1)//2
    print(layers)

solve()
","
from math import ceil

def solve():
    N = int(input())
    layers = 1

    for i in range(2, N + 1):
        layers += i

    return layers


solve()","
def solve():
    n = int(input())
    layers = n*(n+1)//2
    print(layers)


solve()","
def solve():
    N = int(input())
    layers = N * (N + 1) // 2
    print(layers)

solve()
","
def solve():
    N = int(input())
    layers = 0
    for i in range(1, N+1):
        layers += i
    print(layers)

solve()
","
def solve():
    n = int(input())
    layers = n*(n+1)//2
    print(layers)

solve()
","
def solve():
    import math
    N = int(input())
    layers = math.ceil(N*(N+1)/2 / N)
    return layers

solve()","
def solve():
    n = int(input())
    layers = n*(n+1)//2
    print(layers)

solve()
","6.666666666666667","0.0","6.666666666666667","6.666666666666667","6.666666666666667","0.0","0.0","0.0","6.666666666666667","0.0","6.666666666666667","6.666666666666667","6.666666666666667","6.666666666666667","0.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/90","
QUESTION:
Anya loves to fold and stick. Today she decided to do just that.

Anya has n cubes lying in a line and numbered from 1 to n from left to right, with natural numbers written on them. She also has k stickers with exclamation marks. We know that the number of stickers does not exceed the number of cubes.

Anya can stick an exclamation mark on the cube and get the factorial of the number written on the cube. For example, if a cube reads 5, then after the sticking it reads 5!, which equals 120.

You need to help Anya count how many ways there are to choose some of the cubes and stick on some of the chosen cubes at most k exclamation marks so that the sum of the numbers written on the chosen cubes after the sticking becomes equal to S. Anya can stick at most one exclamation mark on each cube. Can you do it?

Two ways are considered the same if they have the same set of chosen cubes and the same set of cubes with exclamation marks.


-----Input-----

The first line of the input contains three space-separated integers n, k and S (1 ≤ n ≤ 25, 0 ≤ k ≤ n, 1 ≤ S ≤ 10^16) — the number of cubes and the number of stickers that Anya has, and the sum that she needs to get. 

The second line contains n positive integers a_{i} (1 ≤ a_{i} ≤ 10^9) — the numbers, written on the cubes. The cubes in the input are described in the order from left to right, starting from the first one. 

Multiple cubes can contain the same numbers.


-----Output-----

Output the number of ways to choose some number of cubes and stick exclamation marks on some of them so that the sum of the numbers became equal to the given number S.


-----Examples-----
Input
2 2 30
4 3

Output
1

Input
2 2 7
4 3

Output
1

Input
3 1 1
1 1 1

Output
6



-----Note-----

In the first sample the only way is to choose both cubes and stick an exclamation mark on each of them.

In the second sample the only way is to choose both cubes but don't stick an exclamation mark on any of them.

In the third sample it is possible to choose any of the cubes in three ways, and also we may choose to stick or not to stick the exclamation mark on it. So, the total number of ways is six.
Use user-input-Based format and function signature solve()","
from math import factorial

def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    def count_ways(idx, stickers_left, sum_so_far):
        if idx == n:
            return 1 if sum_so_far == S else 0
        ways = count_ways(idx + 1, stickers_left, sum_so_far)
        if stickers_left > 0:
            ways += count_ways(idx + 1, stickers_left - 1, sum_so_far + factorial(cubes[idx]))
        return ways

    ways = count_ways(0, k, 0)
    print(ways)

solve()
","
import functools

def solve():
    n, k, S = map(int, input().split())
    a = list(map(int, input().split()))

    @functools.lru_cache(None)
    def dp(idx, stickers_left, target_sum):
        if idx == n:
            return target_sum == 0

        res = dp(idx + 1, stickers_left, target_sum) + dp(idx + 1, stickers_left, target_sum - a[idx])
        
        if stickers_left > 0:
            res += dp(idx + 1, stickers_left - 1, target_sum - a[idx] * a[idx])

        return res

    print(dp(0, k, S))

solve()
  ","
def solve():
    from itertools import product

    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    total_ways = 0
    for i in range(1, k + 1):
        for combo in product(range(2), repeat=n):
            marked_sum = sum(cubes[j] if combo[j] == 0 else cubes[j] * cubes[j] for j in range(n))
            if marked_sum == S:
                total_ways += 1

    print(total_ways)

solve()
","
from math import factorial

def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    count = 0

    for mask in range(1 << n):
        total = 0
        stickers_used = 0
        
        for i in range(n):
            if (mask & (1 << i)):
                total += factorial(cubes[i])
                stickers_used += 1
        
        if total == S and stickers_used <= k:
            count += 1
            
    print(count)

solve()
","
from math import factorial

def solve():
    n, k, S = map(int, input().split())
    a = list(map(int, input().split()))

    def count_ways(i, remaining_k, remaining_S):
        if i == n:
            if remaining_k == 0 and remaining_S == 0:
                return 1
            else:
                return 0

        ways = count_ways(i + 1, remaining_k, remaining_S) + count_ways(i + 1, remaining_k - 1, remaining_S - a[i] * factorial(a[i]))

        return ways

    ways = count_ways(0, k, S)
    print(ways)

solve()
","
def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    def count_ways(S, pos, count, total):
        if pos == n:
            return count if count <= k and total == S else 0
        return count_ways(S, pos + 1, count, total) + count_ways(S, pos + 1, count + 1, total * cubes[pos])

    total_ways = count_ways(S, 0, 0, 1)
    print(total_ways)

solve()
  ","
def solve():
    import itertools
    
    n, k, s = map(int, input().split())
    cubes = list(map(int, input().split()))
    
    count = 0
    for i in range(1, n+1):
        for combination in itertools.combinations(range(n), i):
            for stickers in itertools.product(range(2), repeat=i):
                total = sum(cubes[j] if stickers[idx] == 0 else cubes[j] * cubes[j] for idx, j in enumerate(combination))
                if total == s:
                    count += 1
    
    print(count)
  
solve()","
from itertools import product

def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    count = 0
    for i in range(1, n+1):
        for positions in product([0, 1], repeat=i):
            selected_cubes = [cubes[idx] for idx, stick in enumerate(positions) if stick == 1]
            if len(selected_cubes) <= k and sum(selected_cubes) == S:
                count += 1

    print(count)

solve()
","
def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    def count_ways(idx, stickers_left, sum_so_far):
        if idx == n:
            return 1 if sum_so_far == S else 0
        ways = count_ways(idx + 1, k, sum_so_far)  # Choose not to put sticker on current cube
        ways += count_ways(idx + 1, stickers_left, sum_so_far + cubes[idx]) if stickers_left > 0 else 0  # Choose to put sticker on current cube
        return ways

    return count_ways(0, k, 0)

solve()
","
def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    def recursive(idx, total, stickers_left):
        if idx == n:
            if total == S:
                return 1
            else:
                return 0

        ways = 0
        # Choose not to stick exclamation mark on current cube
        ways += recursive(idx + 1, total, stickers_left)
        # Choose to stick exclamation mark on current cube
        ways += recursive(idx + 1, total + cubes[idx], stickers_left - 1) if stickers_left > 0 else 0

        return ways

    return recursive(0, 0, k)

solve()
","
def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    def factorial(num):
        result = 1
        for i in range(1, num + 1):
            result *= i
        return result

    def count_ways(curr_cube, curr_sum, curr_stick):
        if curr_cube == n:
            if curr_sum == S and curr_stick <= k:
                return 1
            else:
                return 0
        no_stick = count_ways(curr_cube + 1, curr_sum + cubes[curr_cube], curr_stick)
        stick = count_ways(curr_cube + 1, curr_sum + factorial(cubes[curr_cube]), curr_stick + 1)
        return no_stick + stick

    return count_ways(0, 0, 0)

solve()
","
import itertools

def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))
    
    count = 0
    for i in range(1, n+1):
        for subset in itertools.combinations(range(n), i):
            factorials = [1] * n
            for j in subset:
                factorials[j] = cubes[j]
            total = sum(factorials)
            if total == S and sum(1 for f in factorials if f > 1) <= k:
                count += 1
    
    print(count)

solve()
","
from itertools import product

def solve():
    n, k, S = map(int, input().split())
    a = list(map(int, input().split()))
    
    total_ways = 0
    for i in range(1, n + 1):
        for comb in product([0, 1], repeat=n):
            sum_selected = sum(a[j] if comb[j] == 1 else a[j]*factorial(a[j]) for j in range(n))
            if sum_selected == S and sum(comb) <= k:
                total_ways += 1

    print(total_ways)

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

solve()
","
from itertools import product

def solve():
    n, k, S = map(int, input().split())
    cubes = list(map(int, input().split()))

    ways = 0
    for i in range(1, n + 1):
        for comb in product([0, 1], repeat=i):
            if sum(c * cubes[j] for j, c in enumerate(comb)) == S and sum(comb) <= k:
                ways += 1

    print(ways)

solve()
  ","
def solve():
    from math import factorial

    def count_ways(n, k, S, numbers):
        def helper(index, stickers_left, current_sum):
            if index == n:
                return current_sum == S

            ways = 0
            for i in range(k + 1):
                new_sum = current_sum + (factorial(numbers[index]) if i == 1 else numbers[index])
                ways += helper(index + 1, stickers_left - i, new_sum)

            return ways

        return helper(0, k, 0)

    n, k, S = map(int, input().split())
    numbers = list(map(int, input().split()))

    result = count_ways(n, k, S, numbers)
    return result

solve()","
import math

def solve():
    n, k, S = map(int, input().split())
    a = list(map(int, input().split()))
    
    def count_ways(idx, sum_so_far, sticker_cnt):
        if idx == n:
            if sum_so_far == S and sticker_cnt <= k:
                return 1
            else:
                return 0
        ways = 0
        ways += count_ways(idx + 1, sum_so_far + math.factorial(a[idx]), sticker_cnt + 1)
        ways += count_ways(idx + 1, sum_so_far, sticker_cnt)
        return ways
    
    result = count_ways(0, 0, 0)
    print(result)

solve()
  ","7.6923076923076925","33.33333333333333","0.0","9.090909090909092","0.0","0.0","25.0","16.666666666666664","0.0","0.0","0.0","8.333333333333332","0.0","16.666666666666664","0.0","9.090909090909092","","","","","","","","","","","","","","","",""
"APPS/91","
QUESTION:
Suppose you are performing the following algorithm. There is an array $v_1, v_2, \dots, v_n$ filled with zeroes at start. The following operation is applied to the array several times — at $i$-th step ($0$-indexed) you can:   either choose position $pos$ ($1 \le pos \le n$) and increase $v_{pos}$ by $k^i$;  or not choose any position and skip this step. 

You can choose how the algorithm would behave on each step and when to stop it. The question is: can you make array $v$ equal to the given array $a$ ($v_j = a_j$ for each $j$) after some step?


-----Input-----

The first line contains one integer $T$ ($1 \le T \le 1000$) — the number of test cases. Next $2T$ lines contain test cases — two lines per test case.

The first line of each test case contains two integers $n$ and $k$ ($1 \le n \le 30$, $2 \le k \le 100$) — the size of arrays $v$ and $a$ and value $k$ used in the algorithm.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($0 \le a_i \le 10^{16}$) — the array you'd like to achieve.


-----Output-----

For each test case print YES (case insensitive) if you can achieve the array $a$ after some step or NO (case insensitive) otherwise.


-----Example-----
Input
5
4 100
0 0 0 0
1 2
1
3 4
1 4 1
3 2
0 1 3
3 9
0 59049 810

Output
YES
YES
NO
NO
YES



-----Note-----

In the first test case, you can stop the algorithm before the $0$-th step, or don't choose any position several times and stop the algorithm.

In the second test case, you can add $k^0$ to $v_1$ and stop the algorithm.

In the third test case, you can't make two $1$ in the array $v$.

In the fifth test case, you can skip $9^0$ and $9^1$, then add $9^2$ and $9^3$ to $v_3$, skip $9^4$ and finally, add $9^5$ to $v_2$.
Use user-input-Based format and function signature solve()","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        possible = True
        for i in range(n):
            diff = a[i]
            for j in range(i):
                diff -= k ** (i - j) * a[j]
            if diff % k != 0 or diff < 0:
                possible = False
                break
        
        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        possible = False
        for i in range(30):
            diff = a[0] % (k ** (i + 1))
            valid = True
            for j in range(1, n):
                if a[j] % (k ** (i + 1)) != diff:
                    valid = False
                    break
            if valid:
                possible = True
                break
        
        if possible:
            print(""YES"")
        else:
            print(""NO"")
  
solve()","
from typing import List

def solve() -> None:
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        res = ""YES""
        for i in range(n):
            if (a[i] - sum(k**j for j in range(i+1))) % (k**(i+1)) != 0:
                res = ""NO""
                break
        
        print(res)

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        # Function to check if array 'a' can be achieved
        def can_achieve(n, k, a):
            target = [0] * n
            for i in range(n):
                c = 0
                while target[i] < a[i]:
                    if k**c == a[i] - target[i]:
                        target[i] = a[i]
                    elif k**c < a[i] - target[i]:
                        c += 1
                    else:
                        return False
            return True
        
        if can_achieve(n, k, a):
            print(""YES"")
        else:
            print(""NO"")


solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))

        can_achieve = False
        for i in range(2**n):
            v = [0] * n
            for j in range(n):
                if (i >> j) & 1:
                    v[j] = sum(k**m for m in range(i+1))
            
            if v == a:
                can_achieve = True
                break
        
        if can_achieve:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        total_sum = sum([k**i for i in range(n)])
        max_val = max(a)
        
        if total_sum < max_val or (total_sum - max_val) % 2 != 0:
            print(""NO"")
        else:
            print(""YES"")

solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        possible = True
        curr_val = [0] * n
        for i in range(30):  # we only need to iterate till 30 as k goes up to 100
            temp_val = [0] * n
            for j in range(n):
                if a[j] - curr_val[j] < 0 or (a[j] - curr_val[j]) % k != 0:
                    possible = False
                    break
                temp_val[j] = (a[j] - curr_val[j]) // k
                
            for j in range(n):
                curr_val[j] += temp_val[j] * (k**i)
        
        if possible and curr_val == a:
            print(""YES"")
        else:
            print(""NO"")


solve()
","
def solve():
    import sys

    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))

        max_possible_value = sum([k**i for i in range(n)])

        if max(a) > max_possible_value:
            print(""NO"")
        elif sum(a) % (k-1) == 0:
            print(""YES"")
        else:
            print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))

        possible = True
        for i in range(n):
            diff = a[i] - sum(k ** j for j in range(i + 1))
            if diff % (k ** (i + 1)) != 0 or diff < 0:
                possible = False
                break
        
        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()
  ","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))

        can_achieve = True
        for i in range(n):
            if a[i] % k != 0:
                can_achieve = False

        if can_achieve:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        can_achieve = 'YES'
        sum_values = 0
        max_value = pow(k, n - 1)
        
        for i in range(n):
            if a[i] > max_value:
                can_achieve = 'NO'
                break
            sum_values += a[i]
            if sum_values > max_value:
                can_achieve = 'NO'
                break
        
        print(can_achieve)

solve()
","
def solve():
    import math
    
    T = int(input())
    
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        max_sum = sum(k ** i for i in range(n))
        
        possible = False
        for i in range(max_sum + 1):
            dp = [False] * (max_sum + 1)
            dp[0] = True
            
            for j in range(n):
                if dp[max(0, a[j] - i)]:
                    dp[a[j]] = True
                    
            if dp[i]:
                possible = True
                break
                
        if possible:
            print(""YES"")
        else:
            print(""NO"")
  
solve()","
def solve():
    import math
    
    T = int(input())
    
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        possible = False
        for i in range(1, n+1):
            target_sum = sum(k**j for j in range(i))
            
            if (sum(a[:i]) <= target_sum) and ((target_sum - sum(a[:i])) % k**i == 0):
                possible = True
                break
        
        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    T = int(input())
    for _ in range(T):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))

        possible = True
        curr_val = 0
        for i in range(n):
            if a[i] < curr_val:
                possible = False
                break
            if (a[i] - curr_val) % k != 0:
                curr_val += ((a[i] - curr_val) // k + 1) * k
            elif i < n - 1 and (a[i] - curr_val) // k < (a[i + 1] - curr_val) % k:
                curr_val += ((a[i] - curr_val) // k + 1) * k
            else:
                curr_val = a[i]

        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    t = int(input())
    
    for _ in range(t):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        current = [0] * n
        possible = True
        
        for i in range(30):  # We consider at most 30 steps
            target = [(a[j] - current[j]) % k for j in range(n)]
            if sum(target) == 0:
                break
                
            if sum(target) % n != 0 or max(target) > k:
                possible = False
                break
                
            incr = sum(target) // n
            for j in range(n):
                current[j] += incr
        
        if possible:
            print(""YES"")
        else:
            print(""NO"")

# Needed imports
import sys

# Call the function
solve()
","
def solve():
    t = int(input())
    for _ in range(t):
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        
        if sum(a) % (k ** n) == 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
  ","80.0","40.0","80.0","66.66666666666666","78.57142857142857","66.66666666666666","60.0","73.33333333333333","80.0","53.333333333333336","66.66666666666666","0.0","66.66666666666666","20.0","40.0","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/92","
QUESTION:
Let's denote d(n) as the number of divisors of a positive integer n. You are given three integers a, b and c. Your task is to calculate the following sum:

$\sum_{i = 1}^{a} \sum_{j = 1}^{b} \sum_{k = 1}^{c} d(i \cdot j \cdot k)$

Find the sum modulo 1073741824 (2^30).


-----Input-----

The first line contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 100).


-----Output-----

Print a single integer — the required sum modulo 1073741824 (2^30).


-----Examples-----
Input
2 2 2

Output
20

Input
5 6 7

Output
1520



-----Note-----

For the first example.

  d(1·1·1) = d(1) = 1;  d(1·1·2) = d(2) = 2;  d(1·2·1) = d(2) = 2;  d(1·2·2) = d(4) = 3;  d(2·1·1) = d(2) = 2;  d(2·1·2) = d(4) = 3;  d(2·2·1) = d(4) = 3;  d(2·2·2) = d(8) = 4. 

So the result is 1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 = 20.
Use user-input-Based format and function signature solve()","
from math import sqrt

def solve():
    a, b, c = map(int, input().split())
    
    def d(n):
        count = 0
        for i in range(1, int(sqrt(n)) + 1):
            if n % i == 0:
                count += 2 if n // i != i else 1
        return count
    
    result = 0
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                result += d(i * j * k)
    
    print(result % 1073741824)

solve()
","
# Function to calculate d(n)
def divisors_count(n):
    divisors = 0
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            divisors += 1
            if n // i != i:
                divisors += 1
    return divisors

# Main function to solve the problem
def solve():
    # Get input values for a, b, c
    a, b, c = map(int, input().split())
    
    ans = 0
    mod = 1073741824
    
    # Calculate the sum using triple nested loops
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                ans = (ans + divisors_count(i * j * k)) % mod
    
    print(ans)

# Call the solve function
solve()
  ","
from math import sqrt

def solve():
    a, b, c = map(int, input().split())
    MOD = 1073741824
    
    def divisor_count(n):
        count = 0
        limit = int(sqrt(n)) + 1
        for i in range(1, limit):
            if n % i == 0:
                count += 1
                if i != n // i:
                    count += 1
        return count
    
    result = 0
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                result = (result + divisor_count(i * j * k)) % MOD
    
    print(result)

solve()
  ","
import math

def solve():
    a, b, c = map(int, input().split())
    mod = 1073741824
    result = 0

    for i in range(1, a+1):
        for j in range(1, b+1):
            for k in range(1, c+1):
                result += math.prod([len(set([d for d in range(1, i*j*k+1) if i*j*k % d == 0]))])
    
    print(result % mod)


solve()
","
def solve():
    a, b, c = map(int, input().split())
    
    def d(n):
        count = 0
        for i in range(1, int(n ** 0.5) + 1):
            if n % i == 0:
                count += 1
                if i != n // i:
                    count += 1
        return count
    
    mod = 1073741824
    total_sum = 0
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                total_sum += d(i * j * k)
    
    print(total_sum % mod)

solve()
","
import math

def solve():
    a, b, c = map(int, input().split())
    
    def d(n):
        divisors = 0
        for i in range(1, int(math.sqrt(n)) + 1):
            if n % i == 0:
                if n / i == i:
                    divisors += 1
                else:
                    divisors += 2
        return divisors
    
    total_sum = 0
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                total_sum += d(i * j * k)
    
    print(total_sum % 1073741824)

solve()
","
from math import sqrt

def solve():
    def get_divisors_count(n):
        count = 0
        for i in range(1, int(sqrt(n)) + 1):
            if n % i == 0:
                if n / i == i:
                    count += 1
                else:
                    count += 2
        return count

    a, b, c = map(int, input().split())
    mod = 1073741824
    total_sum = 0

    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                total_sum += get_divisors_count(i * j * k)
    
    print(total_sum % mod)

solve()
","
from math import sqrt

def solve():
    a, b, c = map(int, input().split())
    def divisors_count(n):
        count = 0
        for i in range(1, int(sqrt(n)) + 1):
            if n % i == 0:
                count += 2 if i * i != n else 1
        return count
    
    modulo = 1073741824
    total_sum = 0
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                total_sum += divisors_count(i * j * k)
    print(total_sum % modulo)

solve()
","
import math

def solve():
    a, b, c = map(int, input().split())
    
    MAXN = 100*100*100 + 5
    MOD = 1073741824
    div_count = [1] * MAXN
    
    for i in range(1, a+1):
        for j in range(1, b+1):
            for k in range(1, c+1):
                div_count[i*j*k] += 1
    
    result = sum(div_count) % MOD
    print(result)

solve()
","
from math import sqrt

def solve():
    def count_divisors(n):
        count = 0
        for i in range(1, int(sqrt(n)) + 1):
            if n % i == 0:
                count += 2 if i * i != n else 1
        return count
    
    a, b, c = map(int, input().split())
    
    modulo = 1073741824
    total_sum = 0
    
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                total_sum = (total_sum + count_divisors(i * j * k)) % modulo
    
    return total_sum
  
solve()","
def solve():
    a, b, c = map(int, input().split())
    
    MAX_DIV = 108
    all_divisors = [[] for _ in range(MAX_DIV)]
    
    for i in range(1, MAX_DIV):
        for j in range(i, MAX_DIV, i):
            all_divisors[j].append(i)
    
    result = 0
    mod = 1073741824
    
    for i in range(1, a+1):
        for j in range(1, b+1):
            for k in range(1, c+1):
                div = i * j * k
                div_sum = sum(all_divisors[div])
                result = (result + div_sum) % mod
    
    return result

solve()
","
from sympy import divisors

def solve():
    a, b, c = map(int, input().split())
    mod = 1073741824
    total_sum = 0

    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                total_sum = (total_sum + len(divisors(i*j*k))) % mod

    print(total_sum)

solve()
","
from sympy import divisors

def solve():
    a, b, c = map(int, input().split())
    mod = 1073741824
    total_sum = 0
    
    for i in range(1, a+1):
        for j in range(1, b+1):
            for k in range(1, c+1):
                result = len(list(divisors(i*j*k)))
                total_sum = (total_sum + result) % mod
    
    return total_sum

print(solve())

solve()","
from math import sqrt

def count_divisors(n):
    count = 0
    for i in range(1, int(sqrt(n)) + 1):
        if n % i == 0:
            if n / i == i:
                count += 1
            else:
                count += 2
    return count

def solve():
    a, b, c = map(int, input().split())
    MOD = 1073741824
    result = 0
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                result += count_divisors(i * j * k)
                result %= MOD
    return result

print(solve())
  
solve()","
from math import sqrt

def count_divisors(n):
    count = 0
    for i in range(1, int(sqrt(n)) + 1):
        if n % i == 0:
            count += 2 if n / i != i else 1
    return count

def solve():
    a, b, c = map(int, input().split())
    mod = 1073741824
    result = 0
    
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                result += count_divisors(i * j * k)
    
    print(result % mod)

solve()
","
def d(n):
    count = 0
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            count += 2 if i * i != n else 1
    return count

def solve():
    a, b, c = map(int, input().split())
    MOD = 1073741824
    result = 0
    for i in range(1, a + 1):
        for j in range(1, b + 1):
            for k in range(1, c + 1):
                result = (result + d(i * j * k)) % MOD
    print(result)

solve()
  ","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","0.0","0.0","0.0","0.0","0.0","0.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/93","
QUESTION:
Bessie the cow and her best friend Elsie each received a sliding puzzle on Pi Day. Their puzzles consist of a 2 × 2 grid and three tiles labeled 'A', 'B', and 'C'. The three tiles sit on top of the grid, leaving one grid cell empty. To make a move, Bessie or Elsie can slide a tile adjacent to the empty cell into the empty cell as shown below: $\rightarrow$ 

In order to determine if they are truly Best Friends For Life (BFFLs), Bessie and Elsie would like to know if there exists a sequence of moves that takes their puzzles to the same configuration (moves can be performed in both puzzles). Two puzzles are considered to be in the same configuration if each tile is on top of the same grid cell in both puzzles. Since the tiles are labeled with letters, rotations and reflections are not allowed.


-----Input-----

The first two lines of the input consist of a 2 × 2 grid describing the initial configuration of Bessie's puzzle. The next two lines contain a 2 × 2 grid describing the initial configuration of Elsie's puzzle. The positions of the tiles are labeled 'A', 'B', and 'C', while the empty cell is labeled 'X'. It's guaranteed that both puzzles contain exactly one tile with each letter and exactly one empty position.


-----Output-----

Output ""YES""(without quotes) if the puzzles can reach the same configuration (and Bessie and Elsie are truly BFFLs). Otherwise, print ""NO"" (without quotes).


-----Examples-----
Input
AB
XC
XB
AC

Output
YES

Input
AB
XC
AC
BX

Output
NO



-----Note-----

The solution to the first sample is described by the image. All Bessie needs to do is slide her 'A' tile down.

In the second sample, the two puzzles can never be in the same configuration. Perhaps Bessie and Elsie are not meant to be friends after all...
Use user-input-Based format and function signature solve()","
def solve():
    bessie_puzzle = [input() for _ in range(2)]
    elsie_puzzle = [input() for _ in range(2)]

    bessie_tiles = [tile for row in bessie_puzzle for tile in row]
    elsie_tiles = [tile for row in elsie_puzzle for tile in row]

    if sorted(bessie_tiles) == sorted(elsie_tiles):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    bessie_initial = [input() for _ in range(2)]
    elsie_initial = [input() for _ in range(2)]
    
    bessie_tiles = set()
    elsie_tiles = set()
    
    for row in range(2):
        for col in range(2):
            if bessie_initial[row][col] != 'X':
                bessie_tiles.add(bessie_initial[row][col])
            if elsie_initial[row][col] != 'X':
                elsie_tiles.add(elsie_initial[row][col])
    
    if bessie_tiles == elsie_tiles:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    bessie = [input() for _ in range(2)]
    elsie = [input() for _ in range(2)]

    def grid_to_tuple(grid):
        return tuple(grid[0] + grid[1])

    bessie_tuple = grid_to_tuple(bessie)
    elsie_tuple = grid_to_tuple(elsie)

    if bessie_tuple == elsie_tuple:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    bessie_initial = [input() for _ in range(2)]
    elsie_initial = [input() for _ in range(2)]

    def get_empty_position(grid):
        for i in range(2):
            for j in range(2):
                if grid[i][j] == 'X':
                    return i, j

    def check_same_configuration(bessie, elsie):
        def rotate(grid):
            return ["""".join(row) for row in zip(*grid[::-1])]

        def reflect(grid):
            return [row[::-1] for row in grid]

        for _ in range(2):
            for _ in range(4):
                if bessie == elsie:
                    return True
                bessie = rotate(bessie)
            elsie = rotate(elsie)
            elsie = reflect(elsie)
        return False

    bessie_empty = get_empty_position(bessie_initial)
    elsie_empty = get_empty_position(elsie_initial)

    bessie_initial[bessie_empty[0]] = bessie_initial[bessie_empty[0]][:bessie_empty[1]] + 'X' + bessie_initial[bessie_empty[0]][bessie_empty[1] + 1:]
    elsie_initial[elsie_empty[0]] = elsie_initial[elsie_empty[0]][:elsie_empty[1]] + 'X' + elsie_initial[elsie_empty[0]][elsie_empty[1] + 1:]

    if check_same_configuration(bessie_initial, elsie_initial):
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    bessie_puzzle = [input() for _ in range(2)]
    elsie_puzzle = [input() for _ in range(2)]

    bessie_tiles = set()
    elsie_tiles = set()

    for i in range(2):
        for j in range(2):
            if bessie_puzzle[i][j] != 'X':
                bessie_tiles.add(bessie_puzzle[i][j])
            if elsie_puzzle[i][j] != 'X':
                elsie_tiles.add(elsie_puzzle[i][j])

    if bessie_tiles == elsie_tiles:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    # Read input
    bessie_initial = [input() for _ in range(2)]
    elsie_initial = [input() for _ in range(2)]

    # Convert input to a tuple representing positions of tiles in both puzzles
    bessie_pos = tuple([(r, c) for r in range(2) for c in range(2) if bessie_initial[r][c] != 'X'])
    elsie_pos = tuple([(r, c) for r in range(2) for c in range(2) if elsie_initial[r][c] != 'X'])

    # Check if the positions of tiles in both puzzles are the same
    return ""YES"" if sorted(bessie_pos) == sorted(elsie_pos) else ""NO""

solve()
","
def solve():
    bessie_initial = [input() for _ in range(2)]
    elsie_initial = [input() for _ in range(2)]

    bessie_set = set()
    elsie_set = set()

    for i in range(2):
        for j in range(2):
            if bessie_initial[i][j] != 'X':
                bessie_set.add(bessie_initial[i][j])
            if elsie_initial[i][j] != 'X':
                elsie_set.add(elsie_initial[i][j])

    if bessie_set == elsie_set:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    bessie = [input() for _ in range(2)]
    elsie = [input() for _ in range(2)]

    def rotate(grid):
        return ["""".join(row) for row in zip(*grid[::-1])]

    def is_same_configuration():
        for _ in range(4):
            if bessie == elsie:
                return True
            bessie = rotate(bessie)

    if is_same_configuration():
        return ""YES""
    else:
        return ""NO""

solve()","
def solve():
    bessie_config = [input() for _ in range(2)]
    elsie_config = [input() for _ in range(2)]

    def check_same_configuration(grid1, grid2):
        for i in range(2):
            for j in range(2):
                if grid1[i][j] != grid2[i][j]:
                    return False
        return True

    if check_same_configuration(bessie_config, elsie_config):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    bessie = [input() for _ in range(2)]
    elsie = [input() for _ in range(2)]
    
    bessie_config = tuple(["""".join(row) for row in bessie])
    elsie_config = tuple(["""".join(row) for row in elsie])
    
    if bessie_config == elsie_config:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    bessie_grid = [input(), input()]
    elsie_grid = [input(), input()]

    # Check if the same configuration can be reached
    bessie_tiles = ''.join([char for row in bessie_grid for char in row if char != 'X'])
    elsie_tiles = ''.join([char for row in elsie_grid for char in row if char != 'X'])

    if sorted(bessie_tiles) == sorted(elsie_tiles):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    from itertools import permutations

    bessie_puzzle = [input() for _ in range(2)]
    elsie_puzzle = [input() for _ in range(2)]

    def check_configuration(puzzle1, puzzle2):
        sides = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        transformations = permutations(sides)
        for transformation in transformations:
            transformed_puzzle = [['X', 'X'], ['X', 'X']]
            for i in range(2):
                for j in range(2):
                    new_i = i + transformation[i][0]
                    new_j = j + transformation[j][1]
                    if 0 <= new_i <= 1 and 0 <= new_j <= 1:
                        transformed_puzzle[new_i][new_j] = puzzle1[i][j]
                    else:
                        break
            if transformed_puzzle == puzzle2:
                return True
        return False

    if check_configuration(bessie_puzzle, elsie_puzzle):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    bessie_puzzle = [input() for _ in range(2)]
    elsie_puzzle = [input() for _ in range(2)]

    bessie_tiles = [tile for row in bessie_puzzle for tile in row]
    elsie_tiles = [tile for row in elsie_puzzle for tile in row]

    bessie_canonical = ''.join(sorted(bessie_tiles))
    elsie_canonical = ''.join(sorted(elsie_tiles))

    if bessie_canonical == elsie_canonical:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    bessie = [input() for _ in range(2)]
    elsie = [input() for _ in range(2)]

    bessie_chars = {char for row in bessie for char in row}
    elsie_chars = {char for row in elsie for char in row}

    if bessie_chars == elsie_chars:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    bessie_puzzle = [input() for _ in range(2)]
    elsie_puzzle = [input() for _ in range(2)]

    if set(''.join(bessie_puzzle)) == set(''.join(elsie_puzzle)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    bessie_grid = [input() for _ in range(2)]
    elsie_grid = [input() for _ in range(2)]
    
    bessie_config = ''.join(''.join(row) for row in bessie_grid)
    elsie_config = ''.join(''.join(row) for row in elsie_grid)
    
    if bessie_config == elsie_config:
        print(""YES"")
    else:
        print(""NO"")

solve()
","46.666666666666664","46.666666666666664","53.333333333333336","53.333333333333336","46.666666666666664","0.0","46.666666666666664","0.0","53.333333333333336","53.333333333333336","46.666666666666664","53.333333333333336","46.666666666666664","46.666666666666664","46.666666666666664","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/94","
QUESTION:
Alexander is learning how to convert numbers from the decimal system to any other, however, he doesn't know English letters, so he writes any number only as a decimal number, it means that instead of the letter A he will write the number 10. Thus, by converting the number 475 from decimal to hexadecimal system, he gets 11311 (475 = 1·16^2 + 13·16^1 + 11·16^0). Alexander lived calmly until he tried to convert the number back to the decimal number system.

Alexander remembers that he worked with little numbers so he asks to find the minimum decimal number so that by converting it to the system with the base n he will get the number k.


-----Input-----

The first line contains the integer n (2 ≤ n ≤ 10^9). The second line contains the integer k (0 ≤ k < 10^60), it is guaranteed that the number k contains no more than 60 symbols. All digits in the second line are strictly less than n.

Alexander guarantees that the answer exists and does not exceed 10^18.

The number k doesn't contain leading zeros.


-----Output-----

Print the number x (0 ≤ x ≤ 10^18) — the answer to the problem.


-----Examples-----
Input
13
12

Output
12
Input
16
11311

Output
475
Input
20
999

Output
3789
Input
17
2016

Output
594


-----Note-----

In the first example 12 could be obtained by converting two numbers to the system with base 13: 12 = 12·13^0 or 15 = 1·13^1 + 2·13^0.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    k = input()
    x = int(k, n)
    print(x)

solve()","
def solve():
    n = int(input())
    k = input()

    x = 0
    for digit in k:
        x = x * n + int(digit)

    print(x)

solve()
","
def solve():
    n = int(input())
    k = input()

    x = int(k, n)
    print(x)

solve()","
def solve():
    n = int(input())
    k = input().strip()

    x = 0
    for digit in k:
        x = x * n + int(digit)

    print(x)

solve()
","
def solve():
    n = int(input())
    k = input()
    x = 0
    for digit in k:
        x = x * n + int(digit)
    print(x)

solve()
","
def solve():
    n = int(input())
    k = input().strip()
    
    x = 0
    for digit in k:
        x = x * n + int(digit)
    
    print(x)

solve()
","
def solve():
    n = int(input())
    k = input()

    x = 0
    for digit in k:
        x = x * n + int(digit)

    print(x)

solve()
","
def solve():
    n = int(input())
    k = input().strip()

    x = 0
    for digit in k:
        x = x * n + int(digit)

    print(x)

solve()
","
def solve():
    n = int(input())
    k = input().strip()

    x = 0
    for digit in k:
        x = x * n + int(digit)

    return x

solve()","
def solve():
    n = int(input())
    k = input().strip()

    x = 0
    for digit in k:
        x = x * n + int(digit)

    print(x)

solve()
","
def solve():
    n = int(input())
    k = input()
    
    x = int(k, n)
    
    print(x)

solve()
","
def solve():
    import math
    n = int(input())
    k = input().strip()
    ans = 0
    for i in range(len(k)):
        ans = ans * n + int(k[i])
    print(ans)

solve()","
def solve():
    n = int(input())
    k = input()

    x = 0
    for digit in k:
        x = x * n + int(digit)

    print(x)

solve()
","
def solve():
    n = int(input())
    k = input().strip()
    
    x = 0
    for digit in k:
        x = x*n + int(digit)
    print(x)

solve()
","
def solve():
    n = int(input())
    k = input().strip()
    x = 0

    for digit in k:
        x = x * n + int(digit)

    print(x)

solve()
","
def solve():
    n = int(input())
    k = input()
    
    x = int(k, n)
    
    print(x)

solve()","40.0","40.0","40.0","40.0","40.0","40.0","40.0","40.0","0.0","40.0","40.0","40.0","40.0","40.0","40.0","40.0","","","","","","","","","","","","","","","",""
"APPS/95","
QUESTION:
Array of integers is unimodal, if:

  it is strictly increasing in the beginning;  after that it is constant;  after that it is strictly decreasing. 

The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.

For example, the following three arrays are unimodal: [5, 7, 11, 11, 2, 1], [4, 4, 2], [7], but the following three are not unimodal: [5, 5, 6, 6, 1], [1, 2, 1, 2], [4, 5, 5, 6].

Write a program that checks if an array is unimodal.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the array.

The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 1 000) — the elements of the array.


-----Output-----

Print ""YES"" if the given array is unimodal. Otherwise, print ""NO"".

You can output each letter in any case (upper or lower).


-----Examples-----
Input
6
1 5 5 5 4 2

Output
YES

Input
5
10 20 30 20 10

Output
YES

Input
4
1 2 1 2

Output
NO

Input
7
3 3 3 3 3 3 3

Output
YES



-----Note-----

In the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    constant = False
    decreasing = False

    for i in range(1, n):
        if arr[i] > arr[i-1]:
            if constant or decreasing:
                print(""NO"")
                return
        elif arr[i] == arr[i-1]:
            if decreasing:
                print(""NO"")
                return
            constant = True
        else:
            constant = decreasing = True

    print(""YES"")

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    constant = True
    decreasing = False

    for i in range(1, n):
        if decreasing:
            if arr[i] >= arr[i-1]:
                print(""NO"")
                return
        elif increasing:
            if arr[i] < arr[i-1]:
                increasing = False
            elif arr[i] == arr[i-1]:
                constant = True
        elif constant:
            if arr[i] > arr[i-1]:
                constant = False
        else:
            if arr[i] >= arr[i-1]:
                print(""NO"")
                return
            else:
                decreasing = True

    print(""YES"")
  
solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    constant = False
    decreasing = True

    ptr = 1

    while ptr < n and arr[ptr] > arr[ptr - 1]:
        ptr += 1

    if ptr == n:
        constant = True

    while ptr < n and arr[ptr] == arr[ptr - 1]:
        ptr += 1

    while ptr < n and arr[ptr] < arr[ptr - 1]:
        ptr += 1

    if ptr != n:
        decreasing = False

    if increasing and constant and decreasing:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    increasing = True
    constant = True
    decreasing = False
    
    for i in range(1, n):
        if a[i] > a[i-1]:  # Check if increasing
            constant = False
            decreasing = False
        elif a[i] < a[i-1]:  # Check if decreasing
            if increasing:  # If it was increasing before, mark the switch to decreasing
                increasing = False
            else:
                constant = False
        else:  # Check if constant
            if increasing or decreasing:  # If either increasing or decreasing, then not constant
                constant = False
    
    if increasing and constant or constant and decreasing:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    elements = list(map(int, input().split()))

    increasing = True
    decreasing = False

    for i in range(1, n):
        if elements[i] == elements[i - 1]:
            if decreasing:
                print(""NO"")
                return
        elif elements[i] < elements[i - 1]:
            decreasing = True
            if increasing:
                increasing = False
        else:
            if decreasing:
                print(""NO"")
                return

    print(""YES"")

solve()
","
def solve():
    n = int(input())
    array = list(map(int, input().split()))

    increasing = True
    constant = True
    decreasing = True

    # Check for increasing part
    for i in range(1, n):
        if array[i] <= array[i-1]:
            increasing = False
            break

    # Check for constant part
    for i in range(1, n):
        if array[i] != array[i-1]:
            constant = False
            break

    # Check for decreasing part
    for i in range(1, n):
        if array[i] >= array[i-1]:
            decreasing = False
            break

    if (increasing and constant) or (constant and decreasing) or (increasing and decreasing):
        print(""YES"")
    else:
        print(""NO"")

# Required import
import sys
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    increasing = True
    constant = True
    decreasing = False
    
    for i in range(1, n):
        if a[i] == a[i-1]:
            constant = True
        elif a[i] > a[i-1]:
            if decreasing:
                print(""NO"")
                return
        else:
            decreasing = True
            increasing = False
            if constant:
                constant = False
    
    if increasing and (not constant or not decreasing):
        print(""NO"")
    else:
        print(""YES"")
  
solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    increasing = True
    constant = True
    decreasing = True
    
    for i in range(1, n):
        if arr[i] < arr[i-1]:
            increasing = False
            break
    
    if increasing:
        print(""YES"")
        return
    
    for i in range(1, n):
        if arr[i] > arr[i-1]:
            constant = False
            break
    
    if constant:
        print(""YES"")
        return
    
    for i in range(1, n):
        if arr[i] > arr[i-1]:
            decreasing = False
            break
    
    if decreasing:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    constant = False
    decreasing = False

    i = 1
    while i < n and arr[i] > arr[i - 1]:
        i += 1
    if i == n:
        print(""YES"")
        return

    while i < n and arr[i] == arr[i - 1]:
        i += 1
    if i == n:
        print(""YES"")
        return

    while i < n and arr[i] < arr[i - 1]:
        i += 1
    if i == n:
        print(""YES"")
    else:
        print(""NO"")

solve()
    ","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    decreasing = False

    # Check if array is strictly increasing
    for i in range(1, n):
        if arr[i] <= arr[i - 1]:
            break
    else:
        increasing = False

    # Check if array is constant
    for i in range(1, n):
        if arr[i] != arr[i - 1]:
            break
    else:
        increasing = False

    # Check if array is strictly decreasing
    for i in range(1, n):
        if arr[i] >= arr[i - 1]:
            break
    else:
        decreasing = True

    if increasing and decreasing:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    array = list(map(int, input().split()))

    increasing = True
    constant = False
    for i in range(1, n):
        if array[i] <= array[i - 1]:
            increasing = False
            if array[i] < array[i - 1]:
                constant = True
            break

    decreasing = False
    if not increasing and constant:
        for j in range(i+1, n):
            if array[j] >= array[j-1]:
                decreasing = True
                break

    if increasing and not decreasing:
        print(""YES"")
    elif increasing and constant and decreasing:
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    decreasing = False

    for i in range(1, n):
        if arr[i] < arr[i-1]:
            decreasing = True
        elif arr[i] == arr[i-1]:
            if decreasing:
                print(""NO"")
                return

    print(""YES"")

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    decreasing = False

    for i in range(1, n):
        if arr[i] < arr[i-1]:
            decreasing = True
        elif arr[i] == arr[i-1] and decreasing:
            print(""NO"")
            return

    print(""YES"")

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    increasing = True
    constant = False
    decreasing = False

    idx = 1
    while idx < n and arr[idx] > arr[idx - 1]:
        idx += 1

    if idx == n:
        print(""YES"")
        return

    if arr[idx] == arr[idx - 1]:
        constant = True

    while idx < n and arr[idx] < arr[idx - 1]:
        idx += 1

    if idx == n and constant:
        print(""YES"")
    else:
        print(""NO"")


solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    increasing = True
    constant = False
    decreasing = False
    
    # Check for increasing part of the array
    i = 0
    while i < n - 1 and arr[i] < arr[i + 1]:
        i += 1
    
    if i == n - 1:  # If the array is strictly increasing
        constant = True
    
    # Check for constant part of the array
    while i < n - 1 and arr[i] == arr[i + 1]:
        i += 1
    
    if i == n - 1:  # If the array is constant after increasing
        decreasing = True
    
    # Check for decreasing part of the array
    while i < n - 1 and arr[i] > arr[i + 1]:
        i += 1
    
    if i == n - 1:  # If the array is strictly decreasing after constant
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    increasing = True
    constant = True
    decreasing = True

    for i in range(1, n):
        if a[i] > a[i-1]:
            constant = False
            decreasing = False
        elif a[i] < a[i-1]:
            increasing = False
            if constant:
                constant = False
        else:
            if decreasing:
                decreasing = False

    if increasing and constant and decreasing:
        print(""YES"")
    else:
        print(""NO"")

solve()","100.0","80.0","26.666666666666668","26.666666666666668","86.66666666666667","26.666666666666668","60.0","60.0","100.0","20.0","26.666666666666668","80.0","80.0","26.666666666666668","100.0","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/96","
QUESTION:
At first, let's define function $f(x)$ as follows: $$ \begin{matrix} f(x) & = & \left\{ \begin{matrix} \frac{x}{2} & \mbox{if } x \text{ is even} \\ x - 1 & \mbox{otherwise } \end{matrix} \right. \end{matrix} $$

We can see that if we choose some value $v$ and will apply function $f$ to it, then apply $f$ to $f(v)$, and so on, we'll eventually get $1$. Let's write down all values we get in this process in a list and denote this list as $path(v)$. For example, $path(1) = [1]$, $path(15) = [15, 14, 7, 6, 3, 2, 1]$, $path(32) = [32, 16, 8, 4, 2, 1]$.

Let's write all lists $path(x)$ for every $x$ from $1$ to $n$. The question is next: what is the maximum value $y$ such that $y$ is contained in at least $k$ different lists $path(x)$?

Formally speaking, you need to find maximum $y$ such that $\left| \{ x ~|~ 1 \le x \le n, y \in path(x) \} \right| \ge k$.


-----Input-----

The first line contains two integers $n$ and $k$ ($1 \le k \le n \le 10^{18}$).


-----Output-----

Print the only integer — the maximum value that is contained in at least $k$ paths.


-----Examples-----
Input
11 3

Output
5

Input
11 6

Output
4

Input
20 20

Output
1

Input
14 5

Output
6

Input
1000000 100

Output
31248



-----Note-----

In the first example, the answer is $5$, since $5$ occurs in $path(5)$, $path(10)$ and $path(11)$.

In the second example, the answer is $4$, since $4$ occurs in $path(4)$, $path(5)$, $path(8)$, $path(9)$, $path(10)$ and $path(11)$.

In the third example $n = k$, so the answer is $1$, since $1$ is the only number occuring in all paths for integers from $1$ to $20$.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    def path(x):
        res = [x]
        while x != 1:
            x = f(x)
            res.append(x)
        return res
    
    count_dict = {}
    for i in range(1, n+1):
        p = path(i)
        for num in p:
            if num in count_dict:
                count_dict[num] += 1
            else:
                count_dict[num] = 1
    
    max_val = max([key for key, val in count_dict.items() if val >= k])
    
    print(max_val)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1

    def path(x):
        result = [x]
        while x != 1:
            x = f(x)
            result.append(x)
        return result
    
    max_value = 0
    counts = {}

    for x in range(1, n + 1):
        for val in path(x):
            counts[val] = counts.get(val, 0) + 1

    for key, value in counts.items():
        if value >= k:
            max_value = max(max_value, key)

    return max_value

solve()
","
def solve():
    n, k = map(int, input().split())
    def f(x):
        if x % 2 == 0:
            return x // 2
        return x - 1

    def path(x):
        res = [x]
        current = x
        while current != 1:
            current = f(current)
            res.append(current)
        return res

    occurrences = {}
    for i in range(1, n+1):
        for num in path(i):
            if num not in occurrences:
                occurrences[num] = 1
            else:
                occurrences[num] += 1

    max_val = max([key for key, val in occurrences.items() if val >= k])
    print(max_val)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    def path(x):
        path_list = []
        while x != 1:
            path_list.append(x)
            x = f(x)
        path_list.append(1)
        return path_list
    
    count_dict = {}
    for i in range(1, n+1):
        path_list = path(i)
        for num in path_list:
            if num in count_dict:
                count_dict[num] += 1
            else:
                count_dict[num] = 1
    
    max_val = max([key for key, val in count_dict.items() if val >= k])
    print(max_val)

solve()
","
def solve():
    n, k = map(int, input().split())

    def path(x):
        res = [x]
        while x != 1:
            if x % 2 == 0:
                x //= 2
            else:
                x -= 1
            res.append(x)
        return res

    freq = {}
    for i in range(1, n+1):
        for p in path(i):
            freq[p] = freq.get(p, 0) + 1

    max_val = max(key for key, val in freq.items() if val >= k)
    print(max_val)

solve()
  ","
def solve():
    import math
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    def path(x):
        res = []
        while x >= 1:
            res.append(x)
            x = f(x)
        return res
    
    n, k = map(int, input().split())
    
    vals_count = {}
    
    for i in range(1, n+1):
        p = path(i)
        for val in set(p):
            if val in vals_count:
                vals_count[val] += 1
            else:
                vals_count[val] = 1
    
    max_val = max([key for key, value in vals_count.items() if value >= k])
    
    return max_val

solve()","
def solve():
    import math
    
    def f(x):
        return x // 2 if x % 2 == 0 else x - 1
    
    def path(x):
        result = [x]
        while x != 1:
            x = f(x)
            result.append(x)
        return result
    
    n, k = map(int, input().split())
    candidates = set()
    
    for i in range(1, n + 1):
        for num in path(i):
            candidates.add(num)
            if len(candidates) >= k:
                break
        if len(candidates) >= k:
            break
    
    answer = max(candidates)
    print(answer)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    paths = [[] for _ in range(n+1)]
    for x in range(1, n+1):
        current_path = [x]
        while x != 1:
            x = f(x)
            current_path.append(x)
        for num in current_path:
            paths[num].append(x)
    
    max_value = 0
    for i in range(1, n+1):
        if len(set(paths[i])) >= k:
            max_value = max(max_value, i)
    
    return max_value

solve()
","
def solve():
    n, k = map(int, input().split())
    occurences = {}
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1

    for x in range(1, n+1):
        path = []
        while x not in path:
            path.append(x)
            x = f(x)
        
        for num in path:
            if num not in occurences:
                occurences[num] = 1
            else:
                occurences[num] += 1

    max_value = max([num for num in occurences if occurences[num] >= k])
    print(max_value)

solve()
","
def solve():
    n, k = map(int, input().split())
    answer = 1
    
    def f(x):
        return x // 2 if x % 2 == 0 else x - 1
    
    def path(x):
        result = [x]
        while x != 1:
            x = f(x)
            result.append(x)
        return result
    
    occurrences = {}
    for i in range(1, n + 1):
        p = path(i)
        for num in p:
            if num in occurrences:
                occurrences[num] += 1
            else:
                occurrences[num] = 1
    
    for num in sorted(occurrences.keys(), reverse=True):
        if occurrences[num] >= k:
            answer = num
            break

    print(answer)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    def path(x):
        result = [x]
        while x != 1:
            x = f(x)
            result.append(x)
        return result
    
    count_dict = {}
    for i in range(1, n+1):
        p = path(i)
        for num in p:
            if num in count_dict:
                count_dict[num] += 1
            else:
                count_dict[num] = 1
    
    max_val = max([key for key, value in count_dict.items() if value >= k])
    
    print(max_val)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    path_dict = {}
    
    for x in range(1, n + 1):
        path = [x]
        while path[-1] != 1:
            path.append(f(path[-1]))
        path_dict[x] = path
    
    values_count = {}
    for path in path_dict.values():
        for num in path:
            if num not in values_count:
                values_count[num] = 1
            else:
                values_count[num] += 1
    
    max_value = max([val for val, count in values_count.items() if count >= k])
    
    return max_value


solve()","
def solve():
    n, k = map(int, input().split())
    def f(x):
        return x//2 if x % 2 == 0 else x - 1
    def path(x):
        res = []
        while x >= 1:
            res.append(x)
            x = f(x)
        return res
    occurrences = {}
    for x in range(1, n+1):
        for num in path(x):
            if num in occurrences:
                occurrences[num] += 1
            else:
                occurrences[num] = 1
    max_value = max([key for key, value in occurrences.items() if value >= k])
    print(max_value)

solve()
","
def solve():
    import math
    
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    def path(x):
        res = []
        while x != 1:
            res.append(x)
            x = f(x)
        res.append(1)
        return res
    
    freq = {}
    for i in range(1, n+1):
        p = path(i)
        for num in set(p):
            if num not in freq:
                freq[num] = 1
            else:
                freq[num] += 1
    
    max_val = max([num for num, count in freq.items() if count >= k])
    
    return max_val

solve()","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        return x // 2 if x % 2 == 0 else x - 1
    
    def path(x):
        res = [x]
        while x != 1:
            x = f(x)
            res.append(x)
        return res
    
    occurrences = {}
    for x in range(1, n + 1):
        for elem in path(x):
            if elem in occurrences:
                occurrences[elem] += 1
            else:
                occurrences[elem] = 1
    
    max_value = max(key for key, value in occurrences.items() if value >= k)
    
    print(max_value)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    
    def f(x):
        if x % 2 == 0:
            return x // 2
        else:
            return x - 1
    
    def path(x):
        res = []
        while x != 1:
            res.append(x)
            x = f(x)
        res.append(1)
        return res
    
    freq = {}
    for i in range(1, n+1):
        for num in path(i):
            freq[num] = freq.get(num, 0) + 1
    
    max_val = max(num for num, count in freq.items() if count >= k)
    print(max_val)

solve()
","100.0","0.0","100.0","100.0","100.0","0.0","6.666666666666667","0.0","100.0","100.0","100.0","0.0","100.0","0.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/97","
QUESTION:
Consider a billiard table of rectangular size $n \times m$ with four pockets. Let's introduce a coordinate system with the origin at the lower left corner (see the picture).  [Image] 

There is one ball at the point $(x, y)$ currently. Max comes to the table and strikes the ball. The ball starts moving along a line that is parallel to one of the axes or that makes a $45^{\circ}$ angle with them. We will assume that:   the angles between the directions of the ball before and after a collision with a side are equal,  the ball moves indefinitely long, it only stops when it falls into a pocket,  the ball can be considered as a point, it falls into a pocket if and only if its coordinates coincide with one of the pockets,  initially the ball is not in a pocket. 

Note that the ball can move along some side, in this case the ball will just fall into the pocket at the end of the side.

Your task is to determine whether the ball will fall into a pocket eventually, and if yes, which of the four pockets it will be.


-----Input-----

The only line contains $6$ integers $n$, $m$, $x$, $y$, $v_x$, $v_y$ ($1 \leq n, m \leq 10^9$, $0 \leq x \leq n$; $0 \leq y \leq m$; $-1 \leq v_x, v_y \leq 1$; $(v_x, v_y) \neq (0, 0)$) — the width of the table, the length of the table, the $x$-coordinate of the initial position of the ball, the $y$-coordinate of the initial position of the ball, the $x$-component of its initial speed and the $y$-component of its initial speed, respectively. It is guaranteed that the ball is not initially in a pocket.


-----Output-----

Print the coordinates of the pocket the ball will fall into, or $-1$ if the ball will move indefinitely.


-----Examples-----
Input
4 3 2 2 -1 1

Output
0 0
Input
4 4 2 0 1 1

Output
-1
Input
10 10 10 1 -1 0

Output
-1


-----Note-----

The first sample:  [Image] 

The second sample:  [Image] 

In the third sample the ball will never change its $y$ coordinate, so the ball will never fall into a pocket.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    def check_collision(x, y, vx, vy):
        if vx == 0:
            return (0, y) if vy > 0 else (0, 0)
        if vy == 0:
            return (x, 0) if vx > 0 else (0, 0)
        
        dx = x if vx > 0 else n - x
        dy = y if vy > 0 else m - y
        
        gcd_val = gcd(abs(dx), abs(vx))
        dx //= gcd_val
        vx //= gcd_val
        
        gcd_val = gcd(abs(dy), abs(vy))
        dy //= gcd_val
        vy //= gcd_val
        
        if dx == dy:
            return (0, 0)
        if dx == n - dy:
            return (n, 0)
        if dy == m - dx:
            return (0, m)
        if dx == dy - n:
            return (n, m)
        
        return None
    
    while True:
        collision = check_collision(x, y, vx, vy)
        if collision is not None:
            print(*collision)
            return
        x += vx
        y += vy
        if x == 0 or x == n or y == 0 or y == m:
            print(-1)
            return

solve()
","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())

    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)

    dx, dy = abs(vx), abs(vy)
    dist_x, dist_y = min(x // dx if vx > 0 else (n - x) // -vx, 10 ** 9), min(y // dy if vy > 0 else (m - y) // -vy, 10 ** 9)

    if dist_x == 10 ** 9 and dist_y == 10 ** 9:
        print(-1)
    elif dist_x < dist_y:
        print(0, 0 if vy > 0 else m)
    else:
        print(n if vx > 0 else 0, 0)

solve()","
import math

def solve():
    n, m, x, y, vx, vy = map(int, input().split())

    def check_collision(x, y, vx, vy):
        if vx == 0 and vy == 0:
            return False
        collisions = []
        if vx == 1:
            collisions.append(((n-x)/vx, 0))
        elif vx == -1:
            collisions.append((-x/vx, 0))
        if vy == 1:
            collisions.append((m-y)/vy, 2)
        elif vy == -1:
            collisions.append((-y/vy, 1)

        t, collision_type = min(collisions, key=lambda x: x[0])
        if collision_type == 0:
            final_x = 0 if vx == 1 else n
            final_y = y + t*vy
        elif collision_type == 1:
            final_x = x + t*vx
            final_y = 0 if vy == 1 else m
        else:
            final_x = n if vx == 1 else 0
            final_y = m if vy == 1 else 0

        if final_x % n == 0 and final_y % m == 0:
            print(0, 0)
        else:
            print(-1)

    check_collision(x, y, vx, vy)

solve()
","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    while True:
        min_dist = float('inf')
        pocket = (-1, -1)
        
        if vx > 0:
            dist = (n - x) / vx
            if dist < min_dist:
                min_dist = dist
                pocket = (n, y + dist * vy)
        elif vx < 0:
            dist = x / abs(vx)
            if dist < min_dist:
                min_dist = dist
                pocket = (0, y + dist * vy)
        
        if vy > 0:
            dist = (m - y) / vy
            if dist < min_dist:
                min_dist = dist
                pocket = (x + dist * vx, m)
        elif vy < 0:
            dist = y / abs(vy)
            if dist < min_dist:
                min_dist = dist
                pocket = (x + dist * vx, 0)
        
        if min_dist == float('inf'):
            print(-1)
            break
        else:
            print(pocket[0], pocket[1])
            break

solve()
  ","
def solve():
    # Input
    n, m, x, y, v_x, v_y = map(int, input().split())

    # Determine direction of ball movement
    dx = 1 if v_x > 0 else -1 if v_x < 0 else 0
    dy = 1 if v_y > 0 else -1 if v_y < 0 else 0

    # Calculate intersections with edges
    horizontal_dist = n - x if dx == 1 else x
    vertical_dist = m - y if dy == 1 else y

    horizontal_time = horizontal_dist / abs(v_x) if v_x != 0 else float('inf')
    vertical_time = vertical_dist / abs(v_y) if v_y != 0 else float('inf')

    min_time = min(horizontal_time, vertical_time)

    # Determine pocket based on min time
    if min_time == float('inf'):
        print(-1)
    else:
        pocket_x = x + min_time * dx
        pocket_y = y + min_time * dy

        if pocket_x == 0 and pocket_y == 0:
            print(0, 0)
        elif pocket_x == n and pocket_y == 0:
            print(n, 0)
        elif pocket_x == 0 and pocket_y == m:
            print(0, m)
        elif pocket_x == n and pocket_y == m:
            print(n, m)
        else:
            print(-1)

solve()
  ","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    while True:
        if vx > 0:
            tx = (n - x) // vx if vx > 0 else float('inf')
        elif vx < 0:
            tx = x // -vx if vx < 0 else float('inf')
        else:
            tx = float('inf')
        
        if vy > 0:
            ty = (m - y) // vy if vy > 0 else float('inf')
        elif vy < 0:
            ty = y // -vy if vy < 0 else float('inf')
        else:
            ty = float('inf')
        
        t = min(tx, ty)
        x += vx * t
        y += vy * t
        
        if 0 < x < n and 0 < y < m:
            vx *= -1
            vy *= -1
        elif (x == 0 and y == 0) or (x == n and y == 0) or (x == 0 and y == m) or (x == n and y == m):
            print(x, y)
            return
        else:
            print(-1)
            return
  
solve()","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    dx = min(x // abs(vx), (n - x) // abs(vx)) if vx != 0 else float('inf')
    dy = min(y // abs(vy), (m - y) // abs(vy)) if vy != 0 else float('inf')
    
    min_steps = min(dx, dy)
    
    if min_steps == float('inf'):
        print(-1)
    else:
        target_x = x + min_steps * vx
        target_y = y + min_steps * vy
        
        pocket_x = 0 if target_x == 0 or target_x == n else -1
        pocket_y = 0 if target_y == 0 or target_y == m else -1
        
        print(pocket_x, pocket_y)

solve()
  ","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    # Calculate the number of steps required to reach a pocket
    steps_to_top = (m - y) // abs(vy) if vy != 0 else float('inf')
    steps_to_bottom = y // abs(vy) if vy != 0 else float('inf')
    steps_to_left = x // abs(vx) if vx != 0 else float('inf')
    steps_to_right = (n - x) // abs(vx) if vx != 0 else float('inf')
    
    min_steps_to_pocket = min(steps_to_top, steps_to_bottom, steps_to_left, steps_to_right)
    
    if min_steps_to_pocket == float('inf'):
        print(-1)
    else:
        x_pocket = x + min_steps_to_pocket * vx
        y_pocket = y + min_steps_to_pocket * vy
        print(x_pocket, y_pocket if y_pocket in {0, m} else 0 if x_pocket in {0, n} else -1)
  
solve()","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    def get_collision_time(a, b):
        if a > 0:
            return (n - b) / a
        elif a < 0:
            return (0 - b) / a
        else:
            return float('inf')
    
    def get_pocket_time(coord, dir):
        if dir > 0:
            return (n - coord)
        elif dir < 0:
            return coord
        return float('inf')

    x_collision_time = min(get_collision_time(vx, x), get_pocket_time(x, vx))
    y_collision_time = min(get_collision_time(vy, y), get_pocket_time(y, vy))
    
    if x_collision_time < y_collision_time:
        x += vx * x_collision_time
        y += vy * x_collision_time
        if 0 <= y <= m:
            print('0', y if y in [0, m] else '-1')
        else:
            print('-1')
    elif x_collision_time > y_collision_time:
        x += vx * y_collision_time
        y += vy * y_collision_time
        if 0 <= x <= n:
            print(x if x in [0, n] else '-1', '0')
        else:
            print('-1')
    else:
        print('-1')

solve()
","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    a = min(x // vx if vx > 0 else (n - x) // -vx, y // vy if vy > 0 else (m - y) // -vy)
    vx *= a
    vy *= a
    
    g = gcd(abs(vx), abs(vy))
    vx //= g
    vy //= g
    
    def dest(offset_x, offset_y):
        px, py = None, None
        if vx > 0:
            px = (n - x) // vx
        elif vx < 0:
            px = x // -vx
        if vy > 0:
            py = (m - y) // vy
        elif vy < 0:
            py = y // -vy
        
        if px is not None and py is not None:
            if px == py:
                return offset_x, offset_y
        return None
    
    pockets = [dest(0, 0), dest(n, 0), dest(0, m), dest(n, m)]
    
    for pocket in pockets:
        if pocket is not None:
            print(*pocket)
            return
    
    print(-1)

solve()","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    while True:
        if vx > 0:
            tx = n - x
        elif vx < 0:
            tx = x
        else:
            tx = float('inf')
        
        if vy > 0:
            ty = m - y
        elif vy < 0:
            ty = y
        else:
            ty = float('inf')
        
        t = min(tx / abs(vx), ty / abs(vy))
        x += vx * t
        y += vy * t
        
        if x == 0 or x == n:
            if y == 0:
                print(""0 0"")
            elif y == m:
                print(""0"", m)
            else:
                print(""-1"")
            return 
        
        if y == 0 or y == m:
            if x == 0:
                print(""0 0"")
            elif x == n:
                print(n, 0)
            else:
                print(""-1"")
            return 
        
        if x == 0 and y == 0:
            print(""0 0"")
            return 
        
        if x == n and y == m:
            print(n, m)
            return 
        
        d = min(x, n - x, y, m - y)
        
        x -= d
        y -= d
        
        vx = -vx
        vy = -vy
    
    print(""-1"")
  
solve()","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)
    
    def reduce(vx, vy):
        g = gcd(abs(vx), abs(vy))
        return vx // g, vy // g
    
    def collision_time(pos, vel, bound):
        if vel > 0:
            return (bound - pos) / vel
        elif vel < 0:
            return -pos / vel
        else:
            return float(""inf"")
    
    def pocket_position(pos, vel, bound):
        time = collision_time(pos, vel, bound)
        return pos + time * vel
    
    def pocket(pos, vel, bound):
        time = collision_time(pos, vel, bound)
        return (int(pocket_position(pos, vel, bound)), 0 if time >= 0 else -1)
    
    vx, vy = reduce(vx, vy)
    
    pocket_x, pocket_y = float('inf'), float('inf')
    
    if vx != 0:
        pocket_x = pocket(x, vx, n)
    if vy != 0:
        pocket_y = pocket(y, vy, m)
    
    if pocket_x == pocket_y:
        print(*pocket_x)
    else:
        print(-1)

solve()
  ","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)
    
    def canReachPocket(x, y, n, m):
        gcd_xy = gcd(abs(x), abs(y))
        dx, dy = x // gcd_xy, y // gcd_xy
        if (dx > 0 and vx < 0) or (dx < 0 and vx > 0) or (dy > 0 and vy < 0) or (dy < 0 and vy > 0):
            return False
        steps_x = (n - x) // vx if vx != 0 else float('inf')
        steps_y = (m - y) // vy if vy != 0 else float('inf')
        return min(steps_x, steps_y) % gcd(abs(vx), abs(vy)) == 0
    
    if canReachPocket(x, y, n, m):
        min_steps = min((n - x) // abs(vx) if vx != 0 else float('inf'), (m - y) // abs(vy) if vy != 0 else float('inf'))
        pocket_x = (x + min_steps * vx) // n * n
        pocket_y = (y + min_steps * vy) // m * m
        print(pocket_x, pocket_y)
    else:
        print(-1)

solve()
","
def solve():
    n, m, x, y, v_x, v_y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    def collide_horizontal():
        if v_y == 0:
            return
        if v_y < 0:
            dt = y / abs(v_y)
        else:
            dt = (m - y) / v_y
        cycles = dt / m
        x += cycles * n
        y = 0 if y == 0 else m
        v_y = -v_y
       
    def collide_vertical():
        if v_x == 0:
            return
        if v_x < 0:
            dt = x / abs(v_x)
        else:
            dt = (n - x) / v_x
        cycles = dt / n
        y += cycles * m
        x = 0 if x == 0 else n
        v_x = -v_x
    
    def collide_pocket(x, y):
        pocket = set([(0, 0), (0, m), (n, 0), (n, m)])
        return (x, y) if (x, y) in pocket else -1
    
    g = gcd(abs(v_x), abs(v_y))
    v_x //= g
    v_y //= g
    
    while True:
        min_dt = float('inf')
        for direction in [(0, 0), (n - x, m - y), (n - x, -y), (-x, m - y), (-x, -y)]:
            dx, dy = direction
            if v_x == 0 and dx != 0 or v_y == 0 and dy != 0:
                continue
            dt_x = dx / v_x if v_x != 0 else float('inf')
            dt_y = dy / v_y if v_y != 0 else float('inf')
            dt = min(dt_x, dt_y)
            if 0 < dt < min_dt:
                min_dt = dt
                d = direction
        
        if min_dt == float('inf'):
            return collide_pocket(x, y)
        
        x += v_x * min_dt
        y += v_y * min_dt
        
        if d[0] != 0:
            v_x = -v_x
        if d[1] != 0:
            v_y = -v_y
        
        collide_horizontal()
        collide_vertical()
        
solve()
  ","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)
    
    def intersect(p1, p2, q1, q2):
        dx, dy = abs(p1[0] - p2[0]), abs(p1[1] - p2[1])
        ddx, ddy = abs(q1[0] - q2[0]), abs(q1[1] - q2[1])
        
        d = gcd(dx, dy)
        dx //= d
        dy //= d
        
        d = gcd(ddx, ddy)
        ddx //= d
        ddy //= d
        
        return dx == ddx and dy == ddy
    
    if vx == 0:
        vx = 0
    if vy == 0:
        vy = 0
    
    if vx < 0:
        x = n - x
        vx = -vx
    if vy < 0:
        y = m - y
        vy = -vy
   
    if vx > 0:
        t = (n - x) // vx
    else:
        t = x // (-vx)
        
    if vy > 0:
        u = (m - y) // vy
    else:
        u = y // (-vy)
    
    if t == u and intersect((x, y), (x + vx * t, y + vy * t), (0, 0), (0, m)) or t < u and intersect((x, y), (x + vx * t, y + vy * t), (0, 0), (0, m)) or u < t and intersect((x, y), (x + vx * u, y + vy * u), (0, 0), (n, 0)):
        print(0, m)
    elif t == u and intersect((x, y), (x + vx * t, y + vy * t), (n, 0), (n, m)) or t < u and intersect((x, y), (x + vx * t, y + vy * t), (0, m), (n, m)) or u < t and intersect((x, y), (x + vx * u, y + vy * u), (n, 0), (n, m)):
        print(n, m)
    elif t == u and intersect((x, y), (x + vx * t, y + vy * t), (n, m), (n, 0)) or t < u and intersect((x, y), (x + vx * t, y + vy * t), (n, m), (n, 0)) or u < t and intersect((x, y), (x + vx * u, y + vy * u), (0, m), (n, 0)):
        print(n, 0)
    elif t == u and intersect((x, y), (x + vx * t, y + vy * t), (0, m), (0, 0)) or t < u and intersect((x, y), (x + vx * t, y + vy * t), (n, 0), (0, 0)) or u < t and intersect((x, y), (x + vx * u, y + vy * u), (0, m), (0, 0)):
        print(0, 0)
    else:
        print(-1)

  
solve()","
def solve():
    n, m, x, y, vx, vy = map(int, input().split())
    
    while True:
        min_dist = min(x/(abs(vx)+1e-9), (n-x)/(abs(vx)+1e-9), y/(abs(vy)+1e-9), (m-y)/(abs(vy)+1e-9))
        
        x += vx * min_dist
        y += vy * min_dist
        
        if x == 0 and y == 0:
            print(0, 0)
            break
        elif x == 0 and y == m:
            print(0, m)
            break
        elif x == n and y == 0:
            print(n, 0)
            break
        elif x == n and y == m:
            print(n, m)
            break
        
        if x == 0 or x == n or y == 0 or y == m:
            print(-1)
            break
        
        if x == 0:
            if vx > 0:
                vx *= -1
        elif x == n:
            if vx < 0:
                vx *= -1
        elif y == 0:
            if vy > 0:
                vy *= -1
        elif y == m:
            if vy < 0:
                vy *= -1


solve()","23.076923076923077","13.333333333333334","0.0","0.0","53.333333333333336","53.333333333333336","6.666666666666667","6.666666666666667","13.333333333333334","33.33333333333333","40.0","46.666666666666664","13.333333333333334","0.0","26.666666666666668","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/98","
QUESTION:
Gerald bought two very rare paintings at the Sotheby's auction and he now wants to hang them on the wall. For that he bought a special board to attach it to the wall and place the paintings on the board. The board has shape of an a_1 × b_1 rectangle, the paintings have shape of a a_2 × b_2 and a_3 × b_3 rectangles.

Since the paintings are painted in the style of abstract art, it does not matter exactly how they will be rotated, but still, one side of both the board, and each of the paintings must be parallel to the floor. The paintings can touch each other and the edges of the board, but can not overlap or go beyond the edge of the board. Gerald asks whether it is possible to place the paintings on the board, or is the board he bought not large enough?


-----Input-----

The first line contains two space-separated numbers a_1 and b_1 — the sides of the board. Next two lines contain numbers a_2, b_2, a_3 and b_3 — the sides of the paintings. All numbers a_{i}, b_{i} in the input are integers and fit into the range from 1 to 1000.


-----Output-----

If the paintings can be placed on the wall, print ""YES"" (without the quotes), and if they cannot, print ""NO"" (without the quotes).


-----Examples-----
Input
3 2
1 3
2 1

Output
YES

Input
5 5
3 3
3 3

Output
NO

Input
4 2
2 3
1 2

Output
YES



-----Note-----

That's how we can place the pictures in the first test:

[Image]

And that's how we can do it in the third one.

[Image]
Use user-input-Based format and function signature solve()","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    if (a2 + a3 <= a1 and max(b2, b3) <= b1) or (a2 + b3 <= a1 and max(b2, a3) <= b1) or (b2 + a3 <= a1 and max(a2, b3) <= b1) or (b2 + b3 <= a1 and max(a2, a3) <= b1):
        print(""YES"")
    elif (a2 + a3 <= b1 and max(b2, b3) <= a1) or (a2 + b3 <= b1 and max(b2, a3) <= a1) or (b2 + a3 <= b1 and max(a2, b3) <= a1) or (b2 + b3 <= b1 and max(a2, a3) <= a1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if (a1 >= max(a2, b2) + max(a3, b3)) and (b1 >= max(b2, a2) + max(b3, a3)):
        print(""YES"")
    elif (a1 >= max(b2, a2) + max(a3, b3)) and (b1 >= max(a2, b2) + max(b3, a3)):
        print(""YES"")
    elif (a1 >= max(a2, b2) + max(b3, a3)) and (b1 >= max(b2, a2) + max(a3, b3)):
        print(""YES"")
    elif (a1 >= max(b2, a2) + max(b3, a3)) and (b1 >= max(a2, b2) + max(a3, b3)):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    if ((a2 + a3 <= a1 and max(b2, b3) <= b1) or
        (b2 + b3 <= b1 and max(a2, a3) <= a1) or
        (a2 + b3 <= a1 and max(b2, a3) <= b1) or
        (b2 + a3 <= b1 and max(a2, b3) <= a1) or
        (a3 + a2 <= a1 and max(b3, b2) <= b1) or
        (b3 + b2 <= b1 and max(a3, a2) <= a1) or
        (a3 + b2 <= a1 and max(b3, a2) <= b1) or
        (b3 + a2 <= b1 and max(a3, b2) <= a1)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if (a1 >= max(a2, a3) and b1 >= (b2 + b3)) or (a1 >= (a2 + a3) and b1 >= max(b2, b3)):
        print(""YES"")
    elif (a1 >= max(b2, b3) and b1 >= (a2 + a3)) or (a1 >= (b2 + b3) and b1 >= max(a2, a3)):
        print(""YES"")
    elif (a1 >= (a2 + b3) and b1 >= max(b2, a3)) or (a1 >= max(a2, b3) and b1 >= (b2 + a3)):
        print(""YES"")
    elif (a1 >= max(b2, a3) and b1 >= (a2 + b3)) or (a1 >= (b2 + a3) and b1 >= max(a2, b3)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    if (a2 + a3 <= a1 and max(b2, b3) <= b1) or (a2 + a3 <= b1 and max(b2, b3) <= a1) or \
        (b2 + b3 <= a1 and max(a2, a3) <= b1) or (b2 + b3 <= b1 and max(a2, a3) <= a1):
        print(""YES"")
    elif (a2 + b3 <= a1 and max(b2, a3) <= b1) or (a2 + b3 <= b1 and max(b2, a3) <= a1) or \
        (b2 + a3 <= a1 and max(a2, b3) <= b1) or (b2 + a3 <= b1 and max(a2, b3) <= a1):
        print(""YES"")
    elif (b2 + a3 <= a1 and max(a2, b3) <= b1) or (b2 + a3 <= b1 and max(a2, b3) <= a1) or \
        (a2 + b3 <= a1 and max(b2, a3) <= b1) or (a2 + b3 <= b1 and max(b2, a3) <= a1):
        print(""YES"")
    elif (b2 + b3 <= a1 and max(a2, a3) <= b1) or (b2 + b3 <= b1 and max(a2, a3) <= a1) or \
        (a2 + a3 <= a1 and max(b2, b3) <= b1) or (a2 + a3 <= b1 and max(b2, b3) <= a1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    if (a1 >= max(a2, b2) and b1 >= a2 + b3) or (a1 >= max(a2, b3) and b1 >= a2 + b2) or (a1 >= max(b2, b3) and b1 >= a2 + a3) or (a1 >= max(b3, a2) and b1 >= b2 + b3) or (a1 >= max(a3, b2) and b1 >= a3 + b3) or (a1 >= max(a3, b3) and b1 >= a3 + b2):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    if (a1 >= max(a2, b2) + max(a3, b3) and b1 >= max(b2, a3)) or \
       (a1 >= max(a2, b3) + max(a3, b2) and b1 >= max(b2, a3)) or \
       (b1 >= max(a2, b2) + max(a3, b3) and a1 >= max(b2, a3)) or \
       (b1 >= max(a2, b3) + max(a3, b2) and a1 >= max(b2, a3)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if (a2 + a3 <= a1 and max(b2, b3) <= b1) or (a2 + b3 <= a1 and max(b2, a3) <= b1) or (b2 + a3 <= a1 and max(a2, b3) <= b1) or (b2 + b3 <= a1 and max(a2, a3) <= b1):
        print(""YES"")
    elif (a2 + a3 <= b1 and max(b2, b3) <= a1) or (a2 + b3 <= b1 and max(b2, a3) <= a1) or (b2 + a3 <= b1 and max(a2, b3) <= a1) or (b2 + b3 <= b1 and max(a2, a3) <= a1):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if (a1 >= max(a2, a3) and b1 >= (b2 + b3)) or (a1 >= (a2 + a3) and b1 >= max(b2, b3)):
        print(""YES"")
    elif (a1 >= max(b2, a3) and b1 >= (a2 + b3)) or (a1 >= (b2 + a3) and b1 >= max(a2, b3)):
        print(""YES"")
    elif (a1 >= max(a2, b3) and b1 >= (b2 + a3)) or (a1 >= (a2 + b3) and b1 >= max(b2, a3)):
        print(""YES"")
    elif (a1 >= max(b2, b3) and b1 >= (a2 + a3)) or (a1 >= (b2 + b3) and b1 >= max(a2, a3)):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    if (a1 >= max(a2, a3) and b1 >= b2 + b3) or (a1 >= max(b2, b3) and b1 >= a2 + a3):
        print(""YES"")
    elif (a1 >= b2 + b3 and b1 >= max(a2, a3)) or (a1 >= a2 + a3 and b1 >= max(b2, b3)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if ((a2 <= a1 and b2 <= b1) and ((a3 <= a1 and b3 <= b1) or (a3 <= b1 and b3 <= a1))) or ((a2 <= b1 and b2 <= a1) and ((a3 <= a1 and b3 <= b1) or (a3 <= b1 and b3 <= a1))):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    if (a1 >= max(a2, a3) and b1 >= (b2 + b3)) or (a1 >= (a2 + a3) and b1 >= max(b2, b3)) or (a1 >= (a2 + b3) and b1 >= max(b2, a3)) or (a1 >= max(a2, b3) and b1 >= (b2 + a3)):
        print(""YES"")
    elif (b1 >= max(a2, a3) and a1 >= (b2 + b3)) or (b1 >= (a2 + a3) and a1 >= max(b2, b3)) or (b1 >= (a2 + b3) and a1 >= max(b2, a3)) or (b1 >= max(a2, b3) and a1 >= (b2 + a3)):
        print(""YES"")
    else:
        print(""NO"")


import sys

if __name__ == ""__main__"":
    solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if (a2 + a3 <= a1 and max(b2, b3) <= b1) or (max(a2, a3) <= a1 and b2 + b3 <= b1) or (a2 + b3 <= a1 and max(b2, a3) <= b1) or (max(a2, b3) <= a1 and b2 + a3 <= b1) or (b2 + b3 <= a1 and max(a2, a3) <= b1) or (max(b2, b3) <= a1 and a2 + a3 <= b1) or (b2 + a3 <= a1 and max(a2, b3) <= b1) or (max(b2, a3) <= a1 and a2 + b3 <= b1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if (a2 + a3 <= a1 and max(b2, b3) <= b1) or (a2 + b3 <= a1 and max(b2, a3) <= b1) or (max(a2, a3) <= a1 and b2 + b3 <= b1) or (max(a2, b3) <= a1 and b2 + a3 <= b1):
        print(""YES"")
    elif (a2 + a3 <= b1 and max(b2, b3) <= a1) or (a2 + b3 <= b1 and max(b2, a3) <= a1) or (max(a2, a3) <= b1 and b2 + b3 <= a1) or (max(a2, b3) <= b1 and b2 + a3 <= a1):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())
    
    if (a2 + a3 <= a1 and max(b2, b3) <= b1) or (b2 + b3 <= b1 and max(a2, a3) <= a1):
        print(""YES"")
    elif (a2 + b3 <= a1 and max(b2, a3) <= b1) or (b2 + a3 <= b1 and max(a2, b3) <= a1):
        print(""YES"")
    elif (b2 + a3 <= a1 and max(a2, b3) <= b1) or (a2 + b3 <= b1 and max(b2, a3) <= a1):
        print(""YES"")
    elif (b2 + b3 <= a1 and max(a2, a3) <= b1) or (a2 + a3 <= b1 and max(b2, b3) <= a1):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    from itertools import permutations

    a1, b1 = map(int, input().split())
    a2, b2 = map(int, input().split())
    a3, b3 = map(int, input().split())

    paintings = [(a2, b2), (a3, b3)]

    for perm in permutations(paintings):
        for rot1 in [0, 1]:
            for rot2 in [0, 1]:
                w = max(perm[0][rot1], perm[1][rot2])
                h = perm[0][1-rot1] + perm[1][1-rot2]
                if w <= a1 and h <= b1 or w <= b1 and h <= a1:
                    print(""YES"")
                    return

    print(""NO"")
  
solve()","100.0","20.0","93.33333333333333","100.0","100.0","93.33333333333333","20.0","100.0","100.0","80.0","86.66666666666667","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/99","
QUESTION:
Masha really loves algebra. On the last lesson, her strict teacher Dvastan gave she new exercise.

You are given geometric progression b defined by two integers b_1 and q. Remind that a geometric progression is a sequence of integers b_1, b_2, b_3, ..., where for each i > 1 the respective term satisfies the condition b_{i} = b_{i} - 1·q, where q is called the common ratio of the progression. Progressions in Uzhlyandia are unusual: both b_1 and q can equal 0. Also, Dvastan gave Masha m ""bad"" integers a_1, a_2, ..., a_{m}, and an integer l.

Masha writes all progression terms one by one onto the board (including repetitive) while condition |b_{i}| ≤ l is satisfied (|x| means absolute value of x). There is an exception: if a term equals one of the ""bad"" integers, Masha skips it (doesn't write onto the board) and moves forward to the next term.

But the lesson is going to end soon, so Masha has to calculate how many integers will be written on the board. In order not to get into depression, Masha asked you for help: help her calculate how many numbers she will write, or print ""inf"" in case she needs to write infinitely many integers.


-----Input-----

The first line of input contains four integers b_1, q, l, m (-10^9 ≤ b_1, q ≤ 10^9, 1 ≤ l ≤ 10^9, 1 ≤ m ≤ 10^5) — the initial term and the common ratio of progression, absolute value of maximal number that can be written on the board and the number of ""bad"" integers, respectively.

The second line contains m distinct integers a_1, a_2, ..., a_{m} (-10^9 ≤ a_{i} ≤ 10^9) — numbers that will never be written on the board.


-----Output-----

Print the only integer, meaning the number of progression terms that will be written on the board if it is finite, or ""inf"" (without quotes) otherwise.


-----Examples-----
Input
3 2 30 4
6 14 25 48

Output
3
Input
123 1 2143435 4
123 11 -5453 141245

Output
0
Input
123 1 2143435 4
54343 -13 6 124

Output
inf


-----Note-----

In the first sample case, Masha will write integers 3, 12, 24. Progression term 6 will be skipped because it is a ""bad"" integer. Terms bigger than 24 won't be written because they exceed l by absolute value.

In the second case, Masha won't write any number because all terms are equal 123 and this is a ""bad"" integer.

In the third case, Masha will write infinitely integers 123.
Use user-input-Based format and function signature solve()","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if abs(b_1) > l:
        print(0)
        return

    if q == 0:
        if b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return

    if q == 1:
        if b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return

    if q == -1:
        if b_1 in bad_integers and -b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return

    terms_written = 0
    current_term = b_1

    while abs(current_term) <= l:
        if current_term not in bad_integers:
            terms_written += 1
        current_term *= q

    print(terms_written)

solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))
    
    if abs(b_1) > l:
        print(0)
        return
    
    if q == 1:
        if b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return
    
    if q == -1:
        if b_1 in bad_integers and -b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return
    
    count = 0
    current_term = b_1
    while abs(current_term) <= l:
        if current_term not in bad_integers:
            count += 1
        current_term *= q
        
        if q == 0:
            break
    
    print(count)

solve()
  ","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    current_term = b_1
    written_terms = 0

    if abs(current_term) > l:
        print(0)
        return

    while abs(current_term) <= l:
        if current_term in bad_integers:
            current_term *= q
            continue
        written_terms += 1
        current_term *= q

        if q == 1 and current_term == b_1:
            print('inf')
            return

    print(written_terms)
  
solve()","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if b_1 == 0:
        if 0 not in bad_integers:
            print(1)
        else:
            print(0)
        return

    if q == 1:
        if b_1 not in bad_integers:
            print('inf')
        else:
            print(0)
        return

    if q == -1:
        if b_1 not in bad_integers and -b_1 not in bad_integers:
            print('inf')
        else:
            print(0)
        return

    count = 0
    while abs(b_1) <= l:
        if b_1 not in bad_integers:
            count += 1
        b_1 *= q

    print(count)

solve()
","
def solve():
    b1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if b1 == 0:
        if 0 in bad_integers:
            print(0)
        else:
            print('inf')
    else:
        ans = 0
        terms = set()
        terms.add(b1)
        while terms:
            new_terms = set()
            for term in terms:
                if abs(term) > l:
                    continue
                if term not in bad_integers:
                    ans += 1
                    new_terms.add(term*q)
            if not new_terms:
                break
            terms = new_terms

        print(ans)

solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    current_term = b_1
    terms_written = 0

    if q == 0:
        if b_1 not in bad_integers:
            terms_written = 1
    elif q == 1:
        while abs(current_term) <= l:
            if current_term not in bad_integers:
                terms_written += 1
            current_term *= q
            if current_term == 0 or q == 0:
                break
    else:
        while abs(current_term) <= l:
            if current_term not in bad_integers:
                terms_written += 1
            current_term *= q
            if abs(current_term) == abs(b_1) or q == 1 or current_term == 0 or q == 0:
                break

    if terms_written == 0:
        print(0)
    elif current_term == 0 or q == 0:
        print(terms_written)
    else:
        print(""inf"")

solve()","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))
    
    if q == 1:
        if b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
    elif q == -1:
        if b_1 in bad_integers or -b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
    else:
        terms_written = 0
        current_term = b_1
        while abs(current_term) <= l:
            if current_term not in bad_integers:
                terms_written += 1
            if abs(current_term) > l:
                break
            current_term *= q
        print(terms_written)

solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if b_1 == 0:
        if 0 not in bad_integers:
            print(1)
        else:
            print(0)
        return

    if q == 0:
        if b_1 not in bad_integers:
            print(""inf"")
        else:
            print(0)
        return

    if q == 1:
        if b_1 not in bad_integers:
            if abs(b_1) <= l:
                print(""inf"")
            else:
                print(0)
        else:
            print(0)
        return

    if q == -1:
        if b_1 not in bad_integers:
            if abs(b_1) <= l and abs(b_1) not in bad_integers:
                print(""inf"")
            else:
                print(0)
        else:
            print(0)
        return

    cnt = 0
    while abs(b_1) <= l:
        if b_1 not in bad_integers:
            cnt += 1
        b_1 *= q

    print(cnt)

import sys
if __name__ == ""__main__"":
    solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if abs(b_1) > l:
        print(0)
        return

    if q == 0:
        if b_1 not in bad_integers:
            print(""inf"")
        else:
            print(0)
        return

    current_term = b_1
    terms_count = 0

    while abs(current_term) <= l:
        if current_term not in bad_integers:
            terms_count += 1

        if q == 1:
            break

        if abs(current_term) > l:
            break

        current_term *= q

    print(terms_count)

# Call the function to execute
solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if b_1 == 0:
        if 0 not in bad_integers:
            print(1 if abs(q) <= l else 0)
        else:
            print(0)
    elif q == 0:
        print(""inf"" if b_1 in bad_integers else 1)
    elif q == 1:
        if b_1 in bad_integers:
            print(0)
        else:
            if abs(b_1) <= l:
                print(""inf"")
            else:
                print(0)
    elif q == -1:
        if b_1 in bad_integers or abs(b_1) <= l:
            print(0)
        else:
            print(""inf"")
    else:
        count = 0
        current_term = b_1
        while abs(current_term) <= l and current_term not in bad_integers:
            count += 1
            current_term *= q
        print(count)

# Call the function
solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if abs(b_1) > l:
        print(0)
    elif b_1 in bad_integers:
        print(0)
    elif q == 0:
        if b_1 not in bad_integers:
            print(""inf"")
        else:
            print(0)
    elif q == 1:
        if b_1 not in bad_integers:
            print(""inf"")
        else:
            print(0)
    elif q == -1:
        if b_1 not in bad_integers and -b_1 not in bad_integers:
            print(""inf"")
        else:
            print(0)
    else:
        terms_written = 0
        current = b_1

        while abs(current) <= l:
            if current not in bad_integers:
                terms_written += 1
            current *= q

        print(terms_written)

# Example usage
solve()
","
def solve():
    b1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))
    
    if abs(b1) > l:
        print(0)
        return
    
    if q == 1:
        if b1 in bad_integers:
            print(0)
            return
        else:
            print(""inf"")
            return
    
    if q == -1:
        if b1 in bad_integers and -b1 in bad_integers:
            print(0)
            return
        else:
            print(""inf"")
            return
    
    count = 0
    current_value = b1
    while abs(current_value) <= l:
        if current_value not in bad_integers:
            count += 1
        current_value *= q
        
        if q == 0:
            break
    
    print(count)

solve()","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if abs(b_1) > l:
        print(0)
    elif b_1 in bad_integers:
        print(0)
    elif q == 1 and b_1 not in bad_integers:
        print('inf')
    else:
        count = 0
        while abs(b_1) <= l:
            if b_1 not in bad_integers:
                count += 1
            b_1 *= q
        print(count)

solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))
    
    if abs(b_1) > l:
        print(0)
        return
    
    if q == 0:
        if b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return
    
    if q == 1 or q == -1:
        if b_1 in bad_integers or (q == 1 and b_1 > l) or (q == -1 and b_1 < -l):
            print(0)
        else:
            print(""inf"")
        return
    
    terms = set()
    while abs(b_1) <= l and b_1 not in bad_integers:
        terms.add(b_1)
        b_1 *= q
    
    print(len(terms))

solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))

    if b_1 == 0:
        if 0 in bad_integers:
            print(0)
        else:
            print(""inf"")
    else:
        count = 0
        while abs(b_1) <= l:
            if b_1 not in bad_integers:
                count += 1
            if q == 1:
                break
            b_1 *= q
        print(count)

solve()
","
def solve():
    b_1, q, l, m = map(int, input().split())
    bad_integers = set(map(int, input().split()))
    
    if abs(b_1) > l:
        print(0)
        return
    
    if q == 0:
        if b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return
    
    if q == 1:
        if b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return
    
    if q == -1:
        if b_1 in bad_integers and -b_1 in bad_integers:
            print(0)
        else:
            print(""inf"")
        return
    
    count = 0
    while abs(b_1) <= l:
        if b_1 not in bad_integers:
            count += 1
        if q == 1:
            if b_1 not in bad_integers:
                b_1 += 1
            else:
                break
        elif q == -1:
            if b_1 not in bad_integers:
                b_1 -= 1
            else:
                break
        else:
            b_1 *= q

    print(count)

solve()
","93.33333333333333","80.0","100.0","81.81818181818183","66.66666666666666","30.76923076923077","90.0","80.0","85.71428571428571","40.0","80.0","80.0","90.0","73.33333333333333","90.0","93.33333333333333","","","","","","","","","","","","","","","",""
"APPS/100","
QUESTION:
Innocentius has a problem — his computer monitor has broken. Now some of the pixels are ""dead"", that is, they are always black. As consequence, Innocentius can't play the usual computer games. He is recently playing the following game with his younger brother Polycarpus.

Innocentius is touch-typing a program that paints a white square one-pixel wide frame on the black screen. As the monitor is broken, some pixels that should be white remain black. Polycarpus should look at what the program displayed on the screen and guess the position and size of the frame Innocentius has painted. Polycarpus doesn't like the game but Innocentius persuaded brother to play as ""the game is good for the imagination and attention"".

Help Polycarpus, automatize his part in the gaming process. Write the code that finds such possible square frame that:  the frame's width is 1 pixel,  the frame doesn't go beyond the borders of the screen,  all white pixels of the monitor are located on the frame,  of all frames that satisfy the previous three conditions, the required frame must have the smallest size. 

Formally, a square frame is represented by such pixels of the solid square, that are on the square's border, that is, are not fully surrounded by the other pixels of the square. For example, if the frame's size is d = 3, then it consists of 8 pixels, if its size is d = 2, then it contains 4 pixels and if d = 1, then the frame is reduced to a single pixel.


-----Input-----

The first line contains the resolution of the monitor as a pair of integers n, m (1 ≤ n, m ≤ 2000). The next n lines contain exactly m characters each — the state of the monitor pixels at the moment of the game. Character ""."" (period, ASCII code 46) corresponds to the black pixel, and character ""w"" (lowercase English letter w) corresponds to the white pixel. It is guaranteed that at least one pixel of the monitor is white.


-----Output-----

Print the monitor screen. Represent the sought frame by characters ""+"" (the ""plus"" character). The pixels that has become white during the game mustn't be changed. Print them as ""w"". If there are multiple possible ways to position the frame of the minimum size, print any of them.

If the required frame doesn't exist, then print a single line containing number -1.


-----Examples-----
Input
4 8
..w..w..
........
........
..w..w..

Output
..w++w..
..+..+..
..+..+..
..w++w..

Input
5 6
......
.w....
......
..w...
......

Output
......
+w+...
+.+...
++w...
......

Input
2 4
....
.w..

Output
....
.w..

Input
2 6
w..w.w
...w..

Output
-1



-----Note-----

In the first sample the required size of the optimal frame equals 4. In the second sample the size of the optimal frame equals 3. In the third sample, the size of the optimal frame is 1. In the fourth sample, the required frame doesn't exist.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]

    white_pixels = [(i, j) for i in range(n) for j in range(m) if monitor[i][j] == 'w']

    if not white_pixels:
        print(-1)
        return

    min_row = min(white_pixels, key=lambda x: x[0])[0]
    max_row = max(white_pixels, key=lambda x: x[0])[0]
    min_col = min(white_pixels, key=lambda x: x[1])[1]
    max_col = max(white_pixels, key=lambda x: x[1])[1]

    for i in range(min_row, max_row + 1):
        for j in range(min_col, max_col + 1):
            if monitor[i][j] == '.':
                print(-1)
                return

    for i in range(n):
        for j in range(m):
            if i == min_row or i == max_row or j == min_col or j == max_col:
                monitor[i][j] = '+'

    for row in monitor:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    grid = [list(input()) for _ in range(n)]
    
    white_pixels = [(i,j) for i in range(n) for j in range(m) if grid[i][j] == 'w']
    
    if not white_pixels:
        print(-1)
        return
    
    min_row = min(white_pixels, key=lambda x: x[0])[0]
    max_row = max(white_pixels, key=lambda x: x[0])[0]
    min_col = min(white_pixels, key=lambda x: x[1])[1]
    max_col = max(white_pixels, key=lambda x: x[1])[1]
    
    size = max(max_row - min_row + 1, max_col - min_col + 1)
    
    for i in range(min_row, max_row+1):
        for j in range(min_col, max_col+1):
            if (i,j) not in white_pixels:
                grid[i][j] = '+'
    
    for row in grid:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [input() for _ in range(n)]
    frame = [['.' for _ in range(m)] for _ in range(n)]
    
    for i in range(1, n-1):
        for j in range(1, m-1):
            if monitor[i][j] == 'w' and all(pixel == 'w' for pixel in [monitor[i-1][j], monitor[i+1][j], monitor[i][j-1], monitor[i][j+1]]):
                frame[i][j] = '+'
                frame[i-1][j] = '+'
                frame[i+1][j] = '+'
                frame[i][j-1] = '+'
                frame[i][j+1] = '+'
                
    for row in frame:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]

    white_pixels = []
    for i in range(n):
        for j in range(m):
            if monitor[i][j] == 'w':
                white_pixels.append((i, j))

    min_x, min_y, max_x, max_y = n, m, 0, 0
    for x, y in white_pixels:
        min_x = min(min_x, x)
        max_x = max(max_x, x)
        min_y = min(min_y, y)
        max_y = max(max_y, y)

    if max_x - min_x > 1 or max_y - min_y > 1:
        print(-1)
        return

    for i in range(n):
        for j in range(m):
            if (i == min_x or i == max_x) and (j == min_y or j == max_y):
                if monitor[i][j] != 'w':
                    monitor[i][j] = '+'
            elif monitor[i][j] == 'w':
                monitor[i][j] = 'w'
    
    for row in monitor:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]
    
    white_pixels = []
    for i in range(n):
        for j in range(m):
            if monitor[i][j] == 'w':
                white_pixels.append((i, j))
    
    if len(white_pixels) == 1:
        i, j = white_pixels[0]
        monitor[i][j] = '+'
    else:
        min_col = min(row[1] for row in white_pixels)
        max_col = max(row[1] for row in white_pixels)
        min_row = min(row[0] for row in white_pixels)
        max_row = max(row[0] for row in white_pixels)
        
        if min_row == max_row:
            for j in range(min_col, max_col+1):
                monitor[min_row][j] = '+'
        elif min_col == max_col:
            for i in range(min_row, max_row+1):
                monitor[i][min_col] = '+'
        else:
            print(-1)
    
    for row in monitor:
        print(''.join(row))

solve()
  ","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]
    
    for i in range(1, n-1):
        for j in range(1, m-1):
            if monitor[i][j] == 'w':
                if monitor[i-1][j] == 'w' and monitor[i+1][j] == 'w' and monitor[i][j-1] == 'w' and monitor[i][j+1] == 'w':
                    for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:
                        if monitor[x][y] != 'w':
                            monitor[x][y] = '+'
    
    for row in monitor:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]

    white_pixels = [(i, j) for i in range(n) for j in range(m) if monitor[i][j] == 'w']

    if len(white_pixels) == 1:
        x, y = white_pixels[0]
        monitor[x][y] = '+'
    else:
        x_min = min(x for x, _ in white_pixels)
        x_max = max(x for x, _ in white_pixels)
        y_min = min(y for _, y in white_pixels)
        y_max = max(y for _, y in white_pixels)

        if x_max - x_min >= y_max - y_min:
            for i in range(x_min, x_max + 1):
                monitor[i][y_min] = '+'
                monitor[i][y_max] = '+'
        else:
            for j in range(y_min, y_max + 1):
                monitor[x_min][j] = '+'
                monitor[x_max][j] = '+'

    for row in monitor:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]

    white_pixels = []
    for i in range(n):
        for j in range(m):
            if monitor[i][j] == 'w':
                white_pixels.append((i, j))

    min_row = min(pixel[0] for pixel in white_pixels)
    max_row = max(pixel[0] for pixel in white_pixels)
    min_col = min(pixel[1] for pixel in white_pixels)
    max_col = max(pixel[1] for pixel in white_pixels)

    # Check if the frame can exist
    for row in range(min_row, max_row + 1):
        for col in range(min_col, max_col + 1):
            if monitor[row][col] == '.':
                print(-1)
                return

    # Build the frame
    for pixel in white_pixels:
        if pixel[0] == min_row or pixel[0] == max_row or pixel[1] == min_col or pixel[1] == max_col:
            monitor[pixel[0]][pixel[1]] = '+'

    for row in monitor:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [input() for _ in range(n)]

    vertical = [False] * m
    horizontal = [False] * n

    for i in range(n):
        for j in range(m):
            if monitor[i][j] == 'w':
                vertical[j] = horizontal[i] = True

    frame_size = min(vertical.count(False), horizontal.count(False))
    if frame_size == 0:
        print(""-1"")
        return

    for i in range(n):
        row = """"
        for j in range(m):
            if not horizontal[i] and not vertical[j]:
                row += ""+""
            else:
                row += ""w"" if monitor[i][j] == 'w' else "".""
        print(row)

solve()
","
def solve():
    n, m = map(int, input().split())
    screen = [list(input()) for _ in range(n)]
    
    def is_valid(i, j):
        if i < 0 or j < 0 or i >= n or j >= m:
            return False
        return True
    
    def check_frame(i, j):
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            ni, nj = i + di, j + dj
            if not is_valid(ni, nj) or screen[ni][nj] == '.':
                return False
        return True
    
    def mark_frame(i, j):
        screen[i][j] = '+'
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            ni, nj = i + di, j + dj
            screen[ni][nj] = '+'    
    
    for i in range(n):
        for j in range(m):
            if screen[i][j] == 'w':
                if check_frame(i, j):
                    mark_frame(i, j)
    
    for row in screen:
        print("""".join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input().strip()) for _ in range(n)]

    def check_frame(i, j, s):
        for x in range(s):
            if monitor[i][j+x] != 'w' or monitor[i+s-1][j+x] != 'w':
                return False
            if monitor[i+x][j] != 'w' or monitor[i+x][j+s-1] != 'w':
                return False
        return True

    for i in range(n):
        for j in range(m):
            if monitor[i][j] == 'w':
                for s in range(1, min(n,m)):
                    if i+s <= n and j+s <= m and check_frame(i, j, s):
                        for x in range(s):
                            monitor[i][j+x] = '+'
                            monitor[i+s-1][j+x] = '+'
                            monitor[i+x][j] = '+'
                            monitor[i+x][j+s-1] = '+'
                        for row in monitor:
                            print(''.join(row))
                        return

    print(""-1"")

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]

    def check_frame(x, y):
        for dx in range(-1, 2):
            for dy in range(-1, 2):
                if (dx, dy) != (0, 0):
                    if n > x+dx >= 0 and m > y+dy >= 0 and monitor[x+dx][y+dy] != ""w"":
                        return False
        return True

    for i in range(n):
        for j in range(m):
            if monitor[i][j] == ""w"" and check_frame(i, j):
                for dx in range(-1, 2):
                    for dy in range(-1, 2):
                        if (dx, dy) != (0, 0):
                            if n > i+dx >= 0 and m > j+dy >= 0:
                                monitor[i+dx][j+dy] = ""+""
                for row in monitor:
                    print("""".join(row))
                return

    print(""-1"")

solve()
","
def solve():
    n, m = map(int, input().split())
    screen = [list(input()) for _ in range(n)]
    
    white_pixels = []
    for i in range(n):
        for j in range(m):
            if screen[i][j] == 'w':
                white_pixels.append((i, j))
    
    if not white_pixels:
        print(""-1"")
        return
    
    min_row = min(col = min_row = float('inf')
    max_col = max_row = 0
    for row, col in white_pixels:
        min_row = min(min_row, row)
        max_row = max(max_row, row)
        min_col = min(min_col, col)
        max_col = max(max_col, col)
    
    min_col = max(0, min_col - 1)
    min_row = max(0, min_row - 1)
    max_col = min(m - 1, max_col + 1)
    max_row = min(n - 1, max_row + 1)
    
    for i in range(n):
        for j in range(m):
            if i == min_row or i == max_row or j == min_col or j == max_col:
                if screen[i][j] == '.':
                    screen[i][j] = '+'
    
    for row in screen:
        print(''.join(row))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [input() for _ in range(n)]
    
    white_pixels = []
    for i in range(n):
        for j in range(m):
            if monitor[i][j] == 'w':
                white_pixels.append((i, j))
    
    if not white_pixels:
        print(-1)
        return
    
    min_row, min_col = min(white_pixels, key=lambda x: x[0] + x[1])
    max_row, max_col = max(white_pixels, key=lambda x: x[0] + x[1])
    
    if min_row == max_row:
        for i in range(n):
            if monitor[i][min_col] == ""."":
                monitor[i] = monitor[i][:min_col] + ""+"" + monitor[i][min_col+1:]
    else:
        for j in range(m):
            if monitor[min_row][j] == ""."":
                monitor[min_row] = monitor[min_row][:j] + ""+"" + monitor[min_row][j+1:]
            if monitor[max_row][j] == ""."":
                monitor[max_row] = monitor[max_row][:j] + ""+"" + monitor[max_row][j+1:]
        
        for i in range(n):
            if monitor[i][min_col] == ""."":
                monitor[i] = monitor[i][:min_col] + ""+"" + monitor[i][min_col+1:]
            if monitor[i][max_col] == ""."":
                monitor[i] = monitor[i][:max_col] + ""+"" + monitor[i][max_col+1:]
    
    for line in monitor:
        print(line)

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input()) for _ in range(n)]
    white_pixels = [(i, j) for i in range(n) for j in range(m) if monitor[i][j] == 'w']

    if not white_pixels:
        print(""-1"")
        return

    min_row = min([i for i, _ in white_pixels])
    max_row = max([i for i, _ in white_pixels])
    min_col = min([j for _, j in white_pixels])
    max_col = max([j for _, j in white_pixels])

    if max_row - min_row > max_col - min_col:
        size = max_row - min_row + 1
        for i in range(min_row, max_row + 1):
            monitor[i][min_col] = '+'
            monitor[i][max_col] = '+'
    else:
        size = max_col - min_col + 1
        for j in range(min_col, max_col + 1):
            monitor[min_row][j] = '+'
            monitor[max_row][j] = '+'

    for i in range(n):
        print(''.join(monitor[i]))

solve()
","
def solve():
    n, m = map(int, input().split())
    monitor = [list(input().strip()) for _ in range(n)]

    white_pixels = [(i, j) for i in range(n) for j in range(m) if monitor[i][j] == 'w']

    if not white_pixels:
        print(-1)
        return

    top, bottom, left, right = n, 0, m, 0

    for i, j in white_pixels:
        top = min(top, i)
        bottom = max(bottom, i)
        left = min(left, j)
        right = max(right, j)

    frame_size = max(bottom - top, right - left) + 1

    for i in range(n):
        for j in range(m):
            if (top <= i <= bottom and j in [left, right]) or (left <= j <= right and i in [top, bottom]):
                monitor[i][j] = '+'

    for row in monitor:
        print(''.join(row))

solve()
","6.666666666666667","20.0","0.0","26.666666666666668","0.0","20.0","0.0","6.666666666666667","20.0","20.0","13.333333333333334","13.333333333333334","0.0","13.333333333333334","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/101","
QUESTION:
Vasya has n burles. One bottle of Ber-Cola costs a burles and one Bars bar costs b burles. He can buy any non-negative integer number of bottles of Ber-Cola and any non-negative integer number of Bars bars.

Find out if it's possible to buy some amount of bottles of Ber-Cola and Bars bars and spend exactly n burles.

In other words, you should find two non-negative integers x and y such that Vasya can buy x bottles of Ber-Cola and y Bars bars and x·a + y·b = n or tell that it's impossible.


-----Input-----

First line contains single integer n (1 ≤ n ≤ 10 000 000) — amount of money, that Vasya has.

Second line contains single integer a (1 ≤ a ≤ 10 000 000) — cost of one bottle of Ber-Cola.

Third line contains single integer b (1 ≤ b ≤ 10 000 000) — cost of one Bars bar.


-----Output-----

If Vasya can't buy Bars and Ber-Cola in such a way to spend exactly n burles print «NO» (without quotes).

Otherwise in first line print «YES» (without quotes). In second line print two non-negative integers x and y — number of bottles of Ber-Cola and number of Bars bars Vasya should buy in order to spend exactly n burles, i.e. x·a + y·b = n. If there are multiple answers print any of them.

Any of numbers x and y can be equal 0.


-----Examples-----
Input
7
2
3

Output
YES
2 1

Input
100
25
10

Output
YES
0 10

Input
15
4
8

Output
NO

Input
9960594
2551
2557

Output
YES
1951 1949



-----Note-----

In first example Vasya can buy two bottles of Ber-Cola and one Bars bar. He will spend exactly 2·2 + 1·3 = 7 burles.

In second example Vasya can spend exactly n burles multiple ways:   buy two bottles of Ber-Cola and five Bars bars;  buy four bottles of Ber-Cola and don't buy Bars bars;  don't buy Ber-Cola and buy 10 Bars bars. 

In third example it's impossible to but Ber-Cola and Bars bars in order to spend exactly n burles.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n // a + 1):
        y = (n - x * a) // b
        if x * a + y * b == n:
            print(""YES"")
            print(x, y)
            return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    for x in range(n//a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n//a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return

    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return

    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return

    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    for x in range(n//a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    for x in range(n//a + 1):
        if (n - x*a) % b == 0:
            y = (n - x*a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            print(""YES"")
            print(x, (n - x * a) // b)
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    for x in range(n // a + 1):
        if (n - x * a) % b == 0:
            y = (n - x * a) // b
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())

    for x in range(n//a + 1):
        if (n - x*a) % b == 0:
            y = (n - x*a) // b
            print(""YES"")
            print(x, y)
            return

    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    
    for i in range(n // a + 1):
        if (n - i * a) % b == 0:
            print(""YES"")
            print(i, (n - i * a) // b)
            return
    
    print(""NO"")

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/102","
QUESTION:
Today Tavas got his test result as an integer score and he wants to share it with his girlfriend, Nafas.

His phone operating system is Tavdroid, and its keyboard doesn't have any digits! He wants to share his score with Nafas via text, so he has no choice but to send this number using words. [Image] 

He ate coffee mix without water again, so right now he's really messed up and can't think.

Your task is to help him by telling him what to type.


-----Input-----

The first and only line of input contains an integer s (0 ≤ s ≤ 99), Tavas's score. 


-----Output-----

In the first and only line of output, print a single string consisting only from English lowercase letters and hyphens ('-'). Do not use spaces.


-----Examples-----
Input
6

Output
six

Input
99

Output
ninety-nine

Input
20

Output
twenty



-----Note-----

You can find all you need to know about English numerals in http://en.wikipedia.org/wiki/English_numerals .
Use user-input-Based format and function signature solve()","
def solve():
    from num2words import num2words
    s = int(input())
    print(num2words(s, lang='en').replace(' ', '-'))

solve()","
def solve():
    from num2words import num2words
    
    score = int(input())
    words = num2words(score, lang='en').replace(' ', '-').replace(',', '')

    return words

solve()","
def solve():
    num = int(input())
    ones = [""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"", ""nine""]
    tens = ["""", """", ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
    teens = [""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""]

    if num < 10:
        print(ones[num])
    elif num < 20:
        print(teens[num-10])
    else:
        if num % 10 == 0:
            print(tens[num//10])
        else:
            print(tens[num//10] + ""-"" + ones[num%10])
  
solve()","
def solve():
    s = int(input())
    
    # dictionary to store English numerals
    num_dict = {
        0: '', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
        6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
        11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen',
        15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen',
        19: 'nineteen', 20: 'twenty', 30: 'thirty', 40: 'forty',
        50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety'
    }

    if s in num_dict:
        print(num_dict[s])
    else:
        tens = s // 10 * 10
        ones = s % 10
        print(num_dict[tens] + '-' + num_dict[ones])

solve()
","
def solve():
    from inflect import engine
    p = engine()
    s = int(input())
    score = p.number_to_words(s)
    print(score.replace(' ', '-'))

solve()","
def solve():
    num_words = {
        0: 'zero',
        1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
        6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
        11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen',
        15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen',
        19: 'nineteen', 20: 'twenty', 30: 'thirty', 40: 'forty',
        50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety'
    }
    
    s = int(input())
    
    if s in num_words:
        print(num_words[s])
    else:
        tens = s // 10 * 10
        ones = s % 10
        print(num_words[tens] + '-' + num_words[ones])
  
solve()","
def solve():
    from inflect import engine
    p = engine()
    s = int(input())
    print(p.number_to_words(s, andword='', zero='zero', group=2))

solve()","
def solve():
    from inflect import engine
    p = engine()
    
    s = int(input())
    if s == 0:
        return ""zero""
    
    return p.number_to_words(s).replace(' ', '-').replace(',', '')

solve()
","
def solve():
    from num2words import num2words
    s = int(input().strip())
    print(num2words(s).replace(' ', '-'))

solve()
","
import inflect

def solve():
    p = inflect.engine()
    num = int(input())
    print(p.number_to_words(num).replace(' ', '-').replace(',', ''))

solve()","
def solve():
    from num2words import num2words
    
    s = int(input())
    score_text = num2words(s, to='cardinal').replace(' ', '-').replace(',', '')
    
    print(score_text)
  
solve()","
def solve():
    from inflect import engine
    engine = engine()
    
    s = int(input())
    print(engine.number_to_words(s).replace(' ', '-'))

solve()","
def solve():
    num_to_word = {0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 
                   7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten', 11: 'eleven', 12: 'twelve',
                   13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen',
                   18: 'eighteen', 19: 'nineteen', 20: 'twenty', 30: 'thirty', 40: 'forty',
                   50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety'}

    s = int(input())
    
    if s in num_to_word:
        return num_to_word[s]
    else:
        tens = s // 10 * 10
        ones = s % 10
        return num_to_word[tens] + '-' + num_to_word[ones] if ones != 0 else num_to_word[tens]


solve()","
def solve():
    from inflect import engine
    p = engine()
    s = int(input())
    print(p.number_to_words(s, zero='zero', andword='', zerostr=''))

solve()","
def solve():
    from num2words import num2words
    
    s = int(input())
    print(num2words(s, to='cardinal').replace(' ', '-'))

solve()
","
def solve():
    import inflect
    p = inflect.engine()

    s = int(input())
    print(p.number_to_words(s).replace("" "", ""-""))

solve()","0.0","0.0","100.0","93.33333333333333","0.0","100.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/103","
QUESTION:
JATC and his friend Giraffe are currently in their room, solving some problems. Giraffe has written on the board an array $a_1$, $a_2$, ..., $a_n$ of integers, such that $1 \le a_1 < a_2 < \ldots < a_n \le 10^3$, and then went to the bathroom.

JATC decided to prank his friend by erasing some consecutive elements in the array. Since he doesn't want for the prank to go too far, he will only erase in a way, such that Giraffe can still restore the array using the information from the remaining elements. Because Giraffe has created the array, he's also aware that it's an increasing array and all the elements are integers in the range $[1, 10^3]$.

JATC wonders what is the greatest number of elements he can erase?


-----Input-----

The first line of the input contains a single integer $n$ ($1 \le n \le 100$) — the number of elements in the array.

The second line of the input contains $n$ integers $a_i$ ($1 \le a_1<a_2<\dots<a_n \le 10^3$) — the array written by Giraffe.


-----Output-----

Print a single integer — the maximum number of consecutive elements in the array that JATC can erase.

If it is impossible to erase even a single element, print $0$.


-----Examples-----
Input
6
1 3 4 5 6 9

Output
2
Input
3
998 999 1000

Output
2
Input
5
1 2 3 4 5

Output
4


-----Note-----

In the first example, JATC can erase the third and fourth elements, leaving the array $[1, 3, \_, \_, 6, 9]$. As you can see, there is only one way to fill in the blanks.

In the second example, JATC can erase the second and the third elements. The array will become $[998, \_, \_]$. Because all the elements are less than or equal to $1000$, the array is still can be restored. Note, that he can't erase the first $2$ elements.

In the third example, JATC can erase the first $4$ elements. Since all the elements are greater than or equal to $1$, Giraffe can still restore the array. Note, that he can't erase the last $4$ elements.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        for j in range(i, n):
            if a[j] - a[i] == j - i:
                max_erase = max(max_erase, j - i - 1)
    
    print(max_erase)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[j] - a[i] == j - i:
                max_erase = max(max_erase, j - i - 1)
    
    print(max_erase)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        for j in range(i, n):
            if all(a[k] - a[k-1] == 1 for k in range(i+1, j+1)):
                max_erase = max(max_erase, j - i - 1)
    
    print(max_erase)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    ans = 0
    for i in range(1, n-1):
        if a[i+1] - a[i-1] <= 2:
            ans = max(ans, a[i+1] - a[i-1] - 1)

    print(ans)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        left_border = a[i] - i
        right_border = a[i] + n - i - 1
        max_erase = max(max_erase, right_border - left_border + 1)
    
    print(max_erase - n)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    max_erase = 0
    for i in range(n):
        left_range = a[i] - i
        right_range = 10**3 - (n - i - 1)

        max_erase = max(max_erase, min(left_range, right_range))

    print(max_erase)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        left = i - 1 if i > 0 else i
        right = i + 1 if i < n - 1 else i

        if arr[right] - arr[left] == right - left + 2:
            max_erase = max(max_erase, right - left - 1)

    print(max_erase)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_erase = max(min(a[i] - a[i-1] - 1, n - i) for i in range(1, n))
    
    print(max_erase)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    max_erase = 0
    current_erase = 0

    for i in range(1, n):
        if a[i] - a[i-1] == 1:
            current_erase += 1
        else:
            max_erase = max(max_erase, current_erase)
            current_erase = 0

    max_erase = max(max_erase, current_erase)

    if max_erase == 0:
        print(0)
    else:
        print(max_erase)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        for j in range(i, n):
            if all(arr[k] <= arr[k + 1] for k in range(i, j)):
                max_erase = max(max_erase, j - i)
    
    print(max_erase)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    max_erased = 0
    for i in range(n):
        for j in range(i + 1, n):
            diff = a[j] - a[i] - (j - i)
            if diff == 0 or a[i] == 1 or a[j] == 1000:
                max_erased = max(max_erased, j - i - 1)

    print(max_erased)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        left = a[i] - i
        right = a[n-1] - a[i] - (n-1-i)
        max_erase = max(max_erase, n - max(left, right))
    
    print(max_erase)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_elements_erased = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[j] - a[i] == j - i:
                max_elements_erased = max(max_elements_erased, j - i - 1)
    
    print(max_elements_erased)

solve()
","
def solve():
    n = int(input())
    array = list(map(int, input().split()))
    
    max_erase = 0
    for i in range(n):
        for j in range(i, n):
            if array[j] - array[i] == j - i:
                max_erase = max(max_erase, j - i - 1)
    
    print(max_erase)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    count = 0
    max_count = 0
    for i in range(1, n):
        if arr[i] - arr[i-1] == 1:
            count += 1
        else:
            max_count = max(max_count, count)
            count = 0

    max_count = max(max_count, count)
    
    print(max_count)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    max_erase = 0
    for i in range(n):
        for j in range(i, n):
            if arr[j] - arr[i] == j - i:
                max_erase = max(max_erase, j - i - 1)

    print(max_erase)

# Call the function
solve()
","53.333333333333336","53.333333333333336","53.333333333333336","40.0","26.666666666666668","6.666666666666667","33.33333333333333","0.0","73.33333333333333","60.0","40.0","66.66666666666666","53.333333333333336","53.333333333333336","73.33333333333333","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/104","
QUESTION:
Polycarp has created his own training plan to prepare for the programming contests. He will train for $n$ days, all days are numbered from $1$ to $n$, beginning from the first.

On the $i$-th day Polycarp will necessarily solve $a_i$ problems. One evening Polycarp plans to celebrate the equator. He will celebrate it on the first evening of such a day that from the beginning of the training and to this day inclusive he will solve half or more of all the problems.

Determine the index of day when Polycarp will celebrate the equator.


-----Input-----

The first line contains a single integer $n$ ($1 \le n \le 200\,000$) — the number of days to prepare for the programming contests.

The second line contains a sequence $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10\,000$), where $a_i$ equals to the number of problems, which Polycarp will solve on the $i$-th day.


-----Output-----

Print the index of the day when Polycarp will celebrate the equator.


-----Examples-----
Input
4
1 3 2 1

Output
2

Input
6
2 2 2 2 2 2

Output
3



-----Note-----

In the first example Polycarp will celebrate the equator on the evening of the second day, because up to this day (inclusive) he will solve $4$ out of $7$ scheduled problems on four days of the training.

In the second example Polycarp will celebrate the equator on the evening of the third day, because up to this day (inclusive) he will solve $6$ out of $12$ scheduled problems on six days of the training.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))
    
    total_problems = sum(problems_solved)
    solved_so_far = 0
    for i in range(n):
        solved_so_far += problems_solved[i]
        if solved_so_far * 2 >= total_problems:
            return i + 1

# Call the function to get the result
print(solve())

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_problems = sum(a)
    solved_problems = 0
    for i in range(n):
        solved_problems += a[i]
        if solved_problems * 2 >= total_problems:
            print(i + 1)
            break

solve()
  ","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_problems = sum(a)
    prefix_sum = 0
    for i in range(n):
        prefix_sum += a[i]
        if prefix_sum * 2 >= total_problems:
            print(i + 1)
            break

solve()
","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))
    
    total_problems = sum(problems_solved)
    half_problems = total_problems // 2
    
    solved = 0
    day = 0
    for i in range(n):
        solved += problems_solved[i]
        if solved >= half_problems:
            day = i + 1
            break
    
    print(day)

solve()
","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))
    
    total_problems = sum(problems_solved)
    target_problems = (total_problems + 1) // 2
    
    cumulative_problems = 0
    for day, problems in enumerate(problems_solved, start=1):
        cumulative_problems += problems
        if cumulative_problems >= target_problems:
            print(day)
            break

solve()
","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))
    
    total_problems = sum(problems_solved)
    
    solved_so_far = 0
    for i in range(n):
        solved_so_far += problems_solved[i]
        if solved_so_far >= (total_problems + 1) // 2:
            return i + 1

# Call the function to run the solution
solve()
","
def solve():
    n = int(input())
    problems = list(map(int, input().split()))

    total_problems = sum(problems)
    solved_problems = 0
    day = 0

    for i in range(n):
        solved_problems += problems[i]
        if solved_problems * 2 >= total_problems:
            day = i + 1
            break

    print(day)

solve()
","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))
    
    total_problems = sum(problems_solved)
    running_total = 0
    
    for i in range(n):
        running_total += problems_solved[i]
        if running_total * 2 >= total_problems:
            return i+1

# Example usage
print(solve())

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_problems = sum(a)
    solved_problems = 0
    equator_day = 0

    for i in range(n):
        solved_problems += a[i]
        if solved_problems * 2 >= total_problems:
            equator_day = i + 1
            break

    print(equator_day)

solve()","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))

    total_problems = sum(problems_solved)
    solved_so_far = 0
    for i, problems in enumerate(problems_solved, start=1):
        solved_so_far += problems
        if solved_so_far * 2 >= total_problems:
            print(i)
            break

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_problems = sum(a)
    solved_problems = 0
    day = 1

    for problems in a:
        solved_problems += problems
        if solved_problems * 2 >= total_problems:
            print(day)
            break

        day += 1

solve()
","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))

    total_problems = sum(problems_solved)
    problems_seen_so_far = 0

    for i in range(n):
        problems_seen_so_far += problems_solved[i]
        if problems_seen_so_far * 2 >= total_problems:
            return i + 1

# Example usage
print(solve())

solve()","
def solve():
    n = int(input())
    days = list(map(int, input().split()))
    
    total_problems = sum(days)
    solved_problems = 0
    for i in range(n):
        solved_problems += days[i]
        if solved_problems * 2 >= total_problems:
            return i + 1

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_problems = sum(a)
    solved_problems = 0
    
    for i in range(n):
        solved_problems += a[i]
        if solved_problems * 2 >= total_problems:
            return i + 1

# Call the function to find the day when Polycarp will celebrate the equator
print(solve())

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_problems = sum(a)
    solved_problems = 0
    day = 0
    
    for i in range(n):
        solved_problems += a[i]
        if solved_problems * 2 >= total_problems:
            day = i + 1
            break
    
    print(day)

solve()
","
def solve():
    n = int(input())
    problems_solved = list(map(int, input().split()))
    
    total_problems = sum(problems_solved)
    half_problems = (total_problems + 1) // 2
    
    solved_so_far = 0
    for i in range(n):
        solved_so_far += problems_solved[i]
        if solved_so_far >= half_problems:
            return i + 1

# Call the function to solve the problem
print(solve())

solve()","0.0","100.0","100.0","33.33333333333333","100.0","0.0","100.0","0.0","100.0","100.0","100.0","0.0","0.0","0.0","100.0","0.0","","","","","","","","","","","","","","","",""
"APPS/105","
QUESTION:
You stumbled upon a new kind of chess puzzles. The chessboard you are given is not necesserily $8 \times 8$, but it still is $N \times N$. Each square has some number written on it, all the numbers are from $1$ to $N^2$ and all the numbers are pairwise distinct. The $j$-th square in the $i$-th row has a number $A_{ij}$ written on it.

In your chess set you have only three pieces: a knight, a bishop and a rook. At first, you put one of them on the square with the number $1$ (you can choose which one). Then you want to reach square $2$ (possibly passing through some other squares in process), then square $3$ and so on until you reach square $N^2$. In one step you are allowed to either make a valid move with the current piece or replace it with some other piece. Each square can be visited arbitrary number of times.

A knight can move to a square that is two squares away horizontally and one square vertically, or two squares vertically and one square horizontally. A bishop moves diagonally. A rook moves horizontally or vertically. The move should be performed to a different square from the one a piece is currently standing on.

You want to minimize the number of steps of the whole traversal. Among all the paths to have the same number of steps you want to choose the one with the lowest number of piece replacements.

What is the path you should take to satisfy all conditions?


-----Input-----

The first line contains a single integer $N$ ($3 \le N \le 10$) — the size of the chessboard.

Each of the next $N$ lines contains $N$ integers $A_{i1}, A_{i2}, \dots, A_{iN}$ ($1 \le A_{ij} \le N^2$) — the numbers written on the squares of the $i$-th row of the board.

It is guaranteed that all $A_{ij}$ are pairwise distinct.


-----Output-----

The only line should contain two integers — the number of steps in the best answer and the number of replacement moves in it.


-----Example-----
Input
3
1 9 3
8 6 7
4 2 5

Output
12 1



-----Note-----

Here are the steps for the first example (the starting piece is a knight):  Move to $(3, 2)$  Move to $(1, 3)$  Move to $(3, 2)$  Replace the knight with a rook  Move to $(3, 1)$  Move to $(3, 3)$  Move to $(3, 2)$  Move to $(2, 2)$  Move to $(2, 3)$  Move to $(2, 1)$  Move to $(1, 1)$  Move to $(1, 2)$
Use user-input-Based format and function signature solve()","
def solve():
    import sys
    input = sys.stdin.readline

    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]

    def find_position(num):
        for i in range(N):
            for j in range(N):
                if board[i][j] == num:
                    return i, j

    def min_moves(piece, start, end):
        def knight_moves(start, end):
            return abs(start[0] - end[0]) + abs(start[1] - end[1]) == 3 and (abs(start[0] - end[0]) == 1 or abs(start[1] - end[1]) == 1)

        def bishop_moves(start, end):
            return abs(start[0] - end[0]) == abs(start[1] - end[1])

        def rook_moves(start, end):
            return start[0] == end[0] or start[1] == end[1]

        def num_moves(start, end):
            if piece == 'knight':
                return knight_moves(start, end)
            elif piece == 'bishop':
                return bishop_moves(start, end)
            elif piece == 'rook':
                return rook_moves(start, end)

        steps = 0
        replacements = 0
        current_pos = start

        for num in range(2, N*N+1):
            next_pos = find_position(num)
            if not num_moves(current_pos, next_pos):
                replacements += 1
                if piece == 'knight':
                    piece = 'bishop' if bishop_moves(current_pos, next_pos) else 'rook'
                elif piece == 'bishop':
                    piece = 'knight' if knight_moves(current_pos, next_pos) else 'rook'
                else:
                    piece = 'knight' if knight_moves(current_pos, next_pos) else 'bishop'
            steps += abs(current_pos[0] - next_pos[0]) + abs(current_pos[1] - next_pos[1])
            current_pos = next_pos

        return steps, replacements

    start_pos = find_position(1)
    steps_knight, replacements_knight = min_moves('knight', start_pos, start_pos)
    steps_bishop, replacements_bishop = min_moves('bishop', start_pos, start_pos)
    steps_rook, replacements_rook = min_moves('rook', start_pos, start_pos)

    min_steps = min(steps_knight, steps_bishop, steps_rook)
    min_replacements = min(replacements_knight, replacements_bishop, replacements_rook)

    print(min_steps, min_replacements)

solve()
","
def solve():
    import itertools

    def manhattan_distance(point1, point2):
        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])

    def calculate_steps_and_replacements(N, board):
        positions = {}
        for i in range(N):
            for j in range(N):
                positions[board[i][j]] = (i, j)

        steps = 0
        replacements = 0
        current_position = positions[1]
        current_piece = 'knight'  # start with a knight

        for num in range(2, N*N+1):
            target_position = positions[num]
            if current_piece == 'knight':
                possible_moves = [(current_position[0] + 2, current_position[1] + 1),
                                  (current_position[0] + 2, current_position[1] - 1),
                                  (current_position[0] - 2, current_position[1] + 1),
                                  (current_position[0] - 2, current_position[1] - 1),
                                  (current_position[0] + 1, current_position[1] + 2),
                                  (current_position[0] + 1, current_position[1] - 2),
                                  (current_position[0] - 1, current_position[1] + 2),
                                  (current_position[0] - 1, current_position[1] - 2)]
                min_distance = float('inf')
                for move in possible_moves:
                    if move[0] >= 0 and move[0] < N and move[1] >= 0 and move[1] < N:
                        distance = manhattan_distance(move, target_position)
                        if distance < min_distance:
                            min_distance = distance
                            next_position = move
                if current_position != next_position:
                    steps += 1
                    current_position = next_position
                else:
                    replacements += 1
                    current_piece = 'rook'

            elif current_piece == 'rook':
                if current_position[0] != target_position[0] and current_position[1] != target_position[1]:
                    steps += 1
                    current_position = (target_position[0], current_position[1])
                if current_position != target_position:
                    steps += abs(current_position[1] - target_position[1]) + abs(current_position[0] - target_position[0])
                    current_position = target_position
                else:
                    replacements += 1
                    current_piece = 'bishop'

            elif current_piece == 'bishop':
                if current_position[0] != target_position[0] and current_position[1] != target_position[1]:
                    steps += 1
                    current_position = target_position
                else:
                    replacements += 1
                    current_piece = 'knight'

        return (steps, replacements)

    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]

    steps, replacements = calculate_steps_and_replacements(N, board)

    print(steps, replacements)

solve()
","
from collections import deque

def solve():
    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]
    
    target_positions = {(i, j): board[i][j] for i in range(N) for j in range(N)}
    total_steps = 0
    total_replacements = 0
    
    def can_move(current_pos, next_pos, piece):
        diff = abs(target_positions[current_pos] - target_positions[next_pos])
        if piece == 'knight':
            return diff == 3 or diff == 4
        elif piece == 'bishop':
            return abs(current_pos[0] - next_pos[0]) == abs(current_pos[1] - next_pos[1])
        elif piece == 'rook':
            return current_pos[0] == next_pos[0] or current_pos[1] == next_pos[1]
    
    def move_to(current_pos, next_pos, piece):
        nonlocal total_steps
        total_steps += 1
        if not can_move(current_pos, next_pos, piece):
            total_replacements += 1
            piece = 'rook' if piece != 'rook' else 'knight'
        return piece
    
    current_pos = (0, 0)
    current_piece = 'knight'
    
    for i in range(1, N*N):
        next_pos = [(r, c) for r in range(N) for c in range(N) if board[r][c] == i+1][0]
        current_piece = move_to(current_pos, next_pos, current_piece)
        current_pos = next_pos
    
    print(total_steps, total_replacements)

solve()
  ","
def solve():
    pass

solve()","
def solve():
    pass  # Your solution here

if __name__ == ""__main__"":
    solve()
","
def solve():
    import sys

    n = int(input())
    board = [list(map(int, input().split())) for _ in range(n)]

    def get_position(num):
        for i in range(n):
            for j in range(n):
                if board[i][j] == num:
                    return (i, j)
        return None

    def get_distance(pos1, pos2):
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

    def get_min_moves_num(start_pos, end_pos, piece):
        curr_pos = start_pos
        moves = 0
        replacements = 0
        for num in range(1, n * n + 1):
            target_pos = get_position(num)
            if target_pos is None:
                continue
            if piece == ""knight"":
                move_options = [(2, 1), (1, 2), (2, -1), (1, -2), (-2, 1), (-1, 2), (-2, -1), (-1, -2)]
            elif piece == ""bishop"":
                move_options = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            else:
                move_options = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            min_moves = sys.maxsize
            min_move_option = None
            for move_option in move_options:
                new_pos = (curr_pos[0] + move_option[0], curr_pos[1] + move_option[1])
                if 0 <= new_pos[0] < n and 0 <= new_pos[1] < n:
                    if get_distance(new_pos, target_pos) < min_moves:
                        min_moves = get_distance(new_pos, target_pos)
                        min_move_option = move_option
            moves += min_moves
            replacements += 1
            if piece == ""knight"":
                curr_pos = (curr_pos[0] + min_move_option[0], curr_pos[1] + min_move_option[1])
            else:
                curr_pos = (new_pos[0], new_pos[1])
        return moves, replacements

    min_steps = sys.maxsize
    min_replacements = sys.maxsize
    for piece in [""knight"", ""bishop"", ""rook""]:
        start_pos = get_position(1)
        moves, replacements = get_min_moves_num(start_pos, start_pos, piece)
        if moves < min_steps or (moves == min_steps and replacements < min_replacements):
            min_steps = moves
            min_replacements = replacements
    
    print(min_steps, min_replacements)

solve()
","
def solve():
    import queue

    def get_coord(num, N):
        x = (num - 1) // N
        y = (num - 1) % N
        return x, y

    def knight_moves(x1, y1, x2, y2):
        dx = abs(x1 - x2)
        dy = abs(y1 - y2)
        if (dx == 1 and dy == 2) or (dx == 2 and dy == 1):
            return True
        return False

    def bishop_moves(x1, y1, x2, y2):
        if abs(x1 - x2) == abs(y1 - y2):
            return True
        return False

    N = int(input())
    board = []
    for _ in range(N):
        row = list(map(int, input().split()))
        board.append(row)

    moves = queue.Queue()
    moves.put((0, 0, 0, 0))  # steps, piece replacement count, current number, current piece

    while not moves.empty():
        steps, rep_cnt, curr_num, curr_piece = moves.get()
        x1, y1 = get_coord(curr_num, N)

        if curr_num == N*N:
            print(steps, rep_cnt)
            break

        x2, y2 = get_coord(curr_num + 1, N)

        if curr_piece == 0:  # Knight
            if knight_moves(x1, y1, x2, y2):
                moves.put((steps + abs(x1 - x2) + abs(y1 - y2), rep_cnt, curr_num + 1, curr_piece))
            else:
                moves.put((steps + abs(x1 - x2) + abs(y1 - y2), rep_cnt + 1, curr_num + 1, 1))
        elif curr_piece == 1:  # Bishop
            if bishop_moves(x1, y1, x2, y2):
                moves.put((steps + abs(x1 - x2), rep_cnt, curr_num + 1, curr_piece))
            else:
                moves.put((steps + abs(x1 - x2), rep_cnt + 1, curr_num + 1, 2))
        elif curr_piece == 2:  # Rook
            if x1 == x2 or y1 == y2:
                moves.put((steps + abs(x1 - x2) + abs(y1 - y2), rep_cnt, curr_num + 1, curr_piece))
            else:
                moves.put((steps + abs(x1 - x2) + abs(y1 - y2), rep_cnt + 1, curr_num + 1, 0))

solve()
","
def solve():
    import sys

    N = int(input())
    chessboard = [list(map(int, input().split())) for _ in range(N)]

    positions = {}
    for i in range(N):
        for j in range(N):
            positions[chessboard[i][j]] = (i, j)

    def dist(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    def get_piece_moves(piece_type, current_pos, target_pos):
        if piece_type == ""knight"":
            return dist(current_pos, target_pos) == 3 and abs(current_pos[0] - target_pos[0]) != 0 and abs(current_pos[1] - target_pos[1]) != 0
        elif piece_type == ""bishop"":
            return abs(current_pos[0] - target_pos[0]) == abs(current_pos[1] - target_pos[1])
        elif piece_type == ""rook"":
            return current_pos[0] == target_pos[0] or current_pos[1] == target_pos[1]

    def get_piece_moves_count(piece_type, current_pos, target_pos):
        if piece_type == ""knight"" or piece_type == ""bishop"":
            return 1
        elif piece_type == ""rook"":
            return 2

    def get_steps(pieces=[""knight"", ""bishop"", ""rook""]):
        min_steps = float('inf')
        min_replacements = float('inf')
        for i in range(1, N*N):
            current_piece = pieces[0]
            steps = 0
            replacements = 0
            current_pos = positions[i]
            for j in range(i+1, N*N+1):
                target_pos = positions[j]
                if not get_piece_moves(current_piece, current_pos, target_pos):
                    replacements += 1
                    current_piece = pieces[1] if pieces[0] != pieces[1] else pieces[2]
                steps += get_piece_moves_count(current_piece, current_pos, target_pos)
                current_pos = target_pos
            if steps < min_steps or (steps == min_steps and replacements < min_replacements):
                min_steps = steps
                min_replacements = replacements
        return min_steps, min_replacements

    steps, replacements = get_steps()
    print(steps, replacements)

  
solve()","
def solve():
    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]

    steps = 0
    replacements = 0
    current_piece = 'knight'
    
    for num in range(1, N*N + 1):
        for i in range(N):
            for j in range(N):
                if board[i][j] == num:
                    row_diff = abs(i - (num-1)//N)
                    col_diff = abs(j - (num-1)%N)
                    
                    move_steps = max(row_diff, col_diff)
                    if current_piece == 'knight':
                        if move_steps == 2:
                            replacements += 1
                            current_piece = 'bishop'
                        elif move_steps == 1:
                            steps += 1
                    elif current_piece == 'bishop':
                        if row_diff == col_diff:
                            steps += 1
                        else:
                            replacements += 1
                            current_piece = 'rook'
                    elif current_piece == 'rook':
                        steps += move_steps
    
    return steps, replacements

solve()","
def solve():
    import itertools

    def manhattan_distance(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    def get_possible_moves(curr_square, N):
        x, y = curr_square
        possible_moves = []
        for i in range(N):
            for j in range(N):
                if (i, j) == curr_square:
                    continue
                if i == x or j == y or abs(x-i) == abs(y-j):
                    possible_moves.append((i, j))
        return possible_moves

    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]
    pieces = ['knight', 'bishop', 'rook']
    best_steps = float('inf')
    best_replacements = float('inf')

    for perm in itertools.permutations(pieces):
        curr_piece = 0
        steps = 0
        replacements = 0
        curr_square = (0, 0)

        for num in range(1, N*N+1):
            num_position = None
            for i in range(N):
                for j in range(N):
                    if board[i][j] == num:
                        num_position = (i, j)
                        break
                if num_position:
                    break

            distance = manhattan_distance(curr_square, num_position)
            if perm[curr_piece] == 'knight' and distance == 3:
                replacement = True
            elif perm[curr_piece] == 'bishop' and (num_position[0] + num_position[1]) % 2 != 0:
                replacement = True
            elif perm[curr_piece] == 'rook' and num_position[0] != curr_square[0] and num_position[1] != curr_square[1]:
                replacement = True
            else:
                replacement = False

            if replacement:
                replacements += 1
                curr_piece = (curr_piece + 1) % 3

            steps += distance + 1
            curr_square = num_position

        if steps < best_steps or (steps == best_steps and replacements < best_replacements):
            best_steps = steps
            best_replacements = replacements

    print(best_steps, best_replacements)

solve()
","
from collections import deque

def solve():
    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]
    
    visited = [[False for _ in range(N)] for _ in range(N)]
    knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
    
    def valid(x, y):
        return 0 <= x < N and 0 <= y < N
    
    def bfs(start_x, start_y):
        steps = 0
        replacements = 0
        
        queue = deque([(start_x, start_y, 0)])
        visited[start_x][start_y] = True

        while queue:
            x, y, num = queue.popleft()
            if num == N*N:  # Reached the final square
                return steps, replacements
            
            possible_moves = []
            for dx, dy in knight_moves:
                new_x, new_y = x + dx, y + dy
                if valid(new_x, new_y) and not visited[new_x][new_y]:
                    possible_moves.append((new_x, new_y, num+1))

            if board[x][y] != num+1:
                replacements += 1

            for new_x, new_y, new_num in possible_moves:
                visited[new_x][new_y] = True
                queue.append((new_x, new_y, new_num))
                steps += 1

        return steps, replacements
    
    result = bfs(*divmod([board[i].index(1) for i in range(N)].index(0), N))
    print(result[0], result[1])

solve()
","
def solve():
    n = int(input())
    chessboard = [list(map(int, input().split())) for _ in range(n)]
    start_piece = (0, 0)
    end_piece = (0, 0)
    steps = 0
    replacements = 0
    
    for i in range(n):
        for j in range(n):
            if chessboard[i][j] == 1:
                start_piece = (i, j)
            elif chessboard[i][j] == n*n:
                end_piece = (i, j)
    
    # Function to calculate manhattan distance between two points
    def manhattan_distance(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
    
    steps += manhattan_distance(start_piece, end_piece)
    
    if steps % 2 == 0:
        replacements += steps//2
    else:
        replacements += steps//2 + 1
    
    print(f""{steps} {replacements}"")

solve()
","
from itertools import permutations

def solve():
    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]
    target_order = sorted([i+1 for i in range(N*N)], key=lambda x: (x-1)//N + (x-1)%N)
    
    def dist(a, b):
        return abs((a-1)//N - (b-1)//N) + abs((a-1)%N - (b-1)%N)
    
    def count_steps_order(order):
        steps = 0
        replacements = 0
        for i in range(len(order)-1):
            steps += dist(order[i], order[i+1])
            if i < N*N-1:
                if (order[i+1] not in board[(order[i]-1)//N] and order[i+1] not in board[(order[i]-1)%N]):
                    replacements += 1
        return steps, replacements
    
    min_steps = float('inf')
    min_replacements = float('inf')
    
    for perm in permutations(target_order):
        steps, replacements = count_steps_order(perm)
        if steps < min_steps or (steps == min_steps and replacements < min_replacements):
            min_steps = steps
            min_replacements = replacements
            
    print(min_steps, min_replacements)

solve()","
import itertools

def solve():
    n = int(input())
    chessboard = [list(map(int, input().split())) for _ in range(n)]

    def distance(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    def can_move(piece, current_pos, next_pos):
        if piece == ""knight"":
            return (distance(current_pos, next_pos) == 3 and
                    (abs(current_pos[0] - next_pos[0]) != 0) and
                    (abs(current_pos[1] - next_pos[1]) != 0))
        elif piece == ""bishop"":
            return abs(current_pos[0] - next_pos[0]) == abs(current_pos[1] - next_pos[1])
        elif piece == ""rook"":
            return current_pos[0] == next_pos[0] or current_pos[1] == next_pos[1]

    pieces = [""knight"", ""bishop"", ""rook""]
    perms = itertools.permutations(pieces, 3)
    min_steps = float('inf')
    min_replacements = float('inf')

    for perm in perms:
        steps = 0
        replacements = 0
        current_piece = perm[0]
        current_position = None

        for i in range(1, n*n+1):
            next_position = None
            for r in range(n):
                for c in range(n):
                    if chessboard[r][c] == i:
                        next_position = (r+1, c+1)

            if current_position is not None:
                if not can_move(current_piece, current_position, next_position):
                    replacements += 1
                    if perm.index(current_piece) < 2:
                        current_piece = perm[perm.index(current_piece) + 1]

            steps += distance(current_position, next_position)
            current_position = next_position

        if steps < min_steps or (steps == min_steps and replacements < min_replacements):
            min_steps = steps
            min_replacements = replacements

    print(min_steps, min_replacements)

solve()
","
def solve():
    import itertools
    
    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]
    
    positions = {}
    for i in range(N):
        for j in range(N):
            positions[board[i][j]] = (i, j)
    
    moves = {
        'knight': lambda i, j, x, y: abs(i - x) == 2 and abs(j - y) == 1 or abs(i - x) == 1 and abs(j - y) == 2,
        'bishop': lambda i, j, x, y: abs(i - x) == abs(j - y),
        'rook': lambda i, j, x, y: i == x or j == y
    }
    
    best_steps = float('inf')
    best_replacements = float('inf')
    
    for perm in itertools.permutations(['knight', 'bishop', 'rook']):
        steps = 0
        replacements = 0
        current_piece = 'knight'
        current_pos = positions[1]
        
        for num in range(2, N*N+1):
            target_pos = positions[num]
            
            if moves[current_piece](*current_pos, *target_pos):
                steps += abs(current_pos[0] - target_pos[0]) + abs(current_pos[1] - target_pos[1])
            else:
                replacements += 1
                steps += abs(current_pos[0] - target_pos[0]) + abs(current_pos[1] - target_pos[1])
            
            current_piece = perm[replacements % 3]
            current_pos = target_pos
        
        if steps < best_steps or (steps == best_steps and replacements < best_replacements):
            best_steps = steps
            best_replacements = replacements
    
    print(best_steps, best_replacements)


solve()","
from collections import deque

def solve():
    N = int(input())
    board = [list(map(int, input().split())) for _ in range(N)]
    
    target_positions = {}
    for i in range(N):
        for j in range(N):
            target_positions[board[i][j]] = (i, j)
    
    directions = [(2, 1), (1, 2), (-2, 1), (1, -2), (2, -1), (-1, 2), (-2, -1), (-1, -2)]
    
    def min_steps(start_piece):
        queue = deque([(start_piece, 0, 0)])  # (piece, steps, replacements)
        visited = {(start_piece, 0)}
        
        while queue:
            piece, steps, replacements = queue.popleft()
            
            if steps == N*N:
                return steps, replacements
            
            current_position = target_positions[steps+1]
            for d in directions:
                new_position = (current_position[0] + d[0], current_position[1] + d[1])
                if 0 <= new_position[0] < N and 0 <= new_position[1] < N:
                    new_number = board[new_position[0]][new_position[1]]
                    new_piece = piece
                    if (new_number - 1) // N == steps // N:
                        if new_number == steps + 1:
                            pass
                        elif new_number == steps + 2:
                            new_piece = 'rook' if piece != 'rook' else piece
                        else:
                            new_piece = 'bishop' if piece != 'bishop' else piece
                    
                    if (new_piece, new_number) not in visited:
                        queue.append((new_piece, new_number, replacements + (new_piece != piece)))
                        visited.add((new_piece, new_number))
        
        return -1, -1
    
    steps_knight, replacements_knight = min_steps('knight')
    steps_bishop, replacements_bishop = min_steps('bishop')
    steps_rook, replacements_rook = min_steps('rook')
    
    best_steps = min(steps_knight, steps_bishop, steps_rook)
    
    if steps_knight == best_steps:
        return steps_knight, replacements_knight
    elif steps_bishop == best_steps:
        return steps_bishop, replacements_bishop
    else:
        return steps_rook, replacements_rook

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/106","
QUESTION:
Есть n-подъездный дом, в каждом подъезде по m этажей, и на каждом этаже каждого подъезда ровно k квартир. Таким образом, в доме всего n·m·k квартир. Они пронумерованы естественным образом от 1 до n·m·k, то есть первая квартира на первом этаже в первом подъезде имеет номер 1, первая квартира на втором этаже первого подъезда имеет номер k + 1 и так далее. Особенность этого дома состоит в том, что он круглый. То есть если обходить его по часовой стрелке, то после подъезда номер 1 следует подъезд номер 2, затем подъезд номер 3 и так далее до подъезда номер n. После подъезда номер n снова идёт подъезд номер 1.

Эдвард живёт в квартире номер a, а Наташа — в квартире номер b. Переход на 1 этаж вверх или вниз по лестнице занимает 5 секунд, переход от двери подъезда к двери соседнего подъезда — 15 секунд, а переход в пределах одного этажа одного подъезда происходит мгновенно. Также в каждом подъезде дома есть лифт. Он устроен следующим образом: он всегда приезжает ровно через 10 секунд после вызова, а чтобы переместить пассажира на один этаж вверх или вниз, лифт тратит ровно 1 секунду. Посадка и высадка происходят мгновенно.

Помогите Эдварду найти минимальное время, за которое он сможет добраться до квартиры Наташи. Считайте, что Эдвард может выйти из подъезда только с первого этажа соответствующего подъезда (это происходит мгновенно). Если Эдвард стоит перед дверью какого-то подъезда, он может зайти в него и сразу окажется на первом этаже этого подъезда (это также происходит мгновенно). Эдвард может выбирать, в каком направлении идти вокруг дома.


-----Входные данные-----

В первой строке входных данных следуют три числа n, m, k (1 ≤ n, m, k ≤ 1000) — количество подъездов в доме, количество этажей в каждом подъезде и количество квартир на каждом этаже каждого подъезда соответственно.

Во второй строке входных данных записаны два числа a и b (1 ≤ a, b ≤ n·m·k) — номера квартир, в которых живут Эдвард и Наташа, соответственно. Гарантируется, что эти номера различны. 


-----Выходные данные-----

Выведите единственное целое число — минимальное время (в секундах), за которое Эдвард сможет добраться от своей квартиры до квартиры Наташи.


-----Примеры-----
Входные данные
4 10 5
200 6

Выходные данные
39

Входные данные
3 1 5
7 2

Выходные данные
15



-----Примечание-----

В первом тестовом примере Эдвард находится в 4 подъезде на 10 этаже, а Наташа находится в 1 подъезде на 2 этаже. Поэтому Эдварду выгодно сначала спуститься на лифте на первый этаж (на это он потратит 19 секунд, из которых 10 — на ожидание и 9 — на поездку на лифте), затем обойти дом против часовой стрелки до подъезда номер 1 (на это он потратит 15 секунд), и наконец подняться по лестнице на этаж номер 2 (на это он потратит 5 секунд). Таким образом, ответ равен 19 + 15 + 5 = 39.

Во втором тестовом примере Эдвард живёт в подъезде 2 на этаже 1, а Наташа находится в подъезде 1 на этаже 1. Поэтому Эдварду выгодно просто обойти дом по часовой стрелке до подъезда 1, на это он потратит 15 секунд.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())
    
    a -= 1
    b -= 1
    
    a_floor = a // k // m
    a_entrance = a // k % m
    
    b_floor = b // k // m
    b_entrance = b // k % m
    
    time = abs(a_floor - b_floor) * 15  # Time to move between entrances
    
    time += min(abs(a_entrance - b_entrance), m - abs(a_entrance - b_entrance)) * 5  # Time to move between floors within the same entrance
    
    time += min(abs(a_entrance - b_entrance), m - abs(a_entrance - b_entrance)) * 10  # Time for the elevator to move between floors
    
    print(time)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    time_to_reach_first_floor = 10
    time_to_move_between_buildings = 15
    time_to_move_between_floors = 5
    time_per_floor_by_lift = 1

    a_building = (a - 1) // (m * k) + 1
    a_floor = ((a - 1) % (m * k)) // k + 1

    b_building = (b - 1) // (m * k) + 1
    b_floor = ((b - 1) % (m * k)) // k + 1

    time = min(abs(a_building - b_building) * time_to_move_between_buildings,
               n * time_to_move_between_buildings) # clockwise or counterclockwise

    if a_building != b_building:
        time += time_to_reach_first_floor + time_to_move_between_floors * abs(a_floor - 1) + time_per_floor_by_lift

    time += time_to_reach_first_floor + time_to_move_between_floors * abs(b_floor - 1) + time_per_floor_by_lift

    print(time)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())
    
    apartments_per_block = m * k
    time_to_reach_neighbor_block = 15
    time_per_floor = 5
    
    a_block = (a - 1) // apartments_per_block
    a_floor = ((a - 1) % apartments_per_block) // k
    
    b_block = (b - 1) // apartments_per_block
    b_floor = ((b - 1) % apartments_per_block) // k
    
    time_to_neighbors = abs(a_block - b_block) * time_to_reach_neighbor_block
    
    time_to_same_block = min((b_floor - a_floor) % m, (a_floor - b_floor) % m) * time_per_floor
    
    total_time = time_to_neighbors + time_to_same_block
    
    print(total_time)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    a -= 1
    b -= 1

    a_floor = a // k
    a_entrance = a_floor // m
    a_time = min(a % k, k - a % k) + abs(a_floor % m) * 5 + a_entrance * 15

    b_floor = b // k
    b_entrance = b_floor // m
    b_time = min(b % k, k - b % k) + abs(b_floor % m) * 5 + b_entrance * 15

    elevator_time = abs(a_entrance - b_entrance) * 10

    time1 = b_time + abs(b_entrance - a_entrance) * 15
    time2 = a_time + elevator_time + 5

    print(min(time1, time2))

solve()
","
python
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    total_apartments = n * m * k
    
    start_floor = (a - 1) // k + 1
    start_entrance = (start_floor - 1) // m + 1
    
    end_floor = (b - 1) // k + 1
    end_entrance = (end_floor - 1) // m + 1
    
    time = 0
    
    # Calculate time to reach Natasha's entrance
    time += 10  # Waiting for the elevator
    time += min((end_entrance - start_entrance) % n, (start_entrance - end_entrance) % n) * 15
    
    # Calculate time to reach Natasha's floor
    time += 10  # Waiting for the elevator
    time += abs((end_floor - start_floor) * (5 * m))  # Floors * time per floor change
    print(time)

solve()

","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    time_to_reach_nearest_floor = 10 * ((abs(a - b) + k - 1) // k)
    time_to_reach_same_building = 15 * ((abs((a-1) // (m*k) - (b-1) // (m*k)) + n - 1) % n)
    time_to_reach_destination_floor = 5 * ((abs((a-1) // k % m - (b-1) // k % m)))

    total_time = time_to_reach_nearest_floor + time_to_reach_same_building + time_to_reach_destination_floor

    return total_time

solve()","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    a -= 1  # adjust apartment numbers to 0-indexing
    b -= 1

    time_waiting_for_lift = 10
    time_per_floor_stairs = 5
    time_per_floor_lift = 1
    time_per_block = 15

    time_to_b = (b // (m * k)) * n * (time_per_block + time_waiting_for_lift) + ((b % (m * k)) // k) * m * time_per_floor_stairs + (b % k) * time_per_floor_lift

    time_to_a = (a // (m * k)) * n * (time_per_block + time_waiting_for_lift) + ((a % (m * k)) // k) * m * time_per_floor_stairs + (a % k) * time_per_floor_lift

    if time_to_b < time_to_a:
        time_around = min((n - (a // (m * k))) * (time_per_block + time_waiting_for_lift), (a // (m * k)) * (time_per_block + time_waiting_for_lift))
        time_total = time_to_b + time_around
    else:
        time_around = min((n - (b // (m * k))) * (time_per_block + time_waiting_for_lift), (b // (m * k)) * (time_per_block + time_waiting_for_lift))
        time_total = time_to_a + time_around

    return time_total

  
solve()","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())
    
    def get_time(a, b):
        def get_distance(x, y):
            return min(abs(x - y), n*m*k - abs(x - y))
        
        elevator_time = 10 + 1  # Time for elevator to move between adjacent floors
        stairs_time = 5  # Time for stairs movement
        
        elevator_a = (a - 1) // (m*k)  # Calculate which block Edward is in
        elevator_b = (b - 1) // (m*k)  # Calculate which block Natasha is in
        
        floor_a = ((a - 1) // k) % m + 1  # Calculate Edward's floor
        floor_b = ((b - 1) // k) % m + 1  # Calculate Natasha's floor
        
        time = abs(elevator_a - elevator_b) * 15  # Time to move between blocks
        
        # Calculate time for elevator from Edward to Natasha
        if elevator_a == elevator_b:
            time += elevator_time * get_distance(a, b)
        else:
            time += elevator_time * (get_distance(a, k) + get_distance(b, 1))
        
        # Calculate time for stairs from Natasha's floor to Edward's floor
        time += stairs_time * get_distance(floor_a, 1)  # Time to reach ground floor from Edward's floor
        time += stairs_time * get_distance(floor_b, 1)  # Time to reach ground floor from Natasha's floor
        
        return time
    
    print(get_time(a, b))

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())
    
    minutes_to_lift = 10  # Time to wait for the elevator
    time_per_floor = 5  # Time to move 1 floor up or down
    time_per_adjacent_entrance = 15  # Time to move to an adjacent entrance
    
    first_step = 9 + minutes_to_lift  # Time to go to the ground floor from a specific floor
    
    a -= 1
    b -= 1
    
    a_entrance = a // (m * k)  # Determine the entrance of apartment a
    a_floor = (a % (m * k)) // k  # Determine the floor of apartment a
    
    b_entrance = b // (m * k)  # Determine the entrance of apartment b
    b_floor = (b % (m * k)) // k  # Determine the floor of apartment b
    
    # Calculate the time for Edward to reach Natasha
    time = min(abs(a_entrance - b_entrance), n - abs(a_entrance - b_entrance)) * time_per_adjacent_entrance
    time += min(abs(a_floor - b_floor), m - abs(a_floor - b_floor)) * time_per_floor
    
    print(first_step + time)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())
    
    a -= 1
    b -= 1
    
    stairs_time = 5 * abs(a % (m*k) - b % (m*k))
    
    elevator_time = min((5 * (m*k - a % (m*k))) + (15 * (n - 1)), (5 * a % (m*k)) + (15 * (n - 1))) + abs(a // (m*k) - b // (m*k)) * 20
    
    result = min(stairs_time, elevator_time)
    
    print(result)

solve()
","
python
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())
    
    a -= 1
    b -= 1
    
    a_res = (a // (m * k), (a % (m * k)) // k, (a % (m * k)) % k)
    b_res = (b // (m * k), (b % (m * k)) // k, (b % (m * k)) % k)
    
    time = abs(a_res[0] - b_res[0]) * 15
    time += min(abs(a_res[1] - b_res[1]), m - abs(a_res[1] - b_res[1])) * 5
    time += abs(a_res[2] - b_res[2]) * 5
    
    print(time)


solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    a -= 1
    b -= 1

    time = min(abs(a % (m*k) - b % (m*k)), m*k - abs(a % (m*k) - b % (m*k)))

    time = min(time, abs(a // (m*k) - b // (m*k)) * 15 + min(a // (m*k), b // (m*k)) * 10)

    print(time + min(a % (m*k), m*k - a % (m*k)) + min(b % (m*k), m*k - b % (m*k)) + abs(a // (m*k) - b // (m*k)) * 5)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    time_to_reach_1st_floor = 10
    time_to_move_between_buildings = 15
    time_between_floors = 5

    a_building, a_floor, _ = divmod(a - 1, k*m)
    b_building, b_floor, _ = divmod(b - 1, k*m)

    time_with_lift = time_between_floors * abs(a_floor - b_floor)  # time with lift
    time_without_lift = (time_to_move_between_buildings + time_to_reach_1st_floor)  # time without lift

    time_to_reach_destination = min(time_with_lift, time_without_lift) + time_to_move_between_buildings + time_to_reach_1st_floor

    print(time_to_reach_destination)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    time = abs(((a-1)//(m*k)) - ((b-1)//(m*k))) * 20
    time += abs((a-1)//k%m - (b-1)//k%m) * 5

    print(time)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())
    
    time_to_get_to_first_floor = 10 + 9  # 10 seconds for elevator to arrive, 9 seconds to go down
    time_to_move_between_buildings = 15
    
    a_building = (a - 1) // (m * k) + 1
    a_floor = ((a - 1) % (m * k)) // k + 1
    b_building = (b - 1) // (m * k) + 1
    b_floor = ((b - 1) % (m * k)) // k + 1
    
    time = min(abs(a_building - b_building), n - abs(a_building - b_building)) * time_to_move_between_buildings
    time += abs(a_floor - 1) * 5  # time to go to the first floor from a
    
    if a_building != b_building:
        time += 10  # waiting time for the elevator
    
    time += abs(b_floor - 1) * 5  # time to go from the first floor to b
    
    print(time)

solve()
","
python
def solve():
    n, m, k = map(int, input().split())
    a, b = map(int, input().split())

    time_to_reach_floor = 5
    time_to_neighboring_entrance = 15
    time_to_move_between_floors = 5

    first_floor_to_door = time_to_reach_floor + (a - 1) // (m * k) * time_to_neighboring_entrance
    second_floor_to_door = time_to_reach_floor + (b - 1) // (m * k) * time_to_neighboring_entrance

    time_to_goto_neighbor_entrance = min(abs(a - b) % (n * m * k),
                                         (a - b) % (n * m * k),
                                         abs(a - b),
                                         n * m * k - abs(a - b),
                                         n * m * k - (a - b)) * time_to_move_between_floors

    return min(first_floor_to_door, second_floor_to_door) + time_to_goto_neighbor_entrance

solve()","6.666666666666667","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/107","
QUESTION:
Top-model Izabella participates in the competition. She wants to impress judges and show her mathematical skills.

Her problem is following: for given string, consisting of only 0 and 1, tell if it's possible to remove some digits in such a way, that remaining number is a representation of some positive integer, divisible by 64, in the binary numerical system.


-----Input-----

In the only line given a non-empty binary string s with length up to 100.


-----Output-----

Print «yes» (without quotes) if it's possible to remove digits required way and «no» otherwise.


-----Examples-----
Input
100010001

Output
yes
Input
100

Output
no


-----Note-----

In the first test case, you can get string 1 000 000 after removing two ones which is a representation of number 64 in the binary numerical system.

You can read more about binary numeral system representation here: https://en.wikipedia.org/wiki/Binary_system
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    count_ones = s.count('1')
    if count_ones >= 6 and '1' in s[-6:]:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    num_zeros = s.count('0')
    num_ones = s.count('1')
    
    if num_zeros >= 6 and num_ones >= 1:
        print(""yes"")
    elif num_zeros >= 1 and num_ones >= 1:
        print(""yes"")
    else:
        print(""no"")

solve()","
def solve():
    s = input().strip()
    n = len(s)

    if '1' not in s:
        print(""no"")
        return

    for i in range(n):
        if s[i] == '1':
            idx = i
            break

    count_ones = s.count('1', idx)

    if count_ones >= 6:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    ones_count = s.count('1')
    if ones_count >= 6 and s[-6] == '1':
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    ones_count = s.count('1')
    if ones_count >= 6:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    
    ones_count = s.count('1')
    
    if ones_count >= 6:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    ones_count = s.count('1')
    if ones_count >= 6:
        print(""yes"")
    else:
        print(""no"")

# Call the function to start solving
solve()
","
def solve():
    s = input().strip()
    
    ones_count = s.count('1')

    if ones_count >= 6 and s[-6:].count('1') >= 1:
        print(""yes"")
    else:
        print(""no"")

solve()","
def solve():
    s = input().strip()
    count_zeros = s.count('0')

    if count_zeros == 0:
        print(""no"")
    else:
        index = s.rfind('1')
        if count_zeros >= 6 and (len(s) - index - 1) >= 6:
            print(""yes"")
        else:
            print(""no"")

solve()
","
def solve():
    s = input()
    cnt_ones = s.count('1')
    cnt_zeros = s.count('0')
    if cnt_ones >= 6 and cnt_zeros >= 1:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()

    count_zeros = s.count('0')
    count_ones = s.count('1')

    if count_zeros >= 6 or s == '0':
        print(""yes"")
    elif count_zeros >= 5 and count_ones > 0:
        print(""yes"")
    elif count_zeros >= 4 and count_ones > 1:
        print(""yes"")
    elif count_zeros >= 3 and count_ones > 2:
        print(""yes"")
    elif count_zeros >= 2 and count_ones > 3:
        print(""yes"")
    elif count_zeros >= 1 and count_ones > 4:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    
    count_zeros = s.count('0')
    
    if count_zeros >= 6:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    ones_count = s.count('1')
    zeros_count = s.count('0')
    
    if ones_count < 6:
        print(""no"")
    else:
        index = s.rfind('1')
        if ones_count - index >= 6:
            print(""yes"")
        else:
            print(""no"")

solve()
","
def solve():
    s = input().strip()
    n = s.count('1')
    for i in range(n):
        if int(s.replace('1', '0', i)) % 64 == 0:
            return 'yes'
    return 'no'

solve()
","
def solve():
    s = input().strip()
    ones_count = s.count('1')
    if ones_count >= 6:
        print(""yes"")
    else:
        print(""no"")

solve()
","
def solve():
    s = input().strip()
    n = len(s)
    
    for i in range(n):
        if int(s[:i] + s[i+1:], 2) % 64 == 0:
            print(""yes"")
            return
    
    print(""no"")

solve()
","53.333333333333336","66.66666666666666","53.333333333333336","46.666666666666664","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","60.0","60.0","53.333333333333336","80.0","60.0","0.0","53.333333333333336","40.0","","","","","","","","","","","","","","","",""
"APPS/108","
QUESTION:
You are given a string s consisting of |s| small english letters.

In one move you can replace any character of this string to the next character in alphabetical order (a will be replaced with b, s will be replaced with t, etc.). You cannot replace letter z with any other letter.

Your target is to make some number of moves (not necessary minimal) to get string abcdefghijklmnopqrstuvwxyz (english alphabet) as a subsequence. Subsequence of the string is the string that is obtained by deleting characters at some positions. You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible.


-----Input-----

The only one line of the input consisting of the string s consisting of |s| (1 ≤ |s| ≤ 10^5) small english letters.


-----Output-----

If you can get a string that can be obtained from the given string and will contain english alphabet as a subsequence, print it. Otherwise print «-1» (without quotes).


-----Examples-----
Input
aacceeggiikkmmooqqssuuwwyy

Output
abcdefghijklmnopqrstuvwxyz

Input
thereisnoanswer

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    import string

    s = input().strip()
    alphabet = string.ascii_lowercase
    target = 'abcdefghijklmnopqrstuvwxyz'
    
    idx = 0
    result = ''
    
    for char in s:
        if char == target[idx]:
            result += char
            idx += 1
            if idx == 26:
                break
    
    if result == target:
        print(result)
    else:
        print(""-1"")

solve()","
def solve():
    s = input().strip()
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    ans = """"
    i, j = 0, 0
    while i < len(alphabet) and j < len(s):
        if s[j] == alphabet[i]:
            ans += s[j]
            i += 1
        j += 1
    if ans == alphabet:
        print(ans)
    else:
        print(""-1"")

solve()","
def solve():
    import string
    
    s = input().strip()
    
    alphabet = string.ascii_lowercase
    next_char = {char: alphabet[i+1] if i < 25 else None for i, char in enumerate(alphabet)}
    
    result = []
    idx = 0
    for char in s:
        if char == 'z':
            result.append('z')
        elif next_char[char] is not None and next_char[char] >= alphabet[idx]:
            result.append(next_char[char])
            idx = alphabet.index(next_char[char]) + 1
    
    if ''.join(result) == alphabet:
        print(''.join(result))
    else:
        print(""-1"")

solve()
","
def solve():
    from collections import defaultdict
    s = input()
    
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    target = defaultdict(int)
    for i, char in enumerate(alphabet):
        target[char] = i
    
    ans = ''
    prev_idx = -1
    for char in s:
        if target[char] > prev_idx:
            ans += char
            prev_idx = target[char]
            if ans == alphabet:
                print(ans)
                return
    print('-1')

solve()
","
def solve():
    import string

    s = input()
    alphabet = string.ascii_lowercase

    result = ''
    idx = 0
    for char in s:
        if char <= alphabet[idx]:
            result += alphabet[idx]
            idx += 1
            if idx == 26:
                break

    if len(result) == 26:
        print(result)
    else:
        print(""-1"")

solve()","
def solve():
    from string import ascii_lowercase
    
    s = input().strip()
    alphabet = list(ascii_lowercase)
    idx = 0
    result = []
    
    for c in s:
        if c >= alphabet[idx]:
            result.append(c)
            if c == alphabet[idx]:
                idx += 1
            if idx == 26:
                break
    
    if idx == 26:
        print(''.join(result))
    else:
        print('-1')

solve()","
def solve():
    import string
    
    s = input()
    alphabet = string.ascii_lowercase
    
    current_idx = 0
    result = ''
    
    for char in s:
        if char == alphabet[current_idx]:
            result += char
            current_idx += 1
        
        if current_idx == 26:
            break
    
    if current_idx == 26:
        print(result)
    else:
        print(-1)

solve()","
def solve():
    import string
    
    s = input().strip()
    alphabets = string.ascii_lowercase
    
    ans = []
    idx = 0
    for char in s:
        while idx < 26 and alphabets[idx] < char:
            idx += 1
        if idx >= 26:
            print(""-1"")
            return
        if alphabets[idx] == char:
            ans.append(char)
            idx += 1
    
    print("""".join(ans))

solve()
","
def solve():
    import string

    s = input().strip()
    alphabet = string.ascii_lowercase
    result = []
    idx = 0

    for char in s:
        if char < alphabet[idx]:
            continue
        if char == alphabet[idx]:
            result.append(char)
            idx += 1
        if idx == 26:
            break

    if len(result) == 26:
        print(''.join(result))
    else:
        print(""-1"")

solve()
","
def solve():
    import string
    
    s = input()
    alphabet = string.ascii_lowercase
    
    target = """"
    j = 0
    
    for i in range(len(s)):
        if s[i] == alphabet[j]:
            target += s[i]
            j += 1
            if j == len(alphabet):
                break
    
    if target == alphabet:
        print(target)
    else:
        print(""-1"")

solve()","
def solve():
    import string

    s = input()
    alphabet = list(string.ascii_lowercase)
    
    current_index = 0
    result = """"

    for char in s:
        if char >= alphabet[current_index]:
            result += char
            if char == alphabet[current_index]:
                current_index += 1
            if current_index == 26:
                break
    
    if current_index == 26:
        print(result)
    else:
        print(""-1"")

solve()","
def solve():
    import string

    s = input().strip()
    n = len(s)
    alphabet = string.ascii_lowercase

    res = [''] * 26
    pos = 0

    for i in range(n):
        if s[i] > alphabet[pos]:
            continue
        if s[i] == alphabet[pos]:
            res[pos] = s[i]
            pos += 1
            if pos == 26:
                break

    if pos == 26:
        print(''.join(res))
    else:
        print(-1)

solve()","
def solve():
    import string

    s = input().strip()
    alphabet = string.ascii_lowercase
    result = []
    idx = 0

    for char in s:
        if char == alphabet[idx]:
            result.append(char)
            idx += 1
        if idx == 26:
            break
    
    if idx == 26:
        print(''.join(result))
    else:
        print('-1')

solve()","
def solve():
    import string

    s = input().strip()
    alphabet = string.ascii_lowercase

    i = 0
    result = []
    
    for char in s:
        if char <= alphabet[i]:
            result.append(alphabet[i])
            i += 1
        if i == 26:
            break

    if i == 26:
        print("""".join(result))
    else:
        print(""-1"")

solve()
","
def solve():
    import string
    s = input().strip()
    alphabet = string.ascii_lowercase
    new_string = ''
    for char in s:
        if char <= 'z':
            new_string += char
            if char == 'z':
                break
    if len(new_string) < 26:
        print(-1)
    else:
        print(new_string)

solve()
","
def solve():
    import string

    s = input().strip()
    alphabet = string.ascii_lowercase

    idx = 0
    ans = """"

    for letter in s:
        if idx == 26:
            break
        if letter == alphabet[idx]:
            ans += letter
            idx += 1

    if idx == 26:
        print(ans)
    else:
        print(-1)

solve()","26.666666666666668","26.666666666666668","6.666666666666667","26.666666666666668","60.0","26.666666666666668","26.666666666666668","13.333333333333334","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","60.0","13.333333333333334","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/109","
QUESTION:
While Grisha was celebrating New Year with Ded Moroz, Misha gifted Sasha a small rectangular pond of size n × m, divided into cells of size 1 × 1, inhabited by tiny evil fishes (no more than one fish per cell, otherwise they'll strife!).

The gift bundle also includes a square scoop of size r × r, designed for fishing. If the lower-left corner of the scoop-net is located at cell (x, y), all fishes inside the square (x, y)...(x + r - 1, y + r - 1) get caught. Note that the scoop-net should lie completely inside the pond when used.

Unfortunately, Sasha is not that skilled in fishing and hence throws the scoop randomly. In order to not frustrate Sasha, Misha decided to release k fishes into the empty pond in such a way that the expected value of the number of caught fishes is as high as possible. Help Misha! In other words, put k fishes in the pond into distinct cells in such a way that when the scoop-net is placed into a random position among (n - r + 1)·(m - r + 1) possible positions, the average number of caught fishes is as high as possible.


-----Input-----

The only line contains four integers n, m, r, k (1 ≤ n, m ≤ 10^5, 1 ≤ r ≤ min(n, m), 1 ≤ k ≤ min(n·m, 10^5)).


-----Output-----

Print a single number — the maximum possible expected number of caught fishes.

You answer is considered correct, is its absolute or relative error does not exceed 10^{ - 9}. Namely, let your answer be a, and the jury's answer be b. Your answer is considered correct, if $\frac{|a - b|}{\operatorname{max}(1,|b|)} \leq 10^{-9}$.


-----Examples-----
Input
3 3 2 3

Output
2.0000000000

Input
12 17 9 40

Output
32.8333333333



-----Note-----

In the first example you can put the fishes in cells (2, 1), (2, 2), (2, 3). In this case, for any of four possible positions of the scoop-net (highlighted with light green), the number of fishes inside is equal to two, and so is the expected value. [Image]
Use user-input-Based format and function signature solve()","
def solve():
    import sys
    n, m, r, k = map(int, sys.stdin.readline().split())
    if r > n or r > m:
        r = min(n, m)
    if k == 1:
        print((n - r + 1) * (m - r + 1)
    elif r == 1:
        print(k)
    else:
        s = (r * r - 1) // 2
        if s + 1 >= k:
            print(k * 2)
        else:
            print(s * 4 + (k - s) * 3)

solve()","
import math

def solve():
    n, m, r, k = map(int, input().split())
    
    def f(x, y):
        cnt = max(0, min(x + r - 1, n) - max(x, 1) + 1) * max(0, min(y + r - 1, m) - max(y, 1) + 1)
        return cnt

    def check(mid):
        res = 0
        for i in range(1, n+1):
            res += f(i, 1)
        
        fish = [(f(i, 1), i) for i in range(1, n+1)]
        fish.sort(reverse=True)
        
        for i in range(1, m + 1):
            res -= fish[i-1][0]
            fish[i-1] = (f(fish[i-1][1], i+r-1), fish[i-1][1])
            if fish[i-1][0] > 0:
                j = i
                while j < m and fish[j][0] > fish[j-1][0]:
                    fish[j], fish[j-1] = fish[j-1], fish[j]
                    j += 1
                    
        return res

    left = 0
    right = 1e18

    for _ in range(200):
        mid = (left + right) / 2
        if check(mid) > k:
            right = mid
        else:
            left = mid

    print(""{:.10f}"".format(left))

solve()
","
from math import ceil

def solve():
    n, m, r, k = map(int, input().split())
    if r > n or r > m:
        r = min(n, m)
    
    total_cells = n * m
    fish_per_cell = k / total_cells
    
    grid_cells = min(r, n) * min(r, m)
    fish_captured = min(grid_cells, k)
    
    remaining_fish = k - fish_captured
    avg_fish_per_cell = fish_per_cell + (remaining_fish / total_cells)
    
    print('{:.10f}'.format(avg_fish_per_cell))
  
solve()","
python
from itertools import combinations

def solve():
    n, m, r, k = map(int, input().split())
    ans = 0
    bestCells = None
    for cells in combinations([(i, j) for i in range(1, n + 1) for j in range(1, m + 1)], k):
        cnt = sum(1 <= i <= n - r + 1 and 1 <= j <= m - r + 1 for i in range(1, n + 1) for j in range(1, m + 1)
                  if any(i <= x <= i + r - 1 and j <= y <= j + r - 1 for x, y in cells))
        if cnt > ans:
            ans = cnt
            bestCells = cells
    print('%.10f' % (ans / ((n - r + 1) * (m - r + 1))))

solve()

","
def solve():
    import sys
    n, m, r, k = map(int, sys.stdin.readline().split())
    if r > n or r > m:
        r = min(n, m)
    if k <= (n - r + 1) * (m - r + 1):
        print(r * r + (k - 1) / ((n - r + 1) * (m - r + 1)))
    else:
        print(n * m)

solve()","
def solve():
    import sys
    input = sys.stdin.readline

    n, m, r, k = map(int, input().split())

    def calc(x, y):
        x_min, x_max = max(1, x - r + 1), min(n - r + 1, x) + 1
        y_min, y_max = max(1, y - r + 1), min(m - r + 1, y) + 1
        return (x_max - x_min) * (y_max - y_min)

    def check(mid):
        tot = 0
        for i in range(1, n+1):
            tot += calc(i, r)
        if tot >= k:
            return True
        return False

    ans = 0
    l, r = 0, 1e12
    while r - l > 1e-10:
        mid = (l + r) / 2
        if check(mid):
            ans = mid
            l = mid
        else:
            r = mid

    print(ans)

solve()
","
from math import ceil

def solve():
    n, m, r, k = map(int, input().split())
    
    def fish_count(x, y, r):
        return (min(x + r - 1, n) - max(x, 1) + 1) * (min(y + r - 1, m) - max(y, 1) + 1)
    
    def valid(x, y):
        return x >= 1 and x <= n and y >= 1 and y <= m
    
    def check(mid):
        cnt = 0
        for i in range(1, min(r, n) + 1):
            for j in range(1, min(r, m) + 1):
                if valid(i, j):
                    cnt += fish_count(i, j, r)
        return cnt >= k
    
    lo = 0
    hi = k
    while hi - lo > 1e-10:
        mid = (lo + hi) / 2
        if check(mid):
            lo = mid
        else:
            hi = mid
    
    return ""{:.10f}"".format(lo)

solve()
","
def solve():
    import math

    n, m, r, k = map(int, input().split())

    if r == 1:
        print(k)
    else:
        total_squares = (n - r + 1) * (m - r + 1)
        max_fishes = min(r, k)

        if k <= total_squares:
            print(max_fishes)
        else:
            remaining_fishes = k - total_squares
            per_square_fishes = max_fishes + remaining_fishes // total_squares
            remaining_individual_fishes = remaining_fishes % total_squares

            expected_fishes = per_square_fishes
            if remaining_individual_fishes > 0:
                expected_fishes += remaining_individual_fishes / total_squares

            print(""{:.10f}"".format(expected_fishes))
  
solve()","
from math import ceil

def solve():
    n, m, r, k = map(int, input().split())
    if r > n or r > m:
        r = min(n, m)

    total_squares = (n - r + 1) * (m - r + 1)
    if k * r * r >= total_squares:
        print(""{:.10f}"".format(total_squares))
    else:
        k_per_square = ceil(k / total_squares)
        filled_squares = min(total_squares, k)
        remaining_fish = k - filled_squares
        expected_fish = filled_squares + remaining_fish / 2
        print(""{:.10f}"".format(expected_fish))

solve()
","
from math import ceil

def solve():
    n, m, r, k = map(int, input().split())
    if r > n or r > m:
        r = min(n, m)
    count = (n - r + 1) * (m - r + 1)
    if r == 1:
        print(""{:.10f}"".format(k / count))
    else:
        half_r = ceil(r / 2)
        if r % 2 == 1:
            k = min(k, half_r ** 2)
        else:
            k = min(k, half_r ** 2 + half_r)
        total_fish = k + (count - k) * (4 * half_r - 4) / (r ** 2)
        print(""{:.10f}"".format(total_fish))

solve()","
def solve():
    import sys
    input = sys.stdin.readline

    n, m, r, k = map(int, input().split())

    def get_cells():
        odd_r = r % 2 == 1
        half_r = r // 2

        cnt, subcnt = 0, 0
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                even_i = i % 2 == 0

                if odd_r and even_i or not odd_r and not even_i:
                    if j % 2 == 1:
                        cnt += 1
                        if subcnt + 1 <= k:
                            subcnt += 1
                            yield i, j

                if subcnt == k:
                    return

    cells = list(get_cells())

    res = 0
    if len(cells) == k:
        for x, y in cells:
            res += 4 * (x - 1) * (m - r + 1) + 4 * (y - 1) + 2

    print(""{:0.10f}"".format(res))

solve()
","
def solve():
    n, m, r, k = map(int, input().split())
    
    def count_fishes(x, y):
        x_min = max(1, x - r + 1)
        x_max = min(n - r + 2, x + 1)
        y_min = max(1, y - r + 1)
        y_max = min(m - r + 2, y + 1)
        return (x_max - x_min) * (y_max - y_min)
    
    def calc_position_val(x, y):
        return count_fishes(x, y) * (n - r + 1) * (m - r + 1) - count_fishes(x, y) ** 2
    
    possible_positions = [(x, y) for x in range(1, n + 1) for y in range(1, m + 1)]
    possible_positions.sort(key=lambda pos: -calc_position_val(*pos))
    
    sum_fishes = 0
    fishes_placed = set()
    for x, y in possible_positions[:k]:
        sum_fishes += count_fishes(x, y)
        fishes_placed.add((x, y))
    
    print(""{:.10f}"".format(sum_fishes / ((n - r + 1) * (m - r + 1)))

solve()
","
from math import ceil

def solve():
    n, m, r, k = map(int, input().split())
    if r > min(n, m):
        print(0.0)
        return

    def f(x, y):
        return (x + 1) * (m - r + 1) + (y + 1) * (n - r + 1) - (x + 1) * (y + 1)

    def g(x):
        return 2 * ceil(r / 2) - 1 + max(0, r - 2 * (ceil(r / 2) - 1) - 1)

    l, r = 2, n * m
    while l < r:
        x = (l + r) // 2
        y = min(k, f(ceil(x / m) - 1, ceil(x / n) - 1) * g(x))
        if y < k:
            l = x + 1
        else:
            r = x

    x = r
    y = min(k, f(ceil(x / m) - 1, ceil(x / n) - 1) * g(x))
    print(""{:.10f}"".format(y / 2))
  
solve()","
from math import ceil

def solve():
    n, m, r, k = map(int, input().split())
    
    # Helper function to calculate the number of fishes caught in a single scoop position
    def count_fishes(x, y):
        return max(0, min(x + r, n) - max(x, 1)) * max(0, min(y + r, m) - max(y, 1))
    
    # Initialize a list to store all possible counts of fishes
    counts = []
    
    # Iterate through all possible positions to place fishes and calculate the number of caught fishes
    for i in range(1, n+1):
        for j in range(1, m+1):
            counts.append(count_fishes(i, j))
    
    # Sort the counts in descending order
    counts.sort(reverse=True)
    
    # Calculate the prefix sums of counts
    prefix_sums = [0]
    for c in counts:
        prefix_sums.append(prefix_sums[-1] + c)
    
    # Helper function to calculate the expected number of caught fishes given x fishes are placed
    def expected_fishes(x):
        total_executions = (n - r + 1) * (m - r + 1)
        extra_fishes = 0
        
        if x < total_executions:
            extra_fishes = prefix_sums[x] - x * k
        
        return x * k + extra_fishes / total_executions
    
    # Perform binary search to find the optimal number of fishes to place
    left, right = 0, len(counts)
    while right - left > 1:
        mid = (left + right) // 2
        if expected_fishes(mid) < expected_fishes(mid + 1):
            left = mid
        else:
            right = mid
            
    optimal_fishes = min(left + 1, k)
    optimal_expected_fishes = expected_fishes(optimal_fishes)
    
    print(""{:.10f}"".format(optimal_expected_fishes))

solve()
","
from math import ceil

def solve():
    n, m, r, k = map(int, input().split())
    if r > n or r > m:
        r = min(n, m)
    x = (n - r + 1) * (m - r + 1)
    if k * r * r >= x:
        print(""{:.10f}"".format(1.0 * x))
    else:
        mid = (k + 1) // 2
        total = 1.0 * (r - 1) * r * 2 * mid
        rem = k - mid
        choices = (r - 2) * (r - 1) * 2 + (n - r) * r * 2 + (m - r) * r * 2
        if rem > 0:
            total += 1.0 * choices * rem
        print(""{:.10f}"".format(total / x))

solve()
","
from itertools import combinations

def solve():
    n, m, r, k = map(int, input().split())
    if k * r * r >= n * m: # If we can place all k fishes without overlap
        print(""{:.10f}"".format(n * m)) # Maximum possible expected number of caught fishes
        return

    ans = 0
    for x, y in combinations(range(1, n + 1), 2):
        for a, b in combinations(range(1, m + 1), 2):
            fishes = max(0, min(x + r - 1, n) - x + 1) * max(0, min(y + r - 1, m) - y + 1)
            fishes += max(0, min(a + r - 1, n) - a + 1) * max(0, min(b + r - 1, m) - b + 1)
            fishes -= max(0, min(x, a, x + r - 1, a + r - 1) - max(x, a) + 1) * max(0, min(y, b, y + r - 1, b + r - 1) - max(y, b) + 1)
            ans = max(ans, fishes) # Update the maximum possible number of caught fishes

    expected = ans + max(0, k - 2) * (r * r - 4) # Remaining fishes can be added with worst-case expectation
    print(""{:.10f}"".format((expected * 4 + n * m) / ((n - r + 1) * (m - r + 1))))
  
solve()","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","6.666666666666667","33.33333333333333","0.0","0.0","0.0","8.333333333333332","6.666666666666667","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/110","
QUESTION:
Nick had received an awesome array of integers $a=[a_1, a_2, \dots, a_n]$ as a gift for his $5$ birthday from his mother. He was already going to explore its various properties but after unpacking he was disappointed a lot because the product $a_1 \cdot a_2 \cdot \dots a_n$ of its elements seemed to him not large enough.

He was ready to throw out the array, but his mother reassured him. She told him, that array would not be spoiled after the following operation: choose any index $i$ ($1 \le i \le n$) and do $a_i := -a_i - 1$.

For example, he can change array $[3, -1, -4, 1]$ to an array $[-4, -1, 3, 1]$ after applying this operation to elements with indices $i=1$ and $i=3$. 

Kolya had immediately understood that sometimes it's possible to increase the product of integers of the array a lot. Now he has decided that he wants to get an array with the maximal possible product of integers using only this operation with its elements (possibly zero, one or more times, as many as he wants), it is not forbidden to do this operation several times for the same index. 

Help Kolya and print the array with the maximal possible product of elements $a_1 \cdot a_2 \cdot \dots a_n$ which can be received using only this operation in some order.

If there are multiple answers, print any of them.


-----Input-----

The first line contains integer $n$ ($1 \leq n \leq 10^{5}$) — number of integers in the array.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($-10^{6} \leq a_i \leq 10^{6}$) — elements of the array


-----Output-----

Print $n$ numbers — elements of the array with the maximal possible product of elements which can be received using only this operation in some order from the given array.

If there are multiple answers, print any of them.


-----Examples-----
Input
4
2 2 2 2

Output
-3 -3 -3 -3 
Input
1
0

Output
0 
Input
3
-3 -3 2

Output
-3 -3 2
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    negatives = 0
    zeros = 0
    for i in range(n):
        if a[i] < 0:
            negatives += 1
            a[i] = -a[i] - 1
        elif a[i] == 0:
            zeros += 1
    
    if zeros == 0 and negatives % 2 == 1:
        min_val = min(a, key=lambda x: abs(x))
        for i in range(n):
            if a[i] == min_val:
                a[i] = -a[i] - 1
    
    print(*a)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    neg_count = sum(1 for i in a if i < 0)
    if neg_count % 2 == 0:
        for i in range(n):
            if a[i] < 0:
                a[i] = -a[i] - 1

    print(*a)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    negatives = sum(1 for x in a if x < 0)
    
    if negatives % 2 == 0:
        for i in range(n):
            if a[i] < 0:
                a[i] *= -1
    else:
        min_abs = min(abs(x) for x in a)
        for i in range(n):
            if abs(a[i]) == min_abs:
                a[i] *= -1
                break
    
    print(*a)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    neg_count = 0
    zero_count = 0
    for i in range(n):
        if a[i] < 0:
            neg_count += 1
        elif a[i] == 0:
            zero_count += 1

    if zero_count > 0:
        for i in range(n):
            if a[i] != 0:
                a[i] = 0
    elif neg_count % 2 == 1:
        min_neg = min(x for x in a if x < 0)
        for i in range(n):
            if a[i] == min_neg:
                a[i] = -a[i] - 1

    print(*a)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    neg_count = 0
    zero_count = 0
    min_abs_val = float('inf')
    
    for i in range(n):
        if a[i] < 0:
            neg_count += 1
        elif a[i] == 0:
            zero_count += 1
        min_abs_val = min(min_abs_val, abs(a[i]))
    
    if zero_count > 0 or neg_count % 2 == 0:
        for i in range(n):
            if a[i] < 0:
                a[i] = -a[i] - 1
    else:
        for i in range(n):
            if abs(a[i]) == min_abs_val:
                a[i] = -a[i] - 1
    
    print(*a)

# Run the function
solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n == 1 and a[0] == 0:
        print(0)
        return

    neg_count = sum(1 for num in a if num < 0)

    if neg_count % 2 == 0:
        for i in range(n):
            if a[i] < 0:
                a[i] = -a[i] - 1
        print(*a)
    else:
        neg = float('inf')
        for i in range(n):
            if abs(a[i]) < abs(neg):
                neg = a[i]
        for i in range(n):
            if a[i] == neg:
                a[i] = -a[i] - 1
        print(*a)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    negatives = 0
    zeros = 0
    total_product = 1

    for i in range(n):
        if a[i] < 0:
            negatives += 1
            total_product *= -a[i] - 1
        elif a[i] == 0:
            zeros += 1
        else:
            total_product *= a[i]

    if negatives % 2 == 1 and zeros == 0:
        min_negative = float('inf')
        for i in range(n):
            if abs(a[i]) < abs(min_negative):
                min_negative = a[i]
        for i in range(n):
            if a[i] == min_negative:
                a[i] = -a[i] - 1
                break

    for i in range(n):
        if a[i] < 0:
            a[i] = -a[i] - 1

    print(*a)

solve()
","
def solve():
    import sys
    n = int(input())
    a = list(map(int, input().split()))

    neg_count = 0
    zero_count = 0
    min_abs_value = float('inf')
    total_product = 1

    for i in range(n):
        if a[i] < 0:
            neg_count += 1
            total_product *= -a[i] - 1
            if abs(-a[i] - 1) < abs(min_abs_value):
                min_abs_value = -a[i] - 1
        elif a[i] == 0:
            zero_count += 1
        else:
            total_product *= a[i]

    ans = [total_product if neg_count % 2 == 0 or zero_count > 0 else total_product // min_abs_value]

    for i in range(1, n):
        if a[i] == 0:
            ans.append(0)
        elif a[i] < 0 and (neg_count % 2 == 0 or zero_count > 0):
            ans.append(-a[i] - 1)
        else:
            ans.append(a[i])

    return ans

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    negative_count = 0
    zero_count = 0
    for i in range(n):
        if a[i] < 0:
            a[i] = -a[i] - 1
            negative_count += 1
        elif a[i] == 0:
            zero_count += 1
    
    if zero_count == 0 and negative_count % 2 == 1:
        max_negative = float('-inf')
        max_negative_index = -1
        for i in range(n):
            if a[i] < 0 and a[i] > max_negative:
                max_negative = a[i]
                max_negative_index = i
        a[max_negative_index] = -a[max_negative_index] - 1

    print(*a)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    negatives = [i for i in arr if i < 0]
    if len(negatives) % 2 == 0:
        for i in range(n):
            if arr[i] == 0:
                return ' '.join(map(str, arr))
            arr[i] = abs(arr[i])
    else:
        for i in range(n):
            arr[i] = abs(abs(arr[i]) - 1)
    
    return ' '.join(map(str, arr))

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    neg_cnt = 0
    zero_cnt = 0
    for i in range(n):
        if a[i] < 0:
            neg_cnt += 1
        elif a[i] == 0:
            zero_cnt += 1

    if zero_cnt > 0:
        for i in range(n):
            if a[i] < 0:
                a[i] = 0
    elif neg_cnt % 2 == 1:
        min_neg = float('inf')
        for i in range(n):
            a[i] = abs(a[i])
            if abs(a[i]) < min_neg:
                min_neg = abs(a[i])
                neg_index = i
        a[neg_index] *= -1

    print(*a)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    neg_count = 0
    zero_count = 0

    for i in range(n):
        if arr[i] < 0:
            neg_count += 1
            arr[i] = -arr[i] - 1
        elif arr[i] == 0:
            zero_count += 1

    if zero_count == 0 and neg_count % 2 == 1:
        min_val = min(arr)
        for i in range(n):
            if arr[i] == min_val:
                arr[i] = -arr[i] - 1

    print(*arr)

solve()
","
def solve():
    import sys

    n = int(sys.stdin.readline())
    a = list(map(int, sys.stdin.readline().split()))

    pos_count = sum(1 for x in a if x >= 0)
    neg_count = len(a) - pos_count

    if neg_count % 2 == 0:
        for i in range(len(a)):
            if a[i] < 0:
                a[i] *= -1
    else:
        min_neg = min(abs(x) for x in a if x < 0)
        for i in range(len(a)):
            if a[i] == -min_neg:
                a[i] *= -1
                break
    
    print(*a)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    neg_count = sum(1 for num in a if num < 0)
    
    if neg_count % 2 == 0 or neg_count == 0:
        result = [-1 * abs(num) - 1 for num in a]
    else:
        min_abs = min(abs(num) for num in a)
        result = [-1 * abs(num) - 1 if abs(num) != min_abs or neg_count == 1 else abs(num) for num in a]
    
    print(*result)

import sys

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    neg_count = 0
    zero_count = 0
    for i in range(n):
        if a[i] < 0:
            neg_count += 1
        elif a[i] == 0:
            zero_count += 1

    if neg_count % 2 == 0:
        for i in range(n):
            if a[i] < 0:
                a[i] *= -1
    else:
        if zero_count > 0:
            for i in range(n):
                if a[i] < 0:
                    a[i] *= -1
        else:
            min_neg = float('inf')
            idx = -1
            for i in range(n):
                if abs(a[i]) < min_neg:
                    min_neg = abs(a[i])
                    idx = i
            a[idx] *= -1

    print(*a)

import sys
solve()
  ","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    count_neg = 0
    min_abs_val = float('inf')

    for i in range(n):
        if arr[i] < 0:
            count_neg += 1
            arr[i] *= -1

        min_abs_val = min(min_abs_val, arr[i])

    if count_neg % 2 == 0:
        for i in range(n):
            arr[i] = -arr[i]

    else:
        for i in range(n):
            if arr[i] == min_abs_val:
                arr[i] = -arr[i]

    print(*arr)

# Example usage
solve()
","6.666666666666667","6.666666666666667","6.666666666666667","33.33333333333333","13.333333333333334","13.333333333333334","13.333333333333334","0.0","6.666666666666667","0.0","20.0","6.666666666666667","6.666666666666667","20.0","6.666666666666667","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/111","
QUESTION:
You are given two integers n and k. Find k-th smallest divisor of n, or report that it doesn't exist.

Divisor of n is any such natural number, that n can be divided by it without remainder.


-----Input-----

The first line contains two integers n and k (1 ≤ n ≤ 10^15, 1 ≤ k ≤ 10^9).


-----Output-----

If n has less than k divisors, output -1.

Otherwise, output the k-th smallest divisor of n.


-----Examples-----
Input
4 2

Output
2

Input
5 3

Output
-1

Input
12 5

Output
6



-----Note-----

In the first example, number 4 has three divisors: 1, 2 and 4. The second one is 2.

In the second example, number 5 has only two divisors: 1 and 5. The third divisor doesn't exist, so the answer is -1.
Use user-input-Based format and function signature solve()","
import math

def solve():
    n, k = map(int, input().split())
    
    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if n // i != i:
                divisors.append(n // i)
    
    divisors.sort()
    
    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()
","
from math import sqrt

def solve():
    n, k = map(int, input().split())
    
    divisors = []
    for i in range(1, int(sqrt(n))+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    
    divisors.sort()
    
    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k-1])

solve()
","
def solve():
    import math
    
    n, k = map(int, input().split())
    
    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if n // i != i:
                divisors.append(n // i)
    
    if len(divisors) < k:
        print(-1)
    else:
        divisors.sort()
        print(divisors[k-1])

solve()
","
def solve():
    n, k = map(int, input().split())
    
    factors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            factors.append(i)
            if n//i != i:
                factors.append(n//i)
    
    factors.sort()
    
    if len(factors) < k:
        print(-1)
    else:
        print(factors[k-1])
    
if __name__ == ""__main__"":
    solve()
","
import math

def solve():
    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if n // i != i:
                divisors.append(n // i)

    divisors.sort()

    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k-1])

solve()","
import math

def solve():
    n, k = map(int, input().split())
    
    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
                
    divisors.sort()
    
    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k-1])

solve()
","
from math import sqrt

def solve():
    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)

    divisors.sort()

    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()
","
import math

def solve():
    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if n/i != i:
                divisors.append(n//i)

    divisors.sort()

    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k-1])

solve()","
def solve():
    import math

    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if n // i != i:
                divisors.append(n // i)

    divisors.sort()

    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()","
import math

def solve():
    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)

    divisors.sort()

    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k-1])

solve()","
def solve():
    import math
    
    n, k = map(int, input().split())
    
    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if n // i != i:
                divisors.append(n // i)
    
    divisors.sort()
    
    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()
","
def solve():
    import math

    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if n // i != i:
                divisors.append(n // i)

    divisors.sort()
    
    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()","
import math

def solve():
    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)

    divisors.sort()

    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()
","
def solve():
    n, k = map(int, input().split())
    divisors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    
    divisors.sort()
    
    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k-1])

solve()
","
def solve():
    n, k = map(int, input().split())
    
    divisors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    
    divisors.sort()
    
    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()
","
import math

def solve():
    n, k = map(int, input().split())

    divisors = []
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)

    divisors.sort()

    if len(divisors) < k:
        print(-1)
    else:
        print(divisors[k - 1])

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/112","
QUESTION:
Absent-minded Masha got set of n cubes for her birthday.

At each of 6 faces of each cube, there is exactly one digit from 0 to 9. Masha became interested what is the largest natural x such she can make using her new cubes all integers from 1 to x.

To make a number Masha can rotate her cubes and put them in a row. After that, she looks at upper faces of cubes from left to right and reads the number.

The number can't contain leading zeros. It's not required to use all cubes to build a number.

Pay attention: Masha can't make digit 6 from digit 9 and vice-versa using cube rotations.


-----Input-----

In first line integer n is given (1 ≤ n ≤ 3) — the number of cubes, Masha got for her birthday.

Each of next n lines contains 6 integers a_{i}_{j} (0 ≤ a_{i}_{j} ≤ 9) — number on j-th face of i-th cube.


-----Output-----

Print single integer — maximum number x such Masha can make any integers from 1 to x using her cubes or 0 if Masha can't make even 1.


-----Examples-----
Input
3
0 1 2 3 4 5
6 7 8 9 0 1
2 3 4 5 6 7

Output
87
Input
3
0 1 3 5 6 8
1 2 4 5 7 8
2 3 4 6 7 9

Output
98


-----Note-----

In the first test case, Masha can build all numbers from 1 to 87, but she can't make 88 because there are no two cubes with digit 8.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]
    
    digits = set()
    for cube in cubes:
        for digit in cube:
            digits.add(digit)
    
    for i in range(1, 100):
        num_str = str(i)
        valid = True
        for digit in num_str:
            if int(digit) not in digits:
                valid = False
                break
        if valid:
            x = i
        else:
            break
    
    print(x)

solve()
","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]
    valid_pairs = [(0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (2, 3), (2, 5), (3, 4), (4, 5)]
    
    digits = set()
    for cube in cubes:
        for i in range(6):
            for j in range(i + 1, 6):
                if (cube[i], cube[j]) in valid_pairs or (cube[j], cube[i]) in valid_pairs:
                    digits.add(cube[i])
                    digits.add(cube[j])
    
    highest_num = 0
    i = 1
    while True:
        num_str = str(i)
        valid = True
        for digit in num_str:
            if int(digit) not in digits:
                valid = False
                break
        if valid:
            highest_num = i
        else:
            break
        i += 1

    print(highest_num)

# Example usage
solve()
","
def solve():
    import itertools

    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    numbers = set()
    for perm in itertools.permutations(cubes, n):
        for i in range(1, len(perm) + 1):
            for subset in itertools.combinations(perm, i):
                num = int(''.join(str(cube[(j + 5) % 6]) for j, cube in enumerate(subset)))
                numbers.add(num)

    for x in range(max(numbers), 0, -1):
        if x not in numbers:
            return x

    return 0

solve()","
def solve():
    import itertools

    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    all_possible_numbers = set()
    for i in range(1, n+1):
        for comb in itertools.permutations(cubes, i):
            for perm in itertools.product(*comb):
                number = int(''.join(map(str, perm)))
                all_possible_numbers.add(number)

    x = 0
    while x+1 in all_possible_numbers:
        x += 1

    print(x)

solve()
","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    valid_digits = set(str(i) for i in range(10))
    valid_pairs = {
        ('6', '9'),
        ('9', '6'),
        ('0', '0'),
        ('1', '1'),
        ('8', '8'),
    }

    cube_strs = [''.join(map(str, cube)) for cube in cubes]

    numbers_available = set()
    for i in range(1, 10):
        for j in range(10):
            for k in range(10):
                num_str = str(i) + str(j) + str(k)
                if all(d in valid_digits for d in num_str):
                    valid = True
                    for a, b in valid_pairs:
                        if a in num_str and b in num_str:
                            if all(cube_str.count(a) < num_str.count(a) or cube_str.count(b) < num_str.count(b) for cube_str in cube_strs):
                                valid = False
                                break
                    if valid:
                        numbers_available.add(int(num_str))
    
    max_num = max(numbers_available) if numbers_available else 0
    print(max_num)

solve()
","
def solve():
    from itertools import permutations

    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    digits = set()
    for cube in cubes:
        for digit in cube:
            if digit != 6 and digit != 9:
                digits.add(str(digit))
            else:
                digits.add('6')
                digits.add('9')

    valid_numbers = set()
    for i in range(1, 10):
        for perm in permutations(digits, i):
            num = int(''.join(perm))
            valid_numbers.add(num)

    x = 0
    for i in range(1, max(valid_numbers) + 1):
        if i not in valid_numbers:
            x = i - 1
            break

    print(x)


solve()","
def solve():
    import itertools

    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    digits = set()
    for i in range(n):
        digits.update(cubes[i])

    max_num = 0
    for perm in itertools.permutations(digits):
        num = int(''.join(map(str, perm)))
        if all(str(i) in str(num) for i in range(1, num + 1)):
            max_num = max(max_num, num)

    print(max_num)

solve()
","
def solve():
    # Input
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    # Possible numbers that can be made with given cubes
    valid_numbers = set()
    for cube in cubes:
        for i in range(6):
            valid_numbers.add(cube[i] * 10 + cube[(i+1)%6])
            valid_numbers.add(cube[i] * 10 + cube[(i-1)%6])

    # Find the maximum number that can be made
    x = 1
    while x in valid_numbers:
        x += 1

    # Output
    print(x-1)

solve()
","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    allowed_pairs = {
        (0, 0), (1, 1), (2, 2), (5, 5),
        (6, 9), (9, 6),
        (3, 4), (4, 3),
        (7, 8), (8, 7),
    }

    digits = set()
    for cube in cubes:
        for num in cube:
            digits.add(num)

    max_x = 0
    for x in range(1, 100):
        x_str = str(x).zfill(2)  # Ensure two digits
        valid = True
        for i in range(1, len(x_str)):
            if (int(x_str[i - 1]), int(x_str[i])) not in allowed_pairs:
                valid = False
                break
        if valid and all(int(d) in digits for d in x_str):
            max_x = x

    print(max_x)

# Example usage:
# solve()
","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]
    
    can_make = set()
    
    for i in range(n):
        for j in range(6):
            if cubes[i][j] == 0: continue
            can_make.add(cubes[i][j])
            for k in range(j+1, 6):
                num = 10 * cubes[i][j] + cubes[i][k]
                can_make.add(num)
    
    for i in range(n):
        for j in range(6):
            if cubes[i][j] == 6 or cubes[i][j] == 9:
                can_make.discard(6 if cubes[i][j] == 9 else 9)
    
    x = 1
    while x in can_make:
        x += 1
    
    return x - 1 if x > 1 else 0
  
solve()","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]
    
    digits = set()
    for cube in cubes:
        for i in range(6):
            digits.add(cube[i])

    for i in range(1, 100):
        if i < 10:
            if i not in digits:
                return i - 1
        else:
            valid = True
            for digit in str(i):
                if int(digit) not in digits:
                    valid = False
                    break
            if not valid:
                return i - 1
    return 0

solve()","
def solve():
    from itertools import permutations
    
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]
    
    def can_build_number(num, cubes):
        for p in permutations(cubes):
            number = """".join(str(p[i][j]) for i in range(len(cubes)) for j in range(6))
            if int(number) == num:
                return True
        return False
    
    max_num = 0
    for x in range(1, 100):
        if can_build_number(x, cubes):
            max_num = x
        else:
            break
    
    return max_num
  
solve()","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]

    numbers = set()
    for cube in cubes:
        numbers.update(set(cube))

    max_num = 0
    for i in range(1, 100):
        possible = True
        for digit in str(i):
            if int(digit) not in numbers:
                possible = False
                break
        if possible:
            max_num = i
        else:
            break
    
    print(max_num)

solve()
","
from itertools import permutations

def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]
    
    valid_numbers = set()
    for i in range(1, n + 1):
        for perm in permutations(cubes, i):
            for rotated_perm in permutations(perm):
                num_str = ''.join(str(cube[rotated_perm[j]]) for j, cube in enumerate(rotated_perm))
                num = int(num_str)
                if '6' in num_str and '9' not in num_str or '9' in num_str and '6' not in num_str:
                    num = max(num_str.count('6'), num_str.count('9')) * 9 + max(num - max(num_str.count('6'), num_str.count('9')) * 9 - 1, 0)
                
                valid_numbers.add(num)
    
    for x in range(1, max(valid_numbers) + 1):
        if x not in valid_numbers:
            return x - 1
    return max(valid_numbers)

  
solve()","
from itertools import permutations

def solve():
    n = int(input())

    cubes = []
    for _ in range(n):
        cubes.append(list(map(int, input().split())))

    digits = set()
    for cube in cubes:
        for digit in set(cube):
            digits.add(digit)

    possible_numbers = set()
    for i in range(1, 10):
        for j in range(i, 10):
            if i != j and ((i != 6 and j != 9) or (i != 9 and j != 6)):
                possible_numbers.add(int(str(i) + str(j)))
    
    max_num = 0
    for x in range(1, 100):
        x_str = str(x)
        check = True
        for digit in x_str:
            if int(digit) not in digits:
                check = False
                break
        if check and x in possible_numbers:
            max_num = max(max_num, x)
    
    print(max_num)

# Uncomment the below lines for testing
# solve()
","
def solve():
    n = int(input())
    cubes = [list(map(int, input().split())) for _ in range(n)]
    
    digits_mapping = {
        0: '0',
        1: '1',
        2: '2',
        3: '3',
        4: '4',
        5: '5',
        6: '6',
        7: '7',
        8: '8',
        9: '9'
    }
    
    def rotate_cube(cube):
        rotated = [cube[1], cube[2], cube[3], cube[0], cube[4], cube[5]]
        return rotated
    
    def get_max_possible_number(cubes):
        all_numbers = set()
        for i in range(n):
            for _ in range(4):
                current_number = ''
                for cube in cubes:
                    for digit in cube:
                        current_number += digits_mapping[digit]
                all_numbers.add(int(current_number))
                cubes[i] = rotate_cube(cubes[i])
        max_possible = max(all_numbers)
        return max_possible
    
    max_possible_number = get_max_possible_number(cubes)
    print(max_possible_number)

solve()
  ","66.66666666666666","60.0","0.0","100.0","0.0","80.0","23.076923076923077","20.0","0.0","0.0","0.0","0.0","86.66666666666667","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/113","
QUESTION:
For a given positive integer n denote its k-rounding as the minimum positive integer x, such that x ends with k or more zeros in base 10 and is divisible by n.

For example, 4-rounding of 375 is 375·80 = 30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the k-rounding of n.


-----Input-----

The only line contains two integers n and k (1 ≤ n ≤ 10^9, 0 ≤ k ≤ 8).


-----Output-----

Print the k-rounding of n.


-----Examples-----
Input
375 4

Output
30000

Input
10000 1

Output
10000

Input
38101 0

Output
38101

Input
123456789 8

Output
12345678900000000
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    x = n
    while x % 10**k != 0:
        x += n
    print(x)

solve()
","
def solve():
    n, k = map(int, input().split())
    multiplier = 10 ** k
    for i in range(1, multiplier + 1):
        if (n * i) % multiplier == 0:
            print(n * i)
            break

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    power = 10 ** k
    x = power
    while x % n != 0:
        x += power
    print(x)

solve()
","
def solve():
    n, k = map(int, input().split())
    x = n
    while x % 10**k != 0:
        x += n
    print(x)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    if k == 0:
        print(n)
    else:
        multiplier = 10**k
        for i in range(1, 10):
            if (n*i) % multiplier == 0:
                print(n * i)
                break

solve()
","
def solve():
    n, k = map(int, input().split())
    x = n
    while x % 10 != 0 and x % n != 0:
        x += n
    while str(x)[-k:] != '0'*(k%10):
        x += n
    return x

solve()
","
def solve():
    n, k = map(int, input().split())
    x = n
    i = 0
    while x % 10 != 0 and i < k:
        x *= 10
        i += 1
    print(x)

solve()
","
def solve():
    n, k = map(int, input().split())
    x = n
    while x % 10**k != 0:
        x += n
    print(x)

solve()
","
def solve():
    n, k = map(int, input().split())

    if k == 0:
        print(n)
    else:
        x = n
        while x % 10 != 0 and x % 10 != k:
            x += n
        print(x)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    factor = 10 ** k
    x = factor
    while x % n != 0:
        x += factor
    
    print(x)

solve()
","
def solve():
    n, k = map(int, input().split())
    print(str(n) + '0'*k)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    def lcm(a, b):
        return a * b // gcd(a, b)
    
    x = 10**k
    result = n * x // gcd(n, x)
    
    print(result)

solve()
","
def solve():
    n, k = map(int, input().split())
    x = 10**k
    for i in range(1, 10):
        if (n * i) % x == 0:
            print(n * i)
            return
    print(n)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    gcd_n_10 = gcd(n, 10)
    x = 10**k // gcd_n_10
    print(n * x)

solve()","
def solve():
    n, k = map(int, input().split())
    ans = n
    for i in range(1, k+1):
        if ans % 10 == 0:
            ans //= 10
        else:
            ans *= (10 - (ans % 10))
    print(ans)

solve()
","
def solve():
    n, k = map(int, input().split())
    x = n
    while x % 10 != k and x % 10 != 0:
        x += n
    print(x)

if __name__ == ""__main__"":
    solve()
","100.0","100.0","100.0","100.0","73.33333333333333","0.0","66.66666666666666","100.0","66.66666666666666","100.0","66.66666666666666","100.0","73.33333333333333","60.0","46.666666666666664","40.0","","","","","","","","","","","","","","","",""
"APPS/114","
QUESTION:
You are given two matrices $A$ and $B$. Each matrix contains exactly $n$ rows and $m$ columns. Each element of $A$ is either $0$ or $1$; each element of $B$ is initially $0$.

You may perform some operations with matrix $B$. During each operation, you choose any submatrix of $B$ having size $2 \times 2$, and replace every element in the chosen submatrix with $1$. In other words, you choose two integers $x$ and $y$ such that $1 \le x < n$ and $1 \le y < m$, and then set $B_{x, y}$, $B_{x, y + 1}$, $B_{x + 1, y}$ and $B_{x + 1, y + 1}$ to $1$.

Your goal is to make matrix $B$ equal to matrix $A$. Two matrices $A$ and $B$ are equal if and only if every element of matrix $A$ is equal to the corresponding element of matrix $B$.

Is it possible to make these matrices equal? If it is, you have to come up with a sequence of operations that makes $B$ equal to $A$. Note that you don't have to minimize the number of operations.


-----Input-----

The first line contains two integers $n$ and $m$ ($2 \le n, m \le 50$).

Then $n$ lines follow, each containing $m$ integers. The $j$-th integer in the $i$-th line is $A_{i, j}$. Each integer is either $0$ or $1$.


-----Output-----

If it is impossible to make $B$ equal to $A$, print one integer $-1$.

Otherwise, print any sequence of operations that transforms $B$ into $A$ in the following format: the first line should contain one integer $k$ — the number of operations, and then $k$ lines should follow, each line containing two integers $x$ and $y$ for the corresponding operation (set $B_{x, y}$, $B_{x, y + 1}$, $B_{x + 1, y}$ and $B_{x + 1, y + 1}$ to $1$). The condition $0 \le k \le 2500$ should hold.


-----Examples-----
Input
3 3
1 1 1
1 1 1
0 1 1

Output
3
1 1
1 2
2 2

Input
3 3
1 0 1
1 0 1
0 0 0

Output
-1

Input
3 2
0 0
0 0
0 0

Output
0



-----Note-----

The sequence of operations in the first example: $\begin{matrix} 0 & 0 & 0 & & 1 & 1 & 0 & & 1 & 1 & 1 & & 1 & 1 & 1 \\ 0 & 0 & 0 & \rightarrow & 1 & 1 & 0 & \rightarrow & 1 & 1 & 1 & \rightarrow & 1 & 1 & 1 \\ 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 0 & 0 & & 0 & 1 & 1 \end{matrix}$
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    B = [[0] * m for _ in range(n)]
    operations = []

    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                B[i][j] = 1
                B[i][j+1] = 1
                B[i+1][j] = 1
                B[i+1][j+1] = 1

    if A == B:
        print(len(operations))
        for op in operations:
            print(op[0], op[1])
    else:
        print(-1)

solve()
","
from typing import List

def solve(n: int, m: int, A: List[List[int]]) -> List[List[int]]:
    B = [[0] * m for _ in range(n)]

    operations = []
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append([i+1, j+1])
                B[i][j] = 1
                B[i][j+1] = B[i][j+1] ^ 1
                B[i+1][j] = B[i+1][j] ^ 1
                B[i+1][j+1] = B[i+1][j+1] ^ 1

    if A == B:
        return [[len(operations)]] + operations
    else:
        return [[-1]]

solve()","
def solve(n, m, matrix):
    operations = []
    for i in range(n - 1):
        for j in range(m - 1):
            if matrix[i][j] == 1:
                operations.append((i+1, j+1))
                matrix[i][j] = 0
                matrix[i][j+1] = 1 - matrix[i][j+1]
                matrix[i+1][j] = 1 - matrix[i+1][j]
                matrix[i+1][j+1] = 1 - matrix[i+1][j+1]
    if any(1 in row for row in matrix):
        return -1
    return len(operations), operations

solve()","
def solve(n, m, A):
    operations = []
    for i in range(n - 1):
        for j in range(m - 1):
            if A[i][j] == 1:
               operations.append((i+1, j+1))
               A[i][j] = 1 - A[i][j]
               A[i][j+1] = 1 - A[i][j+1]
               A[i+1][j] = 1 - A[i+1][j]
               A[i+1][j+1] = 1 - A[i+1][j+1]
    for row in A:
        if 1 in row:
            return -1
    return len(operations), '\n'.join([f""{x} {y}"" for x, y in operations])

# Example usage
n, m = 3, 3
A = [[1, 0, 1],
     [1, 0, 1],
     [0, 0, 0]]

print(solve(n, m, A))

solve()","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    B = [[0] * m for _ in range(n)]
    operations = []

    for i in range(n - 1):
        for j in range(m - 1):
            if A[i][j] == 1:
                operations.append((i + 1, j + 1))
                for x in range(i, i + 2):
                    for y in range(j, j + 2):
                        B[x][y] = 1

    if A == B:
        print(len(operations))
        for x, y in operations:
            print(x, y)
    else:
        print(-1)

# Input reading
solve()
","
def solve():
    n, m = map(int, input().split())
    mat_a = [list(map(int, input().split())) for _ in range(n)]
    mat_b = [[0 for _ in range(m)] for _ in range(n)]

    operations = []
    for i in range(n-1):
        for j in range(m-1):
            if mat_b[i][j] != mat_a[i][j]:
                operations.append((i+1, j+1))
                mat_b[i][j] = 1
                mat_b[i][j+1] = 1
                mat_b[i+1][j] = 1
                mat_b[i+1][j+1] = 1

    if mat_a == mat_b:
        print(len(operations))
        for op in operations:
            print(op[0], op[1])
    else:
        print(-1)
  
solve()","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    operations = []
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                A[i][j] = 0
                for k in range(2):
                    for l in range(2):
                        A[i+k][j+l] ^= 1
    
    for row in A:
        if 1 in row:
            print(-1)
            return
    
    print(len(operations))
    for operation in operations:
        print(operation[0], operation[1])

solve()","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    operations = []
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                A[i][j] = 0
                for x in range(2):
                    for y in range(2):
                        A[i+x][j+y] ^= 1
                
    for row in A:
        if 1 in row:
            print(-1)
            return
    
    print(len(operations))
    for op in operations:
        print(op[0], op[1])

solve()
","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    operations = []
    
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                for x in range(2):
                    for y in range(2):
                        A[i+x][j+y] ^= 1
    
    if any(sum(row) != 0 for row in A):
        print(-1)
    else:
        print(len(operations))
        for operation in operations:
            print(*operation)

solve()
  ","
from typing import List

def solve(n: int, m: int, A: List[List[int]]) -> List[List[int]]:
    B = [[0] * m for _ in range(n)]
    operations = []
    
    def apply_operation(x, y):
        for i in range(x, x + 2):
            for j in range(y, y + 2):
                B[i][j] = 1
                
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j]:
                apply_operation(i, j)
                operations.append([i+1, j+1])
    
    if A != B:
        return [[-1]]
    
    return [[len(operations)]] + operations

solve()","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    operations = []
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                A[i][j] = 1
                A[i][j+1] ^= 1
                A[i+1][j] ^= 1
                A[i+1][j+1] ^= 1
    
    for i in range(n):
        for j in range(m):
            if A[i][j] == 1:
                print(-1)
                return
    
    print(len(operations))
    for op in operations:
        print(op[0], op[1])

solve()
","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    B = [[0] * m for _ in range(n)]
    
    operations = []
    
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                B[i][j] = 1
                B[i][j+1] = 1
                B[i+1][j] = 1
                B[i+1][j+1] = 1
    
    if A == B:
        print(len(operations))
        for op in operations:
            print(op[0], op[1])
    else:
        print(-1)

solve()
","
def solve():
    # Input
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    # Operations to transform B into A
    operations = []
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                for x in range(i, i+2):
                    for y in range(j, j+2):
                        A[x][y] = 1
                        
    for i in range(n):
        for j in range(m):
            if A[i][j] == 1:
                print(-1)
                return
    
    # Output
    print(len(operations))
    for op in operations:
        print(op[0], op[1])

# Run the function
solve()
","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    operations = []
    
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                A[i][j] ^= 1
                A[i][j+1] ^= 1
                A[i+1][j] ^= 1
                A[i+1][j+1] ^= 1
    
    if any(any(row) for row in A):
        print(-1)
    else:
        print(len(operations))
        for op in operations:
            print(op[0], op[1])

solve()
  ","
from typing import List

def solve(n: int, m: int, A: List[List[int]]) -> List[List[int]]:
    operations = []
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append([i+1, j+1])
                A[i][j] = 0
                A[i][j+1] = 1 - A[i][j+1]
                A[i+1][j] = 1 - A[i+1][j]
                A[i+1][j+1] = 1 - A[i+1][j+1]
    
    if any(1 in row for row in A):
        return [[-1]]
    else:
        return [[len(operations)]] + operations

solve()","
def solve():
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    
    operations = []
    
    for i in range(n-1):
        for j in range(m-1):
            if A[i][j] == 1:
                operations.append((i+1, j+1))
                A[i][j] ^= 1
                A[i][j+1] ^= 1
                A[i+1][j] ^= 1
                A[i+1][j+1] ^= 1
    
    for row in A:
        if sum(row) != 0:
            print(-1)
            return
    
    print(len(operations))
    for op in operations:
        print(op[0], op[1])

solve()","80.0","0.0","0.0","0.0","80.0","80.0","73.33333333333333","73.33333333333333","73.33333333333333","0.0","73.33333333333333","80.0","73.33333333333333","73.33333333333333","0.0","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/115","
QUESTION:
The Bad Luck Island is inhabited by three kinds of species: r rocks, s scissors and p papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors, scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time.


-----Input-----

The single line contains three integers r, s and p (1 ≤ r, s, p ≤ 100) — the original number of individuals in the species of rock, scissors and paper, respectively.


-----Output-----

Print three space-separated real numbers: the probabilities, at which the rocks, the scissors and the paper will be the only surviving species, respectively. The answer will be considered correct if the relative or absolute error of each number doesn't exceed 10^{ - 9}.


-----Examples-----
Input
2 2 2

Output
0.333333333333 0.333333333333 0.333333333333

Input
2 1 2

Output
0.150000000000 0.300000000000 0.550000000000

Input
1 1 3

Output
0.057142857143 0.657142857143 0.285714285714
Use user-input-Based format and function signature solve()","
from math import comb

def solve():
    r, s, p = map(int, input().split())
    
    def dp(x, y, z):
        if x == 0:
            return 0
        if y == 0:
            return 1
        if z == 0:
            return 0
        total = x * y + y * z + z * x
        res = 0
        if x > 1:
            res += x * y / total * dp(x - 1, y, z)
        if y > 1:
            res += y * z / total * dp(x, y - 1, z)
        if z > 1:
            res += z * x / total * dp(x, y, z - 1)
        return res
    
    total = comb(r + s + p, 2)
    res_r = dp(r, s, p) * r / total
    res_s = dp(s, p, r) * s / total
    res_p = dp(p, r, s) * p / total
    
    print(""{:.12f} {:.12f} {:.12f}"".format(res_r, res_s, res_p))

solve()
","
def solve():
    r, s, p = map(int, input().split())
    dp = [[[0.0] * 101 for _ in range(101)] for _ in range(101)]
    dp[r][s][p] = 1.0
    
    for a in range(r, -1, -1):
        for b in range(s, -1, -1):
            for c in range(p, -1, -1):
                total_pairs = a*b + b*c + a*c
                
                if total_pairs == 0:
                    continue
                
                if a > 0:
                    dp[a-1][b][c] += dp[a][b][c] * (a * c) / total_pairs
                if b > 0:
                    dp[a][b-1][c] += dp[a][b][c] * (b * a) / total_pairs
                if c > 0:
                    dp[a][b][c-1] += dp[a][b][c] * (c * b) / total_pairs
    
    ans_r = ans_s = ans_p = 0.0
    
    for a in range(1, 101):
        ans_r += dp[a][0][0]
    for b in range(1, 101):
        ans_s += dp[0][b][0]
    for c in range(1, 101):
        ans_p += dp[0][0][c]
    
    print(ans_r, ans_s, ans_p)

solve()
","
def solve():
    r, s, p = map(int, input().split())
    dp = [[[0 for k in range(p+1)] for j in range(s+1)] for i in range(r+1)]
    
    dp[r][s][p] = 1.0
    
    for i in range(r, -1, -1):
        for j in range(s, -1, -1):
            for k in range(p, -1, -1):
                total = i*j + i*k + j*k
                
                if total == 0:
                    continue
                
                if i > 0:
                    dp[i-1][j][k] += dp[i][j][k] * (i*k / total)
                if j > 0:
                    dp[i][j-1][k] += dp[i][j][k] * (i*j / total)
                if k > 0:
                    dp[i][j][k-1] += dp[i][j][k] * (j*k / total)
    
    print(dp[0][0][p], dp[0][s][0], dp[r][0][0])

solve()
","
from math import factorial

def solve():
    r, s, p = map(int, input().split())
    
    def calc_prob(a, b, n):
        dp = [[[0.0 for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]
        dp[a][b][n-a-b] = 1.0
        
        for i in range(n, -1, -1):
            for j in range(n, -1, -1):
                for k in range(n, -1, -1):
                    if i+j+k == 0:
                        continue
                    cur = dp[i][j][k]
                    if i > 0 and j > 0:
                        dp[i-1][j][k] += cur*i*j/(i*j + i*k + j*k)
                    if j > 0 and k > 0:
                        dp[i][j-1][k] += cur*j*k/(i*j + i*k + j*k)
                    if i > 0 and k > 0:
                        dp[i][j][k-1] += cur*i*k/(i*j + i*k + j*k)
        
        return sum(dp[a][b])
    
    total = r + s + p
    prob_r = calc_prob(r, s, total)
    prob_s = calc_prob(s, p, total)
    prob_p = calc_prob(p, r, total)
    
    print(""{:.12f} {:.12f} {:.12f}"".format(prob_r, prob_s, prob_p))

solve()","
from math import comb

def solve():
    r, s, p = map(int, input().split())
    
    total_combinations = comb(r+s+p, 2)
    
    prob_r = 0.0
    prob_s = 0.0
    prob_p = 0.0
    
    for a, b, c in [(r, s, p), (s, p, r), (p, r, s)]:
        prob_a = a * c / (total_combinations - (b * (b - 1) // 2))
        prob_b = b * a / (total_combinations - (c * (c - 1) // 2))
        prob_c = 1 - prob_a - prob_b
        
        prob_r += prob_a
        prob_s += prob_b
        prob_p += prob_c
    
    print(f""{prob_r:.12f} {prob_s:.12f} {prob_p:.12f}"")

solve()
","
from fractions import Fraction

def solve():
    r, s, p = map(int, input().split())
    dp = [[[Fraction(0) for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]
    
    for i in range(r+1):
        for j in range(s+1):
            for k in range(p+1):
                if i == 0 and j == 0 or i == 0 and k == 0 or j == 0 and k == 0:
                    dp[i][j][k] = Fraction(1)
                else:
                    total = i*j + i*k + j*k
                    dp[i][j][k] = Fraction(i*j, total) * dp[i][j-1][k] + Fraction(i*k, total) * dp[i-1][j][k] + Fraction(j*k, total) * dp[i][j][k-1]
    
    print(dp[r][s][p-1], dp[r][s-1][p], dp[r-1][s][p])
  
solve()","
def solve():
    pass

solve()","
def solve():
    r, s, p = map(int, input().split())
    dp = [[[0.0] * 101 for _ in range(101)] for _ in range(101)]
    dp[r][s][p] = 1.0
    
    for x in range(r, 101):
        for y in range(s, 101):
            for z in range(p, 101):
                total = x*y + y*z + z*x
                if total == 0:
                    continue
                if x > 0:
                    dp[x][y][z] += dp[x-1][y][z] * x*z / total
                if y > 0:
                    dp[x][y][z] += dp[x][y-1][z] * x*y / total
                if z > 0:
                    dp[x][y][z] += dp[x][y][z-1] * y*z / total

    result_r = result_s = result_p = 0.0
    for x in range(r+1, 101):
        result_r += dp[x][s][p]
    for y in range(s+1, 101):
        result_s += dp[r][y][p]
    for z in range(p+1, 101):
        result_p += dp[r][s][z]
    
    print(f'{result_r:.12f} {result_s:.12f} {result_p:.12f}')

# Required import
import sys

solve()","
def solve():
    r, s, p = map(int, input().split())
    
    def dp(r, s, p):
        if r == 0 and s == 0:
            return 1, 0, 0
        if s == 0 and p == 0:
            return 0, 0, 1
        if p == 0 and r == 0:
            return 0, 1, 0
        prob_r, prob_s, prob_p = r * p, s * r, s * p
        tot = prob_r + prob_s + prob_p
        prob_r /= tot
        prob_s /= tot
        prob_p /= tot
        new_r, new_s, new_p = 0, 0, 0
        if r >= 1 and s >= 1:
            new_r, new_s, _ = dp(r, s - 1, p)
            new_r *= r
            new_s *= s
        if s >= 1 and p >= 1:
            new_s, new_p, _ = dp(r, s, p - 1)
            new_s *= s
            new_p *= p
        if r >= 1 and p >= 1:
            new_r, _, new_p = dp(r - 1, s, p)
            new_r *= r
            new_p *= p
        new_r += prob_r
        new_s += prob_s
        new_p += prob_p
        return new_r, new_s, new_p

    prob_r, prob_s, prob_p = dp(r, s, p)
    
    print(""{:.12f} {:.12f} {:.12f}"".format(prob_r, prob_s, prob_p))

if __name__ == ""__main__"":
    solve()
","
def solve():
    r, s, p = map(int, input().split())
    dp = [[[0.0 for _ in range(p + 1)] for _ in range(s + 1)] for _ in range(r + 1)]
    dp[r][s][p] = 1.0

    for i in range(r, -1, -1):
        for j in range(s, -1, -1):
            for k in range(p, -1, -1):
                total = i*j + j*k + k*i
                if total == 0:
                    continue
                if i > 0:
                    dp[i-1][j][k] += dp[i][j][k] * i*k / total
                if j > 0:
                    dp[i][j-1][k] += dp[i][j][k] * i*j / total
                if k > 0:
                    dp[i][j][k-1] += dp[i][j][k] * j*k / total

    print(f""{dp[0][r][0]:.12f} {dp[r][0][0]:.12f} {dp[0][0][r]:.12f}"")


solve()
","
from math import comb

def solve():
    r, s, p = map(int, input().split())

    def win_probability(a, b, c):
        total_ways = comb(a + b + c, 2)
        ab = a * b
        bc = b * c
        ca = c * a
        return ((ab + ca) / total_ways, (bc + ab) / total_ways, (ca + bc) / total_ways)

    result = win_probability(r, s, p)

    print('{:.12f} {:.12f} {:.12f}'.format(*result))

solve()
","
from itertools import permutations

def solve():
    r, s, p = map(int, input().split())
    
    total_combinations = (r+s+p) * (r+s+p-1) / 2
    wins = {('r', 's'): (r * s), ('s', 'p'): (s * p), ('p', 'r'): (p * r)}
    
    probabilities = []
    for species in ['r', 's', 'p']:
        wins_single_species = sum([wins[comb] for comb in permutations(['r', 's', 'p'], 2) if comb[0] == species])
        probability = wins_single_species / total_combinations
        probabilities.append(probability)
    
    print(*['{:.12f}'.format(prob) for prob in probabilities])

solve()","
def solve():
    r, s, p = map(int, input().split())

    dp = [[[0.0 for _ in range(p + 1)] for _ in range(s + 1)] for _ in range(r + 1)]
    dp[r][s][p] = 1.0

    for i in range(r, -1, -1):
        for j in range(s, -1, -1):
            for k in range(p, -1, -1):
                total = i * j + i * k + j * k

                if total == 0:
                    continue
                
                if i > 0:
                    dp[i - 1][j][k] += dp[i][j][k] * i * k / total
                if j > 0:
                    dp[i][j - 1][k] += dp[i][j][k] * i * j / total
                if k > 0:
                    dp[i][j][k - 1] += dp[i][j][k] * j * k / total
                
    rocks_prob = sum(sum(row) for row in dp) / sum(sum(sum(subrow) for subrow in row) for row in dp)
    scissors_prob = sum(sum(dp[i][j][0] for j in range(s + 1) for i in range(r + 1)) for k in range(p + 1))
    papers_prob = sum(dp[0][0])

    print('%.12f %.12f %.12f' % (rocks_prob, scissors_prob, papers_prob))
  
solve()","
def solve():
    r, s, p = map(int, input().split())
    
    dp = [[[0.0] * 101 for _ in range(101)] for _ in range(101)]

    dp[r][s][p] = 1.0

    for t in range(r+s+p, 0, -1):
        for i in range(r+1):
            for j in range(s+1):
                k = t - i - j
                if k < 0 or k > p:
                    continue

                cur = dp[i][j][k]

                if i > 0 and j > 0:
                    dp[i][j][k] += cur * i * j / (i * j + j * k + k * i)

                if j > 0 and k > 0:
                    dp[i][j][k] += cur * j * k / (i * j + j * k + k * i)

                if k > 0 and i > 0:
                    dp[i][j][k] += cur * k * i / (i * j + j * k + k * i)
    
    result = [0.0, 0.0, 0.0]

    for i in range(r+1):
        for j in range(s+1):
            k = r + s + p - i - j
            if k < 0 or k > p:
                continue
            if i != 0 and j == 0 and k == 0:
                result[0] += dp[i][j][k]
            if j != 0 and k == 0 and i == 0:
                result[1] += dp[i][j][k]
            if k != 0 and i == 0 and j == 0:
                result[2] += dp[i][j][k]

    print(f""{result[0]:.12f} {result[1]:.12f} {result[2]:.12f}"")

solve()
","
def solve():
    pass

solve()","
def solve():
    r, s, p = map(int, input().split())
    
    dp = [[[0.0] * 101 for _ in range(101)] for _ in range(101)]
    
    dp[r][s][p] = 1.0
    
    for i in range(r, -1, -1):
        for j in range(s, -1, -1):
            for k in range(p, -1, -1):
                total = i * j + j * k + k * i
                
                if total == 0:
                    continue
                
                if i >= 1:
                    dp[i - 1][j][k] += dp[i][j][k] * (i * k) / total
                if j >= 1:
                    dp[i][j - 1][k] += dp[i][j][k] * (j * i) / total
                if k >= 1:
                    dp[i][j][k - 1] += dp[i][j][k] * (k * j) / total

    res_r = res_s = res_p = 0.0

    for i in range(r):
        res_r += dp[i][0][0]
        
    for j in range(s):
        res_s += dp[0][j][0]
        
    for k in range(p):
        res_p += dp[0][0][k]

    print(f""{res_r:.12f} {res_s:.12f} {res_p:.12f}"")

solve()
","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/116","
QUESTION:
Today an outstanding event is going to happen in the forest — hedgehog Filya will come to his old fried Sonya!

Sonya is an owl and she sleeps during the day and stay awake from minute l_1 to minute r_1 inclusive. Also, during the minute k she prinks and is unavailable for Filya.

Filya works a lot and he plans to visit Sonya from minute l_2 to minute r_2 inclusive.

Calculate the number of minutes they will be able to spend together.


-----Input-----

The only line of the input contains integers l_1, r_1, l_2, r_2 and k (1 ≤ l_1, r_1, l_2, r_2, k ≤ 10^18, l_1 ≤ r_1, l_2 ≤ r_2), providing the segments of time for Sonya and Filya and the moment of time when Sonya prinks.


-----Output-----

Print one integer — the number of minutes Sonya and Filya will be able to spend together.


-----Examples-----
Input
1 10 9 20 1

Output
2

Input
1 100 50 200 75

Output
50



-----Note-----

In the first sample, they will be together during minutes 9 and 10.

In the second sample, they will be together from minute 50 to minute 74 and from minute 76 to minute 100.
Use user-input-Based format and function signature solve()","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    start = max(l1, l2)
    end = min(r1, r2)
    overlap = max(0, end - start + 1)
    if k >= start and k <= end:
        overlap -= 1
    print(overlap)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    
    overlap_start = max(l1, l2)
    overlap_end = min(r1, r2)
    
    total_minutes = max(0, overlap_end - overlap_start + 1)
    
    if k >= overlap_start and k <= overlap_end:
        total_minutes -= 1
    
    print(total_minutes)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    left_overlap = max(l1, l2)
    right_overlap = min(r1, r2)
    
    time_together = max(0, right_overlap - left_overlap + 1)
    
    if k >= left_overlap and k <= right_overlap:
        time_together -= 1
    
    print(time_together)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    intersect_left = max(l1, l2)
    intersect_right = min(r1, r2)
    result = intersect_right - intersect_left + (1 if intersect_left <= k <= intersect_right else 0)
    print(result)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    
    start = max(l1, l2)
    end = min(r1, r2)
    
    overlap = max(0, end - start + 1)
    
    if k >= start and k <= end:
        overlap -= 1
    
    print(overlap)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    start = max(l1, l2)
    end = min(r1, r2)
    total_time_together = end - start + 1 if end >= start else 0
    if k >= start and k <= end:
        total_time_together -= 1
    print(total_time_together)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    
    # Calculate the intersection of time intervals for Sonya and Filya
    start = max(l1, l2)
    end = min(r1, r2)
    
    # Check if Sonya is prinking during the intersection time
    if start <= k <= end:
        return end - start - 1
    else:
        return end - start + 1

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    if l2 > r1 or l1 > r2:
        print(0)
    else:
        start = max(l1, l2)
        end = min(r1, r2)
        total_time = end - start + 1
        if l1 <= k <= r1:
            total_time -= 1
        print(total_time)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    start = max(l1, l2)
    end = min(r1, r2)
    overlap = max(0, end - start + 1)
    if k >= start and k <= end:
        overlap -= 1
    print(overlap)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    
    start = max(l1, l2)
    end = min(r1, r2)
    
    result = end - start + 1 if end >= start else 0
    if k >= start and k <= end:
        result -= 1
        
    print(result)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    start = max(l1, l2)
    end = min(r1, r2)
    overlap = max(0, end - start + 1)
    if k >= start and k <= end:
        overlap -= 1
    print(overlap)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    
    shared_start = max(l1, l2)
    shared_end = min(r1, r2)
    
    if shared_start > shared_end:
        print(0)
    else:
        if k >= shared_start and k <= shared_end:
            print(shared_end - shared_start)
        else:
            print(shared_end - shared_start + 1)

solve()","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    overlap_start = max(l1, l2)
    overlap_end = min(r1, r2)
    result = max(0, overlap_end - overlap_start + 1 - (k >= overlap_start and k <= overlap_end))
    print(result)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    
    intersect_start = max(l1, l2)
    intersect_end = min(r1, r2)
    
    overlap = max(0, intersect_end - intersect_start + 1)
    
    if l2 <= k <= r2 and l1 <= k <= r1:
        overlap -= 1
    
    print(overlap)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    start = max(l1, l2)
    end = min(r1, r2)
    
    if start > end:
        print(0)
    else:
        total_time = end - start + 1
        if k >= start and k <= end:
            total_time -= 1
        print(total_time)

solve()
","
def solve():
    l1, r1, l2, r2, k = map(int, input().split())
    
    start = max(l1, l2)
    end = min(r1, r2)
    
    if start > end:
        print(0)
    else:
        result = end - start + 1
        if l1 <= k <= r1:
            result -= 1
        print(result)

solve()","100.0","100.0","100.0","0.0","100.0","100.0","0.0","93.33333333333333","100.0","100.0","100.0","100.0","100.0","100.0","100.0","93.33333333333333","","","","","","","","","","","","","","","",""
"APPS/117","
QUESTION:
There is a grass field that stretches infinitely.
In this field, there is a negligibly small cow. Let (x, y) denote the point that is x\ \mathrm{cm} south and y\ \mathrm{cm} east of the point where the cow stands now. The cow itself is standing at (0, 0).
There are also N north-south lines and M east-west lines drawn on the field. The i-th north-south line is the segment connecting the points (A_i, C_i) and (B_i, C_i), and the j-th east-west line is the segment connecting the points (D_j, E_j) and (D_j, F_j).
What is the area of the region the cow can reach when it can move around as long as it does not cross the segments (including the endpoints)? If this area is infinite, print INF instead.

-----Constraints-----
 - All values in input are integers between -10^9 and 10^9  (inclusive).
 - 1 \leq N, M \leq 1000
 - A_i < B_i\ (1 \leq i \leq N)
 - E_j < F_j\ (1 \leq j \leq M)
 - The point (0, 0) does not lie on any of the given segments.

-----Input-----
Input is given from Standard Input in the following format:
N M
A_1 B_1 C_1
:
A_N B_N C_N
D_1 E_1 F_1
:
D_M E_M F_M

-----Output-----
If the area of the region the cow can reach is infinite, print INF; otherwise, print an integer representing the area in \mathrm{cm^2}.
(Under the constraints, it can be proved that the area of the region is always an integer if it is not infinite.)

-----Sample Input-----
5 6
1 2 0
0 1 1
0 2 2
-3 4 -1
-2 6 3
1 0 1
0 1 2
2 0 2
-1 -4 5
3 -2 4
1 2 4

-----Sample Output-----
13

The area of the region the cow can reach is 13\ \mathrm{cm^2}.
Use user-input-Based format and function signature solve()","
def solve():
    import sys
    input = sys.stdin.readline

    N, M = map(int, input().split())
    vertical_lines = [list(map(int, input().split())) for _ in range(N)]
    horizontal_lines = [list(map(int, input().split())) for _ in range(M)]

    vertical_lines.sort()
    horizontal_lines.sort()

    def check_intersection(x, y):
        for a, b, c in vertical_lines:
            if a < x < b and c <= y:
                return True
        for d, e, f in horizontal_lines:
            if e < y < f and d <= x:
                return True
        return False

    def area(x, y):
        if check_intersection(x, y):
            return float('inf')
        return x * y

    result = 0
    for i in range(1, len(vertical_lines)):
        for j in range(1, len(horizontal_lines)):
            result += area(vertical_lines[i][0] - vertical_lines[i-1][1], horizontal_lines[j][1] - horizontal_lines[j-1][0])

    if result == float('inf'):
        print(""INF"")
    else:
        print(int(result))

solve()
","
def solve():
    import sys
    N, M = map(int, sys.stdin.readline().split())
    lines = []
    for _ in range(N):
        A, B, C = map(int, sys.stdin.readline().split())
        lines.append(((A, C), (B, C)))
    for _ in range(M):
        D, E, F = map(int, sys.stdin.readline().split())
        lines.append(((D, E), (D, F))

    segments = []
    for line in lines:
        for i in range(len(line)):
            if line[i][0] < line[i][1]:
                segments.append((line[i][0], line[i][1]))
            else:
                segments.append((line[i][1], line[i][0]))

    segments.sort()
    ans = 0
    rightmost = -10**9
    for seg in segments:
        if seg[0] > rightmost:
            ans += seg[1] - seg[0]
        else:
            ans += max(0, seg[1] - rightmost)
        rightmost = max(rightmost, seg[1])

    if ans >= 10**9:
        print(""INF"")
    else:
        print(ans)

solve()
  ","
def solve():
    import sys
    input = sys.stdin.readline

    N, M = map(int, input().split())

    NS_lines = [list(map(int, input().split())) for _ in range(N)]
    EW_lines = [list(map(int, input().split())) for _ in range(M)]

    def intersects(x, y, a, b, c):
        return a < x < b and min(y, c) <= 0 <= max(y, c)

    def reachable(x, y):
        for a, b, c in NS_lines:
            if intersects(x, y, a, b, c):
                return False
        for d, e, f in EW_lines:
            if intersects(y, x, e, f, d):
                return False
        return True

    def area(x, y):
        return sum(reachable(x + dx, y + dy) for dx in [-0.5, 0.5] for dy in [-0.5, 0.5]) % 2**31

    if area(0, 0) == 0:
        print(""INF"")
    else:
        print(area(0, 0))


solve()","
from typing import List

def solve() -> None:
    N, M = map(int, input().split())
    north_south_lines = [list(map(int, input().split())) for _ in range(N)]
    east_west_lines = [list(map(int, input().split())) for _ in range(M)]
    
    north_south_points = set()
    for line in north_south_lines:
        x1, x2, y = line
        for x in range(x1, x2):
            north_south_points.add((x, y))
    
    east_west_points = set()
    for line in east_west_lines:
        x, y1, y2 = line
        for y in range(y1, y2):
            east_west_points.add((x, y))
    
    area = len(north_south_points.union(east_west_points))
    print(area if area != float('inf') else ""INF"")
  
solve()","
import sys

def solve():
    N, M = map(int, sys.stdin.readline().split())
    n_segments = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
    m_segments = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]

    min_y, max_y = min(segment[2] for segment in n_segments), max(segment[2] for segment in n_segments)
    min_x, max_x = min(segment[1] for segment in m_segments), max(segment[1] for segment in m_segments)

    area = (max_y - min_y) * (max_x - min_x)
    if area <= 0 or area > 10**9:
        print(""INF"")
    else:
        print(area)

solve()
","
def solve():
    import sys
    N, M = map(int, sys.stdin.readline().split())
    vertical_lines = []
    horizontal_lines = []
    for _ in range(N):
        A, B, C = map(int, sys.stdin.readline().split())
        vertical_lines.append((min(A, B), max(A, B), C))
    for _ in range(M):
        D, E, F = map(int, sys.stdin.readline().split())
        horizontal_lines.append((min(E, F), max(E, F), D))

    vertical_lines.sort()
    horizontal_lines.sort()

    def in_range(x, y, a, b, c):
        return a < x < b and min(c, y) <= max(c, y)

    def calc_area(x1, y1, x2, y2):
        return abs(x1 - x2) * abs(y1 - y2)

    def find_area():
        total_area = 0
        for y1, y2, x in vertical_lines:
            reachable_from_top = -10**9
            reachable_from_bottom = 10**9
            for h1, h2, y3 in horizontal_lines:
                if in_range(x, y1, h1, h2, y3):
                    reachable_from_top = max(reachable_from_top, y3)
                if in_range(x, y2, h1, h2, y3):
                    reachable_from_bottom = min(reachable_from_bottom, y3)
            total_area += calc_area(y1, reachable_from_bottom, y2, reachable_from_top)
        return total_area
    
    result = find_area()
    if result == float('inf'):
        print(""INF"")
    else:
        print(result)

solve()
","
def solve():
    N, M = map(int, input().split())
    vertical_lines = []
    horizontal_lines = []
    
    for _ in range(N):
        A, B, C = map(int, input().split())
        vertical_lines.append((A, C, B))
    
    for _ in range(M):
        D, E, F = map(int, input().split())
        horizontal_lines.append((D, E, F))
    
    vertical_lines.sort()
    horizontal_lines.sort()
    
    # Add your solution logic here

solve()
","
def solve():
    import sys
    from typing import List

    def read_int():
        return int(sys.stdin.readline())

    def read_ints():
        return map(int, sys.stdin.readline().split())

    class Segment:
        def __init__(self, start, end):
            self.start = start
            self.end = end

    def intersects(a, b):
        return a.start < b.end and b.start < a.end

    def calculate_area(N: int, M: int, vertical_lines: List[Segment], horizontal_lines: List[Segment]) -> int:
        vertical_positions = set()
        horizontal_positions = set()

        for line in vertical_lines:
            vertical_positions.add(line.start)
            vertical_positions.add(line.end)

        for line in horizontal_lines:
            horizontal_positions.add(line.start)
            horizontal_positions.add(line.end)

        vertical_positions = sorted(list(vertical_positions))
        horizontal_positions = sorted(list(horizontal_positions))

        total_area = 0
        for i in range(len(vertical_positions) - 1):
            for j in range(len(horizontal_positions) - 1):
                area = (vertical_positions[i + 1] - vertical_positions[i]) * (horizontal_positions[j + 1] - horizontal_positions[j])
                for vertical_line in vertical_lines:
                    if vertical_positions[i] < vertical_line.start < vertical_positions[i + 1] and horizontal_positions[j] < vertical_line.end < horizontal_positions[j + 1]:
                        area = 0
                        break
                for horizontal_line in horizontal_lines:
                    if vertical_positions[i] < horizontal_line.start < vertical_positions[i + 1] and horizontal_positions[j] < horizontal_line.end < horizontal_positions[j + 1]:
                        area = 0
                        break
                total_area += area

        return total_area

    N, M = read_ints()
    vertical_lines = [Segment(*read_ints()) for _ in range(N)]
    horizontal_lines = [Segment(*read_ints()) for _ in range(M)]
    
    area = calculate_area(N, M, vertical_lines, horizontal_lines)

    if area == float('inf'):
        print(""INF"")
    else:
        print(int(area))

solve()
","
from fractions import Fraction

def solve():
    N, M = map(int, input().split())
    north_south_lines = [tuple(map(int, input().split())) for _ in range(N)]
    east_west_lines = [tuple(map(int, input().split())) for _ in range(M)]
    
    region = set()
    for a, b, c in north_south_lines:
        region.add(Fraction(b - a, abs(c)))
    
    for d, e, f in east_west_lines:
        valid = True
        for line in region:
            if line.denominator == 0 and d > 0:
                valid = False
                break
            y = line * d
            if y >= e and y <= f:
                valid = False
                break
        if valid:
            region.add(Fraction(0))
    
    if any(line.denominator == 0 for line in region):
        print(""INF"")
    else:
        print(sum(line.denominator for line in region))

solve()","
def solve():
    import sys
    input = sys.stdin.readline
    N, M = map(int, input().split())
    vertical_lines = [list(map(int, input().split())) for _ in range(N)]
    horizontal_lines = [list(map(int, input().split())) for _ in range(M)]
    
    line_segments = []
    for vline in vertical_lines:
        line_segments.append(((vline[0], vline[2]), (vline[1], vline[2]))
    
    for hline in horizontal_lines:
        line_segments.append(((hline[0], hline[1]), (hline[0], hline[2]))
    
    line_segments.sort(key=lambda x: x[0])
    x_vals = [0]
    for seg in line_segments:
        if seg[0][0] != x_vals[-1]:
            x_vals.append(seg[0][0])
        if seg[1][0] != x_vals[-1]:
            x_vals.append(seg[1][0])
    
    result = 0
    for i in range(len(x_vals) - 1):
        x1, x2 = x_vals[i], x_vals[i + 1]
        y_vals = [0]
        for seg in line_segments:
            if seg[0][0] <= x1 and x2 <= seg[1][0]:
                y_vals.append(seg[0][1])
                y_vals.append(seg[1][1])
        y_vals.sort()
        
        for j in range(len(y_vals) - 1):
            y1, y2 = y_vals[j], y_vals[j + 1]
            area = (x2 - x1) * (y2 - y1)
            if any(seg[0][0] < x1 and x2 < seg[1][0] and seg[0][1] < y1 and y2 < seg[1][1] for seg in line_segments):
                result = float('inf')
                break
            if any(seg[0][0] <= x1 and x2 <= seg[1][0] and seg[0][1] <= y1 and y2 <= seg[1][1] for seg in line_segments):
                continue
            result += area
    
    print(""INF"" if result == float('inf') else int(result))

solve()","
def solve():
    pass  # Your code here

solve()","
from fractions import Fraction

def solve():
    N, M = map(int, input().split())
    
    segments = []
    for _ in range(N):
        A, B, C = map(int, input().split())
        segments.append(((A, C), (B, C)))
    for _ in range(M):
        D, E, F = map(int, input().split())
        segments.append(((D, E), (D, F)))
        
    crossing_points = set()
    for i in range(len(segments)):
        for j in range(i + 1, len(segments)):
            for seg1 in segments[i]:
                for seg2 in segments[j]:
                    if seg1[0] == seg1[1]:
                        x1, y1 = seg1
                        x2, y2 = seg2
                    else:
                        x1, y1 = seg2
                        x2, y2 = seg1
                    
                    if x1 == x2:
                        if y1 == y2:
                            continue
                        y_cross = max(min(y1, y2), 0)
                        if y_cross != 0:
                            crossing_points.add((x1, y_cross))
                    else:
                        slope = Fraction(y2 - y1, x2 - x1)
                        y_at_origin = y1 - slope * x1
                        if x1 <= 0 <= x2:
                            crossing_points.add((0, y_at_origin))
    
    area = 0
    for x1, y1 in crossing_points:
        has_negative = False
        for A, B in segments:
            if A[1] <= y1 < B[1] or B[1] <= y1 < A[1]:
                if (B[0] - A[0]) * (y1 - A[1]) < (B[1] - A[1]) * (x1 - A[0]):
                    has_negative = not has_negative
        
        if not has_negative:
            area += 1
    
    if area == 0:
        print(""INF"")
    else:
        print(area)


solve()","
from fractions import Fraction
import bisect

def solve():
    n, m = map(int, input().split())
    n_segments = [list(map(int, input().split())) for _ in range(n)]
    m_segments = [list(map(int, input().split())) for _ in range(m)]
    
    coord = {0}
    for x1, x2, y in n_segments:
        if x1 < x2:
            coord.add(Fraction(x1, y))
            coord.add(Fraction(x2, y))
    
    for x, y1, y2 in m_segments:
        coord.add(x)
    
    coord = sorted(coord)
    
    ans = 0
    for i in range(len(coord) - 1):
        x1, x2 = coord[i], coord[i + 1]
        up, down = x1.denominator * x2.numerator, x1.numerator * x2.denominator
        
        y1 = bisect.bisect_left([y for a, b, y in n_segments if a < b], up)
        y2 = bisect.bisect_right([y for a, b, y in n_segments if a > b], down)
        y3 = bisect.bisect_left([y for a, b, y in m_segments if a > b], x1)
        y4 = bisect.bisect_right([y for a, b, y in m_segments if a < b], x2)
        
        ans += (y2 - y1) * (y4 - y3) * (x2 - x1)
    
    print(""INF"" if ans >= 10**18 else ans)
  
solve()","
from typing import List

def solve() -> None:
    N, M = map(int, input().split())

    vertical_lines = [tuple(map(int, input().split())) for _ in range(N)]
    horizontal_lines = [tuple(map(int, input().split())) for _ in range(M)]

    xs = set()
    ys = set()

    for line in vertical_lines:
        xs.add(0)
        xs.add(line[0])
        xs.add(line[1])

    for line in horizontal_lines:
        ys.add(0)
        ys.add(line[1])
        ys.add(line[2])

    xs = sorted(list(xs))
    ys = sorted(list(ys))

    area = 0
    for i in range(1, len(xs)):
        for j in range(1, len(ys)):
            for v_line in vertical_lines:
                if v_line[0] < xs[i] and v_line[1] > xs[i - 1] and v_line[2] >= ys[j - 1] and v_line[2] < ys[j]:
                    break
            else:
                for h_line in horizontal_lines:
                    if h_line[1] < ys[j] and h_line[2] > ys[j - 1] and h_line[0] >= xs[i - 1] and h_line[0] < xs[i]:
                        break
                else:
                    area += (xs[i] - xs[i - 1]) * (ys[j] - ys[j - 1])

    if area == float('inf'):
        print(""INF"")
    else:
        print(int(area))


solve()","
def solve():
    import sys
    input = sys.stdin.readline

    N, M = map(int, input().split())

    lines_ns = [list(map(int, input().split())) for _ in range(N)]
    lines_ew = [list(map(int, input().split())) for _ in range(M)]

    def check_intersection(x1, y1, x2, y2, a, b, c):
        if min(x1, x2) < a and a < max(x1, x2) and min(y1, y2) < b and b < max(y1, y2):
            return c
        return 0

    area = 0
    for x in range(-10**9, 10**9):
        for y in range(-10**9, 10**9):
            in_region = True
            for line_ns in lines_ns:
                in_region &= check_intersection(line_ns[0], line_ns[2], line_ns[1], line_ns[2], x, y, y)

            for line_ew in lines_ew:
                in_region &= check_intersection(line_ew[0], line_ew[1], line_ew[0], line_ew[2], x, y, x)

            if in_region:
                area += 1

    if area == 0:
        print(""INF"")
    else:
        print(area)


solve()","
def solve():
    import sys
    input = sys.stdin.readline
    N, M = map(int, input().split())
    vertical_lines, horizontal_lines = [], []
    
    for _ in range(N):
        A, B, C = map(int, input().split())
        if A < 0 and B > 0:
            vertical_lines.append((B, C))
        else:
            horizontal_lines.append((min(A, B), max(A, B), C))
    
    for _ in range(M):
        D, E, F = map(int, input().split())
        if E < 0 and F > 0:
            horizontal_lines.append((E, F, D))
        else:
            vertical_lines.append((min(E, F), max(E, F)))
    
    vertical_lines.sort()
    horizontal_lines.sort()
    
    def check_intersection(vertical, horizontal):
        x, y = vertical
        a, b, c = horizontal
        if a <= x <= b and y >= c:
            return 0
        if x < a:
            return (a - x) * (min(b, y) - c)
        if y > b:
            return (y - b) * (min(b, x) - c)
        return (b - a) * (y - c)
    
    area = 0
    for vertical in vertical_lines:
        for horizontal in horizontal_lines:
            area += check_intersection(vertical, horizontal)
    
    if area >= 10**18:
        print(""INF"")
    else:
        print(area)


solve()","7.6923076923076925","0.0","6.666666666666667","0.0","13.333333333333334","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0","6.666666666666667","","","","","","","","","","","","","","","All tests timed out",""
"APPS/118","
QUESTION:
Ted has a pineapple. This pineapple is able to bark like a bulldog! At time t (in seconds) it barks for the first time. Then every s seconds after it, it barks twice with 1 second interval. Thus it barks at times t, t + s, t + s + 1, t + 2s, t + 2s + 1, etc.

 [Image] 

Barney woke up in the morning and wants to eat the pineapple, but he can't eat it when it's barking. Barney plans to eat it at time x (in seconds), so he asked you to tell him if it's gonna bark at that time.


-----Input-----

The first and only line of input contains three integers t, s and x (0 ≤ t, x ≤ 10^9, 2 ≤ s ≤ 10^9) — the time the pineapple barks for the first time, the pineapple barking interval, and the time Barney wants to eat the pineapple respectively.


-----Output-----

Print a single ""YES"" (without quotes) if the pineapple will bark at time x or a single ""NO"" (without quotes) otherwise in the only line of output.


-----Examples-----
Input
3 10 4

Output
NO

Input
3 10 3

Output
YES

Input
3 8 51

Output
YES

Input
3 8 52

Output
YES



-----Note-----

In the first and the second sample cases pineapple will bark at moments 3, 13, 14, ..., so it won't bark at the moment 4 and will bark at the moment 3.

In the third and fourth sample cases pineapple will bark at moments 3, 11, 12, 19, 20, 27, 28, 35, 36, 43, 44, 51, 52, 59, ..., so it will bark at both moments 51 and 52.
Use user-input-Based format and function signature solve()","
def solve():
    t, s, x = map(int, input().split())
    
    if x == t:
        print(""YES"")
    elif x > t and (x - t) % s == 0:
        print(""YES"")
    elif x > t + 1 and (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())

    if x < t:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    if x == t:
        print(""YES"")
    elif x < t + s:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    
    if x < t + s:
        print(""YES"" if x == t else ""NO"")
    elif (x - t) % s == 0 or (x - t) % s == 1:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    if x == t:
        print(""YES"")
    elif x < t + s:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    t, s, x = map(int, input().split())
    
    if (x - t) % s == 0:
        print(""YES"")
    elif x >= t + s and ((x - t) - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    t, s, x = map(int, input().split())
    
    if (x - t) % s == 0 or ((x - t - 1) % s == 0 and x - t >= s + 1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    
    if x < t:
        print(""NO"")
    elif (x-t) % s == 0 or ((x-t-1) % s == 0 and x != t + 1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    
    if x < t:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0 and x > t+1:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
  
    if x == t:
        print(""YES"")
    elif x > t and (x - t) % s == 0 or (x - t) % s == 1 and (x - t) >= s:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    if x < t:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    t, s, x = map(int, input().split())
    if x == t:
        print(""YES"")
    elif x < t + s:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    
    if x == t:
        print(""YES"")
    elif x < t + s:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    if x == t:
        print(""YES"")
    elif x < t + s:
        print(""NO"")
    elif (x - t) % s == 0 or (x - t - 1) % s == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    t, s, x = map(int, input().split())
    if x == t or (x-t) % s == 0 or (x-t) % s == 1 and x != t+1:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    t, s, x = map(int, input().split())
    
    if x < t:
        print(""NO"")
    else:
        remaining_time = x - t
        if remaining_time % s == 0 or (remaining_time - 1) % s == 0 and remaining_time >= 2:
            print(""YES"")
        else:
            print(""NO"")

solve()
","100.0","93.33333333333333","100.0","100.0","100.0","93.33333333333333","93.33333333333333","100.0","100.0","100.0","93.33333333333333","100.0","100.0","100.0","93.33333333333333","100.0","","","","","","","","","","","","","","","",""
"APPS/119","
QUESTION:
You are given a sequence a_1, a_2, ..., a_{n} of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment a_{i} lies within segment a_{j}.

Segment [l_1, r_1] lies within segment [l_2, r_2] iff l_1 ≥ l_2 and r_1 ≤ r_2.

Print indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 3·10^5) — the number of segments.

Each of the next n lines contains two integers l_{i} and r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ 10^9) — the i-th segment.


-----Output-----

Print two distinct indices i and j such that segment a_{i} lies within segment a_{j}. If there are multiple answers, print any of them. If no answer exists, print -1 -1.


-----Examples-----
Input
5
1 10
2 9
3 9
2 3
2 9

Output
2 1

Input
3
1 5
2 6
6 20

Output
-1 -1



-----Note-----

In the first example the following pairs are considered correct:  (2, 1), (3, 1), (4, 1), (5, 1) — not even touching borders;  (3, 2), (4, 2), (3, 5), (4, 5) — touch one border;  (5, 2), (2, 5) — match exactly.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    segments = []
    for i in range(n):
        l, r = map(int, input().split())
        segments.append((l, r))
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] and segments[i][1] <= segments[j][1]:
                print(i+1, j+1)
                return
    print(-1, -1)

solve()","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]
    
    segments.sort(key=lambda x: (x[0], -x[1]))
    
    for i in range(1, n):
        if segments[i - 1][0] <= segments[i][0] and segments[i - 1][1] >= segments[i][1]:
            print(i + 1, i)
            return
    
    print(-1, -1)

solve()
","
def solve():
    n = int(input())
    segments = []
    for i in range(n):
        l, r = map(int, input().split())
        segments.append((l, r))
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] <= segments[i][1] <= segments[j][1]:
                print(j+1, i+1)
                return
    
    print(""-1 -1"")

solve()
","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]
    
    segments.sort(key=lambda x: (x[0], -x[1]))

    for i in range(1, n):
        if segments[i][1] >= segments[i-1][1]:
            print(i+1, i)
            return

    print(-1, -1)

# Call the function
solve()
","
def solve():
    n = int(input())
    segments = []
    for i in range(n):
        l, r = map(int, input().split())
        segments.append((l, r))
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] <= segments[i][1] <= segments[j][1]:
                print(i+1, j+1)
                return
    print(""-1 -1"")

solve()
","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] and segments[i][1] <= segments[j][1]:
                print(i+1, j+1)
                return
    
    print(-1, -1)

solve()","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]
    
    segments.sort(key=lambda x: (x[0], -x[1]))
    
    for i in range(1, n):
        if segments[i][0] >= segments[i-1][0] and segments[i][1] <= segments[i-1][1]:
            print(i+1, i)
            return
    
    print(-1, -1)

solve()","
def solve():
    import sys

    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] <= segments[i][1] <= segments[j][1]:
                print(i + 1, j + 1)
                return

    print(-1, -1)


solve()
","
def solve():
    n = int(input())
    segments = []
    
    for i in range(n):
        l, r = map(int, input().split())
        segments.append((l, r, i+1))
    
    segments.sort()
    
    for i in range(1, n):
        if segments[i-1][0] <= segments[i][0] and segments[i-1][1] >= segments[i][1]:
            print(segments[i][2], segments[i-1][2])
            return
    
    print(""-1 -1"")

solve()
","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:
                print(i+1, j+1)
                return
    print(-1, -1)

solve()","
def solve():
    n = int(input())
    segments = [tuple(map(int, input().split())) for _ in range(n)]
    
    segments.sort(key=lambda x: (x[0], -x[1]))
    
    for i in range(1, n):
        if segments[i][1] >= segments[i-1][1]:
            print(i+1, i)
            return
    
    print(-1, -1)

solve()","
def solve():
    n = int(input())
    segments = []
    for i in range(n):
        l, r = map(int, input().split())
        segments.append((l, r))

    segments.sort(key=lambda x: x[0])

    for i in range(n-1):
        if segments[i][0] <= segments[i+1][0] and segments[i][1] >= segments[i+1][1]:
            print(i+2, i+1)
            return

    print(-1, -1)

solve()","
def solve():
    import sys
    
    n = int(input().strip())
    segments = []
    for _ in range(n):
        l, r = map(int, input().split())
        segments.append((l, r))
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] <= segments[i][1] <= segments[j][1]:
                print(j+1, i+1)
                return
    
    print(-1, -1)

solve()","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] <= segments[i][1] <= segments[j][1]:
                print(i+1, j+1)
                return
    
    print(-1, -1)

solve()","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] <= segments[i][1] <= segments[j][1]:
                print(i + 1, j + 1)
                return
    print(-1, -1)

solve()","
def solve():
    n = int(input())
    segments = [list(map(int, input().split())) for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            if i != j and segments[j][0] <= segments[i][0] and segments[i][1] <= segments[j][1]:
                print(i+1, j+1)
                return
    
    print(-1, -1)

solve()
","80.0","60.0","33.33333333333333","20.0","80.0","80.0","60.0","80.0","53.333333333333336","80.0","20.0","60.0","33.33333333333333","80.0","80.0","80.0","","","","","","","","","","","","","","","",""
"APPS/120","
QUESTION:
The process of mammoth's genome decoding in Berland comes to its end!

One of the few remaining tasks is to restore unrecognized nucleotides in a found chain s. Each nucleotide is coded with a capital letter of English alphabet: 'A', 'C', 'G' or 'T'. Unrecognized nucleotides are coded by a question mark '?'. Thus, s is a string consisting of letters 'A', 'C', 'G', 'T' and characters '?'.

It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal.

Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal.


-----Input-----

The first line contains the integer n (4 ≤ n ≤ 255) — the length of the genome.

The second line contains the string s of length n — the coded genome. It consists of characters 'A', 'C', 'G', 'T' and '?'.


-----Output-----

If it is possible to decode the genome, print it. If there are multiple answer, print any of them. If it is not possible, print three equals signs in a row: ""==="" (without quotes).


-----Examples-----
Input
8
AG?C??CT

Output
AGACGTCT

Input
4
AGCT

Output
AGCT

Input
6
????G?

Output
===

Input
4
AA??

Output
===



-----Note-----

In the first example you can replace the first question mark with the letter 'A', the second question mark with the letter 'G', the third question mark with the letter 'T', then each nucleotide in the genome would be presented twice.

In the second example the genome is already decoded correctly and each nucleotide is exactly once in it.

In the third and the fourth examples it is impossible to decode the genom.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input()

    counts = {'A': s.count('A'), 'C': s.count('C'), 'G': s.count('G'), 'T': s.count('T'), '?': s.count('?')}
    max_count = max(counts.values())

    if max_count > n // 4:
        print(""==="")
    else:
        decoded_genome = ''
        for char in s:
            if char == '?':
                for nucleotide, count in counts.items():
                    if count < n // 4:
                        decoded_genome += nucleotide
                        counts[nucleotide] += 1
                        break
            else:
                decoded_genome += char
        print(decoded_genome)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    freq = {'A': 0, 'C': 0, 'G': 0, 'T': 0}
    
    for char in s:
        if char in freq:
            freq[char] += 1
    
    max_freq = max(freq.values())
    min_freq = min(freq.values())
    
    if max_freq - min_freq > sum(1 for char in s if char == '?'):
        print(""==="")
    else:
        for i in range(n):
            if s[i] == '?':
                for char in freq:
                    if freq[char] < max_freq:
                        freq[char] += 1
                        s = s[:i] + char + s[i+1:]
                        break
        print(s)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    cnt = {'A': s.count('A'), 'C': s.count('C'), 'G': s.count('G'), 'T': s.count('T')}
    q_marks = s.count('?')
    
    equiv_cnt = n // 4
    if not all(v <= equiv_cnt for v in cnt.values()):
        print(""==="")
        return
    
    remaining_chars = [char for char in cnt.keys() if cnt[char] < equiv_cnt]
    for i in range(n):
        if s[i] == '?':
            if cnt['A'] < equiv_cnt:
                s = s[:i] + 'A' + s[i+1:]
                cnt['A'] += 1
            elif cnt['C'] < equiv_cnt:
                s = s[:i] + 'C' + s[i+1:]
                cnt['C'] += 1
            elif cnt['G'] < equiv_cnt:
                s = s[:i] + 'G' + s[i+1:]
                cnt['G'] += 1
            elif cnt['T'] < equiv_cnt:
                s = s[:i] + 'T' + s[i+1:]
                cnt['T'] += 1
    
    print(s)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    count = {'A': 0, 'C': 0, 'G': 0, 'T': 0, '?': 0}
    
    for char in s:
        count[char] += 1
    
    max_count = max(count.values())
    min_count = min(count.values())
    
    if max_count > (n // 4) + count['?']:
        print(""==="")
    else:
        for i in range(n):
            if s[i] == '?':
                for nucleotide in 'ACGT':
                    if count[nucleotide] < n // 4:
                        count[nucleotide] += 1
                        s = s[:i] + nucleotide + s[i+1:]
                        break
        print(s)
   
solve()
  ","
def solve():
    n = int(input())
    s = input()
    
    counts = [s.count('A'), s.count('C'), s.count('G'), s.count('T')]
    max_count = max(counts)
    
    if s.count('?') % 4 != 0:
        print(""==="")
    else:
        for i in range(4):
            if counts[i] == max_count:
                ans = ['A']*counts[i]
                break
        
        for i in range(len(s)):
            if s[i] == '?':
                s[i] = ans.pop()
                
        print(''.join(s))


solve()
","
def solve():
    n = int(input())
    s = input()
    
    total_nucleotides = s.count('A') + s.count('C') + s.count('G') + s.count('T')
    question_marks = s.count('?')
    
    if (total_nucleotides + question_marks) % 4 != 0:
        print(""==="")
    else:
        A_count = (total_nucleotides + question_marks) // 4 - s.count('A')
        C_count = (total_nucleotides + question_marks) // 4 - s.count('C')
        G_count = (total_nucleotides + question_marks) // 4 - s.count('G')
        T_count = (total_nucleotides + question_marks) // 4 - s.count('T')
        
        decoded_genome = ''
        for char in s:
            if char == '?':
                if A_count > 0:
                    decoded_genome += 'A'
                    A_count -= 1
                elif C_count > 0:
                    decoded_genome += 'C'
                    C_count -= 1
                elif G_count > 0:
                    decoded_genome += 'G'
                    G_count -= 1
                elif T_count > 0:
                    decoded_genome += 'T'
                    T_count -= 1
            else:
                decoded_genome += char
        
        print(decoded_genome)

solve()
","
def solve():
    n = int(input())
    genome = input().strip()
    counts = {char: genome.count(char) for char in ""ACGT""}

    if '?' not in counts:
        print(genome)
    else:
        q_count = counts['?']
        equal_count = n // 4
        remaining_chars = {char: equal_count - counts.get(char, 0) for char in ""ACGT""}

        if any(count < 0 for count in remaining_chars.values()):
            print(""==="")
        else:
            for i in range(n):
                if genome[i] == '?':
                    for char, count in remaining_chars.items():
                        if count > 0:
                            genome = genome[:i] + char + genome[i+1:]
                            remaining_chars[char] -= 1
                            break
            print(genome)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    counts = {'A': s.count('A'), 'C': s.count('C'), 'G': s.count('G'), 'T': s.count('T')}
    
    if '?' not in counts:  # If there are no unrecognized nucleotides
        print(s)
        return
    
    max_count = max(counts.values())
    remaining_count = n - max_count
    
    diff = remaining_count // 4
    
    if diff * 4 != remaining_count or any(count != max_count and count + diff < max_count for count in counts.values()):
        print(""==="")
        return
    
    decoded_genome = []
    
    for nucleotide in s:
        if nucleotide == '?':
            possible_nucleotides = [key for key, value in counts.items() if value < max_count]
            for possible_nucleotide in possible_nucleotides:
                counts[possible_nucleotide] += 1
                decoded_genome.append(possible_nucleotide)
                if all(value == max_count for value in counts.values()):
                    break
        else:
            decoded_genome.append(nucleotide)
    
    print(''.join(decoded_genome))

solve()
","
def solve():
    n = int(input())
    s = input()
    
    total_nucleotides = s.count('A') + s.count('C') + s.count('G') + s.count('T') + s.count('?')
    
    if total_nucleotides % 4 != 0:
        print(""==="")
    else:
        equal_nucleotides = total_nucleotides // 4
        diff = {'A': equal_nucleotides - s.count('A'),
                'C': equal_nucleotides - s.count('C'),
                'G': equal_nucleotides - s.count('G'),
                'T': equal_nucleotides - s.count('T')}
        
        decoded = ''
        for char in s:
            if char == '?':
                for key, value in diff.items():
                    if value > 0:
                        decoded += key
                        diff[key] -= 1
                        break
            else:
                decoded += char
        
        print(decoded)

solve()
  ","
def solve():
    n = int(input())
    s = input()

    total_known = s.count('A') + s.count('C') + s.count('G') + s.count('T')
    unknown_count = s.count('?')

    if total_known % 4 != 0:
        print(""==="")
        return

    target_known = total_known // 4

    for nucleotide in 'ACGT':
        count = s.count(nucleotide)
        if count > target_known:
            print(""==="")
            return

    for i in range(n):
        if s[i] == '?':
            for nucleotide in 'ACGT':
                count = s.count(nucleotide)
                if count < target_known:
                    s = s[:i] + nucleotide + s[i+1:]
                    break

    print(s)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    counts = {char: s.count(char) for char in ['A', 'C', 'G', 'T']}
    num_question_marks = s.count('?')
    
    max_count = max(counts.values())
    min_count = min(counts.values())
    if max_count > min_count + num_question_marks:
        print(""==="")
    else:
        for char in counts:
            if counts[char] == max_count:
                max_char = char
                break
        decoded_genome = []
        for char in s:
            if char == '?':
                decoded_genome.append(max_char)
            else:
                decoded_genome.append(char)
        print(''.join(decoded_genome))

solve()
","
def solve():
    n = int(input())
    s = input()
    
    count = {}
    for char in s:
        if char != '?':
            if char not in count:
                count[char] = 1
            else:
                count[char] += 1
    
    if '?' in count:
        missing = n // 4
        for key in count:
            count[key] += max(0, missing - count[key])
    
    if all(val == n // 4 for val in count.values()) and s.count('?') == sum(val - n // 4 for val in count.values()):
        ans = ''
        for char in s:
            if char == '?':
                for key in count.keys():
                    if count[key] < n // 4:
                        count[key] += 1
                        ans += key
                        break
            else:
                ans += char
        print(ans)
    else:
        print(""==="")

solve()
","
def solve():
    n = int(input())
    s = input()
    
    count = {'A': s.count('A'), 'C': s.count('C'), 'G': s.count('G'), 'T': s.count('T'), '?': s.count('?')}
    
    max_count = max(count.values())
    
    if any(count[nt] > n//4 for nt in 'ACGT'):
        print(""==="")
    else:
        for nt in 'ACGT':
            while count[nt] < n//4:
                if count['?'] > 0:
                    s = s.replace('?', nt, 1)
                    count[nt] += 1
                    count['?'] -= 1
                else:
                    break
        print(s)

solve()","
def solve():
    n = int(input())
    s = input()
    freq = {}
    for char in 'ACGT':
        freq[char] = s.count(char)
    
    max_freq = max(freq.values())
    min_freq = min(freq.values())
    
    if max_freq - min_freq > s.count('?'):
        print(""==="")
    else:
        decoded_genome = ''
        for char in s:
            if char == '?':
                for nucleotide, count in freq.items():
                    if count < max_freq:
                        freq[nucleotide] += 1
                        decoded_genome += nucleotide
                        break
            else:
                decoded_genome += char
        print(decoded_genome)


solve()","
def solve():
    n = int(input())
    s = input()

    counts = {'A': s.count('A'), 'C': s.count('C'), 'G': s.count('G'), 'T': s.count('T'), '?': s.count('?')}

    total_known = counts['A'] + counts['C'] + counts['G'] + counts['T']

    if total_known > n:
        print(""==="")
    else:
        count_per_type = total_known // 4
        remaining = 4 - (total_known % 4)

        for nucleotide in counts:
            if nucleotide != '?':
                while counts[nucleotide] < count_per_type:
                    counts[nucleotide] += 1
                    if remaining > 0:
                        remaining -= 1

        if remaining == 0 and counts['A'] == counts['C'] == counts['G'] == counts['T']:
            decoded = ''
            for char in s:
                if char == '?':
                    for nucleotide in counts:
                        if nucleotide != '?':
                            if counts[nucleotide] > 0:
                                decoded += nucleotide
                                counts[nucleotide] -= 1
                                break
                else:
                    decoded += char
            print(decoded)
        else:
            print(""==="")

solve()
","
def solve():
    n = int(input())
    s = input()

    count_dict = {'A': 0, 'C': 0, 'G': 0, 'T': 0}
    for char in s:
        if char in count_dict:
            count_dict[char] += 1

    question_marks = count_dict['A'] + count_dict['C'] + count_dict['G'] + count_dict['T']
    equal_count = question_marks // 4

    if question_marks % 4 != 0:
        print(""==="")
    else:
        equal_count_char = {'A', 'C', 'G', 'T'}
        for i in range(n):
            if s[i] == '?':
                for char in equal_count_char:
                    if count_dict[char] < equal_count:
                        count_dict[char] += 1
                        s = s[:i] + char + s[i+1:]
                        break
        print(s)

solve()
","26.666666666666668","53.333333333333336","86.66666666666667","80.0","26.666666666666668","93.33333333333333","6.666666666666667","6.666666666666667","93.33333333333333","20.0","6.666666666666667","26.666666666666668","86.66666666666667","53.333333333333336","20.0","20.0","","","","","","","","","","","","","","","",""
"APPS/121","
QUESTION:
Ilya is an experienced player in tic-tac-toe on the 4 × 4 field. He always starts and plays with Xs. He played a lot of games today with his friend Arseny. The friends became tired and didn't finish the last game. It was Ilya's turn in the game when they left it. Determine whether Ilya could have won the game by making single turn or not. 

The rules of tic-tac-toe on the 4 × 4 field are as follows. Before the first turn all the field cells are empty. The two players take turns placing their signs into empty cells (the first player places Xs, the second player places Os). The player who places Xs goes first, the another one goes second. The winner is the player who first gets three of his signs in a row next to each other (horizontal, vertical or diagonal).


-----Input-----

The tic-tac-toe position is given in four lines.

Each of these lines contains four characters. Each character is '.' (empty cell), 'x' (lowercase English letter x), or 'o' (lowercase English letter o). It is guaranteed that the position is reachable playing tic-tac-toe, and it is Ilya's turn now (in particular, it means that the game is not finished). It is possible that all the cells are empty, it means that the friends left without making single turn.


-----Output-----

Print single line: ""YES"" in case Ilya could have won by making single turn, and ""NO"" otherwise.


-----Examples-----
Input
xx..
.oo.
x...
oox.

Output
YES

Input
x.ox
ox..
x.o.
oo.x

Output
NO

Input
x..x
..oo
o...
x.xo

Output
YES

Input
o.x.
o...
.x..
ooxx

Output
NO



-----Note-----

In the first example Ilya had two winning moves: to the empty cell in the left column and to the leftmost empty cell in the first row.

In the second example it wasn't possible to win by making single turn.

In the third example Ilya could have won by placing X in the last row between two existing Xs.

In the fourth example it wasn't possible to win by making single turn.
Use user-input-Based format and function signature solve()","
def solve():
    board = [input() for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            if board[i][j] == '.':
                board[i] = board[i][:j] + 'x' + board[i][j+1:]
                if any(all(board[i][j] == 'x' for j in range(4)) for i in range(4) or
                       any(all(board[i][j] == 'x' for i in range(4)) for j in range(4) or
                       all(board[i][i] == 'x' for i in range(4)) or
                       all(board[i][3-i] == 'x' for i in range(4)):
                    print(""YES"")
                    return
                board[i] = board[i][:j] + '.' + board[i][j+1:]
    
    print(""NO"")

solve()","
def solve():
    # Read input
    field = [list(input()) for _ in range(4)]

    # Check rows
    for i in range(4):
        if field[i].count('x') == 3 and '.' in field[i]:
            print(""YES"")
            return

    # Check columns
    for j in range(4):
        col = [field[i][j] for i in range(4)]
        if col.count('x') == 3 and '.' in col:
            print(""YES"")
            return

    # Check diagonals
    diag1 = [field[i][i] for i in range(4)]
    diag2 = [field[i][3 - i] for i in range(4)]
    if diag1.count('x') == 3 and '.' in diag1:
        print(""YES"")
        return
    if diag2.count('x') == 3 and '.' in diag2:
        print(""YES"")
        return

    print(""NO"")

# Call the function to run
solve()
","
def solve():
    matrix = [input() for _ in range(4)]
    for i in range(4):
        for j in range(4):
            if matrix[i][j] == '.':
                matrix[i] = matrix[i][:j] + 'x' + matrix[i][j+1:]
                if check_win(matrix):
                    print(""YES"")
                    return
                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]
    print(""NO"")

def check_win(matrix):
    for i in range(4):
        if matrix[i].count('x') == 3 or matrix[i].count('x') == 4:
            return True
        col = [matrix[j][i] for j in range(4)]
        if col.count('x') == 3 or col.count('x') == 4:
            return True
    if matrix[0][0] == matrix[1][1] == matrix[2][2] == 'x':
        return True
    if matrix[0][3] == matrix[1][2] == matrix[2][1] == 'x':
        return True
    return False

solve()
","
def solve():
    # Read input
    board = [input() for _ in range(4)]

    # Check rows and columns for possible winning moves
    for i in range(4):
        if board[i].count('x') == 3 or [board[j][i] for j in range(4)].count('x') == 3:
            print(""YES"")
            return

    # Check diagonals for possible winning moves
    if [board[i][i] for i in range(4)].count('x') == 3 or [board[i][3-i] for i in range(4)].count('x') == 3:
        print(""YES"")
        return

    print(""NO"")

# Call the function to run the solution
solve()
","
def solve():
    field = [input() for _ in range(4)]

    for i in range(4):
        for j in range(4):
            if field[i][j] == '.':
                field[i] = field[i][:j] + 'x' + field[i][j+1:]
                if any(all(cell == 'x' for cell in row) for row in field):
                    print(""YES"")
                    return
                if any(all(row[i] == 'x' for row in field) for i in range(4)):
                    print(""YES"")
                    return
                if all(field[i][i] == 'x' for i in range(4)):
                    print(""YES"")
                    return
                if all(field[i][3-i] == 'x' for i in range(4)):
                    print(""YES"")
                    return
                field[i] = field[i][:j] + '.' + field[i][j+1:]

    print(""NO"")

solve()
","
def solve():
    field = [input() for _ in range(4)]
    for i in range(4):
        for j in range(4):
            if field[i][j] == '.':
                field[i] = field[i][:j] + 'x' + field[i][j+1:]
                if any(all(field[i][k] == 'x' for k in range(4)) for i in range(4) or
                       any(all(field[k][j] == 'x' for k in range(4)) for j in range(4) or
                       all(field[i][i] == 'x' for i in range(4)) or
                       all(field[i][3-i] == 'x' for i in range(4)):
                    print(""YES"")
                    return
                field[i] = field[i][:j] + '.' + field[i][j+1:]
    print(""NO"")
  
solve()","
def solve():
    board = [input() for _ in range(4)]

    def check_win(char):
        for i in range(4):
            if all(board[i][j] == char for j in range(4)):
                return True
            if all(board[j][i] == char for j in range(4)):
                return True
        if all(board[i][i] == char for i in range(4)):
            return True
        if all(board[i][3-i] == char for i in range(4)):
            return True
        return False

    for i in range(4):
        for j in range(4):
            if board[i][j] == '.':
                board[i] = board[i][:j] + 'X' + board[i][j+1:]
                if check_win('X'):
                    print(""YES"")
                    return
                board[i] = board[i][:j] + '.' + board[i][j+1:]

    print(""NO"")

solve()
","
# Code below is in Python

def solve():
    board = [input() for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            if board[i][j] == '.':
                board[i] = board[i][:j] + 'x' + board[i][j+1:]
                # Check rows
                if (board[i].count('x') >= 3 or
                    any(row.count('x') == 3 for row in board)):
                    print(""YES"")
                    return
                # Check columns
                if any(board[row][j] == 'x' for row in range(4)):
                    print(""YES"")
                    return
                # Check diagonals
                if (board[0][0] == 'x' and board[1][1] == 'x' and board[2][2] == 'x') or \
                   (board[1][1] == 'x' and board[2][2] == 'x' and board[3][3] == 'x') or \
                   (board[0][3] == 'x' and board[1][2] == 'x' and board[2][1] == 'x') or \
                   (board[1][2] == 'x' and board[2][1] == 'x' and board[3][0] == 'x'):
                    print(""YES"")
                    return
                board[i] = board[i][:j] + '.' + board[i][j+1:]
    
    print(""NO"")

solve()","
def solve():
    field = [input() for _ in range(4)]

    for i in range(4):
        for j in range(4):
            if field[i][j] == '.':
                field[i] = field[i][:j] + 'x' + field[i][j+1:]
                win = False
                for k in range(4):
                    if field[k].count('x') >= 3:
                        win = True
                        break
                    if [field[m][k] for m in range(4)].count('x') >= 3:
                        win = True
                        break
                if field[0][0] == 'x' and field[1][1] == 'x' and field[2][2] == 'x':
                    win = True
                if field[0][2] == 'x' and field[1][1] == 'x' and field[2][0] == 'x':
                    win = True
                field[i] = field[i][:j] + '.' + field[i][j+1:]
                if win:
                    print(""YES"")
                    return
    print(""NO"")

solve()","
def solve():
    field = [input() for _ in range(4)]

    for i in range(4):
        for j in range(4):
            if field[i][j] == '.':
                field[i] = field[i][:j] + 'x' + field[i][j+1:]
                rows = [field[i] for i in range(4)]
                cols = [''.join([field[i][j] for i in range(4)]) for j in range(4)]
                diags = [''.join([field[i][i] for i in range(4)]), ''.join([field[i][3-i] for i in range(4)])]
                win_lines = rows + cols + diags

                if 'xxx' in win_lines:
                    print(""YES"")
                    return

                field[i] = field[i][:j] + '.' + field[i][j+1:]

    print(""NO"")

solve()
","
def solve():
    board = [input() for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            if board[i][j] == '.':
                board[i] = board[i][:j] + 'x' + board[i][j+1:]
                if any(all(board[i][k] == 'x' for k in range(4)) for i in range(4)):
                    print(""YES"")
                    return
                if any(all(board[k][j] == 'x' for k in range(4)) for j in range(4)):
                    print(""YES"")
                    return
                if all(board[k][k] == 'x' for k in range(4)) or all(board[k][3-k] == 'x' for k in range(4)):
                    print(""YES"")
                    return
                board[i] = board[i][:j] + '.' + board[i][j+1:]
    
    print(""NO"")

solve()
","
def solve():
    field = [input() for _ in range(4)]

    # Check rows
    for row in field:
        if row.count('x') == 3 and row.count('.') == 1:
            print(""YES"")
            return

    # Check columns
    for c in range(4):
        if field[0][c] == 'x' and field[1][c] == 'x' and field[2][c] == 'x' and field[3][c] == '.':
            print(""YES"")
            return

    # Check diagonals
    if field[0][0] == 'x' and field[1][1] == 'x' and field[2][2] == 'x' and field[3][3] == '.':
        print(""YES"")
        return

    if field[0][3] == 'x' and field[1][2] == 'x' and field[2][1] == 'x' and field[3][0] == '.':
        print(""YES"")
        return

    print(""NO"")

solve()
","
def solve():
    board = [input() for _ in range(4)]

    for i in range(4):
        for j in range(4):
            if board[i][j] == '.':
                board[i] = board[i][:j] + 'x' + board[i][j+1:]
                result = check_win(board, 'x')
                board[i] = board[i][:j] + '.' + board[i][j+1:]
                if result:
                    print(""YES"")
                    return
    print(""NO"")

def check_win(board, player):
    for i in range(4):
        if board[i].count(player) == 3:
            return True
        if [board[j][i] for j in range(4)].count(player) == 3:
            return True
    if board[0][0] == board[1][1] == board[2][2] == player:
        return True
    if board[0][3] == board[1][2] == board[2][1] == player:
        return True
    return False

solve()
","
def solve():
    field = [input() for _ in range(4)]
    for i in range(4):
        for j in range(4):
            if field[i][j] == '.':
                field[i] = field[i][:j] + 'x' + field[i][j+1:]
                if any(all(field[i][j] == 'x' for j in range(4)) or
                       all(field[j][i] == 'x' for j in range(4)) or
                       all(field[j][j] == 'x' for j in range(4)) or
                       all(field[j][3-j] == 'x' for j in range(4)) for i in range(4)):
                    print(""YES"")
                    return
                field[i] = field[i][:j] + '.' + field[i][j+1:]
    print(""NO"")
  
solve()","
def solve():
    board = [input().strip() for _ in range(4)]

    for i in range(4):
        for j in range(4):
            if board[i][j] == '.':
                board[i] = board[i][:j] + 'x' + board[i][j+1:]
                if check_win(board):
                    print(""YES"")
                    return
                board[i] = board[i][:j] + '.' + board[i][j+1:]
    
    print(""NO"")

def check_win(board):
    for i in range(4):
        if board[i].count('x') >= 3:
            return True
        col = [board[j][i] for j in range(4)]
        if col.count('x') >= 3:
            return True
    if [board[i][i] for i in range(4)].count('x') >= 3:
        return True
    if [board[i][3-i] for i in range(4)].count('x') >= 3:
        return True
    return False

solve()
","
def solve():
    position = [input() for _ in range(4)]

    # Checking rows
    for row in position:
        if row.count('x') == 3 and row.count('.') == 1:
            print(""YES"")
            return

    # Checking columns
    for col in range(4):
        if position[0][col] == 'x' and position[1][col] == 'x' and position[2][col] == 'x' and position[3][col] == '.':
            print(""YES"")
            return

    # Checking diagonals
    if position[0][0] == 'x' and position[1][1] == 'x' and position[2][2] == 'x' and position[3][3] == '.':
        print(""YES"")
        return

    if position[0][3] == 'x' and position[1][2] == 'x' and position[2][1] == 'x' and position[3][0] == '.':
        print(""YES"")
        return

    print(""NO"")


solve()
","0.0","46.666666666666664","46.666666666666664","46.666666666666664","46.666666666666664","0.0","40.0","60.0","53.333333333333336","40.0","46.666666666666664","40.0","46.666666666666664","46.666666666666664","46.666666666666664","40.0","","","","","","","","","","","","","","","",""
"APPS/122","
QUESTION:
Vasya has an array a consisting of positive integer numbers. Vasya wants to divide this array into two non-empty consecutive parts (the prefix and the suffix) so that the sum of all elements in the first part equals to the sum of elements in the second part. It is not always possible, so Vasya will move some element before dividing the array (Vasya will erase some element and insert it into an arbitrary position).

Inserting an element in the same position he was erased from is also considered moving.

Can Vasya divide the array after choosing the right element to move and its new position?


-----Input-----

The first line contains single integer n (1 ≤ n ≤ 100000) — the size of the array.

The second line contains n integers a_1, a_2... a_{n} (1 ≤ a_{i} ≤ 10^9) — the elements of the array.


-----Output-----

Print YES if Vasya can divide the array after moving one element. Otherwise print NO.


-----Examples-----
Input
3
1 3 2

Output
YES

Input
5
1 2 3 4 5

Output
NO

Input
5
2 2 3 4 5

Output
YES



-----Note-----

In the first example Vasya can move the second element to the end of the array.

In the second example no move can make the division possible.

In the third example Vasya can move the fourth element by one position to the left.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    prefix_sum = 0
    suffix_sum = total_sum
    
    for i in range(n):
        prefix_sum += a[i]
        suffix_sum -= a[i]
        
        if prefix_sum == suffix_sum:
            print(""YES"")
            return
    
    for i in range(n-1):
        prefix_sum -= a[i]
        suffix_sum += a[i]
        
        if prefix_sum == suffix_sum:
            print(""YES"")
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    prefix_sum = 0
    suffix_sum = total_sum

    for i in range(n-1):
        prefix_sum += a[i]
        suffix_sum -= a[i]

        if prefix_sum == suffix_sum or prefix_sum == suffix_sum - a[i+1] or prefix_sum - a[i] == suffix_sum:
            print(""YES"")
            return
            
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    prefix_sum = 0
    for i in range(n):
        prefix_sum += a[i]
        if prefix_sum * 3 == total_sum:
            print(""YES"")
            return
        
    suffix_sum = 0
    for i in range(n - 1, -1, -1):
        suffix_sum += a[i]
        if suffix_sum * 3 == total_sum:
            print(""YES"")
            return
    
    print(""NO"")

# Call the function to solve the problem
solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_sum = sum(a)

    prefix_sum = 0
    for i in range(n):
        prefix_sum += a[i]
        suffix_sum = total_sum - prefix_sum

        if prefix_sum == suffix_sum:
            if i == n-1 or a[i] != a[i+1]:  # Check if the element at index i can be moved to a different position
                print(""YES"")
                return

    print(""NO"")


solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    left_sum = 0
    right_sum = total_sum

    for i in range(n-1):
        left_sum += a[i]
        right_sum -= a[i]
        if left_sum == right_sum or left_sum + a[i] == right_sum or left_sum == right_sum + a[i]:
            print(""YES"")
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_sum = sum(a)
    left_sum = 0
    right_sum = total_sum

    for i in range(n - 1):
        left_sum += a[i]
        right_sum -= a[i]
        if left_sum == right_sum or left_sum + a[i] == right_sum + a[i+1]:
            print(""YES"")
            return
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    prefix_sum = 0
    suffix_sum = sum(a)

    for i in range(n):
        prefix_sum += a[i]
        suffix_sum -= a[i]

        if prefix_sum == suffix_sum:
            print(""YES"")
            return

    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_sum = sum(a)
    prefix_sum = 0
    for i in range(n):
        prefix_sum += a[i]
        suffix_sum = total_sum - prefix_sum

        if prefix_sum == suffix_sum or (i < n-1 and prefix_sum + a[i+1] == suffix_sum) or (i > 0 and prefix_sum - a[i-1] == suffix_sum):
            print(""YES"")
            return

    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    prefix_sum = 0
    for i in range(n):
        prefix_sum += a[i]
        if prefix_sum * 2 == total_sum or (prefix_sum == total_sum // 2 and total_sum % 2 == 0) or (i < n - 1 and prefix_sum + a[i+1] == total_sum - prefix_sum):
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_sum = sum(a)
    prefix_sum = 0
    suffix_sum = total_sum

    for i in range(n):
        prefix_sum += a[i]
        suffix_sum -= a[i]
        if prefix_sum == suffix_sum:
            if i == n-1:
                print(""NO"")
            else:
                if a[i] == a[i+1]:
                    print(""YES"")
                else:
                    print(""YES"")
            return
    print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_sum = sum(a)
    left_sum = 0
    for i in range(n):
        left_sum += a[i]
        right_sum = total_sum - left_sum
        if left_sum == right_sum or left_sum + a[i] == right_sum or left_sum == right_sum + a[i]:
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    from sys import stdin

    def check_if_vasya_can_divide_array(n, arr):
        total_sum = sum(arr)
        prefix_sum = 0
        for i in range(n):
            prefix_sum += arr[i]
            suffix_sum = total_sum - prefix_sum
            if prefix_sum == suffix_sum or prefix_sum + arr[i] == suffix_sum or prefix_sum == suffix_sum + arr[i]:
                return True
        return False

    n = int(stdin.readline().strip())
    arr = list(map(int, stdin.readline().split()))

    if check_if_vasya_can_divide_array(n, arr):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_sum = sum(a)
    prefix_sum = 0
    suffix_sum = total_sum

    for i in range(n):
        prefix_sum += a[i]
        suffix_sum -= a[i]

        if prefix_sum == suffix_sum or prefix_sum == suffix_sum + a[i] or prefix_sum + a[i] == suffix_sum:
            print(""YES"")
            return

    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    left_sum = 0
    right_sum = total_sum
    for i in range(n):
        left_sum += a[i]
        right_sum -= a[i]
        if left_sum == right_sum or left_sum == right_sum + a[i] or left_sum + a[i] == right_sum:
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    prefix_sum = a[0]
    suffix_sum = sum(a[1:])

    move_possible = False

    for i in range(1, n-1):
        if prefix_sum == suffix_sum:
            move_possible = True
            break

        prefix_sum += a[i]
        suffix_sum -= a[i]

    if move_possible or prefix_sum == suffix_sum:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    prefix_sum = 0
    suffix_sum = total_sum
    
    for i in range(n):
        prefix_sum += a[i]
        suffix_sum -= a[i]
        
        if prefix_sum == suffix_sum or prefix_sum == suffix_sum + a[i+1] or prefix_sum + a[i] == suffix_sum:
            print(""YES"")
            return
    
    print(""NO"")

solve()
","80.0","73.33333333333333","66.66666666666666","73.33333333333333","60.0","80.0","80.0","73.33333333333333","73.33333333333333","80.0","60.0","60.0","60.0","60.0","80.0","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/123","
QUESTION:
A few years ago, Hitagi encountered a giant crab, who stole the whole of her body weight. Ever since, she tried to avoid contact with others, for fear that this secret might be noticed.

To get rid of the oddity and recover her weight, a special integer sequence is needed. Hitagi's sequence has been broken for a long time, but now Kaiki provides an opportunity.

Hitagi's sequence a has a length of n. Lost elements in it are denoted by zeros. Kaiki provides another sequence b, whose length k equals the number of lost elements in a (i.e. the number of zeros). Hitagi is to replace each zero in a with an element from b so that each element in b should be used exactly once. Hitagi knows, however, that, apart from 0, no integer occurs in a and b more than once in total.

If the resulting sequence is not an increasing sequence, then it has the power to recover Hitagi from the oddity. You are to determine whether this is possible, or Kaiki's sequence is just another fake. In other words, you should detect whether it is possible to replace each zero in a with an integer from b so that each integer from b is used exactly once, and the resulting sequence is not increasing.


-----Input-----

The first line of input contains two space-separated positive integers n (2 ≤ n ≤ 100) and k (1 ≤ k ≤ n) — the lengths of sequence a and b respectively.

The second line contains n space-separated integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 200) — Hitagi's broken sequence with exactly k zero elements.

The third line contains k space-separated integers b_1, b_2, ..., b_{k} (1 ≤ b_{i} ≤ 200) — the elements to fill into Hitagi's sequence.

Input guarantees that apart from 0, no integer occurs in a and b more than once in total.


-----Output-----

Output ""Yes"" if it's possible to replace zeros in a with elements in b and make the resulting sequence not increasing, and ""No"" otherwise.


-----Examples-----
Input
4 2
11 0 0 14
5 4

Output
Yes

Input
6 1
2 3 0 8 9 10
5

Output
No

Input
4 1
8 94 0 4
89

Output
Yes

Input
7 7
0 0 0 0 0 0 0
1 2 3 4 5 6 7

Output
Yes



-----Note-----

In the first sample:   Sequence a is 11, 0, 0, 14.  Two of the elements are lost, and the candidates in b are 5 and 4.  There are two possible resulting sequences: 11, 5, 4, 14 and 11, 4, 5, 14, both of which fulfill the requirements. Thus the answer is ""Yes"". 

In the second sample, the only possible resulting sequence is 2, 3, 5, 8, 9, 10, which is an increasing sequence and therefore invalid.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))
    
    zeros = [i for i in range(n) if a[i] == 0]
    a_sorted = sorted(a)
    
    for i in range(k):
        a[zeros[i]] = b[i]
    
    if a != a_sorted and a != a_sorted[::-1]:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))

    zero_indices = [i for i, x in enumerate(a) if x == 0]

    valid_sequences = set()

    from itertools import permutations

    for permutation in permutations(b):
        temp_a = a[:]
        for i, j in zip(zero_indices, permutation):
            temp_a[i] = j
        if not all(temp_a[i] < temp_a[i+1] for i in range(n-1)):
            valid_sequences.add(tuple(temp_a))

    if valid_sequences:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))

    zeros_indices = [index for index, value in enumerate(a) if value == 0]

    if len(zeros_indices) != k:
        print(""No"")
    else:
        for i, zero_index in enumerate(zeros_indices):
            a[zero_index] = b[i]

        if a != sorted(a):
            print(""Yes"")
        else:
            print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    zero_indices = [i for i, num in enumerate(a) if num == 0]
    a_sorted = sorted(b)
    
    for i, zero_index in enumerate(zero_indices):
        a[zero_index] = a_sorted[i]
    
    if a != sorted(a):
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))

    zeros_positions = [i for i in range(n) if a[i] == 0]

    for i, pos in enumerate(zeros_positions):
        a[pos] = b[i]

    if a == sorted(a):
        print(""No"")
    else:
        print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))

    zeros_indices = [i for i, num in enumerate(a) if num == 0]
    zeros_values = [b.pop() for _ in range(k)]

    for idx, val in zip(zeros_indices, zeros_values):
        a[idx] = val

    if a == sorted(a):
        print(""No"")
    else:
        print(""Yes"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))

    zeros = [idx for idx, val in enumerate(a) if val == 0]
    result_sequence = a[:]
    
    for i, zero_idx in enumerate(zeros):
        result_sequence[zero_idx] = b[i]
    
    if result_sequence != sorted(result_sequence):
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    zeros_indices = [i for i, num in enumerate(a) if num == 0]

    a_sorted = sorted(a)
    res = 'Yes'

    if len(zeros_indices) == 1:
        if a_sorted.index(b[0]) == 0 or a_sorted.index(b[0]) == (n-1):
            res = 'Yes'
        elif a_sorted[a.index(0)-1] < b[0] or a_sorted[a.index(0)+1] > b[0]:
            res = 'Yes'
        else:
            res = 'No'
    else:
        if a_sorted[:a.index(0)] < sorted(b) or a_sorted[a.index(0)+1:] < sorted(b):
            res = 'Yes'
        else:
            res = 'No'
    
    print(res)

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))
    
    zero_indices = [i for i in range(n) if a[i] == 0]
    possible_permutations = itertools.permutations(b)
    
    for perm in possible_permutations:
        temp_a = a.copy()
        for i in range(len(zero_indices)):
            temp_a[zero_indices[i]] = perm[i]
        if not all(temp_a[i] < temp_a[i+1] for i in range(len(temp_a)-1)):
            print(""Yes"")
            return
    print(""No"")

solve()","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))

    zeros = [i for i in range(n) if a[i] == 0]

    for i in range(len(zeros)):
        a[zeros[i]] = b[i]

    if a == sorted(a):
        print(""No"")
    else:
        print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    zeros = [i for i in range(n) if a[i] == 0]
    
    used = [False] * k
    result = 'No'

    def is_valid(sequence):
        for i in range(1, len(sequence)):
            if sequence[i] <= sequence[i - 1]:
                return False
        return True

    def backtrack(index, sequence):
        nonlocal result
        if index == len(zeros):
            if not is_valid(sequence):
                result = 'Yes'
            return
        for i in range(k):
            if not used[i]:
                used[i] = True
                sequence[zeros[index]] = b[i]
                backtrack(index + 1, sequence)
                used[i] = False

    backtrack(0, a)
    
    print(result)

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))

    zero_indices = [i for i, num in enumerate(a) if num == 0]

    result = 'Yes'
    for i, index in enumerate(zero_indices):
        a[index] = b[i]
    
    for i in range(1, n):
        if a[i] <= a[i-1]:
            result = 'No'
            break

    print(result)

solve()
","
python
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    a_zeros = [i for i in a if i == 0]
    a_non_zeros = [i for i in a if i != 0]
    b.sort(reverse=True)

    for i in range(len(a_zeros)):
        a[a.index(0)] = b[i]

    if a != sorted(a) and a != sorted(a, reverse=True):
        print(""Yes"")
    else:
        print(""No"")

# Example usage
solve()

","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))
    
    zero_indices = [i for i, num in enumerate(a) if num == 0]
    a_sorted = sorted(a)
    
    for idx, num in zip(zero_indices, b):
        a[idx] = num
    
    if a != a_sorted and a != sorted(a, reverse=True):
        print(""Yes"")
    else:
        print(""No"")

solve()","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = sorted(list(map(int, input().split())))
    
    zeros_indices = [i for i in range(n) if a[i] == 0]
    a_copy = a.copy()
    
    for i in range(k):
        a_copy[zeros_indices[i]] = b[i]
    
    if a_copy != sorted(a_copy) and a_copy != sorted(a_copy, reverse=True):
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    zeros_count = a.count(0)
    a_sorted = sorted(a)
    
    if zeros_count == 1:
        for i in range(n):
            if a[i] == 0:
                a[i] = b[0]
    else:
        for i in range(zeros_count):
            a[a.index(0)] = b[i]
    
    if a != a_sorted:
        print(""Yes"")
    else:
        print(""No"")

solve()
","60.0","100.0","86.66666666666667","86.66666666666667","86.66666666666667","100.0","86.66666666666667","20.0","0.0","86.66666666666667","100.0","13.333333333333334","0.0","60.0","86.66666666666667","60.0","","","","","","","","","","","","","","","",""
"APPS/124","
QUESTION:
The Duck song

For simplicity, we'll assume that there are only three types of grapes: green grapes, purple grapes and black grapes.

Andrew, Dmitry and Michal are all grapes' lovers, however their preferences of grapes are different. To make all of them happy, the following should happen: Andrew, Dmitry and Michal should eat at least $x$, $y$ and $z$ grapes, respectively. Andrew has an extreme affinity for green grapes, thus he will eat green grapes and green grapes only. On the other hand, Dmitry is not a fan of black grapes — any types of grapes except black would do for him. In other words, Dmitry can eat green and purple grapes. Michal has a common taste — he enjoys grapes in general and will be pleased with any types of grapes, as long as the quantity is sufficient.

Knowing that his friends are so fond of grapes, Aki decided to host a grape party with them. He has prepared a box with $a$ green grapes, $b$ purple grapes and $c$ black grapes.

However, Aki isn't sure if the box he prepared contains enough grapes to make everyone happy. Can you please find out whether it's possible to distribute grapes so that everyone is happy or Aki has to buy some more grapes?

It is not required to distribute all the grapes, so it's possible that some of them will remain unused.


-----Input-----

The first line contains three integers $x$, $y$ and $z$ ($1 \le x, y, z \le 10^5$) — the number of grapes Andrew, Dmitry and Michal want to eat.

The second line contains three integers $a$, $b$, $c$ ($1 \le a, b, c \le 10^5$) — the number of green, purple and black grapes in the box.


-----Output-----

If there is a grape distribution that allows everyone to be happy, print ""YES"", otherwise print ""NO"".


-----Examples-----
Input
1 6 2
4 3 3

Output
YES

Input
5 1 1
4 3 2

Output
NO



-----Note-----

In the first example, there is only one possible distribution:

Andrew should take $1$ green grape, Dmitry should take $3$ remaining green grapes and $3$ purple grapes, and Michal will take $2$ out of $3$ available black grapes.

In the second test, there is no possible distribution, since Andrew is not be able to eat enough green grapes. :(
Use user-input-Based format and function signature solve()","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x and a + b >= x + y and a + b + c >= x + y + z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())

    if x <= a and x + y <= a + b and x + y + z <= a + b + c:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x and a + b >= x + y and a + b + c >= x + y + z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x:
        a -= x
    else:
        return ""NO""
    
    if a + b >= y:
        b -= max(0, y - a)
    else:
        return ""NO""
    
    if a + b + c >= z:
        return ""YES""
    else:
        return ""NO""

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    green_needed = x
    purple_needed = y
    black_needed = z
    
    green_available = a
    purple_available = b
    black_available = c
    
    green_extra = max(0, green_available - green_needed)
    purple_extra = max(0, purple_available - max(purple_needed, y + z))
    black_extra = max(0, black_available - max(black_needed, z))
    
    if green_extra + purple_extra + black_extra >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x and a + b >= x + y and a + b + c >= x + y + z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    # Check if there are enough grapes for each person's preferences
    if x <= a and y <= a + b - x and z <= b + c:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x and a + b >= x + y and a + b + c >= x + y + z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())

    if x <= a and x + y <= a + b and x + y + z <= a + b + c:
        print(""YES"")
    else:
        print(""NO"")

solve()
 ","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())

    if x <= a and x + y <= a + b and x + y + z <= a + b + c:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if x <= a and x + y <= a + b and x + y + z <= a + b + c:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x and a + b >= x + y and a + b + c >= x + y + z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x and (a-x) + b >= y and (a-x) + b + c >= y + z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if x <= a and y <= a + b - x and z <= a + b + c - x - y:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())
    
    if a >= x and a + b - x >= y and a + b + c - x - y >= z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    x, y, z = map(int, input().split())
    a, b, c = map(int, input().split())

    if a >= x and a + b >= x + y and a + b + c >= x + y + z:
        print(""YES"")
    else:
        print(""NO"")

solve()
","100.0","100.0","100.0","0.0","40.0","100.0","93.33333333333333","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/125","
QUESTION:
Sagheer is walking in the street when he comes to an intersection of two roads. Each road can be represented as two parts where each part has 3 lanes getting into the intersection (one for each direction) and 3 lanes getting out of the intersection, so we have 4 parts in total. Each part has 4 lights, one for each lane getting into the intersection (l — left, s — straight, r — right) and a light p for a pedestrian crossing.  [Image] 

An accident is possible if a car can hit a pedestrian. This can happen if the light of a pedestrian crossing of some part and the light of a lane that can get to or from that same part are green at the same time.

Now, Sagheer is monitoring the configuration of the traffic lights. Your task is to help him detect whether an accident is possible.


-----Input-----

The input consists of four lines with each line describing a road part given in a counter-clockwise order.

Each line contains four integers l, s, r, p — for the left, straight, right and pedestrian lights, respectively. The possible values are 0 for red light and 1 for green light.


-----Output-----

On a single line, print ""YES"" if an accident is possible, and ""NO"" otherwise.


-----Examples-----
Input
1 0 0 1
0 1 0 0
0 0 1 0
0 0 0 1

Output
YES

Input
0 1 1 0
1 0 1 0
1 1 0 0
0 0 0 1

Output
NO

Input
1 0 0 0
0 0 0 1
0 0 0 0
1 0 1 0

Output
NO



-----Note-----

In the first example, some accidents are possible because cars of part 1 can hit pedestrians of parts 1 and 4. Also, cars of parts 2 and 3 can hit pedestrians of part 4.

In the second example, no car can pass the pedestrian crossing of part 4 which is the only green pedestrian light. So, no accident can occur.
Use user-input-Based format and function signature solve()","
def solve():
    lights = []
    for _ in range(4):
        lights.append(list(map(int, input().split())))

    for i in range(4):
        for j in range(4):
            if lights[i][j] == 1:
                if lights[i][3] == 1 or lights[j][3] == 1:
                    print(""YES"")
                    return
    print(""NO"")

solve()
","
def solve():
    intersection = [list(map(int, input().split())) for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            if intersection[i][3] == 1 and (intersection[j][0] == 1 or intersection[j][1] == 1 or intersection[j][2] == 1):
                print(""YES"")
                return
    
    print(""NO"")

# Call the function to execute
solve()
","
def solve():
    lights = []
    for _ in range(4):
        lights.append(list(map(int, input().split())))
    
    accidents_possible = False
    for i in range(4):
        if lights[i][3]:
            for j in range(4):
                if j != i and (lights[j][0] or lights[j][1] or lights[j][2]):
                    accidents_possible = True
                    break
            if accidents_possible:
                break
    
    if accidents_possible:
        print(""YES"")
    else:
        print(""NO"")

# Call the function to solve the problem
solve()
","
def solve():
    lights = []
    
    for _ in range(4):
        lights.append(list(map(int, input().split())))
    
    for i in range(4):
        for j in range(4):
            if i != j and (lights[i][3] == 1) and (lights[j][0] == 1 or lights[j][1] == 1 or lights[j][2] == 1 or lights[j][3] == 1):
                print(""YES"")
                return
    
    print(""NO"")

solve()
","
def solve():
    lights = []
    for _ in range(4):
        lights.append(list(map(int, input().split())))

    accidents_possible = False
    for i in range(4):
        for j in range(4):
            if lights[i][3] == 1 and (lights[j][0] == 1 or lights[j][1] == 1 or lights[j][2] == 1):
                accidents_possible = True
                break

    if accidents_possible:
        print(""YES"")
    else:
        print(""NO"")

# Call the function to solve the problem
solve()
","
def solve():
    lights = []
    for _ in range(4):
        lights.append(list(map(int, input().split())))

    possible_accident = False
    for i in range(4):
        for j in range(4):
            if lights[i][j] == 1 and (lights[i][(j+3)%4] == 1 or lights[(i+1)%4][(j+1)%4] == 1):
                possible_accident = True
                break
    
    if possible_accident:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    lights = []
    for _ in range(4):
        lights.append(list(map(int, input().split())))

    for i in range(4):
        for j in range(4):
            if lights[i][3] == 1 and (lights[j][0] == 1 or lights[j][1] == 1 or lights[j][2] == 1):
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    lights = [list(map(int, input().split())) for _ in range(4)]
    
    for i in range(4):
        if lights[i][3] == 1:
            for j in range(4):
                if i != j and (lights[j][0] == 1 or lights[j][1] == 1 or lights[j][2] == 1):
                    print(""YES"")
                    return
    print(""NO"")

solve()
","
def solve():
    parts = [input().split() for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            if parts[i][3] == '1' and (parts[i][j] == '1' or parts[(i+1)%4][j] == '1'):
                print(""YES"")
                return
    
    print(""NO"")

solve()
","
def solve():
    roads = []
    for _ in range(4):
        lights = list(map(int, input().split()))
        roads.append(lights)
    
    for i in range(4):
        for j in range(4):
            if roads[i][j] == 1:
                if roads[i][3] == 1 or roads[(i+1)%4][3] == 1 or roads[(i-1)%4][3] == 1:
                    print(""YES"")
                    return
    print(""NO"")

solve()
","
def solve():
    inputs = [list(map(int, input().split())) for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            if inputs[i][-1] == 1 and (inputs[i][j] == 1 or inputs[(i+1)%4][j] == 1):
                print(""YES"")
                return
    
    print(""NO"")

solve()
","
def solve():
    lights = [list(map(int, input().split())) for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            if lights[i][j] == 1:
                pedestrian_light = lights[i][3]
                car_light = lights[j][3]
                if pedestrian_light == 1 and car_light == 1:
                    print(""YES"")
                    return
    print(""NO"")

solve()
","
def solve():
    accidents_possible = False
    lights = [list(map(int, input().split())) for _ in range(4)]

    for i in range(4):
        for j in range(4):
            if lights[i][j] == 1 and (lights[i][3] == 1 or lights[j][3] == 1):
                accidents_possible = True
                break
      
    if accidents_possible:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    lights = []
    for _ in range(4):
        lights.append(list(map(int, input().split())))

    for i in range(4):
        for j in range(4):
            if lights[i][3] == 1 and (lights[i][j] == 1 or lights[(i+1)%4][j] == 1 or lights[(i+2)%4][j] == 1 or lights[(i+3)%4][j] == 1):
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    traffic_lights = []
    for _ in range(4):
        lights = list(map(int, input().split()))
        traffic_lights.append(lights)
    
    possible_accident = False
    for i in range(4):
        pedestrian_light = traffic_lights[i][3]
        for j in range(4):
            if traffic_lights[j][0] == 1 and pedestrian_light == 1:
                possible_accident = True
    
    if possible_accident:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    lights = []
    for _ in range(4):
        lights.append(list(map(int, input().split())))

    for i in range(4):
        if lights[i][3] == 1:
            for j in range(4):
                if i != j and (lights[j][0] == 1 or lights[j][1] == 1 or lights[j][2] == 1):
                    print(""YES"")
                    return
    print(""NO"")

solve()
","53.333333333333336","66.66666666666666","66.66666666666666","53.333333333333336","66.66666666666666","80.0","66.66666666666666","66.66666666666666","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","73.33333333333333","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/126","
QUESTION:
While swimming at the beach, Mike has accidentally dropped his cellphone into the water. There was no worry as he bought a cheap replacement phone with an old-fashioned keyboard. The keyboard has only ten digital equal-sized keys, located in the following way: [Image] 

Together with his old phone, he lost all his contacts and now he can only remember the way his fingers moved when he put some number in. One can formally consider finger movements as a sequence of vectors connecting centers of keys pressed consecutively to put in a number. For example, the finger movements for number ""586"" are the same as finger movements for number ""253"": [Image]  [Image] 

Mike has already put in a number by his ""finger memory"" and started calling it, so he is now worrying, can he be sure that he is calling the correct number? In other words, is there any other number, that has the same finger movements?


-----Input-----

The first line of the input contains the only integer n (1 ≤ n ≤ 9) — the number of digits in the phone number that Mike put in.

The second line contains the string consisting of n digits (characters from '0' to '9') representing the number that Mike put in.


-----Output-----

If there is no other phone number with the same finger movements and Mike can be sure he is calling the correct number, print ""YES"" (without quotes) in the only line.

Otherwise print ""NO"" (without quotes) in the first line.


-----Examples-----
Input
3
586

Output
NO

Input
2
09

Output
NO

Input
9
123456789

Output
YES

Input
3
911

Output
YES



-----Note-----

You can find the picture clarifying the first sample case in the statement above.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    number = input()

    same_finger_movements = {
        '1': '789',
        '2': '689',
        '3': '578',
        '4': '689',
        '5': '347',
        '6': '125',
        '7': '389',
        '8': '147',
        '9': '236',
        '0': '689'
    }

    for _ in range(n - 1):
        if same_finger_movements[number[_]] == same_finger_movements[number[_ + 1]]:
            continue
        else:
            print(""NO"")
            return

    print(""YES"")

solve()","
def solve():
    n = int(input())
    number = input()

    possible_moves = {
        '1': ['2', '4'],
        '2': ['1', '3', '5'],
        '3': ['2', '6'],
        '4': ['1', '5', '7'],
        '5': ['2', '4', '6', '8'],
        '6': ['3', '5', '9'],
        '7': ['4', '8'],
        '8': ['5', '7', '9'],
        '9': ['6', '8'],
        '0': ['0']
    }

    def dfs(idx, prev_key):
        if idx == n:
            return True
        
        for key in possible_moves[prev_key]:
            if key == number[idx]:
                if dfs(idx + 1, key):
                    return True
        return False

    if dfs(0, ""0""):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    number = input()
    
    valid_numbers = {'1': ['1', '2', '4'], 
                     '2': ['1', '2', '3', '5'],
                         '3': ['2', '3', '6'],
                         '4': ['1', '4', '5', '7'],
                         '5': ['2', '4', '5', '6', '8'],
                         '6': ['3', '5', '6', '9'],
                         '7': ['4', '7', '8'],
                         '8': ['5', '7', '8', '9', '0'],
                         '9': ['6', '8', '9'],
                         '0': ['0', '8']}
    
    movements = [valid_numbers[number[0]]]
    
    for i in range(1, n):
        new_movements = []
        
        for num in valid_numbers[number[i]]:
            for move in movements[-1]:
                new_movements.append(move + num)
                
        movements.append(new_movements)
    
    if any(x[::-1] == number for x in movements[-1]):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    digits = input().strip()
    
    valid_movements = {
        '1': ['2', '4'],
        '2': ['1', '3', '5'],
        '3': ['2', '6'],
        '4': ['1', '5', '7'],
        '5': ['2', '4', '6', '8'],
        '6': ['3', '5', '9'],
        '7': ['4', '8'],
        '8': ['5', '7', '9'],
        '9': ['6', '8'],
        '0': ['5'],
    }
    
    for i in range(n - 1):
        current_digit = digits[i]
        next_digit = digits[i + 1]
        
        if next_digit not in valid_movements[current_digit]:
            print(""NO"")
            return
    
    print(""YES"")

solve()
","
def solve():
    n = int(input())
    number = input()
    
    mapping = {
        '1': (0, 0), '2': (0, 1), '3': (0, 2),
        '4': (1, 0), '5': (1, 1), '6': (1, 2),
        '7': (2, 0), '8': (2, 1), '9': (2, 2),
        '0': (3, 1)
    }
    
    movements = [mapping[number[0]]]
    
    for i in range(1, n):
        curr_pos = mapping[number[i]]
        prev_pos = movements[-1]
        
        x_diff = curr_pos[0] - prev_pos[0]
        y_diff = curr_pos[1] - prev_pos[1]
        
        movements.append((prev_pos[0] + x_diff, prev_pos[1] + y_diff))
    
    unique_movements = set(movements)
    
    if len(movements) == len(unique_movements):
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n = int(input())
    number = input()

    movements_map = {
        '1': '.', '2': '0', '3': '1', '4': '2',
        '5': '3', '6': '4', '7': '5', '8': '6',
        '9': '7', '0': '8'
    }

    original_finger_movement = []

    for i in range(n - 1):
        original_finger_movement.append(movements_map[number[i]] + movements_map[number[i+1]])

    if len(set(original_finger_movement)) == len(original_finger_movement):
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n = int(input())
    number = input()
    valid_numbers = [""123"", ""147"", ""159"", ""258"", ""357"", ""369"", ""456"", ""789"", ""951"", ""753""]
    
    for valid_number in valid_numbers:
        if number in valid_number or number == valid_number:
            print(""YES"")
            return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    number = input().strip()
    
    corresponding_numbers = {'1': ['1', '2', '4'], '2': ['1', '2', '3', '5'], '3': ['2', '3', '6'],
                             '4': ['1', '4', '5', '7'], '5': ['2', '4', '5', '6', '8'],
                             '6': ['3', '5', '6', '9'], '7': ['4', '7', '8'], '8': ['5', '7', '8', '9', '0'],
                             '9': ['6', '8', '9'], '0': ['0', '8']}
    
    def generate_possible_numbers(pos, number):
        if pos == len(number):
            return [""""]
        
        result = []
        possibilities = corresponding_numbers[number[pos]]
        for next_number in possibilities:
            next_results = generate_possible_numbers(pos + 1, number)
            for res in next_results:
                result.append(next_number + res)
        
        return result
    
    possible_numbers = generate_possible_numbers(0, number)
    possible_numbers = list(set(possible_numbers))
    
    if len(possible_numbers) == 1 and possible_numbers[0] == number:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    number = input()

    movements = {'1': (0, 0), '2': (0, 1), '3': (0, 2),
                 '4': (1, 0), '5': (1, 1), '6': (1, 2),
                 '7': (2, 0), '8': (2, 1), '9': (2, 2), '0': (2, 0)}

    finger_movements = []
    for i in range(n-1):
        start = movements[number[i]]
        end = movements[number[i+1]]
        finger_movements.append((end[0] - start[0], end[1] - start[1]))

    unique_movements = set(finger_movements)

    if len(finger_movements) == len(unique_movements):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    number = input()

    finger_movements = {'1': '124578', '2': '1234567890', '3': '234579', '4': '14780', '5': '245689', '6': '35690', '7': '4578', '8': '57890', '9': '689', '0': '2580'}

    movements = [finger_movements[num] for num in number]

    movements_set = set(movements)

    if len(movements) == len(movements_set):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    number = input()
    
    unique_movements = set()
    unique_movements.add('123')
    unique_movements.add('147')
    unique_movements.add('159')
    unique_movements.add('258')
    unique_movements.add('357')
    unique_movements.add('369')
    unique_movements.add('456')
    unique_movements.add('789')

    for _ in range(n-1):
        if number[_] + number[_+1] not in unique_movements:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n = int(input())
    number = input().strip()

    valid_numbers = ['123', '147', '258', '369', '321', '741', '852', '963', '987', '951']

    if number in valid_numbers:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
# Define the function
def solve():
    # Input
    n = int(input())
    number = input()

    valid_numbers = {
        '1': ['6', '8'],
        '2': ['7', '9'],
        '3': ['4', '8'],
        '4': ['3', '9', '0'],
        '5': [],
        '6': ['1', '7', '0'],
        '7': ['2', '6'],
        '8': ['1', '3'],
        '9': ['2', '4'],
        '0': ['4', '6']
    }

    # Check if the number can be called with finger memory
    for i in range(n):
        digit = number[i]
        if any(number[i] not in valid_numbers[digit] for i in range(len(number))):
            print(""NO"")
            return

    print(""YES"")

# Call the function
solve()
","
def solve():
    n = int(input())
    number = input()

    same_finger_movements = {
        '1': '789',
        '2': '689',
        '3': '578',
        '4': '689',
        '5': '347',
        '6': '129',
        '7': '1458',
        '8': '23569',
        '9': '478',
        '0': '69'
    }

    finger_movement = ''
    for digit in number:
        finger_movement += same_finger_movements[digit]

    for i in range(10):
        if all(str(i) in finger_movement for i in range(10)):
            print(""YES"")
            return
    print(""NO"")
  
solve()","
def solve():
    n = int(input())
    number = input()
    
    patterns = {
        ""1"": ""789"", ""2"": ""689"", ""3"": ""578"", ""4"": ""679"", ""5"": ""478"", 
        ""6"": ""5789"", ""7"": ""1248"", ""8"": ""3579"", ""9"": ""2368"", ""0"": ""47""
    }
    
    fingerprint = """"
    for digit in number:
        fingerprint += patterns[digit]
    
    all_numbers = set()
    for i in range(10**n):
        current_number = str(i).zfill(n)
        current_fingerprint = """"
        for digit in current_number:
            current_fingerprint += patterns[digit]
        
        all_numbers.add(current_fingerprint)
    
    if len(all_numbers) == 10**n:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    number = input().strip()

    correct_sequences = {
        '1': '1258',
        '2': '123568',
        '3': '2369',
        '4': '1457',
        '5': '245689',
        '6': '356',
        '7': '478',
        '8': '57890',
        '9': '689',
        '0': '80'
    }

    sequence = ''
    for digit in number:
        sequence += correct_sequences[digit]

    is_unique = True
    for digit, seq in correct_sequences.items():
        if digit != number[0] and sequence == seq:
            is_unique = False
            break

    if is_unique:
        print(""YES"")
    else:
        print(""NO"")

solve()","53.333333333333336","53.333333333333336","46.666666666666664","60.0","33.33333333333333","40.0","73.33333333333333","66.66666666666666","46.666666666666664","33.33333333333333","60.0","66.66666666666666","66.66666666666666","66.66666666666666","30.76923076923077","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/127","
QUESTION:
Summer holidays! Someone is going on trips, someone is visiting grandparents, but someone is trying to get a part-time job. This summer Noora decided that she wants to earn some money, and took a job in a shop as an assistant.

Shop, where Noora is working, has a plan on the following n days. For each day sales manager knows exactly, that in i-th day k_{i} products will be put up for sale and exactly l_{i} clients will come to the shop that day. Also, the manager is sure, that everyone, who comes to the shop, buys exactly one product or, if there aren't any left, leaves the shop without buying anything. Moreover, due to the short shelf-life of the products, manager established the following rule: if some part of the products left on the shelves at the end of the day, that products aren't kept on the next day and are sent to the dump.

For advertising purposes manager offered to start a sell-out in the shop. He asked Noora to choose any f days from n next for sell-outs. On each of f chosen days the number of products were put up for sale would be doubled. Thus, if on i-th day shop planned to put up for sale k_{i} products and Noora has chosen this day for sell-out, shelves of the shop would keep 2·k_{i} products. Consequently, there is an opportunity to sell two times more products on days of sell-out.

Noora's task is to choose f days to maximize total number of sold products. She asks you to help her with such a difficult problem.


-----Input-----

The first line contains two integers n and f (1 ≤ n ≤ 10^5, 0 ≤ f ≤ n) denoting the number of days in shop's plan and the number of days that Noora has to choose for sell-out.

Each line of the following n subsequent lines contains two integers k_{i}, l_{i} (0 ≤ k_{i}, l_{i} ≤ 10^9) denoting the number of products on the shelves of the shop on the i-th day and the number of clients that will come to the shop on i-th day.


-----Output-----

Print a single integer denoting the maximal number of products that shop can sell.


-----Examples-----
Input
4 2
2 1
3 5
2 3
1 5

Output
10
Input
4 1
0 2
0 3
3 5
0 6

Output
5


-----Note-----

In the first example we can choose days with numbers 2 and 4 for sell-out. In this case new numbers of products for sale would be equal to [2, 6, 2, 2] respectively. So on the first day shop will sell 1 product, on the second — 5, on the third — 2, on the fourth — 2. In total 1 + 5 + 2 + 2 = 10 product units.

In the second example it is possible to sell 5 products, if you choose third day for sell-out.
Use user-input-Based format and function signature solve()","
def solve():
    n, f = map(int, input().split())
    products = []
    for _ in range(n):
        k, l = map(int, input().split())
        products.append((k, l))
    
    total_sold = 0
    extra_products = []
    for k, l in products:
        if k >= l:
            total_sold += l
        else:
            total_sold += k
            extra_products.append(min(k, l - k))
    
    extra_products.sort(reverse=True)
    for i in range(min(f, len(extra_products))):
        total_sold += extra_products[i]
    
    print(total_sold)

solve()
","
def solve():
    n, f = map(int, input().split())
    days = [list(map(int, input().split())) for _ in range(n)]
    
    total_sold = 0
    extra_products = []
    for k, l in days:
        normal_sales = min(k, l)
        double_sales = min(2*k, l)
        total_sold += max(normal_sales, double_sales)
        extra_products.append(min(2*k - k, l - normal_sales))
    
    extra_products.sort(reverse=True)
    total_sold += sum(extra_products[:f])
    
    print(total_sold)

solve()
","
def solve():
    n, f = map(int, input().split())

    sell_products = []
    total_sold = 0

    for _ in range(n):
        k, l = map(int, input().split())
        min_products = min(k, l)
        max_products = min(2 * k, l)
        sell_products.append(min_products)
        total_sold += min_products

    sell_products.sort(reverse=True)

    for i in range(f):
        total_sold += max(sell_products[i], sell_products[i] * 2)

    print(total_sold)

solve()","
def solve():
    import sys

    n, f = map(int, sys.stdin.readline().split())
    days = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]

    total = 0
    sell_days = []

    for i in range(n):
        k, l = days[i]
        min_products = min(k, l)
        max_extra_products = min(2*k, l) - min_products
        total += min_products
        sell_days.append(min(max_extra_products, k))

    sell_days.sort(reverse=True)
    total += sum(sell_days[:f])

    print(total)

solve()","
def solve():
    n, f = map(int, input().split())
    products = []
    for _ in range(n):
        k, l = map(int, input().split())
        if k < l:
            products.append(min(k, l))
        else:
            products.append(min(2*k, l))
    products.sort(reverse=True)
    sell_out_days = products[:f]
    total_sold = sum(sell_out_days)
    print(total_sold)

solve()
","
def solve():
    n, f = map(int, input().split())
    days = []
    for _ in range(n):
        k, l = map(int, input().split())
        original_products = min(k, l)
        increased_products = min(2 * k, l)
        days.append((original_products, increased_products))

    days.sort(key=lambda x: min(x[1] - x[0], x[1]))

    total_sold = 0
    for idx, (original, increased) in enumerate(days):
        if idx < f:
            total_sold += increased
        else:
            total_sold += original

    print(total_sold)
  
solve()","
def solve():
    n, f = map(int, input().split())
    shelves = []
    profit = 0
    diff_array = []
    
    for _ in range(n):
        k, l = map(int, input().split())
        profit += min(k, l)
        shelves.append(min(2*k, l) - min(k, l))
        diff_array.append(min(k, 2*k) - min(k, l))
    
    diff_array.sort(reverse=True)
    
    for i in range(f):
        profit += diff_array[i]
    
    print(profit)

solve()
","
def solve():
    n, f = map(int, input().split())
    products = []
    total_sold = 0

    for _ in range(n):
        k, l = map(int, input().split())
        sold_on_day = min(k, l)
        total_sold += sold_on_day
        products.append(min(2 * k, l) - sold_on_day)

    products.sort(reverse=True)
    for i in range(f):
        total_sold += max(products[i], 0)

    print(total_sold)

solve()
","
def solve():
    n, f = map(int, input().split())
    products = []
    for _ in range(n):
        k, l = map(int, input().split())
        if k * 2 <= l:
            products.append((0, min(k * 2, l)))
        else:
            products.append((min(k, l), l))
    
    products.sort(key=lambda x: min(2 * x[0], x[1] - x[0]), reverse=True)
    
    ans = 0
    for i in range(f):
        ans += min(2 * products[i][0], products[i][1])
    
    for i in range(f, n):
        ans += min(products[i][0], products[i][1])
    
    print(ans)

solve()","
def solve():
    n, f = map(int, input().split())
    products = []
    for _ in range(n):
        k, l = map(int, input().split())
        original_products = min(k, l)
        doubled_products = min(2*k, l)
        products.append(original_products)
        if original_products < doubled_products:
            f -= 1
    products.sort(reverse=True)
    total_sold = sum(products[:f]) + sum(products[f:])
    print(total_sold)

# Call the function to solve the problem
solve()
","
def solve():
    n, f = map(int, input().split())
    days = []
    for _ in range(n):
        k, l = map(int, input().split())
        days.append((k, l))
    
    sold_products = 0
    all_products = 0
    extra_products = []
    
    for k, l in days:
        sold = min(k, l)
        sold_products += sold
        all_products += min(k*2, l) if k > 0 else 0
        extra = min(k*2 - k, l - sold)
        extra_products.append(extra)
    
    extra_products.sort(reverse=True)
    
    for i in range(f):
        sold_products += extra_products[i]
    
    print(sold_products)

solve()
","
from heapq import *

def solve():
    n, f = map(int, input().split())
    days = [tuple(map(int, input().split())) for _ in range(n)]
    pq = []
    total_sold = 0
    for k, l in days:
        if f > 0:
            heappush(pq, min(2*k, l) - min(k, l))
            f -= 1
        else:
            heappush(pq, min(k, l))
    while pq:
        total_sold += max(heappop(pq), 0)
    print(total_sold)


solve()","
def solve():
    n, f = map(int, input().split())
    products = []
    for _ in range(n):
        k, l = map(int, input().split())
        products.append((min(2 * k, l), min(k, l)))
    
    products.sort(key=lambda x: min(x[0], 2*x[1])-min(x[1], 2*x[0]), reverse=True)
    
    total_sold = 0
    for i, (a, b) in enumerate(products):
        if i < f:
            total_sold += min(2 * a, b)
        else:
            total_sold += min(a, b)
    
    print(total_sold)

solve()
","
def solve():
    n, f = map(int, input().split())
    days = []
    for _ in range(n):
        k, l = map(int, input().split())
        original_products = min(k, l)
        doubled_products = min(2 * k, l)
        days.append((original_products, doubled_products - original_products))
    days.sort(key=lambda x: x[1], reverse=True)
    total_products_sold = 0
    for i in range(n):
        if i < f:
            total_products_sold += days[i][1] if days[i][1] > 0 else days[i][0]
        else:
            total_products_sold += days[i][0]
    print(total_products_sold)

solve()
","
def solve():
    n, f = map(int, input().split())
    products = []
    for _ in range(n):
        k, l = map(int, input().split())
        orig_products = min(k, l)
        doubled_products = min(2 * k, l)
        products.append((orig_products, doubled_products))

    products.sort(key=lambda x: min(x[1] - x[0], x[1]))

    total_sold = sum(p[0] for p in products[-f:] if p[1] > p[0])
    for p in products[:-f]:
        total_sold += min(p[1], p[0])

    print(total_sold)

solve()
","
def solve():
    n, f = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(n)]
    sold_total = 0
    diff = []
    
    for i in range(n):
        sold_total += min(arr[i][0], arr[i][1])
        diff.append(min(arr[i][0], 2*arr[i][0]) - min(arr[i][0], arr[i][1]))
    
    diff.sort(reverse=True)
    for i in range(f):
        sold_total += diff[i] if diff[i] > 0 else 0
    
    print(sold_total)

solve()","100.0","0.0","6.666666666666667","100.0","0.0","13.333333333333334","6.666666666666667","100.0","40.0","6.666666666666667","100.0","6.666666666666667","6.666666666666667","6.666666666666667","6.666666666666667","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/128","
QUESTION:
It is a balmy spring afternoon, and Farmer John's n cows are ruminating about link-cut cacti in their stalls. The cows, labeled 1 through n, are arranged so that the i-th cow occupies the i-th stall from the left. However, Elsie, after realizing that she will forever live in the shadows beyond Bessie's limelight, has formed the Mischievous Mess Makers and is plotting to disrupt this beautiful pastoral rhythm. While Farmer John takes his k minute long nap, Elsie and the Mess Makers plan to repeatedly choose two distinct stalls and swap the cows occupying those stalls, making no more than one swap each minute.

Being the meticulous pranksters that they are, the Mischievous Mess Makers would like to know the maximum messiness attainable in the k minutes that they have. We denote as p_{i} the label of the cow in the i-th stall. The messiness of an arrangement of cows is defined as the number of pairs (i, j) such that i < j and p_{i} > p_{j}.


-----Input-----

The first line of the input contains two integers n and k (1 ≤ n, k ≤ 100 000) — the number of cows and the length of Farmer John's nap, respectively.


-----Output-----

Output a single integer, the maximum messiness that the Mischievous Mess Makers can achieve by performing no more than k swaps. 


-----Examples-----
Input
5 2

Output
10

Input
1 10

Output
0



-----Note-----

In the first sample, the Mischievous Mess Makers can swap the cows in the stalls 1 and 5 during the first minute, then the cows in stalls 2 and 4 during the second minute. This reverses the arrangement of cows, giving us a total messiness of 10.

In the second sample, there is only one cow, so the maximum possible messiness is 0.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        max_messiness = n * (n - 1) // 2
        max_swaps = min(k, n // 2)
        remaining_swaps = k - max_swaps
        messiness = max_messiness - 2 * max_swaps * (n - max_swaps)
        if remaining_swaps > 0:
            messiness -= remaining_swaps
        print(messiness)

solve()
","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        if k >= n // 2:
            ans = n * (n - 1) // 2
            print(ans)
        else:
            ans = k * (k + 1) // 2
            ans *= 2
            print(ans)

solve()
","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        if k >= n // 2:
            print(n * (n-1) // 2)
        else:
            print(k * n)

solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        print(n * (n - 1) // 2)

solve()","
def solve():
    n, k = map(int, input().split())

    if n == 1:
        print(0)
    else:
        res = n * (n - 1) // 2
        print(res if k >= 2 else n // 2)

solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        max_messiness = (n-1) * n // 2
        max_swaps = min(k, n*(n-1)//2)
        if max_swaps == k:
            print(max_messiness)
        else:
            print(max_messiness - 2*(max_messiness - max_swaps))

solve()
","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        print(n*(n-1)//2)

solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        print(n*(n-1)//2 * k)
    
if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        max_messiness = n * (n - 1) // 2
        if k >= n // 2:
            extra_swaps = k - (n // 2)
            max_messiness -= 2 * extra_swaps
        else:
            max_messiness -= 2 * k
        print(max_messiness)

solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
        return
    if k >= (n - 1) // 2:
        print(n * (n - 1) // 2)
        return
    swaps = k
    for i in range(1, k + 1):
        swaps += i * 2 - 1
    print(swaps)

solve()
","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        print(n*(n-1)//2 * k)

solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        if k >= n // 2:
            print(n * (n - 1) // 2)
        else:
            print(k * (2 * n - k - 1))

solve()","
def solve():
    pass

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        print(n * (n-1) // 2)

solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        print(n*(n-1)//2 * k)
  
solve()","
def solve():
    n, k = map(int, input().split())
    if n == 1:
        print(0)
    else:
        if k >= n // 2:
            print((n * (n-1) // 2))
        else:
            print(k * n)

solve()","
def solve():
    n, k = map(int, input().split())

    if n == 1:
        print(0)
        return

    if k >= n / 2:
        print(n * (n - 1) // 2)
        return

    max_messiness = k * n
    print(max_messiness)

solve()
","20.0","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","20.0","33.33333333333333","53.333333333333336","20.0","53.333333333333336","53.333333333333336","20.0","53.333333333333336","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/129","
QUESTION:
Ivan is collecting coins. There are only $N$ different collectible coins, Ivan has $K$ of them. He will be celebrating his birthday soon, so all his $M$ freinds decided to gift him coins. They all agreed to three terms:  Everyone must gift as many coins as others. All coins given to Ivan must be different. Not less than $L$ coins from gifts altogether, must be new in Ivan's collection.

But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.


-----Input-----

The only line of input contains 4 integers $N$, $M$, $K$, $L$ ($1 \le K \le N \le 10^{18}$; $1 \le M, \,\, L \le 10^{18}$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.


-----Output-----

Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).


-----Examples-----
Input
20 15 2 3

Output
1
Input
10 11 2 4

Output
-1


-----Note-----

In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.

In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
Use user-input-Based format and function signature solve()","
def solve():
    N, M, K, L = map(int, input().split())
    
    if K + L > N:
        print(-1)
    else:
        min_gifts = (K + L - 1) // M
        if min_gifts * M < K + L:
            min_gifts += 1
        print(min_gifts)

solve()
","
def solve():
    n, m, k, l = map(int, input().split())
    
    if n < k + l:
        print(-1)
    else:
        remaining_coins = n - k
        min_gifts = (remaining_coins + m - 1) // m
        if min_gifts <= 0:
            min_gifts = 1
        
        total_gifts_required = min_gifts * m
        if total_gifts_required < k + l:
            print(-1)
        else:
            print(min_gifts)

solve()","
def solve():
    N, M, K, L = map(int, input().split())
    
    if K + L > N:
        print(""-1"")
    else:
        min_gifts = (K + L * M - 1) // N
        if K + min_gifts * M < L:
            print(""-1"")
        else:
            print(min_gifts)

solve()
","
def solve():
    N, M, K, L = map(int, input().split())
    
    if K + L > N:
        print(-1)
    else:
        max_gifts_per_friend = (K + L - 1) // M
        if max_gifts_per_friend * M < K + L:
            max_gifts_per_friend += 1
        print(max(0, max_gifts_per_friend - K))

solve()
","
def solve():
    n, m, k, l = map(int, input().split())
    
    min_gifts = max(0, (l + m - 1) // m) # Calculate min number of coin gifts each friend must give
    
    if k + min_gifts > n: # If it's impossible to satisfy all conditions
        print(-1)
    else:
        print(min_gifts)

solve()
","
def solve():
    import math
    
    N, M, K, L = map(int, input().split())
    
    if K + L > N:
        print(-1)
    else:
        rem_coins = N - K
        min_gifts = math.ceil(rem_coins / M)
        
        new_coins = K + min_gifts * M - N
        
        if new_coins >= L:
            print(min_gifts)
        else:
            print(-1)

solve()","
def solve():
    n, m, k, l = map(int, input().split())
    
    if m * n < k + l:
        print(-1)
    else:
        print(max(0, (k + l) // m - (k // m)))

solve()","
def solve():
    n, m, k, l = map(int, input().split())

    if k + l > n:
        print(-1)
    else:
        min_coins = (m * l + k - 1) // n
        if (m + min_coins - 1) * n < k + l * m:
            min_coins = (m + min_coins - 1) * n - k
        print(min_coins)

solve()
","
def solve():
    N, M, K, L = map(int, input().split())

    if K + L > N:
        print(-1)
    else:
        min_coins = (K + L * M - 1) // M - K
        print(min_coins)

solve()
","
def solve():
    n, m, k, l = map(int, input().split())
    
    if n < m or n == k or k + l > n:
        print(-1)
    else:
        res = (k + l - 1) // m
        if k + res > n:
            print(-1)
        else:
            print(res)

solve()
","
def solve():
    # Input
    N, M, K, L = map(int, input().split())

    # Logic
    min_coins = (K + L + M - 1) // M

    # Output
    if min_coins > N:
        print(-1)
    else:
        print(min_coins)

solve()
  ","
def solve():
    # User input
    N, M, K, L = map(int, input().split())

    # Perform calculations
    if N < M or N < L + K:
        print(-1)
    else:
        min_coins = max(0, (L + K + M - 1) // M - K)
        print(min_coins)

# Run the function
solve()
","
def solve():
    N, M, K, L = map(int, input().split())
    if K + L > N * M:
        print(-1)
    else:
        min_coins_per_friend = max(0, (L + K - 1) // M)
        potential_coins = min(N, min_coins_per_friend)
        print(potential_coins)

solve()
","
def solve():
    N, M, K, L = map(int, input().split())
    
    if N < M or K < L:
        print(-1)
    else:
        min_coins = max(0, (K + L - 1) // M - K // M)
        print(min_coins)

solve()","
def solve():
    N, M, K, L = map(int, input().split())
    
    min_coins_needed = (max(0, K + L - N) + M - 1) // M
    
    if min_coins_needed * M > N:
        print(-1)
    else:
        print(min_coins_needed)

solve()","
def solve():
    N, M, K, L = map(int, input().split())
    if K + L > N * M:
        print(-1)
    else:
        print((K + L - 1) // M)

solve()","86.66666666666667","40.0","40.0","33.33333333333333","33.33333333333333","53.333333333333336","6.666666666666667","40.0","40.0","46.666666666666664","60.0","46.666666666666664","6.666666666666667","26.666666666666668","6.666666666666667","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/130","
QUESTION:
Polycarp has a checkered sheet of paper of size n × m. Polycarp painted some of cells with black, the others remained white. Inspired by Malevich's ""Black Square"", Polycarp wants to paint minimum possible number of white cells with black so that all black cells form a square.

You are to determine the minimum possible number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. The square's side should have positive length.


-----Input-----

The first line contains two integers n and m (1 ≤ n, m ≤ 100) — the sizes of the sheet.

The next n lines contain m letters 'B' or 'W' each — the description of initial cells' colors. If a letter is 'B', then the corresponding cell is painted black, otherwise it is painted white.


-----Output-----

Print the minimum number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. If it is impossible, print -1.


-----Examples-----
Input
5 4
WWWW
WWWB
WWWB
WWBB
WWWW

Output
5

Input
1 2
BB

Output
-1

Input
3 3
WWW
WWW
WWW

Output
1



-----Note-----

In the first example it is needed to paint 5 cells — (2, 2), (2, 3), (3, 2), (3, 3) and (4, 2). Then there will be a square with side equal to three, and the upper left corner in (2, 2).

In the second example all the cells are painted black and form a rectangle, so it's impossible to get a square.

In the third example all cells are colored white, so it's sufficient to color any cell black.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]
    
    black_cells = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'B']
    
    if not black_cells:
        print(1)
        return
    
    min_row, max_row, min_col, max_col = min([i for i, _ in black_cells]), max([i for i, _ in black_cells]), min([j for _, j in black_cells]), max([j for _, j in black_cells])
    
    side = max(max_row - min_row + 1, max_col - min_col + 1)
    
    if all(grid[i][j] == 'B' for i in range(min_row, min_row + side) for j in range(min_col, min_col + side) if 0 <= i < n and 0 <= j < m):
        print(len(black_cells) - side**2)
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    sheet = [input() for _ in range(n)]
    
    min_cells = float('inf')
    
    for i in range(n):
        for j in range(m):
            if sheet[i][j] == 'B':
                for side in range(1, min(n, m)+1):
                    if i + side <= n and j + side <= m:
                        is_square = True
                        for k in range(i, i + side):
                            for l in range(j, j + side):
                                if sheet[k][l] != 'B':
                                    is_square = False
                                    break

                        if is_square:
                            min_cells = min(min_cells, sum(sheet[x][y] != 'B' for x in range(n) for y in range(m)) - side**2)

    if min_cells == float('inf'):
        print(-1)
    else:
        print(min_cells)

solve()
","
def solve():
    n, m = map(int, input().split())
    sheet = [input() for _ in range(n)]

    black_cells = [(i, j) for i in range(n) for j in range(m) if sheet[i][j] == 'B']
    if not black_cells:
        print(1)
        return

    min_rows = min(cell[0] for cell in black_cells)
    max_rows = max(cell[0] for cell in black_cells)
    min_cols = min(cell[1] for cell in black_cells)
    max_cols = max(cell[1] for cell in black_cells)

    side_length = max(max_rows - min_rows + 1, max_cols - min_cols + 1)
    
    num_painted_cells = 0
    for i in range(min_rows, min_rows + side_length):
        for j in range(min_cols, min_cols + side_length):
            if i >= n or j >= m or sheet[i][j] != 'B':
                num_painted_cells += 1

    for i in range(n):
        for j in range(m):
            if sheet[i][j] == 'B' and not (min_rows <= i < min_rows + side_length and min_cols <= j < min_cols + side_length):
                num_painted_cells += 1

    if all(sheet[i][j] == 'B' for i in range(n) for j in range(m) if min_rows <= i < min_rows + side_length and min_cols <= j < min_cols + side_length):
        print(num_painted_cells)
    else:
        print(-1)


solve()
","
def solve():
    n, m = map(int, input().split())
    cells = [input() for _ in range(n)]
    
    black_indices = [(i, j) for i in range(n) for j in range(m) if cells[i][j] == 'B']
    
    if not black_indices:
        print(1)
        return
    
    min_row = min(black_indices, key=lambda x: x[0])[0]
    max_row = max(black_indices, key=lambda x: x[0])[0]
    min_col = min(black_indices, key=lambda x: x[1])[1]
    max_col = max(black_indices, key=lambda x: x[1])[1]
    
    side_length = max(max_row - min_row + 1, max_col - min_col + 1)
    painted_cells = [(i, j) for i in range(min_row, min_row + side_length) for j in range(min_col, min_col + side_length)]
    
    for i in range(n):
        for j in range(m):
            if (i, j) not in painted_cells and cells[i][j] == 'B':
                print(-1)
                return
    
    print(len(painted_cells) - len(black_indices))

solve()
","
def solve():
    n, m = map(int, input().split())
    cells = [input() for _ in range(n)]
    
    black_cells = [(i, j) for i in range(n) for j in range(m) if cells[i][j] == 'B']
    if not black_cells:
        print(1)
        return

    top, left, bottom, right = min(i for i, j in black_cells), min(j for i, j in black_cells), max(i for i, j in black_cells), max(j for i, j in black_cells)
    
    side = max(bottom - top + 1, right - left + 1)
    
    black_square_cells = [(i, j) for i in range(top, top + side) for j in range(left, left + side) if 0 <= i < n and 0 <= j < m]
    
    if all(cells[i][j] == 'B' for i, j in black_square_cells) and len(black_square_cells) == sum(1 for row in cells for cell in row):
        print(len(black_cells) - side ** 2)
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    sheet = [list(input().strip()) for _ in range(n)]

    black_cells = [(i, j) for i in range(n) for j in range(m) if sheet[i][j] == 'B']
    if not black_cells:
        print(1)
        return

    min_row, max_row, min_col, max_col = n, -1, m, -1
    for i, j in black_cells:
        min_row = min(min_row, i)
        max_row = max(max_row, i)
        min_col = min(min_col, j)
        max_col = max(max_col, j)

    side = max(max_row - min_row, max_col - min_col) + 1
    num_paint = 0
    for i in range(min_row, min_row + side):
        for j in range(min_col, min_col + side):
            if i < 0 or i >= n or j < 0 or j >= m:
                num_paint += 1
            elif sheet[i][j] != 'B':
                num_paint += 1

    for i in range(n):
        for j in range(m):
            if min_row <= i < min_row + side and min_col <= j < min_col + side:
                if sheet[i][j] == 'W':
                    num_paint += 1
            else:
                if sheet[i][j] == 'B':
                    num_paint += 1

    if min_row + side > n or min_col + side > m:
        print(-1)
    else:
        print(num_paint)

solve()
","
def solve():
    n, m = map(int, input().split())
    sheet = [input() for _ in range(n)]

    black_cells = [(i, j) for i in range(n) for j in range(m) if sheet[i][j] == 'B']

    if not black_cells:
        print(1)
        return

    min_possible_cells = float('inf')
    for i in range(n):
        for j in range(m):
            for side in range(1, min(n - i, m - j) + 1):
                black_count = 0
                for x in range(i, i + side):
                    for y in range(j, j + side):
                        if sheet[x][y] != 'B':
                            black_count += 1
                if black_count == 0:
                    min_possible_cells = min(min_possible_cells, len(black_cells) - side**2)

    if min_possible_cells == float('inf'):
        print(-1)
    else:
        print(min_possible_cells)

solve()","
def solve():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]

    black_cells = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'B']

    if not black_cells:
        print(1)
        return

    min_row, max_row = min(i for i, _ in black_cells), max(i for i, _ in black_cells)
    min_col, max_col = min(j for _, j in black_cells), max(j for _, j in black_cells)

    side = max(max_row - min_row, max_col - min_col) + 1

    for i in range(min_row, min_row + side):
        for j in range(min_col, min_col + side):
            if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != 'B':
                print(-1)
                return

    print(len(black_cells) - side ** 2)


solve()
","
def solve():
    n, m = map(int, input().split())
    matrix = [list(input()) for _ in range(n)]

    black_cells = [(i, j) for i in range(n) for j in range(m) if matrix[i][j] == 'B']

    if not black_cells:
        print(1)
        return

    min_row = min([cell[0] for cell in black_cells])
    max_row = max([cell[0] for cell in black_cells])
    min_col = min([cell[1] for cell in black_cells])
    max_col = max([cell[1] for cell in black_cells])

    side_length = max(max_row - min_row + 1, max_col - min_col + 1)
    painted_cells = [(i, j) for i in range(min_row, min_row + side_length) for j in range(min_col, min_col + side_length)]

    if all(cell in black_cells for cell in painted_cells):
        print(len(black_cells) - len(painted_cells))
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]
    
    black_cells = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'B']
    
    if not black_cells:
        print(1)
        return
    
    top, bottom, left, right = min(i for i, _ in black_cells), max(i for i, _ in black_cells), min(j for _, j in black_cells), max(j for _, j in black_cells)
    
    side_length = max(bottom - top + 1, right - left + 1)
    
    count = 0
    for i in range(top, top+side_length):
        for j in range(left, left+side_length):
            if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 'W':
                count += 1
    
    print(count)

solve()
","
def solve():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]
    
    black_cells = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'B']
    
    if not black_cells:
        print(1)
        return
    
    min_row = min(row for row, _ in black_cells)
    max_row = max(row for row, _ in black_cells)
    min_col = min(col for _, col in black_cells)
    max_col = max(col for _, col in black_cells)
    
    side = max(max_row - min_row + 1, max_col - min_col + 1)
    
    if all(grid[i][j] == 'B' for i in range(min_row, min_row + side) for j in range(min_col, min_col + side)):
        print(len(black_cells) - side**2)
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    board = [input() for _ in range(n)]
    
    black_cells = [(i, j) for i in range(n) for j in range(m) if board[i][j] == 'B']
    if not black_cells:
        print(1)
        return
        
    min_row, max_row = min(black_cells, key=lambda x: x[0])[0], max(black_cells, key=lambda x: x[0])[0]
    min_col, max_col = min(black_cells, key=lambda x: x[1])[1], max(black_cells, key=lambda x: x[1])[1]
    
    side_length = max(max_row - min_row + 1, max_col - min_col + 1)
    square_cells = {(i, j) for i in range(min_row, min_row + side_length) for j in range(min_col, min_col + side_length)}
    
    if all(board[i][j] == 'B' for i in range(n) for j in range(m) if (i, j) not in square_cells):
        print(n*m - len(square_cells))
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]
    min_cells = float('inf')

    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                for side in range(1, min(n, m)+1):
                    black_cells = 0
                    for ni in range(i, min(i + side, n)):
                        for nj in range(j, min(j + side, m)):
                            if grid[ni][nj] == 'W':
                                black_cells += 1
                    if black_cells == side**2:
                        min_cells = min(min_cells, black_cells)

    if min_cells == float('inf'):
        print(-1)
    else:
        print(sum(sum([1 for cell in row if cell == 'B']) for row in grid) - min_cells)

solve()
","
def solve():
    n, m = map(int, input().split())
    sheet = [list(input().strip()) for _ in range(n)]

    black_cells = [(i, j) for i in range(n) for j in range(m) if sheet[i][j] == 'B']

    if not black_cells:
        print(1)
        return

    min_x = min(cell[0] for cell in black_cells)
    max_x = max(cell[0] for cell in black_cells)
    min_y = min(cell[1] for cell in black_cells)
    max_y = max(cell[1] for cell in black_cells)

    side = max(max_x - min_x, max_y - min_y) + 1

    if all(sheet[i][j] == 'B' for i in range(min_x, min_x + side) for j in range(min_y, min_y + side)):
        print(n*m - len(black_cells))
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().strip().split())
    cells = [input() for _ in range(n)]
    
    top, bottom, left, right = n, 0, m, 0
    total_black = 0
    
    for i in range(n):
        for j in range(m):
            if cells[i][j] == 'B':
                top = min(top, i)
                bottom = max(bottom, i)
                left = min(left, j)
                right = max(right, j)
                total_black += 1
    
    side = max(bottom - top + 1, right - left + 1)
    
    if side > min(n, m):
        print(-1)
    else:
        print(side ** 2 - total_black)

solve()
","
def solve():
    n, m = map(int, input().split())
    grid = [input() for _ in range(n)]
    
    black_cells = []
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                black_cells.append((i, j))
    
    if not black_cells:
        print(1)
        return
    
    min_rows = min(cell[0] for cell in black_cells)
    max_rows = max(cell[0] for cell in black_cells)
    min_cols = min(cell[1] for cell in black_cells)
    max_cols = max(cell[1] for cell in black_cells)
    
    side = max(max_rows - min_rows, max_cols - min_cols) + 1
    if all(grid[i][j] == 'B' for i in range(min_rows, min_rows + side) for j in range(min_cols, min_cols + side)):
        print(side**2 - len(black_cells))
    else:
        print(-1)

solve()
","60.0","6.666666666666667","60.0","86.66666666666667","40.0","66.66666666666666","53.333333333333336","66.66666666666666","66.66666666666666","86.66666666666667","53.333333333333336","40.0","13.333333333333334","33.33333333333333","80.0","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/131","
QUESTION:
There is a beautiful garden of stones in Innopolis.

Its most beautiful place is the $n$ piles with stones numbered from $1$ to $n$.

EJOI participants have visited this place twice. 

When they first visited it, the number of stones in piles was $x_1, x_2, \ldots, x_n$, correspondingly. One of the participants wrote down this sequence in a notebook. 

They visited it again the following day, and the number of stones in piles was equal to $y_1, y_2, \ldots, y_n$. One of the participants also wrote it down in a notebook.

It is well known that every member of the EJOI jury during the night either sits in the room $108$ or comes to the place with stones. Each jury member who comes there either takes one stone for himself or moves one stone from one pile to another. We can assume that there is an unlimited number of jury members. No one except the jury goes to the place with stones at night.

Participants want to know whether their notes can be correct or they are sure to have made a mistake.


-----Input-----

The first line of the input file contains a single integer $n$, the number of piles with stones in the garden ($1 \leq n \leq 50$).

The second line contains $n$ integers separated by spaces $x_1, x_2, \ldots, x_n$, the number of stones in piles recorded in the notebook when the participants came to the place with stones for the first time ($0 \leq x_i \leq 1000$).

The third line contains $n$ integers separated by spaces $y_1, y_2, \ldots, y_n$, the number of stones in piles recorded in the notebook when the participants came to the place with stones for the second time ($0 \leq y_i \leq 1000$).


-----Output-----

If the records can be consistent output ""Yes"", otherwise output ""No"" (quotes for clarity).


-----Examples-----
Input
5
1 2 3 4 5
2 1 4 3 5

Output
Yes

Input
5
1 1 1 1 1
1 0 1 0 1

Output
Yes

Input
3
2 3 9
1 7 9

Output
No



-----Note-----

In the first example, the following could have happened during the night: one of the jury members moved one stone from the second pile to the first pile, and the other jury member moved one stone from the fourth pile to the third pile.

In the second example, the jury took stones from the second and fourth piles.

It can be proved that it is impossible for the jury members to move and took stones to convert the first array into the second array.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_x < sum_y:
        print(""No"")
    else:
        diff = sum_x - sum_y
        even_diff = 0
        odd_diff = 0
        for i in range(n):
            if (x[i] - y[i]) % 2 == 0:
                even_diff += x[i] - y[i]
            else:
                odd_diff += x[i] - y[i]

        if even_diff >= diff and odd_diff % 2 == diff % 2:
            print(""Yes"")
        else:
            print(""No"")

solve()
","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))
    
    sum_x = sum(x)
    sum_y = sum(y)
    
    if sum_x < sum_y:
        print(""No"")
    else:
        diff = sum_x - sum_y
        count_x = sum([max(x[i] - y[i], 0) for i in range(n)])
        
        if count_x <= diff:
            print(""Yes"")
        else:
            print(""No"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))
    
    sum_x = sum(x)
    sum_y = sum(y)
    
    if sum_x < sum_y:
        print(""No"")
    else:
        diff = sum_x - sum_y
        count_moves = 0
        for i in range(n):
            if y[i] > x[i]:
                count_moves += y[i] - x[i]
        if count_moves > diff:
            print(""No"")
        else:
            print(""Yes"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_y <= sum_x:
        diff = sum_x - sum_y
        for i in range(n):
            if x[i] >= diff:
                x[i] -= diff
                break
        else:
            print(""No"")
            return

    for i in range(n):
        if (x[i] - y[i]) % 2 != 0:
            print(""No"")
            return

    print(""Yes"")

solve()
","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_y <= sum_x:
        diff = sum_x - sum_y
        count_x = sum([xi - y[i] for i, xi in enumerate(x) if xi > y[i]])
        count_y = sum([y[i] - xi for i, xi in enumerate(x) if xi > y[i]])
        
        if count_x == diff and count_y == diff:
            print(""Yes"")
        else:
            print(""No"")
    else:
        print(""No"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    x_sum = sum(x)
    y_sum = sum(y)

    if x_sum >= y_sum and (x_sum - y_sum) % 2 == 0:
        print(""Yes"")
    else:
        print(""No"")

import sys
if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    total_diff = sum(y) - sum(x)
    if total_diff < 0:
        print(""No"")
    else:
        diffs = [b - a for a, b in zip(x, y)]
        if sum(diffs) == total_diff:
            print(""Yes"")
        else:
            print(""No"")

solve()
","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    x_sum = sum(x)
    y_sum = sum(y)

    if x_sum < y_sum or (x_sum - y_sum) % 2 != 0:
        print(""No"")
    else:
        diff = (x_sum - y_sum) // 2
        x_diff = sum(max(0, x[i] - y[i] - diff) for i in range(n))
        if x_diff == diff:
            print(""Yes"")
        else:
            print(""No"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))
    
    x_sum = sum(x)
    y_sum = sum(y)
    
    if x_sum >= y_sum:
        print(""Yes"" if (x_sum - y_sum) % 2 == 0 else ""No"")
    else:
        print(""No"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_x > sum_y:
        print(""No"")
    else:
        print(""Yes"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))
    
    diff = sum(y) - sum(x)
    if diff < 0 or diff % 2 != 0:
        print(""No"")
    else:
        for i in range(n):
            if y[i] > x[i] + (diff // 2):
                print(""No"")
                return
        print(""Yes"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_x >= sum_y:
        diff = sum_x - sum_y
        count_x = sum(a - b for a, b in zip(x, y) if a > b)
        if diff == count_x:
            print(""Yes"")
        else:
            print(""No"")
    else:
        print(""No"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_x >= sum_y:
        differences = [b - a for a, b in zip(x, y)]
        if all(diff >= 0 and diff % 2 == 0 for diff in differences):
            print(""Yes"")
        else:
            print(""No"")
    else:
        print(""No"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_y <= sum_x:
        for i in range(n):
            if (x[i] - y[i]) % 2 != 0:
                print(""No"")
                return

        print(""Yes"")
    else:
        print(""No"")

solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)
    if sum_x < sum_y:
        print(""No"")
    else:
        diff = sum_x - sum_y
        even_diff = sum([abs(x[i] - y[i]) for i in range(n) if (x[i] - y[i]) % 2 == 0])
        if diff >= even_diff:
            print(""Yes"")
        else:
            print(""No"")
  
solve()","
def solve():
    n = int(input())
    x = list(map(int, input().split()))
    y = list(map(int, input().split()))

    sum_x = sum(x)
    sum_y = sum(y)

    if sum_x >= sum_y:
        diff = sum_x - sum_y
        diff_x_odd = sum(xi for xi in x if xi % 2 != 0)
        diff_y_odd = sum(yi for yi in y if yi % 2 != 0)
        
        if diff > 0 and diff % 2 == 0 and diff_x_odd >= diff_y_odd:
            print(""Yes"")
        elif diff == 0 and diff_x_odd == diff_y_odd:
            print(""Yes"")
        else:
            print(""No"")
    else:
        print(""No"")


solve()
","66.66666666666666","73.33333333333333","73.33333333333333","60.0","53.333333333333336","100.0","33.33333333333333","60.0","100.0","33.33333333333333","46.666666666666664","73.33333333333333","53.333333333333336","60.0","80.0","80.0","","","","","","","","","","","","","","","",""
"APPS/132","
QUESTION:
Students Vasya and Petya are studying at the BSU (Byteland State University). At one of the breaks they decided to order a pizza. In this problem pizza is a circle of some radius. The pizza was delivered already cut into n pieces. The i-th piece is a sector of angle equal to a_{i}. Vasya and Petya want to divide all pieces of pizza into two continuous sectors in such way that the difference between angles of these sectors is minimal. Sector angle is sum of angles of all pieces in it. Pay attention, that one of sectors can be empty.


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 360)  — the number of pieces into which the delivered pizza was cut.

The second line contains n integers a_{i} (1 ≤ a_{i} ≤ 360)  — the angles of the sectors into which the pizza was cut. The sum of all a_{i} is 360.


-----Output-----

Print one integer  — the minimal difference between angles of sectors that will go to Vasya and Petya.


-----Examples-----
Input
4
90 90 90 90

Output
0

Input
3
100 100 160

Output
40

Input
1
360

Output
360

Input
4
170 30 150 10

Output
0



-----Note-----

In first sample Vasya can take 1 and 2 pieces, Petya can take 3 and 4 pieces. Then the answer is |(90 + 90) - (90 + 90)| = 0.

In third sample there is only one piece of pizza that can be taken by only one from Vasya and Petya. So the answer is |360 - 0| = 360.

In fourth sample Vasya can take 1 and 4 pieces, then Petya will take 2 and 3 pieces. So the answer is |(170 + 10) - (30 + 150)| = 0.

Picture explaning fourth sample:

[Image]

Both red and green sectors consist of two adjacent pieces of pizza. So Vasya can take green sector, then Petya will take red sector.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))
    
    total_angle = sum(angles)
    half_angle = total_angle // 2
    
    dp = [0] * (half_angle + 1)
    dp[0] = 1
    
    for angle in angles:
        for i in range(half_angle, angle - 1, -1):
            dp[i] |= dp[i - angle]
    
    min_diff = total_angle
    for i in range(half_angle + 1):
        if dp[i]:
            min_diff = min(min_diff, total_angle - 2 * i)
    
    print(min_diff)

solve()
","
import itertools

def solve():
    n = int(input())
    angles = list(map(int, input().split()))
    
    total = sum(angles)
    half = total // 2
    
    min_diff = total
    for i in range(1, n):
        for combo in itertools.combinations(range(n), i):
            taken = sum(angles[j] for j in combo)
            diff = abs(taken - (total - taken))
            min_diff = min(min_diff, diff)
    
    print(min_diff)

solve()
","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))
    
    total_sum = sum(angles)
    half_sum = total_sum // 2
    
    dp = [False] * (half_sum + 1)
    dp[0] = True
    
    for angle in angles:
        for j in range(half_sum, angle - 1, -1):
            dp[j] |= dp[j - angle]
    
    ans = total_sum
    for i in range(half_sum + 1):
        if dp[i]:
            ans = min(ans, total_sum - 2 * i)
    
    print(ans)

solve()
  ","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))
    total_angle = sum(angles)
    target = total_angle // 2

    dp = [False] * (target + 1)
    dp[0] = True

    for angle in angles:
        for i in range(target, angle - 1, -1):
            dp[i] |= dp[i - angle]

    min_diff = total_angle
    for i in range(target + 1):
        if dp[i]:
            min_diff = min(min_diff, abs(total_angle - 2*i))

    print(min_diff)

solve()
","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    total_angle = sum(angles)
    half_angle = total_angle / 2

    dp = [[False for _ in range(180)] for _ in range(n+1)]
    dp[0][0] = True

    for i in range(1, n+1):
        for j in range(180):
            dp[i][j] = dp[i-1][j] or (j >= angles[i-1] and dp[i-1][j - angles[i-1]])

    ans = min(abs(half_angle - 2 * j) for j in range(half_angle+1) if dp[n][j])

    print(ans)

solve()
","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    total_angle = sum(angles)
    half_angle = total_angle // 2

    min_diff = float('inf')
    curr_sum = 0

    for angle in angles:
        curr_sum += angle
        diff = abs(curr_sum - half_angle)
        min_diff = min(min_diff, diff)

    if min_diff == 0:
        print(0)
    else:
        print(min_diff * 2)

solve()
","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))
    
    total_sum = sum(angles)
    min_diff = float('inf')
    
    for i in range(n):
        angle_sum = 0
        for j in range(i, n):
            angle_sum += angles[j]
            diff = abs(2*angle_sum - total_sum)
            min_diff = min(min_diff, diff)
    
    print(min_diff)

solve()","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    prefix_sum = [0] * n
    prefix_sum[0] = angles[0]
    for i in range(1, n):
        prefix_sum[i] = prefix_sum[i-1] + angles[i]

    answer = float('inf')
    for i in range(n-1):
        answer = min(answer, abs(360 - 2*prefix_sum[i]))

    print(answer)

solve()","
from itertools import combinations

def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    min_diff = float('inf')
    for i in range(1, n):
        for comb in combinations(range(n), i):
            sum1 = sum([angles[j] for j in comb])
            sum2 = sum([angles[j] for j in set(range(n)) - set(comb)])
            min_diff = min(min_diff, abs(sum1 - sum2))

    print(min_diff)


solve()","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))
    
    total_angle = sum(angles)
    half_angle = total_angle // 2
    
    dp = [0] * (half_angle + 1)
    dp[0] = 1
    
    for angle in angles:
        for i in range(half_angle, angle - 1, -1):
            dp[i] |= dp[i - angle]
    
    res = total_angle
    for i in range(half_angle + 1):
        if dp[i]:
            res = min(res, total_angle - 2 * i)
    
    return res

# Call the function to get the result
result = solve()
print(result)

solve()","
from itertools import combinations

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    min_diff = float('inf')
    
    for i in range(1, n):
        for subset in combinations(range(n), i):
            vasya_sectors = sum(a[j] for j in subset)
            petya_sectors = sum(a[j] for j in range(n) if j not in subset)
            min_diff = min(min_diff, abs(vasya_sectors - petya_sectors))
    
    print(min_diff)


solve()","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    total_angle = sum(angles)
    half_angle = total_angle // 2

    dp = [False] * (half_angle + 1)
    dp[0] = True

    for angle in angles:
        for i in range(half_angle, angle - 1, -1):
            dp[i] |= dp[i - angle]

    min_diff = total_angle
    for i in range(half_angle + 1):
        if dp[i]:
            min_diff = min(min_diff, total_angle - 2 * i)

    print(min_diff)

# Call the function to execute
solve()
","
from itertools import combinations

def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    total_angle = sum(angles)
    min_diff = total_angle

    for i in range(1, n):
        for comb in combinations(range(n), i):
            sum_1 = sum(angles[j] for j in comb)
            sum_2 = total_angle - sum_1
            diff = abs(sum_1 - sum_2)
            min_diff = min(min_diff, diff)

    print(min_diff)


solve()","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    total_angle = sum(angles)
    half_angle = total_angle / 2

    dp = [False] * (half_angle + 1)
    dp[0] = True

    for angle in angles:
        for i in range(half_angle, angle - 1, -1):
            dp[i] |= dp[i - angle]

    answer = total_angle
    for i in range(half_angle + 1):
        if dp[i]:
            answer = min(answer, total_angle - 2 * i)

    print(answer)

solve()
","
def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    total_sum = sum(angles)
    half_sum = total_sum // 2

    dp = [0] * 360
    dp[0] = 1

    for angle in angles:
        for i in range(359, -1, -1):
            if dp[i]:
                dp[i + angle] = 1

    result = float('inf')
    for i in range(half_sum + 1):
        if dp[i]:
            result = min(result, abs(2 * i - total_sum))

    print(result)

solve()
","
from itertools import combinations

def solve():
    n = int(input())
    angles = list(map(int, input().split()))

    min_diff = float('inf')

    for i in range(1, n):
        for comb in combinations(range(n), i):
            sector1 = sum(angles[idx] for idx in comb)
            sector2 = sum(angles[idx] for idx in range(n) if idx not in comb)
            diff = abs(sector1 - sector2)
            min_diff = min(min_diff, diff)

    print(min_diff)


solve()","93.33333333333333","93.33333333333333","93.33333333333333","93.33333333333333","0.0","80.0","100.0","73.33333333333333","86.66666666666667","0.0","86.66666666666667","93.33333333333333","93.33333333333333","0.0","0.0","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/133","
QUESTION:
Alice got many presents these days. So she decided to pack them into boxes and send them to her friends.

There are $n$ kinds of presents. Presents of one kind are identical (i.e. there is no way to distinguish two gifts of the same kind). Presents of different kinds are different (i.e. that is, two gifts of different kinds are distinguishable). The number of presents of each kind, that Alice has is very big, so we can consider Alice has an infinite number of gifts of each kind.

Also, there are $m$ boxes. All of them are for different people, so they are pairwise distinct (consider that the names of $m$ friends are written on the boxes). For example, putting the first kind of present into the first box but not into the second box, is different from putting the first kind of present into the second box but not into the first box.

Alice wants to pack presents with the following rules:  She won't pack more than one present of each kind into the same box, so each box should contain presents of different kinds (i.e. each box contains a subset of $n$ kinds, empty boxes are allowed);  For each kind at least one present should be packed into some box. 

Now Alice wants to know how many different ways to pack the presents exists. Please, help her and calculate this number. Since the answer can be huge, output it by modulo $10^9+7$.

See examples and their notes for clarification.


-----Input-----

The first line contains two integers $n$ and $m$, separated by spaces ($1 \leq n,m \leq 10^9$) — the number of kinds of presents and the number of boxes that Alice has.


-----Output-----

Print one integer  — the number of ways to pack the presents with Alice's rules, calculated by modulo $10^9+7$


-----Examples-----
Input
1 3

Output
7
Input
2 2

Output
9


-----Note-----

In the first example, there are seven ways to pack presents:

$\{1\}\{\}\{\}$

$\{\}\{1\}\{\}$

$\{\}\{\}\{1\}$

$\{1\}\{1\}\{\}$

$\{\}\{1\}\{1\}$

$\{1\}\{\}\{1\}$

$\{1\}\{1\}\{1\}$

In the second example there are nine ways to pack presents:

$\{\}\{1,2\}$

$\{1\}\{2\}$

$\{1\}\{1,2\}$

$\{2\}\{1\}$

$\{2\}\{1,2\}$

$\{1,2\}\{\}$

$\{1,2\}\{1\}$

$\{1,2\}\{2\}$

$\{1,2\}\{1,2\}$

For example, the way $\{2\}\{2\}$ is wrong, because presents of the first kind should be used in the least one box.
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    result = pow(2, n, MOD) - 1
    result = pow(result, m, MOD)
    print(result)

solve()
","
def solve():
    n, m = map(int, input().split())
    MOD = 10**9 + 7
    result = pow(pow(2, n, MOD) - 1, m, MOD)
    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    ans = pow(2, n, MOD) - 1
    ans = pow(ans, m, MOD)
    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    result = pow(2, n, MOD) - 1
    result = pow(result, m, MOD)
    print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    result = pow(2, n, MOD) - 1
    result = pow(result, m, MOD)
    return result

solve()
","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    result = pow(pow(2, n, MOD) - 1, m, MOD)
    print(result)

solve()","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    ans = pow(2, m, MOD) - 1
    ans = pow(ans, n, MOD)
    print(ans)

solve()
","
def solve():
    # Get input
    n, m = map(int, input().split())
    
    # Calculate the answer
    result = pow(pow(2, n, 10**9+7) - 1, m, 10**9+7)
    
    # Output the result
    print(result)

solve()
","
def solve(n, m):
    return ((pow(2, m, 10**9+7) - 1) % (10**9+7)) % (10**9+7)

solve()","
def solve():
    MOD = 10**9 + 7
    
    n, m = map(int, input().split())
    
    result = pow(2, n, MOD) - 1
    result = pow(result, m, MOD)
    
    print(result)

solve()","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    result = (pow(pow(2, n, MOD) - 1, m, MOD) + MOD) % MOD
    print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    ans = (pow(2, n, MOD) - 1) % MOD
    ans = pow(ans, m, MOD)
    print(ans)

solve()
","
def solve():
    mod = 10**9 + 7
    n, m = map(int, input().split())
    ans = (pow(2, m, mod) - 1) % mod
    ans = pow(ans, n, mod)
    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    result = pow(2, n, MOD) - 1
    result = pow(result, m, MOD)
    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    result = pow((pow(2, n, MOD) - 1), m, MOD)
    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    
    ans = (pow(2, n, MOD) - 1) % MOD
    ans = pow(ans, m, MOD)
    
    print(ans)

if __name__ == ""__main__"":
    solve()
","20.0","20.0","20.0","20.0","0.0","20.0","100.0","20.0","0.0","20.0","20.0","20.0","100.0","20.0","20.0","20.0","","","","","","","","","","","","","","","",""
"APPS/134","
QUESTION:
Katya studies in a fifth grade. Recently her class studied right triangles and the Pythagorean theorem. It appeared, that there are triples of positive integers such that you can construct a right triangle with segments of lengths corresponding to triple. Such triples are called Pythagorean triples.

For example, triples (3, 4, 5), (5, 12, 13) and (6, 8, 10) are Pythagorean triples.

Here Katya wondered if she can specify the length of some side of right triangle and find any Pythagorean triple corresponding to such length? Note that the side which length is specified can be a cathetus as well as hypotenuse.

Katya had no problems with completing this task. Will you do the same?


-----Input-----

The only line of the input contains single integer n (1 ≤ n ≤ 10^9) — the length of some side of a right triangle.


-----Output-----

Print two integers m and k (1 ≤ m, k ≤ 10^18), such that n, m and k form a Pythagorean triple, in the only line.

In case if there is no any Pythagorean triple containing integer n, print  - 1 in the only line. If there are many answers, print any of them.


-----Examples-----
Input
3

Output
4 5
Input
6

Output
8 10
Input
1

Output
-1
Input
17

Output
144 145
Input
67

Output
2244 2245


-----Note-----[Image]

Illustration for the first sample.
Use user-input-Based format and function signature solve()","
def solve():
    import math

    n = int(input())

    if n % 2 == 0:
        m = n // 2 - 1
        k = n // 2 + 1
    else:
        m = (n - 1) // 2
        k = (n + 1) // 2

    if m > 0 and k > 0:
        print(m, k)
    else:
        print(-1)

solve()","
def solve():
    n = int(input())
    if n == 1:
        print(""-1"")
    else:
        m = 2 * n + 1
        k = m + 1
        print(m, k)

solve()
","
def solve():
    n = int(input())
    m = n + 1
    k = n*n + 1
    if n % 2 == 0:
        m = n*n//4 - 1
        k = n*n//4 + 1
    print(m, k)
    
solve()
","
def solve():
    n = int(input())
    if n == 1:
        print(-1)
    elif n % 2 == 0:
        m = n**2 // 4 - 1
        k = n**2 // 4 + 1
        print(m, k)
    else:
        m = (n-1) * (n+1) // 2
        k = (n+1) * ((n-1) // 2) + n
        print(m, k)

solve()
  ","
def solve():
    import math

    n = int(input())
    if n % 2 == 0:
        m = n // 2 - 1
        k = n // 2 + 1
        print(m * k, (m ** 2) + (k ** 2))
    elif n < 3:
        print(-1)
    else:
        m = (n - 1) // 2
        k = m + 1
        print(2 * m * k, m ** 2 + k ** 2)

solve()
","
def solve():
    n = int(input())
    m = (n + 1) ** 2 / 2
    k = (n - 1) ** 2 / 2
    if m.is_integer() and k.is_integer() and m > n:
        print(int(k), int(m))
    else:
        print(-1)

solve()
","
def solve():
    n = int(input())
    if n == 1:
        print(-1)
    else:
        m = (n**2)//2 + n
        k = (n**2)//2 + n + 1
        print(m, k)

solve()
","
def solve():
    n = int(input())
    
    if n == 1:
        print(-1)
    else:
        m = 2 * n
        k = n ** 2 + 1
        print(m, k)

solve()
","
def solve():
    n = int(input())
    
    if n % 2 == 0:
        m = n // 2 - 1
        k = n // 2 + 1
    elif n % 2 != 0:
        m = (n**2 - 1) // 2
        k = (n**2 + 1) // 2
        
    if m > 0 and k > 0:
        print(m, k)
    else:
        print(-1)

solve()
","
def solve():
    n = int(input())
    
    if n == 1:
        print(-1)
    else:
        if n % 2 == 0:
            m = n // 2 - 1
            k = n // 2 + 1
        else:
            m = (n*n - 1) // 2
            k = (n*n + 1) // 2
        print(m, k)

solve()
","
def solve():
    import math
    n = int(input())
    if n == 1:
        print(-1)
    else:
        m = (n * n // 2) - 1
        k = (n * n // 2) + 1
        print(m, k)

solve()
","
def solve():
    n = int(input())
    if n == 1:
        print(""-1"")
    else:
        m = n + 1
        k = m * m - n * n
        print(m, k)

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        m = n // 2
        k = m + 1
        print(m, k)
    elif n == 1:
        print(-1)
    else:
        m = (n * n - 1) // 2
        k = (n * n + 1) // 2
        print(m, k)

solve()
","
def solve():
    n = int(input())
    if n == 1:
        print(-1)
    else:
        m = n**2 // 2 - 1
        k = n**2 // 2 + 1
        print(m, k)

solve()
","
def solve():
    n = int(input())
    if n == 1:
        print(-1)
    else:
        m = (n * n) // 2
        k = m + 1
        print(m, k)

solve()","
def solve():
    n = int(input())
    if n == 1:
        print(""-1"")
    else:
        m = n * 4
        k = n * 4 + 1
        print(m, k)

solve()
","6.666666666666667","6.666666666666667","60.0","66.66666666666666","33.33333333333333","0.0","6.666666666666667","6.666666666666667","33.33333333333333","33.33333333333333","6.666666666666667","6.666666666666667","33.33333333333333","6.666666666666667","33.33333333333333","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/135","
QUESTION:
Imp is watching a documentary about cave painting. [Image] 

Some numbers, carved in chaotic order, immediately attracted his attention. Imp rapidly proposed a guess that they are the remainders of division of a number n by all integers i from 1 to k. Unfortunately, there are too many integers to analyze for Imp.

Imp wants you to check whether all these remainders are distinct. Formally, he wants to check, if all $n \text{mod} i$, 1 ≤ i ≤ k, are distinct, i. e. there is no such pair (i, j) that:   1 ≤ i < j ≤ k,  $n \operatorname{mod} i = n \operatorname{mod} j$, where $x \operatorname{mod} y$ is the remainder of division x by y. 


-----Input-----

The only line contains two integers n, k (1 ≤ n, k ≤ 10^18).


-----Output-----

Print ""Yes"", if all the remainders are distinct, and ""No"" otherwise.

You can print each letter in arbitrary case (lower or upper).


-----Examples-----
Input
4 4

Output
No

Input
5 3

Output
Yes



-----Note-----

In the first sample remainders modulo 1 and 4 coincide.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    remainders = set()
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())

    remainders = set()
    distinct = True
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            distinct = False
            break
        remainders.add(remainder)

    if distinct:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    seen_remainders = set()
    for i in range(1, k+1):
        remainder = n % i
        if remainder in seen_remainders:
            print(""No"")
            return
        seen_remainders.add(remainder)
    print(""Yes"")

solve()","
def solve():
    n, k = map(int, input().split())
    remainders = set()
    for i in range(1, k+1):
        mod_val = n % i
        if mod_val in remainders:
            print(""No"")
            return
        remainders.add(mod_val)
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    
    remainders = set()
    for i in range(1, k+1):
        rem = n % i
        if rem in remainders:
            print(""No"")
            return
        remainders.add(rem)
    
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    remainders = set()
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)
    print(""Yes"")

solve()","
def solve():
    n, k = map(int, input().split())
    remainders = set()
    for i in range(1, k + 1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    
    remainders = set()
    for i in range(1, k+1):
        rem = n % i
        if rem in remainders:
            print(""No"")
            return
        remainders.add(rem)
    
    print(""Yes"")

solve()","
def solve():
    n, k = map(int, input().split())
    remainders = set()
    for i in range(1, k+1):
        rem = n % i
        if rem in remainders:
            print(""No"")
            return
        remainders.add(rem)
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    remainders = set()
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    remainders = set()

    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)

    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    
    remainders = set()
    distinct = True
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            distinct = False
            break
        remainders.add(remainder)
    
    if distinct:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n, k = map(int, input().split())
    
    remainders = set()
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)
    
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    
    remainders = set()
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)

    print(""Yes"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    
    remainders = set()
    for i in range(1, k + 1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)
    
    print(""Yes"")

solve()
","
def solve():
    n, k = map(int, input().split())
    remainders = set()
    for i in range(1, k+1):
        remainder = n % i
        if remainder in remainders:
            print(""No"")
            return
        remainders.add(remainder)
    print(""Yes"")

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/136","
QUESTION:
You are given two very long integers a, b (leading zeroes are allowed). You should check what number a or b is greater or determine that they are equal.

The input size is very large so don't use the reading of symbols one by one. Instead of that use the reading of a whole line or token.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printf instead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java. Don't use the function input() in Python2 instead of it use the function raw_input().


-----Input-----

The first line contains a non-negative integer a.

The second line contains a non-negative integer b.

The numbers a, b may contain leading zeroes. Each of them contains no more than 10^6 digits.


-----Output-----

Print the symbol ""<"" if a < b and the symbol "">"" if a > b. If the numbers are equal print the symbol ""="".


-----Examples-----
Input
9
10

Output
<

Input
11
10

Output
>

Input
00012345
12345

Output
=

Input
0123
9

Output
>

Input
0123
111

Output
>
Use user-input-Based format and function signature solve()","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip('0')
    b = b.lstrip('0')

    if len(a) < len(b):
        stdout.write('<')
    elif len(a) > len(b):
        stdout.write('>')
    else:
        if a < b:
            stdout.write('<')
        elif a > b:
            stdout.write('>')
        else:
            stdout.write('=')

if __name__ == ""__main__"":
    solve()
","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()
    
    a = a.lstrip('0')
    b = b.lstrip('0')
    
    if len(a) < len(b):
        result = '<'
    elif len(a) > len(b):
        result = '>'
    else:
        result = '<' if a < b else '>' if a > b else '='
    
    stdout.write(result)

solve()
","
def solve():
    import sys

    a = sys.stdin.readline().strip()
    b = sys.stdin.readline().strip()

    a = int(a.lstrip('0')) if a != '0' else 0
    b = int(b.lstrip('0')) if b != '0' else 0

    if a < b:
        print(""<"")
    elif a > b:
        print("">"")
    else:
        print(""="")

solve()
","
import sys

def solve():
    a = sys.stdin.readline().strip()
    b = sys.stdin.readline().strip()

    a = a.lstrip('0')
    b = b.lstrip('0')

    if len(a) < len(b):
        print(""<"")
    elif len(a) > len(b):
        print("">"")
    else:
        if a < b:
            print(""<"")
        elif a > b:
            print("">"")
        else:
            print(""="")

solve()
","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip('0')
    b = b.lstrip('0')

    if len(a) < len(b):
        stdout.write('<')
    elif len(a) > len(b):
        stdout.write('>')
    else:
        comp = a.compare(b)
        if comp < 0:
            stdout.write('<')
        elif comp > 0:
            stdout.write('>')
        else:
            stdout.write('=')

solve()
","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = int(a.lstrip(""0""))
    b = int(b.lstrip(""0""))

    if a < b:
        stdout.write(""<"")
    elif a > b:
        stdout.write("">"")
    else:
        stdout.write(""="")

if __name__ == ""__main__"":
    solve()
","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip('0')
    b = b.lstrip('0')

    if len(a) < len(b):
        stdout.write('<')
    elif len(a) > len(b):
        stdout.write('>')
    else:
        for i in range(len(a)):
            if a[i] < b[i]:
                stdout.write('<')
                return
            elif a[i] > b[i]:
                stdout.write('>')
                return
        stdout.write('=')
 
solve()","
def solve():
    a = int(raw_input().strip())
    b = int(raw_input().strip())
    
    if a < b:
        print(""<"")
    elif a > b:
        print("">"")
    else:
        print(""="")

solve()
","
from sys import stdin

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip('0')
    b = b.lstrip('0')

    if len(a) < len(b):
        print(""<"")
    elif len(a) > len(b):
        print("">"")
    elif a < b:
        print(""<"")
    elif a > b:
        print("">"")
    else:
        print(""="")

solve()
","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip('0')
    b = b.lstrip('0')

    if len(a) < len(b):
        stdout.write(""<"")
    elif len(a) > len(b):
        stdout.write("">"")
    else:
        for i in range(len(a)):
            if a[i] < b[i]:
                stdout.write(""<"")
                return
            elif a[i] > b[i]:
                stdout.write("">"")
                return
        stdout.write(""="")

solve()
  ","
def solve():
    import sys
    a = sys.stdin.readline().strip()
    b = sys.stdin.readline().strip()
    a = int(a.lstrip('0')) if a != '0' else 0
    b = int(b.lstrip('0')) if b != '0' else 0

    if a < b:
        print(""<"")
    elif a > b:
        print("">"")
    else:
        print(""="")

solve()","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip(""0"")
    b = b.lstrip(""0"")
    
    if len(a) < len(b):
        stdout.write(""<"")
    elif len(a) > len(b):
        stdout.write("">"")
    else:
        if a < b:
            stdout.write(""<"")
        elif a > b:
            stdout.write("">"")
        else:
            stdout.write(""="")

solve()
","
from sys import stdin

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip('0')
    b = b.lstrip('0')

    if len(a) < len(b):
        print(""<"")
    elif len(a) > len(b):
        print("">"")
    else:
        if a < b:
            print(""<"")
        elif a > b:
            print("">"")
        else:
            print(""="")

solve()
","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = a.lstrip(""0"")
    b = b.lstrip(""0"")

    len_a = len(a)
    len_b = len(b)

    if len_a < len_b:
        stdout.write(""<"")
    elif len_a > len_b:
        stdout.write("">"")
    else:
        if a < b:
            stdout.write(""<"")
        elif a > b:
            stdout.write("">"")
        else:
            stdout.write(""="")

if __name__ == ""__main__"":
    solve()
","
def solve():
    a = raw_input().strip()
    b = raw_input().strip()
    
    a = a.lstrip('0')
    b = b.lstrip('0')
    
    if len(a) < len(b):
        print(""<"")
    elif len(a) > len(b):
        print("">"")
    else:
        if a < b:
            print(""<"")
        elif a > b:
            print("">"")
        else:
            print(""="")

if __name__ == ""__main__"":
    solve()
","
from sys import stdin, stdout

def solve():
    a = stdin.readline().strip()
    b = stdin.readline().strip()

    a = int(a.lstrip(""0"") or 0)
    b = int(b.lstrip(""0"") or 0)

    if a < b:
        stdout.write(""<"")
    elif a > b:
        stdout.write("">"")
    else:
        stdout.write(""="")

solve()
","100.0","100.0","93.33333333333333","100.0","33.33333333333333","93.33333333333333","100.0","0.0","100.0","100.0","93.33333333333333","100.0","100.0","100.0","0.0","100.0","","","","","","","","","","","","","","","",""
"APPS/137","
QUESTION:
Kuro has recently won the ""Most intelligent cat ever"" contest. The three friends then decided to go to Katie's home to celebrate Kuro's winning. After a big meal, they took a small break then started playing games.

Kuro challenged Katie to create a game with only a white paper, a pencil, a pair of scissors and a lot of arrows (you can assume that the number of arrows is infinite). Immediately, Katie came up with the game called Topological Parity.

The paper is divided into $n$ pieces enumerated from $1$ to $n$. Shiro has painted some pieces with some color. Specifically, the $i$-th piece has color $c_{i}$ where $c_{i} = 0$ defines black color, $c_{i} = 1$ defines white color and $c_{i} = -1$ means that the piece hasn't been colored yet.

The rules of the game is simple. Players must put some arrows between some pairs of different pieces in such a way that for each arrow, the number in the piece it starts from is less than the number of the piece it ends at. Also, two different pieces can only be connected by at most one arrow. After that the players must choose the color ($0$ or $1$) for each of the unpainted pieces. The score of a valid way of putting the arrows and coloring pieces is defined as the number of paths of pieces of alternating colors. For example, $[1 \to 0 \to 1 \to 0]$, $[0 \to 1 \to 0 \to 1]$, $[1]$, $[0]$ are valid paths and will be counted. You can only travel from piece $x$ to piece $y$ if and only if there is an arrow from $x$ to $y$.

But Kuro is not fun yet. He loves parity. Let's call his favorite parity $p$ where $p = 0$ stands for ""even"" and $p = 1$ stands for ""odd"". He wants to put the arrows and choose colors in such a way that the score has the parity of $p$.

It seems like there will be so many ways which satisfy Kuro. He wants to count the number of them but this could be a very large number. Let's help him with his problem, but print it modulo $10^{9} + 7$.


-----Input-----

The first line contains two integers $n$ and $p$ ($1 \leq n \leq 50$, $0 \leq p \leq 1$) — the number of pieces and Kuro's wanted parity.

The second line contains $n$ integers $c_{1}, c_{2}, ..., c_{n}$ ($-1 \leq c_{i} \leq 1$) — the colors of the pieces.


-----Output-----

Print a single integer — the number of ways to put the arrows and choose colors so the number of valid paths of alternating colors has the parity of $p$.


-----Examples-----
Input
3 1
-1 0 1

Output
6
Input
2 1
1 0

Output
1
Input
1 1
-1

Output
2


-----Note-----

In the first example, there are $6$ ways to color the pieces and add the arrows, as are shown in the figure below. The scores are $3, 3, 5$ for the first row and $5, 3, 3$ for the second row, both from left to right.

 [Image]
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 10**9 + 7

    n, p = map(int, input().split())
    colors = list(map(int, input().split()))

    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n+1)]
    dp[0][0][0][0] = 1

    for i in range(1, n+1):
        for j in range(2):
            for k in range(2):
                for l in range(2):
                    for m in range(2):
                        for o in range(2):
                            if colors[i-1] != -1 and colors[i-1] != j:
                                continue
                            if i > 1 and l != m:
                                continue
                            if i > 1 and j == k and l == m:
                                continue
                            dp[i][j][k][o] += dp[i-1][k][l][m]
                            dp[i][j][k][o] %= MOD

    print(sum(dp[n][p][j][1] for j in range(2)) % MOD)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, p = map(int, input().split())
    colors = list(map(int, input().split()))
    
    dp = [[[0, 0] for _ in range(n + 1)] for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        if colors[i-1] != -1:
            dp[i][i][colors[i-1]] = 1
    
    for length in range(2, n + 1):
        for l in range(1, n - length + 2):
            r = l + length - 1
            
            for mid in range(l, r):
                for color_left in range(2):
                    for color_right in range(2):
                        if colors[mid-1] != -1 and colors[mid-1] != color_right:
                            continue
                        
                        add = dp[l][mid][color_left] * dp[mid + 1][r][color_right] % MOD
                        dp[l][r][(color_left + color_right) % 2] = (dp[l][r][(color_left + color_right) % 2] + add) % MOD
    
    print(dp[1][n][p])

solve()
","
def solve():
    MOD = 10**9 + 7

    n, p = map(int, input().split())
    colors = list(map(int, input().split()))

    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n)]
    dp[0][0][0][colors[0] == 0] = 1
    dp[0][0][1][colors[0] == 1] = 1

    for i in range(1, n):
        for x in range(2):
            for y in range(2):
                for c in range(2):
                    for d in range(2):
                        for a in range(2):
                            for b in range(2):
                                if colors[i] != -1 and colors[i] != x:
                                    continue
                                if colors[i-1] != -1 and colors[i-1] != y:
                                    continue
                                if a != b:
                                    continue
                                if (i >= 2 and a == 1 and b == 0 and c == d):
                                    continue
                                dp[i][x][c][a] += dp[i-1][y][d][b]
                                dp[i][x][c][a] %= MOD

    result = sum(sum(dp[n-1][x][p]) for x in range(2)) % MOD
    print(result)

solve()
","
def solve():
    mod = 10**9 + 7
    
    n, p = map(int, input().split())
    colors = list(map(int, input().split()))
    
    dp = [[[[0] * 2 for _ in range(2)] for _ in range(n)] for _ in range(n)]
    
    for i in range(n):
        if colors[i] != 0:
            dp[i][i][colors[i] == 1][0] = 1
        if colors[i] != 1:
            dp[i][i][colors[i] == 0][1] = 1
    
    for h in range(1, n):
        for l in range(n - h):
            r = l + h
            for t1 in range(2):
                for t2 in range(2):
                    for mid in range(l, r):
                        for c1 in range(2):
                            for c2 in range(2):
                                if dp[l][mid][c1][t1] and dp[mid + 1][r][c2][t2]:
                                    dp[l][r][c1 ^ c2][t1 ^ t2 ^ 1] += dp[l][mid][c1][t1] * dp[mid + 1][r][c2][t2]
                                    dp[l][r][c1 ^ c2][t1 ^ t2 ^ 1] %= mod
    
    print(dp[0][n - 1][0][p] + dp[0][n - 1][1][p])
    
solve()
","
def solve():
    MOD = 10**9 + 7
    n, p = map(int, input().split())
    c = list(map(int, input().split()))

    dp = [[0] * 2 for _ in range(n+1)]
    dp[0][0] = 1

    for i in range(n):
        if c[i] != -1:
            dp[i+1][c[i]] += dp[i][p]
            dp[i+1][c[i]] %= MOD
            dp[i+1][c[i] ^ 1] += dp[i][p ^ 1]
            dp[i+1][c[i] ^ 1] %= MOD
        else:
            dp[i+1][0] += dp[i][p]
            dp[i+1][0] %= MOD
            dp[i+1][1] += dp[i][p]
            dp[i+1][1] %= MOD
            dp[i+1][0] += dp[i][p ^ 1]
            dp[i+1][0] %= MOD
            dp[i+1][1] += dp[i][p ^ 1]
            dp[i+1][1] %= MOD

    print(dp[n][p])

solve()
  ","
def solve():
    mod = 10**9 + 7

    n, p = map(int, input().split())
    colors = list(map(int, input().split()))

    dp = [[[0] * 2 for _ in range(2)] for _ in range(n+1)]
    dp[0][0][0] = 1

    for i in range(1, n+1):
        for j in range(2):
            for k in range(2):
                if colors[i-1] != 1 or k == 1:
                    dp[i][j][k] = (dp[i-1][j^1][k] + dp[i-1][j][k]) % mod
                if colors[i-1] != 0 or k == 0:
                    dp[i][j][k] = (dp[i][j][k] + dp[i-1][j^1][k^1]) % mod

    print(dp[n][p][0] % mod)

solve()
","
import sys

def solve():
    n, p = map(int, sys.stdin.readline().split())
    colors = list(map(int, sys.stdin.readline().split()))
    
    # Your implementation here
    
solve()
  ","
def solve():
    MOD = 10**9 + 7
    
    n, p = map(int, input().split())
    colors = list(map(int, input().split()))
    
    # Your implementation to calculate the number of ways to put arrows and choose colors based on the given rules
    
    print(answer % MOD)

solve()
","
def solve():
    MOD = 10**9 + 7

    n, p = map(int, input().split())
    c = list(map(int, input().split()))

    dp = [[[[0 for _ in range(2)] for _ in range(2)] for _ in range(n)] for _ in range(n)]
    dp[0][0][0][0] = 1 if c[0] != -1 else 2
    dp[0][0][1][0] = 1 if c[0] != -1 and c[0] != 0 else 2

    for i in range(1, n):
        for j in range(2):
            for k in range(2):
                if c[i] == -1 or c[i] == j:
                    dp[i][0][j][k] = (dp[i-1][0][1-j][k] + dp[i-1][0][j][k]) % MOD

        for l in range(2):
            for j in range(2):
                dp[i][i][j][l] = (dp[i-1][i-1][1-j][1-l] + dp[i-1][i-1][j][l]) % MOD

        for j in range(2):
            for k in range(2):
                for l in range(2):
                    for m in range(2):
                        if j != l and m == p:
                            dp[i][i][k][m] = (dp[i][i][k][m] + dp[i-1][i-1][l][j]) % MOD

        for j in range(1, i):
            for k in range(2):
                for l in range(2):
                    for m in range(2):
                        for o in range(2):
                            if (j-i) % 2 == 1 and k != l and o == p:
                                dp[i][j][k][o] = (dp[i][j][k][o] + dp[i-1][j-1][l][m]) % MOD

    total = sum(dp[n-1][i][p][p] for i in range(n))
    print(total % MOD)

if __name__ == ""__main__"":
    solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, p = map(int, input().split())
    colors = list(map(int, input().split()))
    
    dp = [[[[0] * 2 for _ in range(2)] for _ in range(51)] for _ in range(51)]
    
    if colors[0] == 0:
        dp[0][0][0][0] = 1
    elif colors[0] == 1:
        dp[0][0][1][1] = 1
    else:
        dp[0][0][0][1] = 1
        dp[0][0][1][0] = 1
        
    for i in range(1, n):
        for j in range(i+1):
            for k in range(2):
                for f1 in range(2):
                    for f2 in range(2):
                        if colors[i] == -1 or colors[i] == k:
                            dp[i][j+1][k][f1] = (dp[i][j+1][k][f1] + dp[i-1][j][k][f2]) % MOD
                            if k != f2:
                                dp[i][j][k][f1] = (dp[i][j][k][f1] + dp[i-1][j][k][f2]) % MOD
    
    ans = sum(dp[n-1][j][p][1] for j in range(n)) % MOD
    print(ans)

solve()
","
def solve():
    import sys
    
    MOD = 10**9 + 7
    
    n, p = map(int, input().split())
    colors = list(map(int, input().split()))
    
    ways = [0] * (2 ** n)
    ways[0] = 1
    
    for mask in range(1, 2 ** n):
        dp = [[0] * 2 for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            if mask & (1 << (i - 1)):
                for j in range(n):
                    dp[j][1] = (dp[j + 1][0] + dp[j + 1][1] + dp[j][0] + dp[j][1]) % MOD
                dp[n - 1][0] = (dp[n - 1][0] + dp[n - 1][1]) % MOD
            else:
                for j in range(n):
                    dp[j][0] = (dp[j][0] + dp[j][1]) % MOD
                    dp[j][1] = 0
        
        score = dp[0][p]
        for i in range(n):
            if colors[i] != -1 and colors[i] != (i % 2):
                score = 0
                break
        
        ways[mask] = score
    
    dp = [0] * (2 ** n)
    dp[0] = 1
    
    for mask in range(1, 2 ** n):
        for sub_mask in range(mask, 0, -1):
            if (sub_mask & mask) == sub_mask:
                dp[mask] = (dp[mask] + dp[mask ^ sub_mask] * ways[sub_mask]) % MOD
    
    print(dp[2 ** n - 1])

solve()
","
def solve():
    mod = 10**9 + 7
    
    n, p = map(int, input().split())
    colors = list(map(int, input().split()))
    
    dp = [[[[0]*2 for _ in range(n)] for _ in range(n)] for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            for k in range(2):
                if colors[i] != 0 and colors[i] != k - 1:
                    continue
                if colors[j] != 1 and colors[j] != k:
                    continue
                
                dp[i][j][1][k] = 1
    
    for size in range(2, n+1):
        for i in range(n-size+1):
            j = i + size - 1
            for k in range(i, j):
                for x in range(2):
                    for y in range(2):
                        for z in range(2):
                            for w in range(2):
                                if (x + y) % 2 == p:
                                    dp[i][j][z][w] = (dp[i][j][z][w] + \
                                        dp[i][k][x][y] * dp[k+1][j][z][w]) % mod
    
    result = 0
    for i in range(n):
        for j in range(n):
            result = (result + dp[i][j][p][1]) % mod
    
    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7

    n, p = map(int, input().split())
    colors = list(map(int, input().split()))

    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n + 1)]
    dp[0][0][0][0] = 1

    for i in range(1, n + 1):
        for p0 in range(2):
            for p1 in range(2):
                for c0 in range(2):
                    for c1 in range(2):
                        for pprev in range(2):
                            for cprev in range(2):
                                if colors[i - 1] != -1 and colors[i - 1] != c1:
                                    continue
                                if i == 1 and colors[i - 1] != -1 and colors[i - 1] != cprev:
                                    continue
                                if pprev == p1 and cprev == c1:
                                    continue
                                dp[i][p1][c1][c0] = (dp[i][p1][c1][c0] + dp[i-1][p0][c0][cprev]) % MOD

    ans = sum(dp[n][p0][0][0] for p0 in range(2) for c0 in range(2) for cprev in range(2) if p0 == p) % MOD

    print(ans)

solve()
","
from math import factorial

def solve():
    n, p = map(int, input().split())
    c = list(map(int, input().split()))

    def dfs(prev, idx, cnt, parity):
        if idx == n:
            if parity == p:
                return factorial(cnt)
            else:
                return 0
        res = 0
        res += dfs(c[idx], idx + 1, 1 if prev != -1 else 0, (parity + 1) % 2)
        if c[idx] != -1:
            res += dfs(c[idx], idx + 1, cnt + 1, parity)
        return res

    result = dfs(-1, 0, 0, 0) % (10**9 + 7)
    print(result)

solve()
","
def solve():
    mod = 10**9 + 7

    n, p = map(int, input().split())
    c = list(map(int, input().split()))

    dp = [[[0, 0] for _ in range(n + 1)] for _ in range(n + 1)]
    dp[0][0][0] = 1

    for i in range(1, n + 1):
        if c[i-1] == 1:
            dp[i][i][1] = 1
        elif c[i-1] == 0:
            dp[i][i][0] = 1
        else:
            dp[i][i][0] = dp[i][i][1] = 1

    for len_seq in range(2, n + 1):
        for i in range(1, n - len_seq + 2):
            j = i + len_seq - 1

            for k in range(i, j + 1):
                if c[k-1] != -1:
                    dp[i][j][0] = (dp[i][j][0] + (dp[i][k-1][1] * dp[k+1][j][0]) % mod) % mod
                    dp[i][j][1] = (dp[i][j][1] + (dp[i][k-1][0] * dp[k+1][j][1]) % mod) % mod
                else:
                    dp[i][j][0] = (dp[i][j][0] + (dp[i][k-1][0] * dp[k+1][j][0]) % mod + (dp[i][k-1][1] * dp[k+1][j][0]) % mod) % mod
                    dp[i][j][1] = (dp[i][j][1] + (dp[i][k-1][0] * dp[k+1][j][1]) % mod + (dp[i][k-1][1] * dp[k+1][j][1]) % mod) % mod

    print(dp[1][n][p])

solve()
","
def solve():
    MOD = 10**9 + 7

    n, p = map(int, input().split())
    colors = list(map(int, input().split()))

    count_unpainted = colors.count(-1)
    count_painted_odd = colors.count(1)
    count_painted_even = colors.count(0)

    dp_unpainted = [[[0, 0] for _ in range(count_unpainted + 1)] for _ in range(n + 1)]
    dp_unpainted[0][0][0] = 1

    for i in range(1, n + 1):
        for j in range(count_unpainted + 1):
            for k in range(2):
                for l in range(j + 1):
                    if k == 1:
                        dp_unpainted[i][j][k] += dp_unpainted[i - 1][j - l][1 - k]
                    else:
                        dp_unpainted[i][j][k] += dp_unpainted[i - 1][j - l][1 - k] + dp_unpainted[i - 1][j - l][k]
                    dp_unpainted[i][j][k] %= MOD

    result = 0
    for i in range(count_unpainted + 1):
        for j in range(count_unpainted - i + 1):
            if (i + count_painted_odd) % 2 == p and (j + count_painted_even) % 2 == p:
                result += dp_unpainted[n][i][0] * dp_unpainted[n][j][1]
                result %= MOD

    print(result)

solve()
","0.0","6.666666666666667","6.666666666666667","6.666666666666667","13.333333333333334","6.666666666666667","0.0","0.0","0.0","0.0","7.6923076923076925","13.333333333333334","0.0","18.181818181818183","0.0","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/138","
QUESTION:
Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for a rubles, a pack of two copybooks for b rubles, and a pack of three copybooks for c rubles. Alyona already has n copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks k that n + k is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.


-----Input-----

The only line contains 4 integers n, a, b, c (1 ≤ n, a, b, c ≤ 10^9).


-----Output-----

Print the minimum amount of rubles she should pay to buy such number of copybooks k that n + k is divisible by 4.


-----Examples-----
Input
1 1 3 4

Output
3

Input
6 2 1 1

Output
1

Input
4 4 4 4

Output
0

Input
999999999 1000000000 1000000000 1000000000

Output
1000000000



-----Note-----

In the first example Alyona can buy 3 packs of 1 copybook for 3a = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for b = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.
Use user-input-Based format and function signature solve()","
def solve():
    n, a, b, c = map(int, input().split())
    remainder = (4 - (n % 4)) % 4
    min_rubles = min(a, b*2, c*3)
    print(min_rubles * remainder)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())

    remaining_copybooks = (4 - (n % 4)) % 4

    min_rubles = min(a, b * 2, c * 3)

    cost = min_rubles * remaining_copybooks

    print(cost)
  
solve()","
def solve():
    n, a, b, c = map(int, input().split())
    rem = (4 - n % 4) % 4
    costs = [a, b, c, 3*a, a+b, 2*b, a+c, 2*a, 2*c]
    min_cost = float('inf')
    for i in range(9):
        if i <= rem:
            cost = rem // 3 * costs[i]
            if rem % 3 > 0:
                cost += costs[i + rem % 3]
            min_cost = min(min_cost, cost)
    print(min_cost)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())
    
    total_copybooks = n
    while (total_copybooks % 4 != 0):
        total_copybooks += 1
    
    min_rubles = min(a, b*2, c*3)
    
    print(min_rubles * (total_copybooks - n))

solve()
","
def solve():
    n, a, b, c = map(int, input().split())
    needed = (4 - (n % 4)) % 4
    costs = [a, b, c, a*3, b+a, c*3]
    print(min(costs[i] for i in range(6) if i%4 == needed))

solve()
","
def solve():
    n, a, b, c = map(int, input().split())
    
    x = 4 - (n % 4)
    
    min_rubles = min(min(a, b*2, c*3), a*x, b*(x//2), c*(x//3))
    
    print(min_rubles)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())
    remainder = (4 - (n % 4)) % 4
    packs = [a, b, c, 3*a, 2*b, a+b, 2*a+c]
    min_rubles = min(packs[i] for i in range(7) if i % 4 == remainder)
    print(min_rubles)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())
    total_copybooks = n
    while (total_copybooks % 4 != 0):
        total_copybooks += 1
    
    min_rubles = min(a, b*2, c*3)
    print(min_rubles * ((total_copybooks - n) // 4))

solve()
","
def solve():
    n, a, b, c = map(int, input().split())

    def cost_to_divisible_by_four(n):
        return (4 - n % 4) % 4

    min_rubles = min(
        cost_to_divisible_by_four(n),
        a + cost_to_divisible_by_four(n + 1),
        b + cost_to_divisible_by_four(n + 2),
        c + cost_to_divisible_by_four(n + 3)
    )

    print(min_rubles)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())
    total_copybooks = n
    while (total_copybooks + 3) % 4 != 0:
        total_copybooks += 1
    cost_a = a * (4 - n % 4)  # cost of buying single copybooks to reach multiple of 4
    cost_b = min(b, a * 2)   # cost of buying pack of 2 copybooks
    cost_c = min(c, a * 3)   # cost of buying pack of 3 copybooks
    total_cost = min(cost_a, cost_b, cost_c)
    print(total_cost)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())
    rem = (4 - (n % 4)) % 4

    if rem == 1:
        print(min(a, b + c, 3 * c))
    elif rem == 2:
        print(min(2 * a, b, 2 * c))
    elif rem == 3:
        print(min(3 * a, a + c, b))
    else:
        print(0)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())

    rem = 4 - (n % 4)
    
    cost = min(a, b*2, c*3)
    cost *= rem
    
    print(cost)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())

    remaining = (4 - n % 4) % 4

    pack_1_price = min(a, b + c, 3 * c)
    pack_2_price = min(2 * a, b, 2 * c)
    pack_3_price = min(3 * a, c)

    total_price = min(pack_1_price * remaining, pack_2_price * (remaining // 2), pack_3_price * (remaining // 3))

    print(total_price)

solve()","
def solve():
    n, a, b, c = map(int, input().split())
    remainder = (4 - (n % 4)) % 4
    pack_costs = [a, b, c]
    cost = float('inf')
    
    for i in range(3):
        current_cost = remainder * pack_costs[i]
        cost = min(cost, current_cost)
    
    print(cost)

solve()
","
def solve():
    n, a, b, c = map(int, input().split())

    remainder = (4 - (n % 4)) % 4

    if remainder == 1:
        print(min(a, b + c, 3*c))
    elif remainder == 2:
        print(min(2*a, b, 2*c))
    elif remainder == 3:
        print(min(3*a, a + c, b))
    else:
        print(0)

solve()","
def solve():
    n, a, b, c = map(int, input().split())
    
    remainder = (4 - (n % 4)) % 4
    cost_a = a * remainder
    cost_b = min(b, a*2)
    cost_c = min(c, min(a*3, b+a))
    
    min_cost = min(cost_a, cost_b, cost_c)
    
    print(min_cost)

solve()
","53.333333333333336","53.333333333333336","46.666666666666664","53.333333333333336","33.33333333333333","6.666666666666667","33.33333333333333","20.0","53.333333333333336","53.333333333333336","80.0","33.33333333333333","40.0","53.333333333333336","80.0","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/139","
QUESTION:
You are given a directed graph consisting of n vertices and m edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.

Can you make this graph acyclic by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).


-----Input-----

The first line contains two integers n and m (2 ≤ n ≤ 500, 1 ≤ m ≤ min(n(n - 1), 100000)) — the number of vertices and the number of edges, respectively.

Then m lines follow. Each line contains two integers u and v denoting a directed edge going from vertex u to vertex v (1 ≤ u, v ≤ n, u ≠ v). Each ordered pair (u, v) is listed at most once (there is at most one directed edge from u to v).


-----Output-----

If it is possible to make this graph acyclic by removing at most one edge, print YES. Otherwise, print NO.


-----Examples-----
Input
3 4
1 2
2 3
3 2
3 1

Output
YES

Input
5 6
1 2
2 3
3 2
3 1
2 1
4 5

Output
NO



-----Note-----

In the first example you can remove edge $2 \rightarrow 3$, and the graph becomes acyclic.

In the second example you have to remove at least two edges (for example, $2 \rightarrow 1$ and $2 \rightarrow 3$) in order to make the graph acyclic.
Use user-input-Based format and function signature solve()","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    edges = []
    for _ in range(m):
        u, v = map(int, input().split())
        edges.append((u, v))

    def has_cycle(adj_list):
        visited = set()
        stack = set()

        def dfs(node):
            if node in stack:
                return True
            if node in visited:
                return False

            visited.add(node)
            stack.add(node)

            for neighbor in adj_list[node]:
                if dfs(neighbor):
                    return True

            stack.remove(node)
            return False

        for node in adj_list:
            if node not in visited:
                if dfs(node):
                    return True

        return False

    adj_list = defaultdict(list)
    for u, v in edges:
        adj_list[u].append(v)

    for i, (u, v) in enumerate(edges):
        adj_list[u].remove(v)
        if not has_cycle(adj_list):
            print(""YES"")
            return
        adj_list[u].append(v)

    print(""NO"")

solve()
","
from collections import defaultdict
from typing import List

def solve(n: int, m: int, edges: List[List[int]]) -> str:
    graph = defaultdict(list)
    
    def is_cyclic(node, visited, stack):
        visited[node] = True
        stack[node] = True
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if is_cyclic(neighbor, visited, stack):
                    return True
            elif stack[neighbor]:
                return True
        
        stack[node] = False
        return False

    for edge in edges:
        graph[edge[0]].append(edge[1])
    
    for node in range(1, n+1):
        visited = [False] * (n+1)
        stack = [False] * (n+1)
        
        if is_cyclic(node, visited, stack):
            return ""YES""
    
    return ""NO""

solve()","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    graph = defaultdict(list)
    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)
    
    def has_cycle(node, visited, stack):
        visited[node] = True
        stack[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if has_cycle(neighbor, visited, stack):
                    return True
            elif stack[neighbor]:
                return True
        stack[node] = False
        return False

    for node in range(1, n + 1):
        visited = [False] * (n + 1)
        stack = [False] * (n + 1)
        if has_cycle(node, visited, stack):
            return ""YES""
    
    for edge in range(m):
        u, v = list(graph.keys())[edge], list(graph.values())[edge][0]
        graph[u].remove(v)
        visited = [False] * (n + 1)
        stack = [False] * (n + 1)
        has_cycle_flag = False
        for start_node in range(1, n + 1):
            if not visited[start_node]:
                if has_cycle(start_node, visited, stack):
                    has_cycle_flag = True
                    break
        graph[u].append(v)
        if not has_cycle_flag:
            return ""YES""

    return ""NO""

# Test the function
print(solve())

solve()","
from collections import defaultdict

def solve():
    def is_acyclic(adj_list, n):
        visited = [False] * n
        parent = [-1] * n

        def dfs(node):
            visited[node] = True
            for neighbor in adj_list[node]:
                if not visited[neighbor]:
                    parent[neighbor] = node
                    if dfs(neighbor):
                        return True
                elif parent[node] != neighbor:
                    return True
            return False

        for i in range(n):
            if not visited[i]:
                if dfs(i):
                    return False
        return True

    n, m = map(int, input().split())
    adj_list = defaultdict(list)
    for _ in range(m):
        u, v = map(int, input().split())
        adj_list[u-1].append(v-1)

    for i in range(m):
        u, v = map(int, input().split())
        adj_list[u-1].remove(v-1)
        if is_acyclic(adj_list, n):
            print(""YES"")
            return
        adj_list[u-1].append(v-1)

    print(""NO"")

solve()
","
from collections import defaultdict
from typing import List, Tuple

def solve(n:int, m:int, edges:List[Tuple[int,int]]) -> str:
    graph = defaultdict(list)
    for u,v in edges:
        graph[u].append(v)

    def has_cycle(u, visited, in_path):
        visited[u] = True
        in_path[u] = True

        for v in graph[u]:
            if not visited[v]:
                if has_cycle(v, visited, in_path):
                    return True
            elif in_path[v]:
                return True

        in_path[u] = False
        return False

    def is_acyclic():
        visited = [False] * (n + 1)
        in_path = [False] * (n + 1)

        for u in range(1, n + 1):
            if not visited[u]:
                if has_cycle(u, visited, in_path):
                    return False
        return True

    if is_acyclic():
        return ""YES""
    else:
        for u,v in edges:
            graph[u].remove(v)
            if is_acyclic():
                return ""YES""
            graph[u].append(v)

        return ""NO""

solve()","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    graph = defaultdict(list)
    
    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)
    
    def is_cyclic(node, visited, stack):
        visited[node] = True
        stack[node] = True
        
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if is_cyclic(neighbor, visited, stack):
                    return True
            elif stack[neighbor]:
                return True
        
        stack[node] = False
        return False
    
    def has_cycle():
        visited = [False] * (n + 1)
        stack = [False] * (n + 1)
        
        for node in range(1, n + 1):
            if not visited[node]:
                if is_cyclic(node, visited, stack):
                    return True
        
        return False
    
    for edge in range(1, m + 1):
        u, v = list(graph.keys())[edge-1], list(graph.values())[edge-1][0]
        graph[u].remove(v)
        
        if not has_cycle():
            print(""YES"")
            return
        
        graph[u].append(v)

    print(""NO"")
    
solve()
","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    edges = []
    for _ in range(m):
        u, v = map(int, input().split())
        edges.append((u, v))
    
    def has_cycle(adj_list):
        visited = set()
        rec_stack = set()
        
        def dfs(node):
            if node in rec_stack:
                return True
            if node in visited:
                return False
            
            visited.add(node)
            rec_stack.add(node)
            for neighbor in adj_list[node]:
                if dfs(neighbor):
                    return True
            
            rec_stack.remove(node)
            return False
        
        for vertex in adj_list:
            if vertex not in visited:
                if dfs(vertex):
                    return True
        return False
    
    adj_list = defaultdict(list)
    for u, v in edges:
        adj_list[u].append(v)
    
    for edge in edges:
        u, v = edge
        adj_list[u].remove(v)
        if not has_cycle(adj_list):
            print(""YES"")
            return
        
        adj_list[u].append(v)
    
    print(""NO"")

solve()
","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    graph = defaultdict(list)
    edges = []
    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)
        edges.append((u, v))

    def has_cycle(node, visited, stack):
        visited[node] = True
        stack[node] = True

        for neighbor in graph[node]:
            if not visited[neighbor]:
                if has_cycle(neighbor, visited, stack):
                    return True
            elif stack[neighbor]:
                return True

        stack[node] = False
        return False

    for edge in edges:
        u, v = edge
        graph[u].remove(v)
        visited = [False] * (n + 1)
        stack = [False] * (n + 1)
        
        cycle_found = False
        for node in range(1, n + 1):
            if not visited[node]:
                if has_cycle(node, visited, stack):
                    cycle_found = True
                    break

        graph[u].append(v)

        if cycle_found:
            print(""NO"")
        else:
            print(""YES"")

solve()
","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    edges = defaultdict(list)

    for _ in range(m):
        u, v = map(int, input().split())
        edges[u].append(v)
    
    def is_acyclic():
        visited = set()
        stack = set()

        def dfs(node):
            if node in stack:
                return True
            if node in visited:
                return False

            visited.add(node)
            stack.add(node)
            for neighbor in edges.get(node, []):
                if dfs(neighbor):
                    return True

            stack.remove(node)
            return False
        
        for node in range(1, n+1):
            if dfs(node):
                return True
        
        return False

    for u, v in list(edges.values()):
        edges[u].remove(v)
        if not is_acyclic():
            print(""YES"")
            return
        edges[u].append(v)

    print(""NO"")

solve()
","
def solve():
    import collections

    def dfs(node, graph, visited, stack):
        visited[node] = True
        stack[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor, graph, visited, stack):
                    return True
            elif stack[neighbor]:
                return True
        stack[node] = False
        return False

    def has_cycle(graph, n):
        visited = [False] * n
        stack = [False] * n
        for i in range(n):
            if not visited[i]:
                if dfs(i, graph, visited, stack):
                    return True
        return False

    def solve(n, m, edges):
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
        if has_cycle(graph, n):
            for u, v in edges:
                graph[u].remove(v)
                if not has_cycle(graph, n):
                    return ""YES""
                graph[u].append(v)
            return ""NO""
        return ""YES""

    n, m = map(int, input().split())
    edges = [list(map(int, input().split())) for _ in range(m)]
    print(solve(n, m, edges))

solve()
","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    edges = []
    for _ in range(m):
        u, v = map(int, input().split())
        edges.append((u, v))

    def has_cycle():
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            
        visited = set()
        rec_stack = set()
        
        def dfs(node):
            if node in rec_stack:
                return True
            if node in visited:
                return False
            
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in graph[node]:
                if dfs(neighbor):
                    return True
                
            rec_stack.remove(node)
            return False
        
        for node in range(1, n + 1):
            if dfs(node):
                return True
        
        return False

    for i in range(m):
        u, v = edges[i]
        edges[i] = (0, 0)
        if not has_cycle():
            return ""YES""
        edges[i] = (u, v)
    
    return ""NO""


solve()","
def solve():
    n, m = map(int, input().split())
    edges = []
    for _ in range(m):
        u, v = map(int, input().split())
        edges.append((u, v))

    def has_cycle():
        def dfs(node, visited, rec_stack):
            visited[node] = True
            rec_stack[node] = True

            for neighbor in graph.get(node, []):
                if not visited[neighbor]:
                    if dfs(neighbor, visited, rec_stack):
                        return True
                elif rec_stack[neighbor]:
                    return True

            rec_stack[node] = False
            return False

        graph = {}
        for u, v in edges:
            if u not in graph:
                graph[u] = []
            graph[u].append(v)

        visited = {node: False for node in range(1, n + 1)}
        rec_stack = {node: False for node in range(1, n + 1)}

        for node in graph.keys():
            if not visited[node]:
                if dfs(node, visited, rec_stack):
                    return True

        return False

    for i in range(m):
        edge_to_remove = edges[i]
        edges.pop(i)
        if not has_cycle():
            return ""YES""
        edges.insert(i, edge_to_remove)

    return ""NO""

solve()
  ","
def solve():
    import collections

    n, m = map(int, input().split())
    adj_list = collections.defaultdict(list)
    edges = []

    for _ in range(m):
        u, v = map(int, input().split())
        adj_list[u].append(v)
        edges.append((u, v))

    def has_cycle():
        visited = [False] * (n + 1)
        stack = [False] * (n + 1)

        def dfs(node):
            visited[node] = True
            stack[node] = True

            for neighbor in adj_list[node]:
                if not visited[neighbor]:
                    if dfs(neighbor):
                        return True
                elif stack[neighbor]:
                    return True

            stack[node] = False
            return False

        for node in range(1, n + 1):
            if not visited[node]:
                if dfs(node):
                    return True

        return False

    if has_cycle():
        for u, v in edges:
            adj_list[u].remove(v)
            if not has_cycle():
                print(""YES"")
                return

            adj_list[u].append(v)

    print(""NO"")

solve()
                                                                                                                                                                                                                                                                    ","
from collections import defaultdict

def solve():
    def dfs(node):
        visited[node] = True
        onPath[node] = True

        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif onPath[neighbor]:
                return True

        onPath[node] = False
        return False

    n, m = map(int, input().split())
    graph = defaultdict(list)
    edges = []

    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)
        edges.append((u, v))

    for i in range(m):
        visited = [False] * (n + 1)
        onPath = [False] * (n + 1)
        
        u, v = edges[i]
        graph[u].remove(v)
        if not dfs(1):
            print(""YES"")
            return

        graph[u].append(v)

    print(""NO"")

solve()","
from collections import defaultdict

def solve():
    n, m = map(int, input().split())
    graph = defaultdict(list)

    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)

    def dfs(node, visited, stack):
        visited[node] = True
        stack[node] = True

        for neighbor in graph[node]:
            if not visited[neighbor]:
                if dfs(neighbor, visited, stack):
                    return True
            elif stack[neighbor]:
                return True

        stack[node] = False
        return False

    for vertex in range(1, n+1):
        if dfs(vertex, [False]*(n+1), [False]*(n+1)):
            return ""YES""

    return ""NO""

solve()","
def solve():
    import sys
    from collections import defaultdict
    
    n, m = map(int, input().split())
    graph = defaultdict(list)
    edges = []
    
    for _ in range(m):
        u, v = map(int, input().split())
        graph[u].append(v)
        edges.append((u, v))
    
    def has_cycle():
        def dfs(node, visited, rec_stack):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor, visited, rec_stack):
                        return True
                elif neighbor in rec_stack:
                    return True
            
            rec_stack.remove(node)
            return False
        
        visited = set()
        rec_stack = set()
        
        for node in graph.keys():
            if node not in visited:
                if dfs(node, visited, rec_stack):
                    return True
        
        return False
    
    for edge in edges:
        graph[edge[0]].remove(edge[1])
        
        if not has_cycle():
            print(""YES"")
            return
        
        graph[edge[0]].append(edge[1])
    
    print(""NO"")

solve()","86.66666666666667","0.0","0.0","0.0","0.0","66.66666666666666","86.66666666666667","0.0","6.666666666666667","13.333333333333334","0.0","0.0","86.66666666666667","80.0","0.0","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/140","
QUESTION:
The mayor of the Central Town wants to modernize Central Street, represented in this problem by the $(Ox)$ axis.

On this street, there are $n$ antennas, numbered from $1$ to $n$. The $i$-th antenna lies on the position $x_i$ and has an initial scope of $s_i$: it covers all integer positions inside the interval $[x_i - s_i; x_i + s_i]$.

It is possible to increment the scope of any antenna by $1$, this operation costs $1$ coin. We can do this operation as much as we want (multiple times on the same antenna if we want).

To modernize the street, we need to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna. Note that it is authorized to cover positions outside $[1; m]$, even if it's not required.

What is the minimum amount of coins needed to achieve this modernization?


-----Input-----

The first line contains two integers $n$ and $m$ ($1 \le n \le 80$ and $n \le m \le 100\ 000$).

The $i$-th of the next $n$ lines contains two integers $x_i$ and $s_i$ ($1 \le x_i \le m$ and $0 \le s_i \le m$).

On each position, there is at most one antenna (values $x_i$ are pairwise distinct).


-----Output-----

You have to output a single integer: the minimum amount of coins required to make all integer positions from $1$ to $m$ inclusive covered by at least one antenna.


-----Examples-----
Input
3 595
43 2
300 4
554 10

Output
281

Input
1 1
1 1

Output
0

Input
2 50
20 0
3 1

Output
30

Input
5 240
13 0
50 25
60 5
155 70
165 70

Output
26



-----Note-----

In the first example, here is a possible strategy:

  Increase the scope of the first antenna by $40$, so that it becomes $2 + 40 = 42$. This antenna will cover interval $[43 - 42; 43 + 42]$ which is $[1; 85]$  Increase the scope of the second antenna by $210$, so that it becomes $4 + 210 = 214$. This antenna will cover interval $[300 - 214; 300 + 214]$, which is $[86; 514]$  Increase the scope of the third antenna by $31$, so that it becomes $10 + 31 = 41$. This antenna will cover interval $[554 - 41; 554 + 41]$, which is $[513; 595]$ 

Total cost is $40 + 210 + 31 = 281$. We can prove that it's the minimum cost required to make all positions from $1$ to $595$ covered by at least one antenna.

Note that positions $513$ and $514$ are in this solution covered by two different antennas, but it's not important.

—

In the second example, the first antenna already covers an interval $[0; 2]$ so we have nothing to do.

Note that the only position that we needed to cover was position $1$; positions $0$ and $2$ are covered, but it's not important.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))

    antennas.sort()
    covered = 0
    coins = 0

    for x, s in antennas:
        if x - s > covered + 1:
            coins += x - s - covered - 1
            covered = x + s
        elif x + s > covered:
            covered = x + s

    if covered < m:
        coins += m - covered

    print(coins)

solve()
","
def solve():
    import heapq
    
    n, m = map(int, input().split())
    antennas = []
    
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x - s - 1, x + s))
    
    antennas.sort()
    
    scope_max = 0
    coins = 0
    covered = 0
    i = 0
    
    pq = []
    
    while covered < m:
        while i < n and antennas[i][0] <= covered:
            heapq.heappush(pq, -antennas[i][1])
            i += 1
        
        if not pq:
            return -1
        
        scope_max = -heapq.heappop(pq)
        coins += 1
        covered = scope_max
        if covered >= m:
            break
        
    return coins

# Call the function to execute
print(solve())
  
solve()","
def solve():
    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))

    antennas.sort()

    dp = [float('inf')] * (m + 1)
    dp[0] = 0

    for i in range(1, m + 1):
        for x, s in antennas:
            dp[i] = min(dp[i], dp[max(0, i - 2 * s + x - 1)] + abs(x - i) + max(0, 2 * s - abs(x - i)))

    return dp[m]

# Example usage
print(solve())

solve()","
def solve():
    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))
    
    antennas.sort()
    coins_needed = 0
    covered_until = 0

    for i in range(n):
        x, s = antennas[i]
        if x - s > covered_until + 1:
            coins_needed += x - s - covered_until - 1
            covered_until = x + s
        elif x + s > covered_until:
            covered_until = x + s
    
    if covered_until < m:
        coins_needed += m - covered_until
    
    print(coins_needed)

solve()
","
def solve():
    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))

    covered = [0] * (m + 2)
    for x, s in antennas:
        left = max(x - s, 0)
        right = min(x + s, m + 1)
        covered[left] += 1
        covered[right + 1] -= 1

    ans = 0
    cnt = 0
    for i in range(1, m + 1):
        cnt += covered[i]
        if cnt == 0:
            ans += 1

    print(ans)

# Input parsing
n, m = map(int, input().split())
# Call the function
solve()
  ","
from typing import List, Tuple

def solve(n: int, m: int, antennas: List[Tuple[int, int]]) -> int:
    coins_needed = 0
    covered_positions = set()
    
    for x, s in antennas:
        left_most = max(1, x - s)
        right_most = min(m, x + s)
        
        for i in range(left_most, right_most + 1):
            if i not in covered_positions:
                coins_needed += 1
                covered_positions.add(i)
    
    return coins_needed

solve()","
def solve():
    n, m = map(int, input().split())
    antennas = [list(map(int, input().split())) for _ in range(n)]
    
    covered = [0] * (m + 2)
    for x, s in antennas:
        covered[max(1, x - s)] += 1
        covered[min(m + 1, x + s + 1)] -= 1

    coins = 0
    curr_sum = 0
    for i in range(1, m + 1):
        curr_sum += covered[i]
        if curr_sum == 0:
            coins += 1

    print(coins)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))
    
    positions = set()
    for x, s in antennas:
        for i in range(max(1, x - s), min(m + 1, x + s + 1)):
            positions.add(i)
    
    coins = 0
    uncovered = set(range(1, m + 1)) - positions
    while uncovered:
        max_gap = 0
        max_gap_pos = -1
        for i in range(1, m + 1):
            if i in uncovered:
                gap_left = 0
                while i - gap_left in uncovered:
                    gap_left += 1
                
                gap_right = 0
                while i + gap_right in uncovered:
                    gap_right += 1
                
                gap = min(gap_left, gap_right)
                if gap > max_gap:
                    max_gap = gap
                    max_gap_pos = i
        
        for x, s in antennas:
            if max_gap_pos in range(max(1, x - s), min(m + 1, x + s + 1)):
                antennas.append((x, s + 1))
                coins += 1
                for i in range(max(1, x - s), min(m + 1, x + s + 1)):
                    positions.add(i)
                break
        
        uncovered = set(range(1, m + 1)) - positions
    
    print(coins)

solve()
","
def solve():
    import sys
    input = sys.stdin.readline

    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))

    antennas.sort()
    covered = 0
    coins = 0
    for i in range(n):
        if covered >= m:
            break
        if antennas[i][0] - antennas[i][1] > covered + 1:
            coins += antennas[i][0] - antennas[i][1] - covered - 1
            covered = antennas[i][0] - antennas[i][1] - 1
        elif antennas[i][0] + antennas[i][1] > covered:
            covered = antennas[i][0] + antennas[i][1] 

    if covered < m:
        coins += m - covered
    return coins

solve()","
from math import ceil

def solve():
    n, m = map(int, input().split())
    antennas = [list(map(int, input().split())) for _ in range(n)]
    
    covered = [0] * (m + 2)
    for x, s in antennas:
        l = max(1, x - s)
        r = min(m + 1, x + s + 1)
        covered[l] += 1
        covered[r] -= 1
    
    cost = 0
    total_covered = 0
    cur_cover = 0
    for i in range(1, m + 2):
        cur_cover += covered[i]
        if cur_cover == 0:
            closest_uncovered = min(abs(i - prev) for prev in range(total_covered, 0, -1))
            cost += ceil(closest_uncovered / 2)
            total_covered = 0
        else:
            total_covered += cur_cover
    
    return cost

solve()","
def solve():
    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))

    coins_needed = 0
    covered_positions = set()
    for i in range(1, m + 1):
        position_covered = False
        for x, s in antennas:
            if abs(i - x) <= s:
                position_covered = True
                break
        if not position_covered:
            closest_antenna = min(antennas, key=lambda a: abs(i - a[0]))
            coins_needed += abs(i - closest_antenna[0]) - closest_antenna[1]
            covered_positions.add(closest_antenna[0])
    
    print(coins_needed)

solve()
","
def solve():
    n, m = map(int, input().split())
    antennas = []
    for _ in range(n):
        x, s = map(int, input().split())
        antennas.append((x, s))

    antennas.sort()

    uncovered = set(range(1, m+1))
    cost = 0

    for x, s in antennas:
        while s > 0 and len(uncovered) > 0:
            min_dist = min(abs(x - u) for u in uncovered)
            s_used = min(s, min_dist)
            s -= s_used
            uncovered = {u for u in uncovered if abs(x - u) > s_used}
            cost += s_used
        if len(uncovered) == 0:
            break

    print(cost)

import sys
solve()
  ","
def solve():
    n, m = map(int, input().strip().split())
    antennas = [list(map(int, input().strip().split())) for _ in range(n)]
    
    coverage = [0] * (m+1)
    for x, s in antennas:
        left = max(1, x - s)
        right = min(m, x + s)
        for i in range(left, right+1):
            coverage[i] = max(coverage[i], x + s - i)
    
    coins = 0
    pos = 1
    while pos <= m:
        if coverage[pos] == 0:
            coins += 1
            pos += 1
        else:
            pos += coverage[pos]
    
    return coins

# Call the function to run with input and output handling
print(solve())

solve()","
# Function signature: solve(n: int, m: int, antennas: List[Tuple[int, int]]) -> int

from typing import List, Tuple

def solve(n: int, m: int, antennas: List[Tuple[int, int]]) -> int:
    max_right = [0] * (m + 1)
    for x, s in antennas:
        left = max(1, x - s)
        right = min(m, x + s)
        max_right[left] = max(max_right[left], right)
    
    dp = [float('inf')] * (m + 1)
    dp[0] = 0
    for i in range(1, m + 1):
        for j in range(1, i + 1):
            if max_right[j] >= i:
                dp[i] = min(dp[i], dp[j - 1] + 1)
    
    return dp[m]
  
solve()","
def solve():
    n, m = map(int, input().split())
    antennas = [list(map(int, input().split())) for _ in range(n)]

    gaps = [0] * (m + 1)
    for x, s in antennas:
        left = max(1, x - s)
        right = min(m, x + s)
        gaps[left] += 1
        if right + 1 <= m:
            gaps[right + 1] -= 1

    cnt = 0
    for i in range(1, m + 1):
        gaps[i] += gaps[i - 1]
        if gaps[i] == 0:
            cnt += 1

    return cnt

# Example of using the function
print(solve())
  
solve()","
def solve():
    n, m = map(int, input().split())
    antennas = [list(map(int, input().split())) for _ in range(n)]
    
    covered = [False] * (m + 1)
    
    for x, s in antennas:
        start = max(1, x - s)
        end = min(m, x + s)
        for i in range(start, end + 1):
            covered[i] = True
    
    ans = 0
    i = 1
    while i <= m:
        if not covered[i]:
            j = i
            while j <= m and not covered[j]:
                j += 1
            ans += j - i
            i = j
        else:
            i += 1
    
    print(ans)

solve()
","26.666666666666668","0.0","0.0","26.666666666666668","0.0","0.0","33.33333333333333","100.0","0.0","0.0","6.666666666666667","7.6923076923076925","0.0","0.0","0.0","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/141","
QUESTION:
You have a set of items, each having some integer weight not greater than $8$. You denote that a subset of items is good if total weight of items in the subset does not exceed $W$.

You want to calculate the maximum possible weight of a good subset of items. Note that you have to consider the empty set and the original set when calculating the answer.


-----Input-----

The first line contains one integer $W$ ($0 \le W \le 10^{18}$) — the maximum total weight of a good subset.

The second line denotes the set of items you have. It contains $8$ integers $cnt_1$, $cnt_2$, ..., $cnt_8$ ($0 \le cnt_i \le 10^{16}$), where $cnt_i$ is the number of items having weight $i$ in the set.


-----Output-----

Print one integer — the maximum possible weight of a good subset of items.


-----Examples-----
Input
10
1 2 3 4 5 6 7 8

Output
10

Input
0
0 0 0 0 0 0 0 0

Output
0

Input
3
0 4 1 0 0 9 8 3

Output
3
Use user-input-Based format and function signature solve()","
def solve():
    W = int(input())
    cnt = list(map(int, input().split()))
    
    dp = [0] * (W + 1)
    for i in range(1, 9):
        for j in range(W, -1, -1):
            for k in range(cnt[i-1] + 1):
                if j - i * k >= 0:
                    dp[j] = max(dp[j], dp[j - i * k] + i * k)
    
    print(dp[W])

solve()
","
def solve():
    W = int(input())
    items = list(map(int, input().split()))

    dp = [0] * (W + 1)
    for i in range(1, 9):
        for j in range(W, -1, -1):
            cnt = min(items[i - 1], j // i)
            for k in range(cnt + 1):
                dp[j] = max(dp[j], dp[j - k * i] + k * i)
    
    return dp[W]

solve()
","
def solve():
    W = int(input())
    items = list(map(int, input().split()))

    dp = [0] * (W + 1)

    for i in range(1, 9):
        for j in range(W, items[i-1] - 1, -1):
            dp[j] = max(dp[j], dp[j - items[i-1]] + items[i-1])

    return dp[W]

solve()
","
from itertools import product

def solve():
    W = int(input())
    items = list(map(int, input().split()))
    
    max_weight = 0
    for i in range(1, 9):
        for subset in product(range(items[i-1] + 1), repeat=i):
            weight = sum([subset[j] * j for j in range(1, i)])
            if weight <= W:
                max_weight = max(max_weight, weight)
    
    print(max_weight)


solve()","
def solve():
    W = int(input())
    cnt = list(map(int, input().split()))

    total_weight = sum(cnt[i] * (i+1) for i in range(8))
    dp = [0] * (W + 1)

    for i in range(8):
        for w in range(W, -1, -1):
            if w >= i + 1:
                dp[w] = max(dp[w], dp[w - (i + 1)] + min(cnt[i], w // (i + 1)))

    return dp[W]

solve()
","
def solve():
    import itertools

    def calculate_subset_weight(w, items):
        max_weight = 0
        for i in range(1, min(w // 2 + 1, 9)):
            for subset in itertools.combinations(range(8), i):
                weight = sum((1 + j) * items[j] for j in subset)
                if weight <= w:
                    max_weight = max(max_weight, weight)
        return max_weight

    W = int(input())
    items = list(map(int, input().split()))
    print(calculate_subset_weight(W, items))

solve()
","
def solve():
    W = int(input())
    cnt = list(map(int, input().split()))
    
    dp = [0] * (W + 1)
    
    for i in range(1, 9):
        for j in range(W, -1, -1):
            for k in range(cnt[i - 1] + 1):
                if j - k * i >= 0:
                    dp[j] = max(dp[j], dp[j - k * i] + k * i)
    
    print(dp[W])

solve()
","
def solve():
    W = int(input())
    cnt = list(map(int, input().split()))
    
    dp = [0] * (W + 1)
    
    for i in range(1, 9):
        for j in range(W, 0, -1):
            for k in range(1, cnt[i-1] + 1):
                if i * k <= j:
                    dp[j] = max(dp[j], dp[j - i * k] + i * k)
    
    print(dp[W])

# Run the function
solve()
  ","
from itertools import product

def solve():
    def knapsack(W, items):
        max_weight = 0
        for i in range(1, len(items)+1):
            for subset in product(items, repeat=i):
                total_weight = sum(subset)
                if total_weight <= W:
                    max_weight = max(max_weight, total_weight)
        return max_weight
    
    W = int(input())
    items = list(map(int, input().split()))
    
    ans = knapsack(W, items)
    print(ans)

solve()
","
def solve():
    W = int(input())
    cnt = list(map(int, input().split()))

    dp = [0] * (W + 1)
    
    for i in range(1, 9):
        for j in range(W, -1, -1):
            for k in range(min(cnt[i-1], j//i) + 1):
                dp[j] = max(dp[j], dp[j - k*i] + k*i)

    return dp[W]

solve()","
def solve():
    W = int(input())
    items = list(map(int, input().split()))

    max_weight = 0

    for i in range(1, 9):
        for j in range(items[i-1] + 1):
            weight = i * j
            if weight <= W and weight > max_weight:
                max_weight = weight
    
    print(max_weight)

solve()
","
def solve():
    import sys
    input = sys.stdin.readline
    from itertools import product

    W = int(input())
    cnt = list(map(int, input().split()))

    ans = 0
    for i in range(1, min(7, W) + 1):
        for j in range(i + 1, min(8, W - i) + 1):
            for k in range(j + 1, min(9, W - i - j) + 1):
                for a, b, c in product(range(cnt[i] + 1), range(cnt[j] + 1), range(cnt[k] + 1)):
                    if i * a + j * b + k * c <= W:
                        ans = max(ans, i * a + j * b + k * c)

    print(ans)

solve()","
def solve():
    W = int(input())
    items = list(map(int, input().split()))
    
    dp = [0] * (W + 1)
    for i in range(1, 9):
        for j in range(W, items[i]+1, -1):
            dp[j] = max(dp[j], dp[j-items[i]] + i)
    
    print(dp[W])

solve()
","
def solve():
    W = int(input())
    items = list(map(int, input().split()))

    dp = [0] * (W + 1)

    for i in range(1, 9):
        for j in range(W, -1, -1):
            for k in range(min(items[i-1], j//i) + 1):
                dp[j] = max(dp[j], dp[j - k*i] + k*i)

    print(dp[W])

# Do not include the following lines in your submission
# Example usage
if __name__ == ""__main__"":
    solve()
","
from itertools import product

def solve():
    W = int(input())
    cnt = list(map(int, input().split()))

    max_weight = 0
    for p in product(*[range(c+1) for c in cnt]):
        weight = sum(i*w for i, w in enumerate(p, 1))
        if weight <= W:
            max_weight = max(max_weight, weight)

    print(max_weight)

solve()","
def solve():
    W = int(input())
    cnt = list(map(int, input().split()))
    
    dp = [0] * (W + 1)
    
    for i in range(1, 9):
        for j in range(W, -1, -1):
            for k in range(min(cnt[i-1], j//i) + 1):
                dp[j] = max(dp[j], dp[j-k*i] + k*i)
    
    return dp[W]

solve()","66.66666666666666","0.0","0.0","30.76923076923077","0.0","40.0","66.66666666666666","66.66666666666666","46.666666666666664","0.0","80.0","26.666666666666668","0.0","66.66666666666666","66.66666666666666","0.0","","","","","","","","","","","","","","","",""
"APPS/142","
QUESTION:
A New Year party is not a New Year party without lemonade! As usual, you are expecting a lot of guests, and buying lemonade has already become a pleasant necessity.

Your favorite store sells lemonade in bottles of n different volumes at different costs. A single bottle of type i has volume 2^{i} - 1 liters and costs c_{i} roubles. The number of bottles of each type in the store can be considered infinite.

You want to buy at least L liters of lemonade. How many roubles do you have to spend?


-----Input-----

The first line contains two integers n and L (1 ≤ n ≤ 30; 1 ≤ L ≤ 10^9) — the number of types of bottles in the store and the required amount of lemonade in liters, respectively.

The second line contains n integers c_1, c_2, ..., c_{n} (1 ≤ c_{i} ≤ 10^9) — the costs of bottles of different types.


-----Output-----

Output a single integer — the smallest number of roubles you have to pay in order to buy at least L liters of lemonade.


-----Examples-----
Input
4 12
20 30 70 90

Output
150

Input
4 3
10000 1000 100 10

Output
10

Input
4 3
10 100 1000 10000

Output
30

Input
5 787787787
123456789 234567890 345678901 456789012 987654321

Output
44981600785557577



-----Note-----

In the first example you should buy one 8-liter bottle for 90 roubles and two 2-liter bottles for 30 roubles each. In total you'll get 12 liters of lemonade for just 150 roubles.

In the second example, even though you need only 3 liters, it's cheaper to buy a single 8-liter bottle for 10 roubles.

In the third example it's best to buy three 1-liter bottles for 10 roubles each, getting three liters for 30 roubles.
Use user-input-Based format and function signature solve()","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    
    total_cost = 0
    i = n - 1
    while L > 0:
        bottles_needed = L // (2**i - 1)
        total_cost += bottles_needed * costs[i]
        L -= bottles_needed * (2**i - 1)
        i -= 1
    
    print(total_cost)

solve()
","
def solve():
    import math

    n, L = map(int, input().split())
    costs = list(map(int, input().split()))

    min_cost = math.inf
    for i in range(n):
        bottles_needed = L >> i
        total_cost = bottles_needed * costs[i]
        if L & (2**i - 1) != 0:
            total_cost += costs[i]
        min_cost = min(min_cost, total_cost)

    print(min_cost)


solve()","
def solve():
    n, L = map(int, input().split())
    c = list(map(int, input().split()))
    
    ans = float(""inf"")
    for i in range(1, 31):
        total_cost = 0
        need = min(2**i-1, L)
        for j in range(n, -1, -1):
            bottles = need // (2**j - 1)
            total_cost += bottles * c[j]
            need -= bottles * (2**j - 1)
        ans = min(ans, total_cost)
    print(ans)

solve()
","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    
    min_cost = float('inf')
    liters_needed = L
    i = n - 1
    
    while i >= 0:
        num_bottles = liters_needed // ((1 << i) - 1)
        total_cost = num_bottles * costs[i]
        
        min_cost = min(min_cost, total_cost)
        
        liters_needed -= num_bottles * ((1 << i) - 1)
        i -= 1
        
    print(min_cost)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    
    total_cost = 0
    i = 0
    while L > 0:
        if L % 2 == 1:
            total_cost += costs[i]
        i += 1
        L //= 2
        
    print(total_cost)

solve()
","
from math import log2

def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    
    min_cost = float('inf')
    
    for i in range(n):
        total_liters = 2**(i+1) - 1
        bottles_needed = -(-L // total_liters)
        total_cost = bottles_needed * costs[i]
        min_cost = min(min_cost, total_cost)
    
    print(min_cost)

solve()
","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    
    answer = float('inf')
    for i in range(n-1, -1, -1):
        bottles_needed = L // (2**i - 1)
        if L % (2**i - 1) != 0:
            bottles_needed += 1
        answer = min(answer, bottles_needed * costs[i])
    
    print(answer)

solve()
","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))

    answer = float('inf')

    for i in range(n):
        bottles_needed = L // (2 ** i)
        if L % (2 ** i) != 0:
            bottles_needed += 1

        total_cost = bottles_needed * costs[i]
        answer = min(answer, total_cost)

    print(answer)

solve()
","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    ans = float('inf')
    
    for i in range(30):
        total_cost = sum(min((L + (1 << i) - 1) // (1 << i) * costs[i], costs[j]) for j in range(i + 1))
        ans = min(ans, total_cost)
    
    print(ans)

solve()
","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    
    min_cost = float('inf')
    remaining_liters = L
    for i in range(n-1, -1, -1):
        num_bottles = remaining_liters // (2**i - 1)
        if remaining_liters % (2**i - 1) != 0:
            num_bottles += 1
        min_cost = min(min_cost, num_bottles * costs[i])
        remaining_liters -= num_bottles * (2**i - 1)
    
    print(min_cost)

solve()
","
def solve():
    from math import log2

    n, L = map(int, input().split())
    costs = list(map(int, input().split()))

    min_cost = float('inf')
    for i in range(1, 31):
        min_cost = min(min_cost, (L // (2**i - 1)) * costs[i-1] + (L % (2**i - 1)) * costs[i-1])

    print(min_cost)

solve()","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    
    total_cost = 0
    i = n - 1
    while L > 0:
        num_bottles = L // (2 ** i)
        if L % (2 ** i) != 0:
            num_bottles += 1
        total_cost += num_bottles * costs[n - 1 - i]
        L -= num_bottles * (2 ** i)
        i -= 1
    
    print(total_cost)

solve()
  ","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))
    total_cost = 0
    i = n
    while L > 0:
        if L % 2 == 1:
            total_cost += costs[i-1]
        i -= 1
        L //= 2
    print(total_cost)

solve()
","
def solve():
    n, L = map(int, input().split())
    c = list(map(int, input().split()))

    result = 0
    for i in range(n-1, -1, -1):
        bottles_needed = L // (2**i - 1)
        result += bottles_needed * c[i]
        L -= bottles_needed * (2**i - 1)

    print(result)

solve()
","
def solve():
    n, L = map(int, input().split())
    costs = list(map(int, input().split()))

    min_cost = float('inf')
    volume = L
    for i in range(n-1, -1, -1):
        bottles_needed = volume // ((1 << i) - 1)
        if volume % ((1 << i) - 1) != 0:
            bottles_needed += 1
        min_cost = min(min_cost, bottles_needed * costs[i])
        volume = max(0, volume - ((1 << i) - 1) * bottles_needed)
    
    print(min_cost)

solve()
","
def solve():
    import math

    n, L = map(int, input().split())
    costs = list(map(int, input().split()))

    min_cost = float('inf')
    for i in range(n):
        bottles_needed = math.ceil(L / (2**i))
        total_cost = bottles_needed * costs[i]
        min_cost = min(min_cost, total_cost)

    print(min_cost)

solve()
","0.0","66.66666666666666","0.0","0.0","13.333333333333334","33.33333333333333","0.0","66.66666666666666","0.0","0.0","0.0","26.666666666666668","13.333333333333334","0.0","0.0","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/143","
QUESTION:
Someone gave Alyona an array containing n positive integers a_1, a_2, ..., a_{n}. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.

Formally, after applying some operations Alyona will get an array of n positive integers b_1, b_2, ..., b_{n} such that 1 ≤ b_{i} ≤ a_{i} for every 1 ≤ i ≤ n. Your task is to determine the maximum possible value of mex of this array.

Mex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of elements in the Alyona's array.

The second line of the input contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the elements of the array.


-----Output-----

Print one positive integer — the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.


-----Examples-----
Input
5
1 3 3 3 6

Output
5

Input
2
2 1

Output
3



-----Note-----

In the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.

To reach the answer to the second sample case one must not decrease any of the array elements.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    
    mex = 1
    for num in a:
        if num >= mex:
            mex += 1
    
    print(mex)

solve()
","
def solve():
    n = int(input())
    array = list(map(int, input().split()))

    max_num = max(array)
    array.sort()
    mex = array[0]
    
    for num in array:
        if num > mex:
            mex += 1
            
    if mex == max_num:
        print(mex + 1)
    else:
        print(mex)

solve()","
def solve():
    n = int(input())
    array = list(map(int, input().split()))

    array.sort()
    mex = 1
    for elem in array:
        if elem >= mex:
            mex += 1

    print(mex)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    
    mex = 1
    for num in a:
        if num >= mex:
            mex += 1
    
    print(mex)

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    arr.sort()
    next_mex = 1
    
    for num in arr:
        if num >= next_mex:
            next_mex += 1
            
    print(next_mex)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    
    mex = 1
    for num in a:
        if num >= mex:
            mex += 1
        else:
            mex = max(mex, num)
    
    print(mex)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()
    mex = 1
    
    for i in range(n):
        if a[i] >= mex:
            mex += 1
            
    print(mex)

solve()
","
def solve():
    n = int(input())
    array = list(map(int, input().split()))
    array.sort()
    
    mex = 1
    for i in range(n):
        if array[i] >= mex:
            mex += 1
    
    print(mex)

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    arr.sort()
    
    mex = 1
    for num in arr:
        if num >= mex:
            mex += 1
    
    return mex

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    a.sort()
    mex = 1
    for num in a:
        if num >= mex:
            mex += 1

    return mex
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()
    
    mex = 1
    for num in a:
        if num >= mex:
            mex += 1
    
    return mex

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_val = 0
    a.sort()
    
    for i in range(n):
        if a[i] > max_val + 1:
            break
        max_val += a[i]
    
    print(max_val + 1)

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    arr.sort()
    
    mex = 1
    for num in arr:
        if num >= mex:
            mex += 1
    
    return mex

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    mex_num = 1
    
    for num in a:
        if num >= mex_num:
            mex_num += 1
    
    print(mex_num)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    mex = 1
    for i in range(n):
        if a[i] >= mex:
            mex += 1
    
    print(mex)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    
    mex = 1
    for num in a:
        if num >= mex:
            mex += 1
    
    return mex

solve()","100.0","46.666666666666664","100.0","100.0","100.0","100.0","100.0","100.0","0.0","0.0","0.0","13.333333333333334","0.0","100.0","100.0","0.0","","","","","","","","","","","","","","","",""
"APPS/144","
QUESTION:
Recently Vasya found a golden ticket — a sequence which consists of $n$ digits $a_1a_2\dots a_n$. Vasya considers a ticket to be lucky if it can be divided into two or more non-intersecting segments with equal sums. For example, ticket $350178$ is lucky since it can be divided into three segments $350$, $17$ and $8$: $3+5+0=1+7=8$. Note that each digit of sequence should belong to exactly one segment.

Help Vasya! Tell him if the golden ticket he found is lucky or not.


-----Input-----

The first line contains one integer $n$ ($2 \le n \le 100$) — the number of digits in the ticket.

The second line contains $n$ digits $a_1 a_2 \dots a_n$ ($0 \le a_i \le 9$) — the golden ticket. Digits are printed without spaces.


-----Output-----

If the golden ticket is lucky then print ""YES"", otherwise print ""NO"" (both case insensitive).


-----Examples-----
Input
5
73452

Output
YES

Input
4
1248

Output
NO



-----Note-----

In the first example the ticket can be divided into $7$, $34$ and $52$: $7=3+4=5+2$.

In the second example it is impossible to divide ticket into segments with equal sum.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))

    total_sum = sum(ticket)
    if total_sum % 2 != 0:
        print(""NO"")
        return

    target_sum = total_sum // 2
    current_sum = 0
    segments = 0

    for digit in ticket:
        current_sum += digit
        if current_sum == target_sum:
            segments += 1
            current_sum = 0
        elif current_sum > target_sum:
            print(""NO"")
            return

    if segments >= 2 and current_sum == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))
    
    total_sum = sum(ticket)
    if total_sum % 2 != 0:
        print(""NO"")
    else:
        target_sum = total_sum // 2
        current_sum = 0
        segments = 0
        
        for digit in ticket:
            current_sum += digit
            if current_sum == target_sum:
                segments += 1
                current_sum = 0
            elif current_sum > target_sum:
                break
        
        if segments >= 2 and current_sum == 0:
            print(""YES"")
        else:
            print(""NO"")

solve()","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))
    
    total_sum = sum(ticket)
    
    if total_sum % n != 0:
        print(""NO"")
    else:
        target_sum = total_sum // n
        current_sum = 0
        segments = 1
        
        for digit in ticket:
            current_sum += digit
            if current_sum == target_sum:
                current_sum = 0
                segments += 1
        
        if segments >= 2:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))

    total_sum = sum(ticket)
    if total_sum % n != 0:
        print(""NO"")
        return
    
    target_sum = total_sum // n
    current_sum = 0
    count = 0
    
    for digit in ticket:
        current_sum += digit
        if current_sum == target_sum:
            current_sum = 0
            count += 1
    
    if count >= 2:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    ticket = input()
    
    total_sum = sum(map(int, ticket))
    
    if total_sum % n != 0:
        print(""NO"")
        return
    
    target_sum = total_sum // n
    segment_sum = 0
    segment_count = 0
    
    for digit in ticket:
        segment_sum += int(digit)
        if segment_sum == target_sum:
            segment_sum = 0
            segment_count += 1
    
    if segment_count >= 2:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    digits = list(map(int, input().strip()))

    total_sum = sum(digits)
    if total_sum % 2 != 0:
        print(""NO"")
        return

    target_sum = total_sum // 2

    current_sum = 0
    segments_count = 0

    for digit in digits:
        current_sum += digit
        if current_sum == target_sum:
            segments_count += 1
            current_sum = 0
        elif current_sum > target_sum:
            print(""NO"")
            return

    if segments_count >= 2 and current_sum == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))
    
    total_sum = sum(ticket)
    if total_sum % 2 == 1:
        print(""NO"")
    else:
        target_sum = total_sum // 2
        prefix_sums = [0]
        current_sum = 0
        for digit in ticket:
            current_sum += digit
            prefix_sums.append(current_sum)
        
        dp = [False] * (target_sum + 1)
        dp[0] = True
        
        for i in range(1, n):
            next_dp = [False] * (target_sum + 1)
            for j in range(min(target_sum, prefix_sums[i]) + 1):
                if dp[j]:
                    next_dp[j] = True
                    if j + ticket[i] <= target_sum:
                        next_dp[j + ticket[i]] = True
            dp = next_dp
        
        if dp[target_sum]:
            print(""YES"")
        else:
            print(""NO"")

import sys
if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    ticket = input()
    
    total_sum = sum(map(int, ticket))
    if total_sum % 2 != 0:
        print(""NO"")
        return
    
    target_sum = total_sum // 2
    current_sum = 0
    segments = 0
    
    for digit in ticket:
        current_sum += int(digit)
        if current_sum == target_sum:
            segments += 1
            current_sum = 0
    
    if segments >= 2:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))

    total_sum = sum(ticket)
    if total_sum % 2 == 1:
        print(""NO"")
        return

    target_sum = total_sum // 2

    dp = [False] * (target_sum + 1)
    dp[0] = True

    for i in range(n):
        for j in range(target_sum, ticket[i] - 1, -1):
            dp[j] |= dp[j - ticket[i]]

    if dp[target_sum]:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))
    
    total_sum = sum(ticket)
    if total_sum % 2 != 0:
        print(""NO"")
        return
    
    target_sum = total_sum // 2
    dp = [False] * (target_sum+1)
    dp[0] = True
    
    for digit in ticket:
        for i in range(target_sum, digit-1, -1):
            dp[i] |= dp[i-digit]
    
    if dp[target_sum]:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))

    total_sum = sum(ticket)
    if total_sum % 2 != 0:
        print(""NO"")
        return
    
    target_sum = total_sum // 2
    prefix_sum = 0
    prefix_sums = set()

    for digit in ticket[:-1]:
        prefix_sum += digit
        if prefix_sum == target_sum:
            print(""YES"")
            return
        if prefix_sum > target_sum:
            break
        prefix_sums.add(prefix_sum)

    for i in range(1, n):
        suffix_sum = 0
        for j in range(i, n):
            suffix_sum += ticket[j]
            if suffix_sum == target_sum and (prefix_sum + suffix_sum) != total_sum:
                print(""YES"")
                return
            if suffix_sum > target_sum:
                break
            if (prefix_sum + suffix_sum) in prefix_sums:
                print(""YES"")
                return

    print(""NO"")

solve()
","
def solve():
    n = int(input())
    nums = list(map(int, input().strip()))

    total_sum = sum(nums)
    if total_sum % n != 0:
        print(""NO"")
        return

    target_sum = total_sum // n
    current_sum = 0
    segments = 0

    for num in nums:
        current_sum += num
        if current_sum == target_sum:
            segments += 1
            current_sum = 0

    if segments >= 2:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))

    total_sum = sum(ticket)

    if total_sum % n != 0:
        print(""NO"")
        return

    target_sum = total_sum // n

    current_sum = 0
    segments_count = 0

    for digit in ticket:
        current_sum += digit

        if current_sum == target_sum:
            segments_count += 1
            current_sum = 0

    if segments_count >= 2:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))
    
    total_sum = sum(ticket)
    if total_sum % 2 != 0:
        print(""NO"")
        return
    
    target_sum = total_sum // 2
    current_sum = 0
    segments = 0
    
    for digit in ticket:
        current_sum += digit
        if current_sum == target_sum:
            segments += 1
            current_sum = 0
        elif current_sum > target_sum:
            print(""NO"")
            return
    
    if segments >= 2:
        print(""YES"")
    else:
        print(""NO"")

# For testing the function
# solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input().strip()))

    total = sum(ticket)
    if total % n != 0:
        print(""NO"")
        return

    target_sum = total // n
    current_sum = 0
    segments = 0

    for digit in ticket:
        current_sum += digit
        if current_sum == target_sum:
            segments += 1
            current_sum = 0

    if segments >= 2:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    ticket = list(map(int, input()))
    
    total_sum = sum(ticket)
    if total_sum % n != 0:
        print(""NO"")
        return
    
    target_sum = total_sum // n
    segment_sum = 0
    segment_count = 0
    
    for digit in ticket:
        segment_sum += digit
        if segment_sum == target_sum:
            segment_sum = 0
            segment_count += 1
    
    if segment_count >= 2:
        print(""YES"")
    else:
        print(""NO"")

solve()","86.66666666666667","86.66666666666667","46.666666666666664","46.666666666666664","46.666666666666664","86.66666666666667","80.0","86.66666666666667","80.0","80.0","80.0","46.666666666666664","46.666666666666664","0.0","46.666666666666664","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/145","
QUESTION:
Those days, many boys use beautiful girls' photos as avatars in forums. So it is pretty hard to tell the gender of a user at the first glance. Last year, our hero went to a forum and had a nice chat with a beauty (he thought so). After that they talked very often and eventually they became a couple in the network. 

But yesterday, he came to see ""her"" in the real world and found out ""she"" is actually a very strong man! Our hero is very sad and he is too tired to love again now. So he came up with a way to recognize users' genders by their user names.

This is his method: if the number of distinct characters in one's user name is odd, then he is a male, otherwise she is a female. You are given the string that denotes the user name, please help our hero to determine the gender of this user by his method.


-----Input-----

The first line contains a non-empty string, that contains only lowercase English letters — the user name. This string contains at most 100 letters.


-----Output-----

If it is a female by our hero's method, print ""CHAT WITH HER!"" (without the quotes), otherwise, print ""IGNORE HIM!"" (without the quotes).


-----Examples-----
Input
wjmzbmr

Output
CHAT WITH HER!

Input
xiaodao

Output
IGNORE HIM!

Input
sevenkplus

Output
CHAT WITH HER!



-----Note-----

For the first example. There are 6 distinct characters in ""wjmzbmr"". These characters are: ""w"", ""j"", ""m"", ""z"", ""b"", ""r"". So wjmzbmr is a female and you should print ""CHAT WITH HER!"".
Use user-input-Based format and function signature solve()","
def solve():
    username = input().strip()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input().strip()
    distinct_chars = len(set(username))
    
    if distinct_chars % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()","
def solve():
    username = input()
    distinct_characters = set(username)
    
    if len(distinct_characters) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input().strip()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input()
    distinct_chars = len(set(username))
    
    if distinct_chars % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()","
def solve():
    username = input().strip()
    distinct_chars = set(username)
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input().strip()
    distinct_characters = set(username)
    if len(distinct_characters) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input().strip()
    distinct_chars = len(set(username))
    
    if distinct_chars % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input().strip()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")


solve()
","
def solve():
    username = input().strip()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    user_name = input()
    distinct_chars = set(user_name)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input().strip()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    username = input()
    distinct_chars = set(username)
    
    if len(distinct_chars) % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()
","
def solve():
    name = input()
    distinct_characters = len(set(name))
    
    if distinct_characters % 2 == 0:
        print(""IGNORE HIM!"")
    else:
        print(""CHAT WITH HER!"")

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/146","
QUESTION:
This morning, Roman woke up and opened the browser with $n$ opened tabs numbered from $1$ to $n$. There are two kinds of tabs: those with the information required for the test and those with social network sites. Roman decided that there are too many tabs open so he wants to close some of them.

He decided to accomplish this by closing every $k$-th ($2 \leq k \leq n - 1$) tab. Only then he will decide whether he wants to study for the test or to chat on the social networks. Formally, Roman will choose one tab (let its number be $b$) and then close all tabs with numbers $c = b + i \cdot k$ that satisfy the following condition: $1 \leq c \leq n$ and $i$ is an integer (it may be positive, negative or zero).

For example, if $k = 3$, $n = 14$ and Roman chooses $b = 8$, then he will close tabs with numbers $2$, $5$, $8$, $11$ and $14$.

After closing the tabs Roman will calculate the amount of remaining tabs with the information for the test (let's denote it $e$) and the amount of remaining social network tabs ($s$). Help Roman to calculate the maximal absolute value of the difference of those values $|e - s|$ so that it would be easy to decide what to do next.


-----Input-----

The first line contains two integers $n$ and $k$ ($2 \leq k < n \leq 100$) — the amount of tabs opened currently and the distance between the tabs closed.

The second line consists of $n$ integers, each of them equal either to $1$ or to $-1$. The $i$-th integer denotes the type of the $i$-th tab: if it is equal to $1$, this tab contains information for the test, and if it is equal to $-1$, it's a social network tab.


-----Output-----

Output a single integer — the maximum absolute difference between the amounts of remaining tabs of different types $|e - s|$.


-----Examples-----
Input
4 2
1 1 -1 1

Output
2

Input
14 3
-1 1 -1 -1 1 -1 -1 1 -1 -1 1 -1 -1 1

Output
9



-----Note-----

In the first example we can choose $b = 1$ or $b = 3$. We will delete then one tab of each type and the remaining tabs are then all contain test information. Thus, $e = 2$ and $s = 0$ and $|e - s| = 2$.

In the second example, on the contrary, we can leave opened only tabs that have social networks opened in them.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    max_diff = 0
    for b in range(1, k+1):
        e = sum(tabs[i] for i in range(b-1, n, k) if tabs[i] == 1)
        s = sum(tabs[i] for i in range(b-1, n, k) if tabs[i] == -1)
        max_diff = max(max_diff, abs(e - s))
    
    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    e_count = tabs.count(1)
    s_count = tabs.count(-1)
    min_remaining = min(e_count, s_count)
    max_abs_diff = min(min_remaining, n // k)
    print(2 * max_abs_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))

    max_diff = -1
    for b in range(1, n+1):
        e, s = 0, 0
        for i in range(n):
            if (i + 1 - b) % k == 0:
                if tabs[i] == 1:
                    e += 1
                else:
                    s += 1
        max_diff = max(max_diff, abs(e - s))

    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))

    max_diff = 0
    for b in range(1, n+1):
        e = sum(tabs[i-1] for i in range(b, n+1, k))
        s = sum(1 for i in range(b, n+1, k) if tabs[i-1] == -1)
        max_diff = max(max_diff, abs(e - s))

    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    remaining_test_tabs = tabs.count(1) - (tabs.count(-1) // k)
    remaining_social_tabs = tabs.count(-1) - (tabs.count(1) // k)
    
    max_absolute_difference = abs(remaining_test_tabs - remaining_social_tabs)
    
    print(max_absolute_difference)

solve()","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    max_diff = 0
    for i in range(k):
        test_tabs = 0
        social_tabs = 0
        
        for j in range(i, n, k):
            if tabs[j] == 1:
                test_tabs += 1
            else:
                social_tabs += 1
        
        diff = abs(test_tabs - social_tabs)
        if diff > max_diff:
            max_diff = diff

    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    max_diff = 0
    
    for i in range(k):
        e_count = s_count = 0
        for j in range(i, n, k):
            if tabs[j] == 1:
                e_count += 1
            else:
                s_count += 1
        max_diff = max(max_diff, abs(e_count - s_count))
    
    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    max_diff = 0
    
    for i in range(n):
        tabs_left = tabs.copy()
        count_e = 0
        count_s = 0
        
        for j in range(i, n, k):
            tabs_left[j] = 0
        
        for tab_type in tabs_left:
            if tab_type == 1:
                count_e += 1
            elif tab_type == -1:
                count_s += 1
        
        diff = abs(count_e - count_s)
        max_diff = max(max_diff, diff)
    
    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    num_test_tabs = tabs.count(1)
    num_social_tabs = tabs.count(-1)
    
    max_diff = 0
    
    for b in range(1, n+1):
        remaining_test_tabs = num_test_tabs
        remaining_social_tabs = num_social_tabs
        for i in range(0, n, k):
            if 1 <= b + i <= n:
                if tabs[b + i - 1] == 1:
                    remaining_test_tabs -= 1
                else:
                    remaining_social_tabs -= 1
        diff = abs(remaining_test_tabs - remaining_social_tabs)
        max_diff = max(max_diff, diff)
    
    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    test_tabs = tabs.count(1)
    social_tabs = tabs.count(-1)
    
    max_difference = 0
    for start_tab in range(k):
        curr_test_tabs = test_tabs
        curr_social_tabs = social_tabs
        for i in range(start_tab, n, k):
            if tabs[i] == 1:
                curr_test_tabs -= 1
            else:
                curr_social_tabs -= 1
        max_difference = max(max_difference, abs(curr_test_tabs - curr_social_tabs))
    
    print(max_difference)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))

    max_diff = 0
    for b in range(1, k+1):
        tabs_copy = tabs.copy()
        e_count, s_count = 0, 0
        for i in range(b-1, n, k):
            if tabs_copy[i] == 1:
                e_count += 1
            else:
                s_count += 1
            tabs_copy[i] = 0
        max_diff = max(max_diff, abs(e_count - s_count))

    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    test_tabs = sum(1 for tab in tabs if tab == 1)
    social_tabs = sum(1 for tab in tabs if tab == -1)
    
    max_diff = abs(test_tabs - social_tabs)
    
    for i in range(k):
        closed_test_tabs = 0
        closed_social_tabs = 0
        for j in range(len(tabs)):
            if (j - i) % k == 0:
                if tabs[j] == 1:
                    closed_test_tabs += 1
                else:
                    closed_social_tabs += 1
        
        test_tabs -= closed_test_tabs
        social_tabs -= closed_social_tabs
        
        diff = abs(test_tabs - social_tabs)
        max_diff = max(max_diff, diff)
    
    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    max_diff = 0
    for b in range(1, k+1):
        e_count = 0
        s_count = 0
        for i in range(n):
            if tabs[i] == 1:
                if (i-b) % k == 0:
                    e_count += 1
            else:
                if (i-b) % k == 0:
                    s_count += 1
        max_diff = max(max_diff, abs(e_count - s_count))
    
    print(max_diff)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    max_diff = 0
    for b in range(1, k + 1):
        info_tabs = 0
        social_tabs = 0
        for i in range(n):
            if (i - b) % k == 0:
                if tabs[i] == 1:
                    info_tabs += 1
                else:
                    social_tabs += 1
        max_diff = max(max_diff, abs(info_tabs - social_tabs))
    
    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))
    
    max_diff = 0
    for b in range(1, n + 1):
        e = s = 0
        for i in range(n):
            if (i - b) % k == 0:
                continue
            if tabs[i] == 1:
                e += 1
            else:
                s += 1
        max_diff = max(max_diff, abs(e - s))
    
    print(max_diff)

solve()
","
def solve():
    n, k = map(int, input().split())
    tabs = list(map(int, input().split()))

    max_diff = 0
    for i in range(1, n + 1):
        info_tabs = tabs.copy()
        for j in range(i, n + 1, k):
            info_tabs[j - 1] = 0
        
        e = info_tabs.count(1)
        s = info_tabs.count(-1)
        diff = abs(e - s)
        max_diff = max(max_diff, diff)
    
    print(max_diff)

solve()
","20.0","20.0","46.666666666666664","26.666666666666668","0.0","46.666666666666664","46.666666666666664","53.333333333333336","53.333333333333336","100.0","46.666666666666664","60.0","46.666666666666664","46.666666666666664","100.0","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/147","
QUESTION:
R3D3 spent some time on an internship in MDCS. After earning enough money, he decided to go on a holiday somewhere far, far away. He enjoyed suntanning, drinking alcohol-free cocktails and going to concerts of popular local bands. While listening to ""The White Buttons"" and their hit song ""Dacan the Baker"", he met another robot for whom he was sure is the love of his life. Well, his summer, at least. Anyway, R3D3 was too shy to approach his potential soulmate, so he decided to write her a love letter. However, he stumbled upon a problem. Due to a terrorist threat, the Intergalactic Space Police was monitoring all letters sent in the area. Thus, R3D3 decided to invent his own alphabet, for which he was sure his love would be able to decipher.

There are n letters in R3D3’s alphabet, and he wants to represent each letter as a sequence of '0' and '1', so that no letter’s sequence is a prefix of another letter's sequence. Since the Intergalactic Space Communications Service has lately introduced a tax for invented alphabets, R3D3 must pay a certain amount of money for each bit in his alphabet’s code (check the sample test for clarifications). He is too lovestruck to think clearly, so he asked you for help.

Given the costs c_0 and c_1 for each '0' and '1' in R3D3’s alphabet, respectively, you should come up with a coding for the alphabet (with properties as above) with minimum total cost.


-----Input-----

The first line of input contains three integers n (2 ≤ n ≤ 10^8), c_0 and c_1 (0 ≤ c_0, c_1 ≤ 10^8) — the number of letters in the alphabet, and costs of '0' and '1', respectively. 


-----Output-----

Output a single integer — minimum possible total a cost of the whole alphabet.


-----Example-----
Input
4 1 2

Output
12



-----Note-----

There are 4 letters in the alphabet. The optimal encoding is ""00"", ""01"", ""10"", ""11"". There are 4 zeroes and 4 ones used, so the total cost is 4·1 + 4·2 = 12.
Use user-input-Based format and function signature solve()","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = n * min(c0, c1) + max(c0, c1)
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = n * min(c0, c1)
    if c0 != c1:
        total_cost += min(c0, c1) + (n-1) * max(c0, c1)
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = n * min(c0, c1) + (n - 1) * max(c0, c1)
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = n * min(c0, c1)
    if c0 != c1:
        total_cost += min(c0, c1)
    return total_cost

solve()","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = (n // 2) * min(c0, c1) + (n - n // 2) * max(c0, c1)
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = (n-1) * min(c0, c1) + max(c0, c1)
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = (n * c0) + (n - 1) * min(c0, c1) if c0 != c1 else n * c0
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    if c0 <= c1:
        ans = n*c0 + max(0, c1)
    else:
        ans = n*c1 + max(0, (n-2)*c0)
    print(ans)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    ans = (n-1)*min(c0, c1) + max(c0, c1)
    print(ans)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    print(n * min(c0, c1) + max(c0, c1))
  
solve()","
def solve():
    n, c0, c1 = map(int, input().split())
    
    total_cost = (n - 1) * min(c0, c1) + max(c0, c1)
    
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = n * min(c0, c1)
    if c0 != c1:
        total_cost += min(c0, c1)  # add cost of the differing bit
    return total_cost

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    
    if c0 <= c1:
        min_cost = n * c0 + max(1, n - 1) * c1
    else:
        min_cost = n * c1 + max(1, n - 1) * c0
    
    print(min_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    return n * min(c0, c1) + max(c0, c1) * (n - 1)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    total_cost = n * min(c0, c1) + (n - 1) * max(c0, c1)
    print(total_cost)

solve()
","
def solve():
    n, c0, c1 = map(int, input().split())
    if c0 < c1:
        c0, c1 = c1, c0
    result = (n-1)*c1 + (n-1)*c0 + min(c0, c1)
    print(result)

solve()
","33.33333333333333","60.0","60.0","0.0","53.333333333333336","53.333333333333336","33.33333333333333","26.666666666666668","53.333333333333336","33.33333333333333","53.333333333333336","0.0","60.0","0.0","60.0","60.0","","","","","","","","","","","","","","","",""
"APPS/148","
QUESTION:
The circle line of the Roflanpolis subway has $n$ stations.

There are two parallel routes in the subway. The first one visits stations in order $1 \to 2 \to \ldots \to n \to 1 \to 2 \to \ldots$ (so the next stop after station $x$ is equal to $(x+1)$ if $x < n$ and $1$ otherwise). The second route visits stations in order $n \to (n-1) \to \ldots \to 1 \to n \to (n-1) \to \ldots$ (so the next stop after station $x$ is equal to $(x-1)$ if $x>1$ and $n$ otherwise). All trains depart their stations simultaneously, and it takes exactly $1$ minute to arrive at the next station.

Two toads live in this city, their names are Daniel and Vlad.

Daniel is currently in a train of the first route at station $a$ and will exit the subway when his train reaches station $x$.

Coincidentally, Vlad is currently in a train of the second route at station $b$ and he will exit the subway when his train reaches station $y$.

Surprisingly, all numbers $a,x,b,y$ are distinct.

Toad Ilya asks you to check if Daniel and Vlad will ever be at the same station at the same time during their journey. In other words, check if there is a moment when their trains stop at the same station. Note that this includes the moments when Daniel or Vlad enter or leave the subway.


-----Input-----

The first line contains five space-separated integers $n$, $a$, $x$, $b$, $y$ ($4 \leq n \leq 100$, $1 \leq a, x, b, y \leq n$, all numbers among $a$, $x$, $b$, $y$ are distinct) — the number of stations in Roflanpolis, Daniel's start station, Daniel's finish station, Vlad's start station and Vlad's finish station, respectively.


-----Output-----

Output ""YES"" if there is a time moment when Vlad and Daniel are at the same station, and ""NO"" otherwise. You can print each letter in any case (upper or lower).


-----Examples-----
Input
5 1 4 3 2

Output
YES

Input
10 2 1 9 10

Output
NO



-----Note-----

In the first example, Daniel and Vlad start at the stations $(1, 3)$. One minute later they are at stations $(2, 2)$. They are at the same station at this moment. Note that Vlad leaves the subway right after that.

Consider the second example, let's look at the stations Vlad and Daniel are at. They are:   initially $(2, 9)$,  after $1$ minute $(3, 8)$,  after $2$ minutes $(4, 7)$,  after $3$ minutes $(5, 6)$,  after $4$ minutes $(6, 5)$,  after $5$ minutes $(7, 4)$,  after $6$ minutes $(8, 3)$,  after $7$ minutes $(9, 2)$,  after $8$ minutes $(10, 1)$,  after $9$ minutes $(1, 10)$. 

After that, they both leave the subway because they are at their finish stations, so there is no moment when they both are at the same station.
Use user-input-Based format and function signature solve()","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    while True:
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            print(""NO"")
            return
        a = a % n + 1
        b = b - 1 if b > 1 else n

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    dan_station = a
    vlad_station = b
    
    while dan_station != x and vlad_station != y:
        dan_station = dan_station % n + 1
        vlad_station = vlad_station - 1 if vlad_station > 1 else n
        
        if dan_station == vlad_station:
            print(""YES"")
            return
    
    print(""NO"")

# Test the function with the input
solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    while True:
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            print(""NO"")
            return
        a = a % n + 1
        b = b - 1 if b > 1 else n

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())

    time = 0
    while True:
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            print(""NO"")
            return
        a = a % n + 1
        b = b - 1 if b != 1 else n
        time += 1

# Call the function to solve the problem
solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())

    # Calculate the absolute difference in stations between Daniel and Vlad
    diff_a_x = abs(x - a)
    diff_b_y = abs(y - b)

    # Check if their difference is a multiple of 2 (they will meet at some point)
    if diff_a_x == diff_b_y or diff_a_x == diff_b_y + n or diff_a_x + n == diff_b_y:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())
    while a != x and b != y:
        a = a % n + 1
        b = (b - 2) % n + 1
        if a == b:
            print(""YES"")
            return
    print(""NO"")

solve()","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    steps_daniel = abs(x - a)
    steps_vlad = abs(y - b)
    
    while steps_daniel != steps_vlad:
        if a == b:
            print(""YES"")
            return
        
        a = a % n + 1
        b = (b - 2) % n + 1
        steps_daniel -= 1
        steps_vlad -= 1
        
    print(""YES"" if a == b else ""NO"")

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())

    def next_station(route, curr, n):
        if route == 1:
            return curr % n + 1
        else:
            return curr - 1 if curr > 1 else n

    time = 0
    while a != x and b != y:
        a = next_station(1, a, n)
        b = next_station(2, b, n)
        time += 1
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            break

    print(""NO"")

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())

    for _ in range(n):
        if a == b:
            print(""YES"")
            return
        a = a % n + 1
        b = (b - 2) % n + 1

    print(""NO"")

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())
    dist_da = (x - a + n) % n
    dist_db = (b - y + n) % n

    for i in range(n):
        if a == b:
            return ""YES""
        a = (a % n) + 1
        b = (b - 2) % n + 1

    return ""NO""

solve()","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    for i in range(2 * n):
        if a == b:
            print(""YES"")
            return
        a = a % n + 1
        b = b - 1 if b > 1 else n
    
    print(""NO"")

solve()","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    while True:
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            break
        a = 1 if a == n else a + 1
        b = n if b == 1 else b - 1

    print(""NO"")

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())
    current_time = 0
    while True:
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            print(""NO"")
            return
        a = 1 if a == n else a + 1
        b = n if b == 1 else b - 1
        current_time += 1
        if current_time > n:
            print(""NO"")
            return

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    while True:
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            print(""NO"")
            return
        a = (a % n) + 1
        b = b - 1 if b > 1 else n

solve()
","
def solve():
    n, a, x, b, y = map(int, input().split())
    
    if a == b:
        print(""YES"")
        return
    
    while True:
        if a == x or b == y:
            print(""NO"")
            return
        a = a % n + 1
        b = b - 1 if b > 1 else n
        if a == b:
            print(""YES"")
            return

solve()
  ","
def solve():
    n, a, x, b, y = map(int, input().split())

    while True:
        if a == b:
            print(""YES"")
            return
        if a == x or b == y:
            print(""NO"")
            return
        a = a % n + 1
        b = b - 1 if b > 1 else n

solve()
","100.0","100.0","100.0","100.0","53.333333333333336","100.0","50.0","100.0","66.66666666666666","0.0","66.66666666666666","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/149","
QUESTION:
Unlucky year in Berland is such a year that its number n can be represented as n = x^{a} + y^{b}, where a and b are non-negative integer numbers. 

For example, if x = 2 and y = 3 then the years 4 and 17 are unlucky (4 = 2^0 + 3^1, 17 = 2^3 + 3^2 = 2^4 + 3^0) and year 18 isn't unlucky as there is no such representation for it.

Such interval of years that there are no unlucky years in it is called The Golden Age.

You should write a program which will find maximum length of The Golden Age which starts no earlier than the year l and ends no later than the year r. If all years in the interval [l, r] are unlucky then the answer is 0.


-----Input-----

The first line contains four integer numbers x, y, l and r (2 ≤ x, y ≤ 10^18, 1 ≤ l ≤ r ≤ 10^18).


-----Output-----

Print the maximum length of The Golden Age within the interval [l, r].

If all years in the interval [l, r] are unlucky then print 0.


-----Examples-----
Input
2 3 1 10

Output
1

Input
3 5 10 22

Output
8

Input
2 3 3 5

Output
0



-----Note-----

In the first example the unlucky years are 2, 3, 4, 5, 7, 9 and 10. So maximum length of The Golden Age is achived in the intervals [1, 1], [6, 6] and [8, 8].

In the second example the longest Golden Age is the interval [15, 22].
Use user-input-Based format and function signature solve()","
def solve():
    x, y, l, r = map(int, input().split())
    
    nums = set()
    for i in range(64):
        for j in range(64):
            num = x**i + y**j
            if num >= l and num <= r:
                nums.add(num)
    
    nums = sorted(list(nums))
    nums.append(r+1)
    
    max_gap = 0
    prev = l - 1
    for num in nums:
        gap = num - prev - 1
        max_gap = max(max_gap, gap)
        prev = num
    
    print(max_gap)

solve()
","
def solve():
    import math

    x, y, l, r = map(int, input().split())

    def lucky_years(x, y, l, r):
        lucky_set = set()
        for i in range(65): # Loop up to 2^32 as the addition of large powers may exceed the limits
            for j in range(65):
                val = x ** i + y ** j
                if val >= l and val <= r:
                    lucky_set.add(val)
        return sorted(list(lucky_set))

    l_s = lucky_years(x, y, l, r)
    intervals = [(l, l_s[0] - 1)] + [(l_s[i] + 1, l_s[i + 1] - 1) for i in range(len(l_s) - 1)] + [(l_s[-1] + 1, r)]

    max_gap = max((end - start) for start, end in intervals)

    print(max_gap)

solve()
","
from math import log

def solve():
    x, y, l, r = map(int, input().split())
    unlucky_years = set()
    
    # generate all possible unlucky years less than r
    for i in range(100):
        for j in range(100):
            val = x**i + y**j
            if val <= r:
                unlucky_years.add(val)
            else:
                break
    
    unlucky_years = sorted(list(unlucky_years))
    max_gap = 0
    start_gap = l
    
    # calculate the maximum gap between unlucky years
    for unlucky_year in unlucky_years:
        gap = unlucky_year - start_gap
        if gap > max_gap:
            max_gap = gap
        start_gap = unlucky_year + 1

    # check the gap after the last unlucky year
    last_gap = r - start_gap + 1
    if last_gap > max_gap:
        max_gap = last_gap

    print(max_gap)

solve()
","
def solve():
    x, y, l, r = map(int, input().split())
    powers = set()
    for i in range(64):
        for j in range(64):
            num = x**i + y**j
            if l <= num <= r:
                powers.add(num)
    powers.add(l-1)
    powers.add(r+1)
    powers = sorted(list(powers))
    max_gap = 0
    for i in range(len(powers)-1):
        max_gap = max(max_gap, powers[i+1] - powers[i] - 1)
    print(max_gap)

solve()
  ","
from math import log

def solve():
    x, y, l, r = map(int, input().split())
    powers = set()
    
    for i in range(64):
        for j in range(64):
            num = x**i + y**j
            if l <= num <= r:
                powers.add(num)
    
    powers.add(l)
    powers.add(r)
    powers = sorted(list(powers))
    
    max_gap = 0
    for i in range(1, len(powers)):
        gap = powers[i] - powers[i-1] - 1
        max_gap = max(max_gap, gap)
    
    print(max_gap)

solve()
","
def solve():
    import math
    
    x, y, l, r = map(int, input().split())
    
    def generate_powers(limit):
        powers = set()
        for i in range(100):
            for j in range(100):
                val = x**i + y**j
                if val <= limit:
                    powers.add(val)
        return sorted(list(powers))
    
    powers = generate_powers(r)
    powers.insert(0, l-1)
    powers.append(r+1)
    
    max_gap = 0
    for i in range(len(powers)-1):
        gap = powers[i+1] - powers[i] - 1
        max_gap = max(max_gap, gap)
    
    print(max_gap)

solve()
","
def solve():
    x, y, l, r = map(int, input().split())
    nums = set()
    for i in range(64):
        for j in range(64):
            num = x ** i + y ** j
            if l <= num <= r:
                nums.add(num)
    nums = sorted(list(nums))
    ans = max(nums[0] - l, r - nums[-1])
    for i in range(1, len(nums)):
        ans = max(ans, nums[i] - nums[i - 1] - 1)
    print(ans)

solve()
  ","
def solve():
    x, y, l, r = map(int, input().split())
    
    nums = set()
    for i in range(64):
        for j in range(64):
            num = x**i + y**j
            if num >= l and num <= r:
                nums.add(num)
    
    nums = sorted(list(nums))
    
    ans = max(nums[0] - l - 1, r - nums[-1] + 1)
    
    for i in range(1, len(nums)):
        ans = max(ans, nums[i] - nums[i-1] - 1)
    
    return ans

solve()
","
def solve():
    x, y, l, r = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    nums = []
    t = 1
    while t <= r:
        nums.append(t)
        t *= x
        if t > r:
            break
    t = 1
    while t <= r:
        nums.append(t)
        t *= y
        if t > r:
            break

    nums.sort()
    ans = max(nums[0] - l, r - nums[-1])
    for i in range(1, len(nums)):
        ans = max(ans, nums[i] - nums[i - 1] - 1)
    print(ans)

solve()
","
def solve():
    x, y, l, r = map(int, input().split())
    unlucky_years = set()
    for i in range(64):
        for j in range(64):
            num = x**i + y**j
            if l <= num <= r:
                unlucky_years.add(num)
    unlucky_years = sorted(list(unlucky_years))
    
    intervals = []
    if unlucky_years[0] > l:
        intervals.append((l, unlucky_years[0]-1))
    if unlucky_years[-1] < r:
        intervals.append((unlucky_years[-1]+1, r))
    for i in range(1, len(unlucky_years)):
        if unlucky_years[i] - unlucky_years[i-1] > 1:
            intervals.append((unlucky_years[i-1]+1, unlucky_years[i]-1))
    
    max_gap = 0
    for start, end in intervals:
        gap = end - start + 1
        max_gap = max(max_gap, gap)
    
    print(max_gap)

solve()
  ","
from itertools import product

def solve():
    x, y, l, r = map(int, input().split())

    powers = []
    for a, b in product(range(64), repeat=2):
        num = x**a + y**b
        if num >= l and num <= r:
            powers.append(num)

    powers.sort()
    if not powers:
        print(r - l + 1)
        return
    
    max_gap = powers[0] - l
    for i in range(1, len(powers)):
        gap = powers[i] - powers[i-1] - 1
        max_gap = max(max_gap, gap)

    end_gap = r - powers[-1]
    print(max(max_gap, end_gap))

solve()
","
def solve():
    x, y, l, r = map(int, input().split())
    
    lucky_years = set()
    m = 1
    while True:
        year = x**m
        if year > r:
            break
        n = 1
        while True:
            year = x**m + y**n
            if year > r:
                break
            lucky_years.add(year)
            n += 1
        m += 1
    
    lucky_years = sorted(lucky_years)
    
    start = l
    max_gap = 0
    
    for year in lucky_years:
        gap = year - start
        if gap > max_gap:
            max_gap = gap
        start = year + 1
        
    if r - start + 1 > max_gap:
        max_gap = r - start + 1
    
    return max_gap

solve()
","
def solve():
    import math

    x, y, l, r = map(int, input().split())

    def generate_unlucky_numbers(x, y, l, r):
        unlucky_numbers = set()
        for i in range(0, 100):
            for j in range(0, 100):
                num = x ** i + y ** j
                if num >= l and num <= r:
                    unlucky_numbers.add(num)
        return unlucky_numbers

    unlucky_numbers = sorted(list(generate_unlucky_numbers(x, y, l, r)))
    max_gap = max(unlucky_numbers[0] - l, r - unlucky_numbers[-1])

    for i in range(len(unlucky_numbers) - 1):
        max_gap = max(max_gap, unlucky_numbers[i+1] - unlucky_numbers[i] - 1)

    print(max_gap)

solve()
  ","
def solve():
    x, y, l, r = map(int, input().split())
    nums = []
    
    for i in range(64):
        for j in range(64):
            num = x**i + y**j
            if l <= num <= r:
                nums.append(num)
    
    nums.sort()
    
    prev = l - 1
    max_gap = 0
    
    for num in nums:
        gap = num - prev - 1
        max_gap = max(max_gap, gap)
        prev = num
    
    max_gap = max(max_gap, r - prev)
    
    print(max_gap)

solve()
  ","
def solve():
    x, y, l, r = map(int, input().split())
    powers = set()
    a = b = 0
    
    while x ** a <= r:
        while x ** a + y ** b <= r:
            if x ** a + y ** b >= l:
                powers.add(x ** a + y ** b)
            if y == 1:
                break
            b += 1
        if x == 1:
            break
        a += 1
        b = 0
    
    powers = sorted(list(powers))
    max_gap = 0
    
    if powers[0] - l > max_gap:
        max_gap = powers[0] - l
    
    for i in range(len(powers) - 1):
        if powers[i+1] - powers[i] - 1 > max_gap:
            max_gap = powers[i+1] - powers[i] - 1
            
    if r - powers[-1] > max_gap:
        max_gap = r - powers[-1]
        
    print(max_gap)


solve()
  ","
def solve():
    x, y, l, r = map(int, input().split())
    powers = set()
    for i in range(62):
        for j in range(62):
            number = x**i + y**j
            if l <= number <= r:
                powers.add(number)
    powers = sorted(list(powers))
    maximum_gap = max(powers[0] - l, r - powers[-1])
    for i in range(1, len(powers)):
        maximum_gap = max(maximum_gap, powers[i] - powers[i-1] - 1)
    maximum_gap = max(maximum_gap, r - powers[-1])
    print(maximum_gap)

solve()
","100.0","0.0","80.0","100.0","40.0","80.0","86.66666666666667","0.0","0.0","86.66666666666667","100.0","0.0","86.66666666666667","100.0","86.66666666666667","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/150","
QUESTION:
Mr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to n (n ≥ 2) burles and the amount of tax he has to pay is calculated as the maximum divisor of n (not equal to n, of course). For example, if n = 6 then Funt has to pay 3 burles, while for n = 25 he needs to pay 5 and if n = 2 he pays only 1 burle.

As mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial n in several parts n_1 + n_2 + ... + n_{k} = n (here k is arbitrary, even k = 1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition n_{i} ≥ 2 should hold for all i from 1 to k.

Ostap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split n in parts.


-----Input-----

The first line of the input contains a single integer n (2 ≤ n ≤ 2·10^9) — the total year income of mr. Funt.


-----Output-----

Print one integer — minimum possible number of burles that mr. Funt has to pay as a tax.


-----Examples-----
Input
4

Output
2

Input
27

Output
3
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    if n % 2 == 0:
        print(2)
    else:
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                print(i)
                break
        else:
            print(n)

solve()","
from math import sqrt

def solve():
    n = int(input())
    divisors = set()
    
    for i in range(2, int(sqrt(n)) + 1):
        if n % i == 0:
            divisors.add(i)
            divisors.add(n//i)
    
    if not divisors:
        print(1)
    else:
        print(min(divisors))

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        print(2)
    else:
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                print(i)
                return
        print(n)

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        print(2)
    else:
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                print(n // i)
                return
        print(n)

solve()","
def solve():
    n = int(input())
    if n % 2 == 0:
        return 2
    for i in range(3, int(n**0.5)+1, 2):
        if n % i == 0:
            return n // i
    return n

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        return 2
    elif n == 2 or n % 3 == 0:
        return 3
    else:
        return 2

solve()","
from math import sqrt

def solve():
    n = int(input())
    if n % 2 == 0:
        print(2)
    else:
        for i in range(3, int(sqrt(n)) + 1, 2):
            if n % i == 0:
                print(i)
                break
        else:
            print(n)

solve()","
def solve():
    n = int(input())
    
    divisors = []
    for i in range(2, int(n**0.5) + 1):
        while n % i == 0:
            divisors.append(i)
            n //= i
    if n > 1:
        divisors.append(n)
    max_divisor = max(divisors)
    
    print(max_divisor)

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        return 2
    for i in range(3, int(n**0.5)+1, 2):
        if n % i == 0:
            return n//i
    return n

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        return 2
    else:
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                return n // i
        return 1

solve()","
def solve():
    n = int(input())
    
    def max_divisor(num):
        if num % 2 == 0:
            return num // 2
        for i in range(3, int(num**0.5) + 1, 2):
            if num % i == 0:
                return num // i
        return num
    
    min_tax = max_divisor(n)
    print(min_tax)

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        return 2
    div = 3
    while div * div <= n:
        if n % div == 0:
            return n // div
        div += 2
    return 1

solve()","
def solve():
    n = int(input())
    
    divisors = []
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if n // i != i:
                divisors.append(n // i)
    
    divisors.append(1)
    divisors.sort()
    
    taxes = []
    for divisor in divisors:
        total_tax = 0
        remaining_n = n
        while remaining_n > 0:
            if remaining_n // divisor >= 2:
                total_tax += remaining_n % divisor
                remaining_n = remaining_n // divisor
            else:
                total_tax += remaining_n - 1
                remaining_n = 0
        taxes.append(total_tax)
    
    return min(taxes)
  
solve()","
from math import isqrt

def solve():
    n = int(input())
    if n % 2 == 0:
        return 2
    else:
        for i in range(3, isqrt(n)+1, 2):
            if n % i == 0:
                return n // i
        return 1

solve()","
def solve():
    n = int(input())
    if n % 2 == 0:
        print(2)
    else:
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                print(i)
                return
        print(n)

solve()","
def solve():
    n = int(input())
    for i in range(2, n + 1):
        if n % i == 0:
            print(n // i)
            break

solve()
","33.33333333333333","86.66666666666667","33.33333333333333","26.666666666666668","0.0","0.0","33.33333333333333","13.333333333333334","0.0","0.0","13.333333333333334","0.0","0","0.0","33.33333333333333","53.84615384615385","","","","","","","","","","","","","All tests timed out","","",""
"APPS/151","
QUESTION:
Beroffice text editor has a wide range of features that help working with text. One of the features is an automatic search for typos and suggestions of how to fix them.

Beroffice works only with small English letters (i.e. with 26 letters from a to z). Beroffice thinks that a word is typed with a typo if there are three or more consonants in a row in the word. The only exception is that if the block of consonants has all letters the same, then this block (even if its length is greater than three) is not considered a typo. Formally, a word is typed with a typo if there is a block of not less that three consonants in a row, and there are at least two different letters in this block.

For example:

  the following words have typos: ""hellno"", ""hackcerrs"" and ""backtothefutttture"";  the following words don't have typos: ""helllllooooo"", ""tobeornottobe"" and ""oooooo"". 

When Beroffice editor finds a word with a typo, it inserts as little as possible number of spaces in this word (dividing it into several words) in such a way that each of the resulting words is typed without any typos.

Implement this feature of Beroffice editor. Consider the following letters as the only vowels: 'a', 'e', 'i', 'o' and 'u'. All the other letters are consonants in this problem.


-----Input-----

The only line contains a non-empty word consisting of small English letters. The length of the word is between 1 and 3000 letters.


-----Output-----

Print the given word without any changes if there are no typos.

If there is at least one typo in the word, insert the minimum number of spaces into the word so that each of the resulting words doesn't have any typos. If there are multiple solutions, print any of them.


-----Examples-----
Input
hellno

Output
hell no 

Input
abacaba

Output
abacaba 

Input
asdfasdf

Output
asd fasd f
Use user-input-Based format and function signature solve()","
def solve():
    word = input().strip()
    vowels = {'a', 'e', 'i', 'o', 'u'}
    consonants = set('bcdfghjklmnpqrstvwxyz')
    
    typo_found = False
    result = ''
    consecutive_consonants = ''
    
    for letter in word:
        if letter in consonants:
            if not consecutive_consonants or consecutive_consonants[-1] == letter:
                consecutive_consonants += letter
            else:
                if len(consecutive_consonants) >= 3 and len(set(consecutive_consonants)) >= 2:
                    typo_found = True
                    result += consecutive_consonants + ' '
                else:
                    result += consecutive_consonants
                consecutive_consonants = letter
        else:
            result += consecutive_consonants + letter
            consecutive_consonants = ''
    
    result += consecutive_consonants
    
    if typo_found:
        print(result)
    else:
        print(word)

solve()
","
def solve():
    word = input().strip()
    vowels = {'a', 'e', 'i', 'o', 'u'}
    result = ''

    typo = False
    consonant_count = 0
    for letter in word:
        if letter not in vowels:
            consonant_count += 1
            if consonant_count >= 3:
                typo = True
        else:
            consonant_count = 0

    if not typo:
        print(word)
    else:
        tmp = ''
        for letter in word:
            if letter not in vowels:
                tmp += letter
                consonant_count += 1
                if consonant_count >= 3 and len(set(tmp)) >= 2:
                    result += tmp + ' '
                    tmp = ''
                    consonant_count = 0
            else:
                result += tmp + ' '
                result += letter
                tmp = ''
                consonant_count = 0
        result += tmp
        print(result)

solve()
  ","
def solve(word):
    vowels = {'a', 'e', 'i', 'o', 'u'}
    result = ''
    i = 0

    while i < len(word):
        if word[i] not in vowels:
            j = i
            while j < len(word) and word[j] not in vowels:
                j += 1
            if j - i >= 3 and len(set(word[i:j])) > 1:
                result += word[i:j] + ' '
                i = j
            else:
                result += word[i:j]
                i = j
        else:
            result += word[i]
            i += 1

    return result

# Example usage
input_word = input().strip()
print(solve(input_word))
  
solve()","
def solve():
    word = input()
    
    vowels = {'a', 'e', 'i', 'o', 'u'}
    
    typo_indices = []
    for i in range(len(word) - 2):
        if word[i] not in vowels and word[i:i+3].count(word[i]) != 3 and len(set(word[i:i+3])) > 1:
            typo_indices.append(i + 2)
    
    if not typo_indices:
        print(word)
    else:
        output = []
        i = 0
        for typo_index in typo_indices:
            output.append(word[i:typo_index])
            i = typo_index
        output.append(word[i:])
        print(' '.join(output))

solve()
","
def solve():
    vowels = ['a', 'e', 'i', 'o', 'u']
    word = input().strip()
    
    result = []
    typo_found = False
    consecutive_consonants = 0
    
    for i in range(len(word)):
        if word[i] not in vowels:
            consecutive_consonants += 1
        else:
            if consecutive_consonants >= 3:
                if consecutive_consonants > 3 or len(set(word[i-consecutive_consonants:i])) > 1:
                    result.append(' ')
                    typo_found = True
            consecutive_consonants = 0
        result.append(word[i])
    
    if consecutive_consonants >= 3 and (consecutive_consonants > 3 or len(set(word[-consecutive_consonants:])) > 1):
        result.append(' ')
        typo_found = True
    
    if typo_found:
        print(''.join(result))
    else:
        print(word)

solve()
","
from string import ascii_lowercase

def solve():
    word = input().strip()
    
    vowels = set('aeiou')
    consonants = set(ascii_lowercase) - vowels
    
    # Function to check if a block of letters is a typo
    def is_typo(block):
        if len(block) < 3:
            return False
        return len(set(block) - vowels) >= 2
    
    result = ''
    current_block = ''
    
    for letter in word:
        if letter in consonants:
            current_block += letter
        else:
            if is_typo(current_block):
                result += ' '
            result += current_block + letter
            current_block = ''
    
    result += current_block
    
    print(result)

solve()
","
def solve():
    vowels = ['a', 'e', 'i', 'o', 'u']
    word = input().strip()
    
    i = 0
    result = []
    while i < len(word):
        count = 0
        while i < len(word) and word[i] not in vowels:
            count += 1
            if count >= 3 and (i+1 == len(word) or word[i+1] in vowels or word[i] != word[i+1]):
                result.append(word[:i+1])
                word = word[i+1:]
                i = 0
                break
            i += 1
        i += 1
    
    if len(result) == 0:
        print(word)
    else:
        print(' '.join(result))

solve()
","
def solve():
    word = input()
    vowels = ['a', 'e', 'i', 'o', 'u']
    result = """"
    count = 0

    for i in range(len(word)):
        if word[i] not in vowels:
            count += 1
            if count >= 3:
                if i+1 < len(word) and word[i] != word[i+1]:
                    result += ' '
                    count = 1
            result += word[i]
        else:
            count = 0
            result += word[i]

    print(result)

solve()
","
def solve():
    word = input().strip()
    vowels = {'a', 'e', 'i', 'o', 'u'}
    consonants = set('bcdfghjklmnpqrstvwxyz')
    
    typo_found = False
    result = """"
    typo_word = """"
    count_consonants = 0
    
    for letter in word:
        if letter in consonants:
            count_consonants += 1
            typo_word += letter
        else:
            if count_consonants >= 3 and len(set(typo_word)) > 1:
                typo_found = True
                result += ' '
            result += typo_word
            count_consonants = 0
            typo_word = """"
        result += letter

    if count_consonants >= 3 and len(set(typo_word)) > 1:
        typo_found = True
        result += ' '
    result += typo_word

    if not typo_found:
        print(word)
    else:
        print(result)


if __name__ == ""__main__"":
    solve()
","
from string import ascii_lowercase

def solve():
    vowels = set('aeiou')
    word = input().strip()
    
    typo_indices = []
    for i in range(1, len(word)-1):
        if word[i-1] not in vowels and word[i] not in vowels and word[i+1] not in vowels:
            typo_indices.append(i)
    
    if not typo_indices:
        print(word)
    else:
        result = """"
        typo_start = 0
        for idx in typo_indices:
            result += word[typo_start:idx] + "" ""
            typo_start = idx
        result += word[typo_start:]
        print(result)

solve()
  ","
def solve():
    word = input().strip()
    
    vowels = set(['a', 'e', 'i', 'o', 'u'])
    
    consonants = []
    typo_indices = []
    
    for i in range(len(word)):
        if word[i] not in vowels:
            if i == 0 or word[i] != word[i - 1]:
                start = i
            consonants.append(word[i])
        else:
            if len(consonants) >= 3 and len(set(consonants)) > 1:
                typo_indices.append(start)
            consonants = []
    
    result = ''
    last_idx = 0
    
    for idx in typo_indices:
        result += word[last_idx:idx] + ' '
        last_idx = idx
    
    result += word[last_idx:]
    
    print(result)

solve()
  ","
def solve():
    word = input().strip()
    
    vowels = {'a', 'e', 'i', 'o', 'u'}
    consonants = set('bcdfghjklmnpqrstvwxyz')
    
    result = []
    current_word = ''
    consecutive_consonants = 0
    
    for letter in word:
        if letter in consonants:
            consecutive_consonants += 1
            if consecutive_consonants >= 3:
                if letter != current_word[-1] and len(set(current_word)) >= 2:
                    result.append(current_word)
                    current_word = ''
        else:
            consecutive_consonants = 0
        
        current_word += letter
        if letter not in vowels:
            result.append(current_word)
            current_word = ''
    
    if current_word:
        result.append(current_word)
    
    print(' '.join(result))

solve()
","
def solve():
    word = input().strip()
    vowels = {'a', 'e', 'i', 'o', 'u'}
    
    i = 0
    while i < len(word):
        if word[i] not in vowels:
            count = 1
            j = i + 1
            while j < len(word) and word[j] not in vowels:
                if word[j] != word[i]:
                    count += 1
                if count >= 3:
                    word = word[:j] + "" "" + word[j:]
                    i = j 
                    break
                j += 1
        i += 1
    
    print(word)

solve()
","
def solve():
    word = input()
    vowels = {'a', 'e', 'i', 'o', 'u'}
    consecutive_consonants = []
    result = []

    for letter in word:
        if letter not in vowels:
            if consecutive_consonants and consecutive_consonants[-1] == letter:
                consecutive_consonants.append(letter)
            else:
                if len(consecutive_consonants) >= 3 and len(set(consecutive_consonants)) > 1:
                    result.append(''.join(consecutive_consonants))
                    consecutive_consonants = [letter]
                else:
                    result.append(''.join(consecutive_consonants))
                    consecutive_consonants = [letter]
        else:
            result.append(''.join(consecutive_consonants))
            consecutive_consonants.clear()
            result.append(letter)

    result.append(''.join(consecutive_consonants))

    print(' '.join(result))


solve()
","
def solve():
    vowels = {'a', 'e', 'i', 'o', 'u'}
    word = input().strip()
    result = ''
    consecutive_consonants = 0
    for letter in word:
        if letter not in vowels:
            consecutive_consonants += 1
            if consecutive_consonants >= 3:
                if letter != result[-1]:
                    result += ' '
                consecutive_consonants = 1
        else:
            consecutive_consonants = 0
        result += letter
    print(result)

# Call the function to run
solve()
","
def solve():
    word = input().strip()
    
    vowels = {'a', 'e', 'i', 'o', 'u'}
    consonant_block = ''
    result = ''
    
    for letter in word:
        if letter not in vowels:
            consonant_block += letter
        else:
            if len(consonant_block) >= 3 and len(set(consonant_block)) >= 2:
                result += ' ' + consonant_block
                consonant_block = ''
            else:
                result += consonant_block + letter
                consonant_block = ''
    
    result += consonant_block
    
    print(result.strip())

import sys
solve()
","20.0","20.0","0.0","6.666666666666667","20.0","20.0","20.0","46.666666666666664","20.0","20.0","33.33333333333333","6.666666666666667","46.666666666666664","0.0","80.0","20.0","","","","","","","","","","","","","","","",""
"APPS/152","
QUESTION:
Anton is playing a very interesting computer game, but now he is stuck at one of the levels. To pass to the next level he has to prepare n potions.

Anton has a special kettle, that can prepare one potions in x seconds. Also, he knows spells of two types that can faster the process of preparing potions.  Spells of this type speed up the preparation time of one potion. There are m spells of this type, the i-th of them costs b_{i} manapoints and changes the preparation time of each potion to a_{i} instead of x.  Spells of this type immediately prepare some number of potions. There are k such spells, the i-th of them costs d_{i} manapoints and instantly create c_{i} potions. 

Anton can use no more than one spell of the first type and no more than one spell of the second type, and the total number of manapoints spent should not exceed s. Consider that all spells are used instantly and right before Anton starts to prepare potions.

Anton wants to get to the next level as fast as possible, so he is interested in the minimum number of time he needs to spent in order to prepare at least n potions.


-----Input-----

The first line of the input contains three integers n, m, k (1 ≤ n ≤ 2·10^9, 1 ≤ m, k ≤ 2·10^5) — the number of potions, Anton has to make, the number of spells of the first type and the number of spells of the second type.

The second line of the input contains two integers x and s (2 ≤ x ≤ 2·10^9, 1 ≤ s ≤ 2·10^9) — the initial number of seconds required to prepare one potion and the number of manapoints Anton can use.

The third line contains m integers a_{i} (1 ≤ a_{i} < x) — the number of seconds it will take to prepare one potion if the i-th spell of the first type is used.

The fourth line contains m integers b_{i} (1 ≤ b_{i} ≤ 2·10^9) — the number of manapoints to use the i-th spell of the first type.

There are k integers c_{i} (1 ≤ c_{i} ≤ n) in the fifth line — the number of potions that will be immediately created if the i-th spell of the second type is used. It's guaranteed that c_{i} are not decreasing, i.e. c_{i} ≤ c_{j} if i < j.

The sixth line contains k integers d_{i} (1 ≤ d_{i} ≤ 2·10^9) — the number of manapoints required to use the i-th spell of the second type. It's guaranteed that d_{i} are not decreasing, i.e. d_{i} ≤ d_{j} if i < j.


-----Output-----

Print one integer — the minimum time one has to spent in order to prepare n potions.


-----Examples-----
Input
20 3 2
10 99
2 4 3
20 10 40
4 15
10 80

Output
20

Input
20 3 2
10 99
2 4 3
200 100 400
4 15
100 800

Output
200



-----Note-----

In the first sample, the optimum answer is to use the second spell of the first type that costs 10 manapoints. Thus, the preparation time of each potion changes to 4 seconds. Also, Anton should use the second spell of the second type to instantly prepare 15 potions spending 80 manapoints. The total number of manapoints used is 10 + 80 = 90, and the preparation time is 4·5 = 20 seconds (15 potions were prepared instantly, and the remaining 5 will take 4 seconds each).

In the second sample, Anton can't use any of the spells, so he just prepares 20 potions, spending 10 seconds on each of them and the answer is 20·10 = 200.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split()))

    min_time = n * x
    for i in range(m):
        if b[i] <= s:
            min_time = min(min_time, max(0, n - c[0]) * a[i])

    for i in range(k):
        if d[i] <= s:
            min_time = min(min_time, max(0, n - c[i]) * x)

    print(min_time)

solve()
","
def solve():
    # Input
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    # Initialize minimum time variable
    min_time = n * x

    # Iterate through spells of first type
    for i in range(m):
        if b[i] <= s:
            remaining_points = s - b[i]
            num_potions = n
            if remaining_points >= d[0]:
                left = 0
                right = k
                while right - left > 1:
                    mid = (left + right) // 2
                    if d[mid] <= remaining_points:
                        left = mid
                    else:
                        right = mid
                num_potions = max(num_potions, (n - c[left]) * a[i])

            min_time = min(min_time, num_potions)

    print(min_time)

# Call the function
solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    ans = n*x

    for i in range(m):
        if b[i] > s:
            continue
        left = 0
        right = k
        while left < right:
            mid = (left+right)//2
            if d[mid] > s-b[i]:
                right = mid
            else:
                left = mid+1
        if right > 0:
            ans = min(ans, (n-c[right-1])*a[i])

    ans = min(ans, n*x)

    for i in range(k):
        if d[i] <= s:
            ans = min(ans, n*c[i])

    print(ans)

solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    min_time = x * n

    for i in range(k):
        if d[i] <= s:
            remaining_s = s - d[i]
            num_potions = n - c[i]
            cur_time = x * num_potions
            j = 0
            while j < m and b[j] > remaining_s:
                j += 1
            if j < m:
                cur_time = min(cur_time, a[j] * num_potions)
            min_time = min(min_time, cur_time)

    return min_time

solve()
","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    ans = n * x
    for i in range(m):
        if b[i] <= s:
            ans = min(ans, a[i] * max(0, n - c[-1]))

    for i in range(k):
        if d[i] <= s:
            j = 0
            while j < m and b[j] > s - d[i]:
                j += 1
            if j < m:
                ans = min(ans, a[j] * max(0, n - c[i]))

    print(ans)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    min_time = n * x

    for i in range(m):
        if b[i] <= s:
            min_time = min(min_time, max(0, n - c[-1]) * a[i])

    for i in range(k):
        if d[i] <= s:
            j = 0
            while c[j] < n:
                j += 1
            min_time = min(min_time, (n - c[j-1]) * x)

    print(min_time)

solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    min_time = n * x
    for i in range(m):
        if b[i] <= s:
            time = n * a[i]
            min_time = min(min_time, time)
    for i in range(k):
        if d[i] <= s:
            remaining_potions = max(0, n - c[i])
            time = remaining_potions * x
            min_time = min(min_time, time)
    
    print(min_time)
  
solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    min_time = n*x
    for i in range(m):
        if b[i] <= s:
            min_time = min(min_time, max(0, n - sum(c[:j] for j in range(k+1) if d[j] <= s - b[i])) * a[i])

    for i in range(k):
        if d[i] <= s:
            min_time = min(min_time, max(0, n - c[i]) * x)

    print(min_time)

solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())
    
    ans = x * n
    for i in range(m):
        if b[i] <= s:
            ans = min(ans, a[i]*max(n - c[bisect_right(d, s-b[i])-1], 0))
    
    ans = min(ans, x*n)
    for i in range(k):
        if d[i] <= s:
            ans = min(ans, x * max(n - c[i], 0))
    
    print(ans)

import bisect
  
solve()","
from typing import List

def solve(n: int, m: int, k: int, x: int, s: int, a: List[int], b: List[int], c: List[int], d: List[int]) -> int:
    min_time = n * x

    for i in range(m):
        if b[i] <= s:
            min_time = min(min_time, max(0, n - c[-1]) * a[i])

    for i in range(k):
        if d[i] <= s:
            j = 0
            while j < m and b[j] > s - d[i]:
                j += 1
            if j < m:
                min_time = min(min_time, c[i] * a[j])

    return min_time

solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    min_time = n * x

    for i in range(k):
        if d[i] <= s:
            potions_needed = n - c[i]
            time = potions_needed * x
            min_time = min(min_time, time)

    for i in range(m):
        if b[i] <= s:
            manapoints_left = s - b[i]
            index = bisect_right(d, manapoints_left)
            if index > 0:
                potions_needed = n - c[index - 1]
                time = potions_needed * a[i]
                min_time = min(min_time, time)

    return min_time

solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    min_time = n * x
    for i in range(m):
        if b[i] <= s:
            rem_manapoints = s - b[i]
            num_potions = n
            mana_needed = rem_manapoints
            idx = min(k-1, max(0, bisect_right(d, rem_manapoints)-1))
            num_potions = max(0, n - c[idx])
            min_time = min(min_time, num_potions * a[i])

    no_spell_time = n * x
    ans = min(min_time, no_spell_time)
    print(ans)

solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())
    
    min_time = n*x
    for i in range(m):
        if b[i] <= s:
            min_time = min(min_time, n*a[i])
    
    i = 0
    for j in range(k):
        if d[j] <= s:
            rem_manapoints = s - d[j]
            num_potions = n - c[j]
            index = bisect.bisect_right(b, rem_manapoints)
            if index <= m:
                min_time = min(min_time, num_potions*a[index-1])
            else:
                min_time = min(min_time, n*x)

    print(min_time)

import bisect

solve()","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split()))

    min_time = x * n

    for i in range(m):
        if b[i] <= s:
            min_time = min(min_time, a[i] * max(0, n - c[-1]))

    for i in range(k):
        if d[i] <= s:
            left = 0
            right = m
            while left < right:
                mid = (left + right) // 2
                if b[mid] + d[i] <= s:
                    left = mid + 1
                else:
                    right = mid
            min_time = min(min_time, x * c[right-1])

    print(min_time)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split())

    ans = n*x
    for i in range(m):
        if b[i] <= s:
            ans = min(ans, n*a[i])
    for i in range(k):
        if d[i] <= s:
            rem_manapoints = s - d[i]
            idx = bisect_left(b, rem_manapoints)
            if idx == m or b[idx] > rem_manapoints:
                idx -= 1
            if idx != -1:
                ans = min(ans, c[i]*(x if a[idx] > x else a[idx]))
            else:
                ans = min(ans, c[i]*x)

    print(ans)

solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    x, s = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    d = list(map(int, input().split()))

    min_time = n * x

    for i in range(m):
        if b[i] <= s:
            min_time = min(min_time, max(0, n - sum(c[: bisect_right(c, n - b[i])])) * x)

    for i in range(k):
        if d[i] <= s:
            min_time = min(min_time, (n - c[bisect_right(d, s) - 1]) * x)

    print(min_time)

solve()
","73.33333333333333","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","40.0","0.0","20.0","","","","","","","","","","","","","","","",""
"APPS/153","
QUESTION:
Polycarp takes part in a math show. He is given n tasks, each consists of k subtasks, numbered 1 through k. It takes him t_{j} minutes to solve the j-th subtask of any task. Thus, time required to solve a subtask depends only on its index, but not on the task itself. Polycarp can solve subtasks in any order.

By solving subtask of arbitrary problem he earns one point. Thus, the number of points for task is equal to the number of solved subtasks in it. Moreover, if Polycarp completely solves the task (solves all k of its subtasks), he recieves one extra point. Thus, total number of points he recieves for the complete solution of the task is k + 1.

Polycarp has M minutes of time. What is the maximum number of points he can earn?


-----Input-----

The first line contains three integer numbers n, k and M (1 ≤ n ≤ 45, 1 ≤ k ≤ 45, 0 ≤ M ≤ 2·10^9).

The second line contains k integer numbers, values t_{j} (1 ≤ t_{j} ≤ 1000000), where t_{j} is the time in minutes required to solve j-th subtask of any task.


-----Output-----

Print the maximum amount of points Polycarp can earn in M minutes.


-----Examples-----
Input
3 4 11
1 2 3 4

Output
6

Input
5 5 10
1 2 4 8 16

Output
7



-----Note-----

In the first example Polycarp can complete the first task and spend 1 + 2 + 3 + 4 = 10 minutes. He also has the time to solve one subtask of the second task in one minute.

In the second example Polycarp can solve the first subtask of all five tasks and spend 5·1 = 5 minutes. Also he can solve the second subtasks of two tasks and spend 2·2 = 4 minutes. Thus, he earns 5 + 2 = 7 points in total.
Use user-input-Based format and function signature solve()","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    
    t.sort()
    points = 0
    for i in range(k+1):
        time_left = M
        solved = 0
        for j in range(n):
            subtasks = min((time_left // t[i]), k)
            solved += subtasks
            time_left -= subtasks * t[i]
        points = max(points, solved)
    
    print(points)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    t.sort()
    
    points = 0
    
    for i in range(k + 1):
        time_left = M
        tasks_solved = min(n, i)
        subtasks_solved = tasks_solved * k - i
        time_required = sum(t[:tasks_solved]) + sum(t[:subtasks_solved])
        if time_required > M:
            break
        points = max(points, tasks_solved + subtasks_solved)
    
    print(points)

import sys
solve()
","
def solve():
    n, k, M = map(int, input().split())
    t_values = list(map(int, input().split()))
    
    t_values.sort()
    
    max_points = 0
    for subtasks_completed in range(k + 1):
        time_to_solve = sum(t_values[:subtasks_completed])
        if time_to_solve > M:
            break
        max_points = max(max_points, subtasks_completed + min((M - time_to_solve) // sum(t_values), n - subtasks_completed))
    
    print(max_points)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    
    t.sort()
    points = 0
    
    for i in range(k+1):
        available_time = M
        total_solved = i
        for j in range(i):
            available_time -= t[j]
            if available_time < 0:
                break
            total_solved += 1
        points = max(points, min(total_solved, (n * (k + 1))))
    
    print(points)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    
    t.sort()
    ans = 0
    
    for i in range(k+1):
        total_time = sum(t[:i]) * (n - (i-1))
        
        if total_time <= M:
            ans = max(ans, i * n + i)
        else:
            break
    
    print(ans)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))

    t.sort()

    points = 0
    max_subtasks = min(M // sum(t), n * k)

    while max_subtasks >= k:
        points += k + 1
        M -= sum(t)
        max_subtasks -= k

    points += max_subtasks

    print(points)

solve()
","
def solve():
    import sys

    n, k, M = map(int, sys.stdin.readline().split())
    t = list(map(int, sys.stdin.readline().split()))

    t.sort()

    total_points = 0
    for i in range(k + 1):
        max_points = i
        remaining_time = M

        for j in range(n):
            points = 0
            for m in range(i):
                if remaining_time >= t[m]:
                    points += 1
                    remaining_time -= t[m]
            
            max_points = max(max_points, i + points)

        total_points = max(total_points, max_points)

    print(total_points)

solve()","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    
    t.sort()
    max_points = 0
    for i in range(k+1):
        total_time = sum(t[:i]) + (k-i) * i
        if total_time <= M:
            max_points = max(max_points, i + k)
    
    print(max_points)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    times = list(map(int, input().split()))
    
    times.sort()
    
    points = 0
    for i in range(1, k + 1):
        total_time = sum(times[:i]) * n
        if total_time <= M:
            points = max(points, i * n + min((M - total_time) // sum(times[:i]), n))
    
    print(points)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    
    t.sort()
    points = 0
    
    for i in range(k+1):
        time_left = M
        subtasks_solved = 0
        
        for j in range(k):
            time_taken = i * t[j]
            
            if time_left >= time_taken:
                subtasks_solved += i
                time_left -= time_taken
            else:
                subtasks_solved += time_left // t[j]
                break
        
        points = max(points, subtasks_solved)
    
    print(points)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    tasks = list(map(int, input().split()))
    tasks.sort()
    
    points = 0
    for i in range(k+1):
        total_time = sum(tasks[:i]) + i
        if total_time <= M:
            points = max(points, i)
        else:
            break
    
    return points

solve()
","
def solve():
    n, k, m = map(int, input().split())
    subtasks_times = list(map(int, input().split()))
    subtasks_times.sort()

    max_points = 0
    for i in range(min(n, m) + 1):
        available_time = m - i
        potential_points = i * k

        for j in range(min(k, available_time)):
            potential_points += subtasks_times[j]

        max_points = max(max_points, potential_points)

    print(max_points)


solve()
","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    t.sort()
    
    points = 0
    for i in range(k+1):
        time_left = M
        tasks_solved = 0
        for j in range(n):
            subtasks_completed = min((time_left // t[i]), k)
            time_left -= subtasks_completed * t[i]
            tasks_solved += subtasks_completed
        points = max(points, tasks_solved)
    
    print(points)

solve()
","
def solve():
    n, k, M = map(int, input().split())
    times = list(map(int, input().split()))

    points = 0
    for solved in range(0, k + 1):
        time_left = M
        tasks_left = n
        subtasks = []
        for t in range(k):
            subtasks.append((t + 1, times[t]))

        subtasks.sort(key=lambda x: x[1])

        for i in range(len(subtasks)):
            subtask_num, subtask_time = subtasks[i]
            if subtask_time <= time_left:
                points += 1
                time_left -= subtask_time
                tasks_left -= 1

                if tasks_left == 0:
                    points += 1
                    break
            else:
                break

    return points


solve()","
from itertools import combinations

def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    max_points = 0

    for i in range(k+1):
        for comb in combinations(t, i):
            time_taken = sum(comb)
            if time_taken <= M:
                points = i + min(n, (M - time_taken) // sum(t))
                max_points = max(max_points, points)

    print(max_points)

solve()","
def solve():
    n, k, M = map(int, input().split())
    t = list(map(int, input().split()))
    
    t.sort()
    res = 0
    
    for i in range(k+1):
        total_time = 0
        max_points = 0
        
        for j in range(i):
            total_time += t[j]
            if total_time > M:
                break
            max_points = i
        
        if max_points > res:
            res = max_points
    
    print(res)
  
solve()","0.0","13.333333333333334","20.0","13.333333333333334","33.33333333333333","26.666666666666668","13.333333333333334","20.0","26.666666666666668","33.33333333333333","0.0","13.333333333333334","0.0","0.0","21.428571428571427","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/154","
QUESTION:
Recall that a binary search tree is a rooted binary tree, whose nodes each store a key and each have at most two distinguished subtrees, left and right. The key in each node must be greater than any key stored in the left subtree, and less than any key stored in the right subtree.

The depth of a vertex is the number of edges on the simple path from the vertex to the root. In particular, the depth of the root is $0$.

Let's call a binary search tree perfectly balanced if there doesn't exist a binary search tree with the same number of vertices that has a strictly smaller sum of depths of its vertices.

Let's call a binary search tree with integer keys striped if both of the following conditions are satisfied for every vertex $v$:   If $v$ has a left subtree whose root is $u$, then the parity of the key of $v$ is different from the parity of the key of $u$.  If $v$ has a right subtree whose root is $w$, then the parity of the key of $v$ is the same as the parity of the key of $w$. 

You are given a single integer $n$. Find the number of perfectly balanced striped binary search trees with $n$ vertices that have distinct integer keys between $1$ and $n$, inclusive. Output this number modulo $998\,244\,353$.


-----Input-----

The only line contains a single integer $n$ ($1 \le n \le 10^6$), denoting the required number of vertices.


-----Output-----

Output the number of perfectly balanced striped binary search trees with $n$ vertices and distinct integer keys between $1$ and $n$, inclusive, modulo $998\,244\,353$.


-----Examples-----
Input
4

Output
1

Input
3

Output
0



-----Note-----

In the first example, this is the only tree that satisfies the conditions: $\left. \begin{array}{l}{\text{perfectly balanced}} \\{\text{striped}} \\{\text{binary search tree}} \end{array} \right.$

In the second example, here are various trees that don't satisfy some condition: [Image]
Use user-input-Based format and function signature solve()","
def solve(n: int) -> int:
    MOD = 998244353
    
    def power(x, y):
        res = 1
        while y > 0:
            if y % 2 == 1:
                res = (res * x) % MOD
            y //= 2
            x = (x * x) % MOD
        return res
    
    if n % 2 == 0:
        return 0
    
    return power(2, (n - 1) // 2)

# Example usage:
n = int(input())
result = solve(n)
print(result)

solve()","
def solve(n):
    mod = 998244353
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1

    for i in range(2, n + 1):
        for j in range(i):
            dp[i] = (dp[i] + dp[j] * dp[i - 1 - j]) % mod

    return dp[n]

# Sample Inputs
print(solve(4))  # Output: 1
print(solve(3))  # Output: 0

solve()","
def solve(n: int) -> int:
    mod = 998244353
    dp = [0, 1] + [0] * (n - 1)
    for i in range(2, n + 1):
        dp[i] = (dp[i - 2] * ((i - 1) * (i - 2) // 2) + dp[i - 1] * (2 * i - 1)) % mod
    return dp[n]

# You may want to include additional imports based on your coding environment

solve()","
def solve(n):
    MOD = 998244353
    
    def factorial_mod(n):
        result = 1
        for i in range(1, n + 1):
            result = (result * i) % MOD
        return result
    
    def power_mod(base, exp):
        result = 1
        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % MOD
            base = (base * base) % MOD
            exp //= 2
        return result
    
    def ncr_mod(n, r):
        numerator = factorial_mod(n)
        denominator = (factorial_mod(r) * factorial_mod(n - r)) % MOD
        return (numerator * power_mod(denominator, MOD - 2)) % MOD
    
    if n % 2 == 0:
        return 0
    
    return (ncr_mod(n, n // 2) * power_mod(n // 2 + 1, MOD - 2)) % MOD
  
solve()","
def solve(n: int) -> int:
    MOD = 998244353
    dp = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n + 1):
        for j in range(i):
            dp[i] = (dp[i] + (dp[j] * dp[i-j-1]) % MOD) % MOD

    return dp[n]

# Example usage
print(solve(4))  # Output: 1
print(solve(3))  # Output: 0

solve()","
def solve(n: int) -> int:
    MOD = 998244353

    def power(base, exp):
        res = 1
        while exp > 0:
            if exp % 2 == 1:
                res = (res * base) % MOD
            base = (base * base) % MOD
            exp //= 2
        return res

    factorial = [1] * (n + 1)
    for i in range(1, n + 1):
        factorial[i] = (factorial[i - 1] * i) % MOD

    def nCr(n, r):
        numerator = factorial[n]
        denominator = (factorial[r] * factorial[n - r]) % MOD
        return (numerator * power(denominator, MOD - 2)) % MOD

    if n % 2 == 1:
        return 0

    return (nCr(n // 2, n // 2) * power(n // 2 + 1, MOD - 2)) % MOD

solve()","
def solve(n):
    MOD = 998244353
    
    dp = [[0, 1] for _ in range(n + 1)]
    
    for i in range(2, n + 1):
        dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % MOD
        dp[i][1] = (dp[i - 2][0] + dp[i - 1][0]) % MOD
    
    return dp[n][1]

# Call the function with user input
n = int(input())
result = solve(n)
print(result)

solve()","
def solve(n: int) -> int:
    mod = 998244353

    def count_perms(n: int) -> int:
        if n == 0:
            return 1
        res = 0
        for k in range(1, n + 1):
            res += ((-1) ** (k - 1)) * count_perms(n - k) * count_perms(k - 1)
            res %= mod
        return res

    return count_perms(n) % mod
  
solve()","
def solve(n):
    MOD = 998244353
    
    dp = [0] * (n+1)
    dp[1] = 1
    
    for i in range(2, n+1):
        dp[i] = (dp[i-2] * dp[i-1]) % MOD
    
    return dp[n]

# Example usage
n = int(input())
result = solve(n)
print(result)

solve()","
def solve(n: int) -> int:
    MOD = 998244353
    
    dp = [0] * (n + 1)
    dp[0] = 1
    
    for i in range(1, n + 1):
        for j in range(i):
            dp[i] = (dp[i] + dp[j] * dp[i - j - 1]) % MOD
            
    return dp[n]

# Example usage:
n = int(input())
result = solve(n)
print(result)

solve()","
class StripedBST:
    def __init__(self, n):
        self.mod = 998244353
        self.n = n
        self.dp = [[[-1 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]

    def solve(self):
        return (self.get_count(1, 0, 0) + self.get_count(1, 1, 0)) % self.mod

    def get_count(self, node, parity, depth):
        if node == self.n + 1:
            return 1 if depth == 0 else 0

        if self.dp[node][parity][depth] != -1:
            return self.dp[node][parity][depth]

        res = 0
        if depth == 0:
            res = (res + self.get_count(node + 1, 1 - parity, 1)) % self.mod
            res = (res + self.get_count(node + 1, parity, 0)) % self.mod
        else:
            res = (res + self.get_count(node + 1, parity, 0)) % self.mod

        self.dp[node][parity][depth] = res
        return res

# Input processing
def solve(n):
    striped_bst = StripedBST(n)
    return striped_bst.solve()

# Taking user input
n = int(input())
print(solve(n))

solve()","
def solve(n: int) -> int:
    MOD = 998244353
    
    def comb(n, r, mod):
        res = 1
        den = 1
        for i in range(r):
            res = (res * (n - i)) % mod
            den = (den * (i + 1)) % mod
        return res * pow(den, mod - 2, mod) % mod
    
    def count_trees(n):
        if n == 1:
            return 1
        if n == 2:
            return 0
        total = 0
        
        for i in range(2, n + 1, 2):
            left_count = count_trees(i // 2 - 1)
            right_count = count_trees(n - i // 2)
            total += (comb(n - 1, i - 1, MOD) * left_count * right_count) % MOD
            total %= MOD
        
        return total
    
    return count_trees(n)

solve()","
def solve(n: int) -> int:
    MOD = 998244353

    dp = [0] * (n+1)
    dp[0] = dp[1] = 1

    for i in range(2, n+1):
        for j in range(i):
            dp[i] = (dp[i] + dp[j] * dp[i-1-j]) % MOD

    return dp[n]

n = int(input())
print(solve(n))

solve()","
from math import factorial

def solve(n):
    mod = 998244353

    def comb(n, k):
        return factorial(n) // (factorial(k) * factorial(n - k))

    def count_trees(n):
        if n <= 2:
            return 1
        result = 0
        for i in range(n):
            result += (comb(n - 1, i) * count_trees(i) * count_trees(n - 1 - i))
        return result % mod

    return count_trees(n)

solve()","
def solve(n: int) -> int:
    MOD = 998244353

    def count(l, r):
        if l > r:
            return 1
        res = 0
        for i in range(l, r + 1):
            left = count(l, i - 1)
            right = count(i + 1, r)
            res = (res + (left * right) % MOD) % MOD
        return res

    return count(1, n) % MOD

solve()","
MOD = 998244353

def solve(n: int) -> int:
    dp = [0] * (n + 1)
    dp[0] = dp[1] = 1

    for i in range(2, n + 1):
        for j in range(i):
            dp[i] = (dp[i] + dp[j] * dp[i - 1 - j]) % MOD

    ans = dp[n]
    for i in range(1, n // 2 + 1):
        ans = (ans - dp[i] * dp[n - i]) % MOD

    return (ans + MOD) % MOD

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/155","
QUESTION:
You might have heard about the next game in Lara Croft series coming out this year. You also might have watched its trailer. Though you definitely missed the main idea about its plot, so let me lift the veil of secrecy.

Lara is going to explore yet another dangerous dungeon. Game designers decided to use good old 2D environment. The dungeon can be represented as a rectangle matrix of n rows and m columns. Cell (x, y) is the cell in the x-th row in the y-th column. Lara can move between the neighbouring by side cells in all four directions.

Moreover, she has even chosen the path for herself to avoid all the traps. She enters the dungeon in cell (1, 1), that is top left corner of the matrix. Then she goes down all the way to cell (n, 1) — the bottom left corner. Then she starts moving in the snake fashion — all the way to the right, one cell up, then to the left to the cell in 2-nd column, one cell up. She moves until she runs out of non-visited cells. n and m given are such that she always end up in cell (1, 2).

Lara has already moved to a neighbouring cell k times. Can you determine her current position?


-----Input-----

The only line contains three integers n, m and k (2 ≤ n, m ≤ 10^9, n is always even, 0 ≤ k < n·m). Note that k doesn't fit into 32-bit integer type!


-----Output-----

Print the cell (the row and the column where the cell is situated) where Lara ends up after she moves k times.


-----Examples-----
Input
4 3 0

Output
1 1

Input
4 3 11

Output
1 2

Input
4 3 7

Output
3 2



-----Note-----

Here is her path on matrix 4 by 3: [Image]
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k = map(int, input().split())
    if k < n:
        print(1, k+1)
    else:
        row = 1 + (k - n) // (m-1)
        col = k % (m-1)
        if row % 2 == 0:
            col = m - col
        if col == 0:
            col = m
        print(row, col)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    if k < n-1:
        print(1, 1+k)
    else:
        row = 1 + (k - (n-1)) // (m-1)
        col = 2 if (row-1) % 2 == 0 else m - (k - (n-1)) % (m-1)
        print(row, col)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    if k < n:
        print(1, k+1)
    else:
        rows = min((k-n)//(n-1), n-1)
        cols = k - rows*(n-1) + 1 if rows < n-1 else m
        print(n - (2*rows), cols)

solve()
","
def solve():
    n, m, k = map(int, input().split())

    rem = k % (n-1)
    if k // (n-1) % 2 == 0:
        print(k // (n-1) + 1, (rem + 1) if k // (n-1) % 2 != 0 else m)
    else:
        print(k // (n-1) + 1, m - rem if k // (n-1) % 2 == 0 else 1)

solve()","
def solve():
    n, m, k = map(int, input().split())
    
    if k < n:
        print(1, 1)
    else:
        row = 1 + (k - n)//(m - 1)
        col = 2 if (k - n) % (m - 1) == 0 else (k - n) % (m - 1) + 1
        print(row, col)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    if k < n:
        print(1, k + 1)
    else:
        row = n - (k - n) // (m - 1)
        col = m - 1 if row % 2 == n % 2 else 2
        print(row, col)

solve()
","
def solve():
    n, m, k = map(int, input().strip().split())
    row, col = 1, 1
    if k < n:
        row += k
    else:
        k -= n
        row = n - k
        if n > 2:
            col = 2 + (k // (m - 1)) if (n // 2) % 2 == 1 else m - (k // (m - 1)) - 1
    print(row, col)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    if k < n-1:
        print(1+k,1)
    else:
        visited = (n-1)*m
        rounds = k // (m-1)
        remainder = k % (m-1)
        if rounds % 2 == 0:
            print(n-rounds, 2+remainder)
        else:
            print(n-rounds, m-1-remainder)

solve()","
def solve():
    n, m, k = map(int, input().split())
    x = min(n-1, k // (m-1) + 1)
    y = 2 if x % 2 == 1 else 1
    if x % 2 == 0:
        y = m - 1 - k % (m-1)
    else:
        y = 2 + k % (m-1)
    print(x, y)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    col = k // n
    row = k % n
    if col % 2 == 0:
        print(1, col + 1)
    else:
        print(n - row + 1, col + 1)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    row = 1 + (k // (m-1)*2 if k % (m-1) != 0 else 0)
    col = 2 if (row % 2 == 0) else 1 + (k % (m-1) if row % 4 == 0 else m - (k % (m-1)))
    print(row, col)

solve()
 "," python
def solve():
    n, m, k = map(int, input().split())
    col = k // n
    if col % 2 == 0:
        row = k % n + 1
    else:
        row = n - k % n
    print(row, col + 1)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    if k < n:
        print(1, k + 1)
    else:
        row = 1 + (k - n) // (m - 1) if ((k - n) % (m - 1) == 0) else n - ((k - n) // (m - 1))
        col = 2 if row % 2 == n % 2 else m - 1
        print(row, col)

solve()","
def solve():
    n, m, k = map(int, input().split())
    
    # Calculate current row and column based on k
    if k < n:
        print(k + 1, 1)
    else:
        row = (k - n) // (m - 1)
        col = 2 if (row % 2) == 0 else m
        if row % 2 == 0:
            col += (k - n) % (m - 1)
        else:
            col -= (k - n) % (m - 1)
        print(n - row, col)

solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    if k < n:
        print(1, 1 + k)
    else:
        row = 2 + (k - n) // (m - 1)
        col = 2 if row % 2 == 0 else m - 1 - (k - n) % (m - 1)
        print(row, col)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    x = (k // (m - 1)) * 2 + 1
    y = k % (m - 1) + 2
    if x > n:
        x = n - x + 1
        y = m - y + 1
    print(x, y)

solve()
","6.666666666666667","26.666666666666668","6.666666666666667","0.0","6.666666666666667","46.666666666666664","26.666666666666668","13.333333333333334","0.0","6.666666666666667","0.0","0.0","20.0","100.0","13.333333333333334","0.0","","","","","","","","","","","","","","","",""
"APPS/156","
QUESTION:
Today, Osama gave Fadi an integer $X$, and Fadi was wondering about the minimum possible value of $max(a, b)$ such that $LCM(a, b)$ equals $X$. Both $a$ and $b$ should be positive integers.

$LCM(a, b)$ is the smallest positive integer that is divisible by both $a$ and $b$. For example, $LCM(6, 8) = 24$, $LCM(4, 12) = 12$, $LCM(2, 3) = 6$.

Of course, Fadi immediately knew the answer. Can you be just like Fadi and find any such pair?


-----Input-----

The first and only line contains an integer $X$ ($1 \le X \le 10^{12}$).


-----Output-----

Print two positive integers, $a$ and $b$, such that the value of $max(a, b)$ is minimum possible and $LCM(a, b)$ equals $X$. If there are several possible such pairs, you can print any.


-----Examples-----
Input
2

Output
1 2

Input
6

Output
2 3

Input
4

Output
1 4

Input
1

Output
1 1
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    X = int(input())
    
    a = 1
    b = X
    
    for i in range(2, int(X**0.5) + 1):
        if X % i == 0:
            a = i
            b = X // i
            break
    
    print(a, b)

solve()
","
def solve():
    import math
    
    X = int(input())
    a = 1
    
    while X % a != 0:
        a += 1

    b = X // a
    print(a, b)

solve()
","
from math import gcd

def solve():
    X = int(input())
    
    a = 1
    b = X
    
    for i in range(2, int(X ** 0.5) + 1):
        if X % i == 0:
            if gcd(i, X // i) == 1:
                a = i
                b = X // i
                break
    
    print(a, b)

solve()
","
from math import gcd

def solve():
    X = int(input())
    
    a = 1
    for b in range(2, X+1):
        if X % b == 0:
            a = X // b
            break
    
    print(a, b)

solve()
","
import math

def solve():
    X = int(input())
    
    a = 1
    b = X
    
    for i in range(2, int(math.sqrt(X)) + 1):
        if X % i == 0:
            a = i
            b = X // i
            break
    
    print(a, b)

solve()
","
from math import gcd

def solve():
    X = int(input())
    
    for i in range(1, int(X ** 0.5) + 1):
        if X % i == 0:
            j = X // i
            if gcd(i, j) == 1:
                print(i, j)
                break

solve()
  ","
from math import gcd

def solve():
    X = int(input())
    a = 1
    b = X
    for i in range(2, int(X**0.5) + 1):
        if X % i == 0:
            if gcd(i, X//i) == 1:  # finding coprime pairs
                a = i
                b = X//i
                break
    print(a, b)

solve()
","
from math import gcd

def solve():
    X = int(input())
    a = 1
    b = X
    for i in range(1, int(X ** 0.5) + 1):
        if X % i == 0 and gcd(i, X // i) == 1:
            a = i
            b = X // i
    print(a, b)

solve()
","
from math import gcd

def solve():
    X = int(input())
    a = 1
    while True:
        b = X // a
        if X % a == 0 and gcd(a, b) == 1:
            print(a, b)
            break
        a += 1


solve()","
from math import gcd

def solve():
    X = int(input())
    
    a = 1
    while gcd(a, X) != 1:
        a += 1
    
    b = X // a
    
    print(a, b)

solve()
","
def solve():
    from math import gcd

    X = int(input())

    a = 1
    b = X

    for i in range(1, int(X**0.5) + 1):
        if X % i == 0 and gcd(i, X//i) == 1:
            a = i
            b = X // i

    print(a, b)

solve()
","
from math import gcd

def solve():
    X = int(input())

    for a in range(1, int(X**0.5)+1):
        if X % a == 0:
            b = X // a
            if gcd(a, b) == 1:
                print(a, b)
                return

        # If a is not divisor of X, try X//a
        if X % (X // a) == 0:
            a = X // a
            b = X // a
            if gcd(a, b) == 1:
                print(a, b)
                return

solve()
","
def solve():
    from math import gcd

    x = int(input())
    if x == 1:
        print(1, 1)
    else:
        a = 1
        b = x
        for i in range(2, int((x)**0.5) + 1):
            if x % i == 0:
                a = i
                b = x//i
                break
        print(a, b)

solve()
","
from math import gcd

def solve():
    X = int(input())
    a = 1
    b = X
    for i in range(1, int(X**0.5) + 1):
        if X % i == 0:
            j = X // i
            if gcd(i, j) == 1:
                a = i
                b = j
                break
    print(a, b)

solve()
  ","
from math import gcd

def solve():
    X = int(input())
    
    a = 1
    b = X
    
    for i in range(2, int(X**0.5) + 1):
        if X % i == 0 and gcd(i, X//i) == 1:
            a = i
            b = X // i
            break
    
    print(a, b)

solve()
  ","
from math import gcd

def solve():
    X = int(input())
    a = 1
    b = X
    for i in range(2, int(X ** 0.5) + 1):
        if X % i == 0:
            a = i
            b = X // i
            break
    print(a, b)

solve()
","33.33333333333333","40.0","60.0","7.142857142857142","33.33333333333333","40.0","60.0","80.0","40.0","40.0","80.0","40.0","33.33333333333333","40.0","60.0","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/157","
QUESTION:
Nikolay has a lemons, b apples and c pears. He decided to cook a compote. According to the recipe the fruits should be in the ratio 1: 2: 4. It means that for each lemon in the compote should be exactly 2 apples and exactly 4 pears. You can't crumble up, break up or cut these fruits into pieces. These fruits — lemons, apples and pears — should be put in the compote as whole fruits.

Your task is to determine the maximum total number of lemons, apples and pears from which Nikolay can cook the compote. It is possible that Nikolay can't use any fruits, in this case print 0. 


-----Input-----

The first line contains the positive integer a (1 ≤ a ≤ 1000) — the number of lemons Nikolay has. 

The second line contains the positive integer b (1 ≤ b ≤ 1000) — the number of apples Nikolay has. 

The third line contains the positive integer c (1 ≤ c ≤ 1000) — the number of pears Nikolay has.


-----Output-----

Print the maximum total number of lemons, apples and pears from which Nikolay can cook the compote.


-----Examples-----
Input
2
5
7

Output
7

Input
4
7
13

Output
21

Input
2
3
2

Output
0



-----Note-----

In the first example Nikolay can use 1 lemon, 2 apples and 4 pears, so the answer is 1 + 2 + 4 = 7.

In the second example Nikolay can use 3 lemons, 6 apples and 12 pears, so the answer is 3 + 6 + 12 = 21.

In the third example Nikolay don't have enough pears to cook any compote, so the answer is 0.
Use user-input-Based format and function signature solve()","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_lemons = min(a, b // 2, c // 4)
    
    total_fruits = max_lemons + 2 * max_lemons + 4 * max_lemons
    
    print(total_fruits)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    total_lemons = min(a, b//2, c//4)
    total_apples = total_lemons * 2
    total_pears = total_lemons * 4
    
    print(total_lemons + total_apples + total_pears)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    lemons = min(a, b // 2, c // 4)
    apples = lemons * 2
    pears = lemons * 4
    
    total_fruits = lemons + apples + pears
    
    print(total_fruits)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    lemons = min(a, b//2, c//4)
    compote_total = lemons + 2*lemons + 4*lemons
    print(compote_total)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())

    total_lemons = min(a, b//2, c//4)
    max_fruits = total_lemons*7

    return max_fruits

solve()","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())

    min_ratio = min(a // 1, b // 2, c // 4)
    total = min_ratio * (1 + 2 + 4)

    print(total)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_lemons = min(a, b // 2, c // 4)
    
    return max_lemons * 7


solve()","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    lemons = min(a, b//2, c//4)
    total = lemons + (2 * lemons) + (4 * lemons)
    
    print(total)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_lemons = min(a, b // 2, c // 4)
    max_apples = 2 * max_lemons
    max_pears = 4 * max_lemons
    
    total_fruits = max_lemons + max_apples + max_pears
    print(total_fruits)

solve()
","
def solve():
    lemons = int(input())
    apples = int(input())
    pears = int(input())

    max_lemons = min(min(lemons, apples // 2), pears // 4)

    total_fruits = 7 * max_lemons
    print(total_fruits)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    # Calculate the maximum total number of fruits that can be used for the compote
    min_ratio = min(a // 1, b // 2, c // 4)
    total_fruits = min_ratio * (1 + 2 + 4)
    
    print(total_fruits)

solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    total_lemons = min(a, b // 2, c // 4)
    
    return total_lemons * 7


solve()","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_lemons = min(a, b // 2, c // 4)
    
    total_fruits = max_lemons + 2 * max_lemons + 4 * max_lemons
    print(total_fruits)

solve()
  ","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())

    max_lemons = min(a, b // 2, c // 4)

    total_fruits = max_lemons + max_lemons * 2 + max_lemons * 4
    print(total_fruits)

# Call the function to execute the solution
solve()
","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())

    max_lemons = min(a, b//2, c//4)  # Calculate the maximum number of lemons based on the ratio
    total_fruits = max_lemons * 7  # Calculate the total number of fruits in the compote
    print(total_fruits)


solve()","
def solve():
    a = int(input())
    b = int(input())
    c = int(input())
    
    lemon_ratio = 1
    apple_ratio = 2
    pear_ratio = 4
    
    max_lemons = min(a, b//apple_ratio, c//pear_ratio)
    
    total_fruits = max_lemons * (lemon_ratio + apple_ratio + pear_ratio)
    
    print(total_fruits)

solve()
","100.0","100.0","100.0","100.0","0.0","100.0","0.0","100.0","100.0","100.0","100.0","0.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/158","
QUESTION:
Berland annual chess tournament is coming!

Organizers have gathered 2·n chess players who should be divided into two teams with n people each. The first team is sponsored by BerOil and the second team is sponsored by BerMobile. Obviously, organizers should guarantee the win for the team of BerOil.

Thus, organizers should divide all 2·n players into two teams with n people each in such a way that the first team always wins.

Every chess player has its rating r_{i}. It is known that chess player with the greater rating always wins the player with the lower rating. If their ratings are equal then any of the players can win.

After teams assignment there will come a drawing to form n pairs of opponents: in each pair there is a player from the first team and a player from the second team. Every chess player should be in exactly one pair. Every pair plays once. The drawing is totally random.

Is it possible to divide all 2·n players into two teams with n people each so that the player from the first team in every pair wins regardless of the results of the drawing?


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 100).

The second line contains 2·n integers a_1, a_2, ... a_2n (1 ≤ a_{i} ≤ 1000).


-----Output-----

If it's possible to divide all 2·n players into two teams with n people each so that the player from the first team in every pair wins regardless of the results of the drawing, then print ""YES"". Otherwise print ""NO"".


-----Examples-----
Input
2
1 3 2 4

Output
YES

Input
1
3 3

Output
NO
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    ratings.sort()
    
    team1 = ratings[:n]
    team2 = ratings[n:]
    
    if max(team1) < min(team2):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))

    ratings.sort()

    team1 = ratings[:n]
    team2 = ratings[n:]

    if max(team1) < min(team2):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    ratings.sort()
    
    team1 = ratings[:n]
    team2 = ratings[n:]
    
    if team1[-1] < team2[0]:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    ratings.sort()
    team1 = ratings[:n]
    team2 = ratings[n:]
    
    if team1[-1] < team2[0]:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    
    ratings.sort()
    first_team = ratings[:n]
    second_team = ratings[n:]
    
    if first_team[n-1] < second_team[0]:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))

    ratings.sort()

    for i in range(n):
        if ratings[i] >= ratings[i + n]:
            return ""NO""
    
    return ""YES""

solve()","
def solve():
    from collections import Counter
  
    n = int(input())
    ratings = list(map(int, input().split()))

    ratings.sort()

    team1 = ratings[:n]
    team2 = ratings[n:]

    if max(team1) < min(team2):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    
    ratings.sort()
    team1 = ratings[:n]
    team2 = ratings[n:]
    
    if max(team1) < min(team2):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort()
    half = len(a) // 2
    
    if a[:half] == a[half:]:
        print(""NO"")
    else:
        print(""YES"")

solve()
","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    ratings.sort()
    team1 = ratings[:n]
    team2 = ratings[n:]
    
    for i in range(n):
        if team1[i] >= team2[i]:
            print(""NO"")
            return
    
    print(""YES"")

solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))

    ratings.sort()

    half = len(ratings) // 2
    if ratings[half-1] < ratings[half]:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    ratings.sort()
    
    first_team = ratings[:n]
    second_team = ratings[n:]
    
    if max(first_team) < min(second_team):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    ratings.sort()
    
    first_team = ratings[:n]
    second_team = ratings[n:]
    
    for i in range(n):
        if first_team[i] >= second_team[i]:
            return ""NO""
    
    return ""YES""

solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))

    ratings.sort()

    if ratings[n-1] < ratings[n]:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
from collections import Counter

def solve():
    n = int(input())
    ratings = list(map(int, input().split()))

    ratings.sort()

    team1 = ratings[:n]
    team2 = ratings[n:]

    if all(player1 > player2 for player1, player2 in zip(team1, team2)):
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n = int(input())
    ratings = list(map(int, input().split()))
    ratings.sort()
    
    if ratings[n-1] == ratings[n]:
        print(""NO"")
    else:
        print(""YES"")
  
solve()","100.0","100.0","100.0","100.0","100.0","0.0","100.0","100.0","60.0","80.0","100.0","100.0","0.0","100.0","60.0","100.0","","","","","","","","","","","","","","","",""
"APPS/159","
QUESTION:
You are given an array of n elements, you must make it a co-prime array in as few moves as possible.

In each move you can insert any positive integral number you want not greater than 10^9 in any place in the array.

An array is co-prime if any two adjacent numbers of it are co-prime.

In the number theory, two integers a and b are said to be co-prime if the only positive integer that divides both of them is 1.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 1000) — the number of elements in the given array.

The second line contains n integers a_{i} (1 ≤ a_{i} ≤ 10^9) — the elements of the array a.


-----Output-----

Print integer k on the first line — the least number of elements needed to add to the array a to make it co-prime.

The second line should contain n + k integers a_{j} — the elements of the array a after adding k elements to it. Note that the new array should be co-prime, so any two adjacent values should be co-prime. Also the new array should be got from the original array a by adding k elements to it.

If there are multiple answers you can print any one of them.


-----Example-----
Input
3
2 7 28

Output
1
2 7 9 28
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    k = 0
    new_array = [a[0]]
    
    for i in range(1, n):
        if gcd(new_array[-1], a[i]) != 1:
            k += 1
            new_array.append(1)
        new_array.append(a[i])
    
    print(k)
    print(' '.join(map(str, new_array)))

solve()
","
from math import gcd

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    k = 0
    new_arr = [arr[0]]
    
    for i in range(1, n):
        if gcd(arr[i-1], arr[i]) != 1:
            k += 1
            new_arr.append(1)
        new_arr.append(arr[i])
    
    print(k)
    print("" "".join(map(str, new_arr)))

solve()
","
import math

def solve():
    n = int(input())
    a = list(map(int, input().split()))

    def is_coprime(x, y):
        return math.gcd(x, y) == 1

    k = 0
    result = []

    for i in range(n-1):
        result.append(a[i])

        if not is_coprime(a[i], a[i+1]):
            k += 1
            gcd = math.gcd(a[i], a[i+1])
            result.append(gcd+1)

    result.append(a[n-1])

    print(k)
    print(*result)

# Example
solve()
","
def solve():
    import math

    n = int(input())
    a = list(map(int, input().split()))

    def is_coprime(x, y):
        return math.gcd(x, y) == 1

    additional_elements = []
    for i in range(n - 1):
        if not is_coprime(a[i], a[i + 1]):
            gcd = math.gcd(a[i], a[i + 1])
            additional_elements.append(gcd + 1)

    print(len(additional_elements))
    result = [a[0]]
    for i in range(len(additional_elements)):
        result.extend([additional_elements[i], a[i + 1]])

    print(' '.join(map(str, result)))

solve()
  ","
from math import gcd

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    def is_coprime(x, y):
        return gcd(x, y) == 1
    
    result = []
    for i in range(n-1):
        result.append(a[i])
        if not is_coprime(a[i], a[i+1]):
            result.append(1)
    
    result.append(a[-1])
    
    print(len(result) - n)
    print(*result)

solve()
","
import math

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    k = 0
    result = [a[0]]
    
    for i in range(1, n):
        if math.gcd(result[-1], a[i]) != 1:
            k += 1
            result.append(1)
        result.append(a[i])
    
    print(k)
    print(' '.join(map(str, result)))

solve()
","
def solve():
    # Import needed libraries
    import math

    # Read input
    n = int(input())
    arr = list(map(int, input().split()))

    new_arr = []
    k = 0

    # Function to check if two numbers are coprime
    def are_coprime(a, b):
        return math.gcd(a, b) == 1

    for i in range(n - 1):
        new_arr.append(arr[i])
        if not are_coprime(arr[i], arr[i + 1]):
            k += 1
            new_arr.append(1)

    new_arr.append(arr[n - 1])

    # Print output
    print(k)
    print(*new_arr)

  
solve()","
from math import gcd

def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    k = 0
    new_arr = [arr[0]]

    for i in range(1, n):
        if gcd(arr[i], new_arr[-1]) != 1:
            k += 1
            new_arr.append(1)
        new_arr.append(arr[i])

    print(k)
    print(' '.join(map(str, new_arr)))

solve()","
from math import gcd

def solve():
    n = int(input())
    a = list(map(int, input().split()))

    res = []
    for i in range(n - 1):
        res.append(a[i])
        if gcd(a[i], a[i + 1]) != 1:
            res.append(1)

    res.append(a[-1])

    k = len(res) - n
    print(k)
    print(*res)

solve()","
from math import gcd

def solve():
    n = int(input())
    a = list(map(int, input().split()))

    k = 0
    new_array = [a[0]]
    for i in range(1, n):
        if gcd(new_array[-1], a[i]) != 1:
            k += 1
            new_array.append(1)
        new_array.append(a[i])

    print(k)
    print(' '.join(map(str, new_array)))

solve()
  ","
import math

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    k = 0
    new_array = [a[0]]
    
    for i in range(1, n):
        if math.gcd(new_array[-1], a[i]) != 1:
            k += 1
            new_array.append(1)
        new_array.append(a[i])
    
    print(k)
    print(' '.join(map(str, new_array)))


solve()","
import math

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    def is_coprime(x, y):
        return math.gcd(x, y) == 1
    
    new_array = [a[0]]
    needed_elements = 0
    
    for i in range(1, n):
        if not is_coprime(new_array[-1], a[i]):
            needed_elements += 1
            new_array.append(1)
        new_array.append(a[i])
    
    print(needed_elements)
    print(' '.join(map(str, new_array)))

solve()
","
from math import gcd

def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    k = 0
    new_arr = [arr[0]]
    for i in range(1, n):
        if gcd(new_arr[-1], arr[i]) != 1:
            k += 1
            new_arr.append(1)
        new_arr.append(arr[i])
    
    print(k)
    print(*new_arr)

solve()
","
from math import gcd

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    def is_coprime(x, y):
        return gcd(x, y) == 1
        
    result = []
    for i in range(n-1):
        result.append(a[i])
        if not is_coprime(a[i], a[i+1]):
            result.append(1)
    
    result.append(a[n-1])
    
    print(len(result) - n)
    print(*result)

solve()
","
def solve():
    import math

    def is_coprime(a, b):
        return math.gcd(a, b) == 1

    n = int(input())
    arr = list(map(int, input().split()))

    k = 0
    res = [arr[0]]
    for i in range(1, n):
        while not is_coprime(res[-1], arr[i]):
            k += 1
            res.append(1)
        res.append(arr[i])

    print(k)
    print(*res)


solve()","
from math import gcd

def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    k = 0
    new_arr = [arr[0]]

    for i in range(1, n):
        if gcd(arr[i-1], arr[i]) != 1:
            k += 1
            new_arr.append(1)
        new_arr.append(arr[i])

    print(k)
    print(*new_arr)

solve()
","100.0","100.0","33.33333333333333","20.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/160","
QUESTION:
We have a sequence of N integers: A_1, A_2, \cdots, A_N.
You can perform the following operation between 0 and K times (inclusive):
 - Choose two integers i and j such that i \neq j, each between 1 and N (inclusive). Add 1 to A_i and -1 to A_j, possibly producing a negative element.
Compute the maximum possible positive integer that divides every element of A after the operations. Here a positive integer x divides an integer y if and only if there exists an integer z such that y = xz.

-----Constraints-----
 - 2 \leq N \leq 500
 - 1 \leq A_i \leq 10^6
 - 0 \leq K \leq 10^9
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N K
A_1 A_2 \cdots A_{N-1} A_{N}

-----Output-----
Print the maximum possible positive integer that divides every element of A after the operations.

-----Sample Input-----
2 3
8 20

-----Sample Output-----
7

7 will divide every element of A if, for example, we perform the following operation:
 - Choose i = 2, j = 1. A becomes (7, 21).
We cannot reach the situation where 8 or greater integer divides every element of A.
Use user-input-Based format and function signature solve()","
def solve():
    import math

    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    gcd_val = A[0]
    for i in range(1, N):
        gcd_val = math.gcd(gcd_val, A[i])

    if K >= gcd_val and (K - gcd_val) % 2 == 0:
        print(gcd_val)
    else:
        print(math.gcd(gcd_val - K, gcd_val))

solve()
","
def solve():
    import math

    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    gcd_val = A[0]
    for i in range(1, N):
        gcd_val = math.gcd(gcd_val, A[i])

    result = gcd_val

    for i in range(N):
        if (K >= (A[i] - result)) and ((K - (A[i] - result)) % gcd_val == 0):
            result = max(result, result + (K - (A[i] - result)))
            
    print(result)
  
solve()","
def solve():
    import sys
    n, k = map(int, sys.stdin.readline().split())
    a = list(map(int, sys.stdin.readline().split()))
    gcd_a = a[0]
    for i in range(1, n):
        gcd_a = gcd(gcd_a, a[i])
    if k >= gcd_a and k % gcd_a == 0:
        print(gcd_a)
    else:
        print(gcd_a - k % gcd_a)

def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)

solve()
","
def solve():
    import math

    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    gcd_num = A[0]
    for i in range(1, N):
        gcd_num = math.gcd(gcd_num, A[i])

    max_gcd = 1
    for i in range(1, K + 1):
        if gcd_num % i == 0:
            max_gcd = max(max_gcd, i)

    print(max_gcd)

solve()","
from math import gcd

def solve():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    divisor = gcd(*A)
    max_possible_divisor = 1

    for a in A:
        max_possible_divisor = gcd(max_possible_divisor, a)

    return max_possible_divisor

solve()","
def solve():
    import math

    N, K = map(int, input().split())
    A = list(map(int, input().split()))
    
    gcd_value = A[0]
    for i in range(1, N):
        gcd_value = math.gcd(gcd_value, A[i])

    max_divisor = max(gcd_value, 1)
    print(max_divisor)

solve()
","
def solve():
    import math

    N, K = map(int, input().split())
    A = list(map(int, input().split()))
    
    G = A[0]
    for i in range(1, N):
        G = math.gcd(G, A[i])

    if G > max(A):
        ans = ""IMPOSSIBLE""
    else:
        ans = ""POSSIBLE""

    print(ans)


# Input reading from Standard Input
if __name__ == ""__main__"":
    solve()
","
def solve():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))
    gcd_val = A[0]
    for a in A[1:]:
        gcd_val = math.gcd(gcd_val, a)
    if K >= gcd_val and (K - gcd_val) % 2 == 0:
        print(gcd_val)
    else:
        print(math.gcd(gcd_val, max(A)))

solve()","
def solve():
    import math
    
    N, K = map(int, input().split())
    A = list(map(int, input().split()))
    
    gcd_value = A[0]
    
    for a in A:
        gcd_value = math.gcd(gcd_value, a)
    
    return gcd_value

solve()","
def solve():
    import math
    
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    gcd_val = A[0]
    for num in A[1:]:
        gcd_val = math.gcd(gcd_val, num)
    
    return gcd_val

solve()
  ","
def solve():
    import sys
    import math

    N, K = map(int, sys.stdin.readline().split())
    A = list(map(int, sys.stdin.readline().split()))

    gcd_val = A[0]
    for i in range(1, N):
        gcd_val = math.gcd(gcd_val, A[i])

    if sum(A) % gcd_val == 0 and sum(A) <= K * N:
        print(gcd_val)
    else:
        print(math.gcd(sum(A), gcd_val))

solve()
","
def solve():
    import sys

    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    gcd_val = A[0]
    for i in range(1, N):
        gcd_val = math.gcd(gcd_val, A[i])

    if K >= gcd_val and (K - gcd_val) % 2 == 0:
        print(gcd_val)
    else:
        print(math.gcd(gcd_val - K, max(A)))

if __name__ == ""__main__"":
    solve()
","
def solve():
    import math
    
    N, K = map(int, input().split())
    A = list(map(int, input().split()))
    
    gcd_val = A[0]
    for i in range(1, N):
        gcd_val = math.gcd(gcd_val, A[i])

    return gcd_val

solve()","
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def solve():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    max_num = A[0]
    for i in A[1:]:
        max_num = gcd(max_num, i)

    if max_num == 1:
        return 1

    if max_num <= max(A) and (K - sum((max(A) - a) % max_num for a in A)) % max_num == 0:
        return max_num

    return max_num

# Sample input
solve()
","
def solve():
    import sys
    input = sys.stdin.readline
    import math

    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    gcd_val = A[0]
    for i in range(1, N):
        gcd_val = math.gcd(gcd_val, A[i])

    if K >= gcd_val and (K - gcd_val) % 2 == 0:
        print(""{}"".format(gcd_val))
    else:
        print(""{}"".format(math.gcd(gcd_val - K, gcd_val)))

solve()","
def solve():
    import math
    
    N, K = map(int, input().split())
    A = list(map(int, input().split()))
    
    gcd_val = A[0]
    for i in range(1, N):
        gcd_val = math.gcd(gcd_val, A[i])
    
    if max(A) >= gcd_val:
        max_divider = math.gcd(max(A), gcd_val)
    else:
        max_divider = gcd_val
    
    print(max_divider)

solve()","6.666666666666667","6.666666666666667","6.666666666666667","7.142857142857142","0.0","6.666666666666667","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","6.666666666666667","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/161","
QUESTION:
Cat Furrier Transform is a popular algorithm among cat programmers to create longcats. As one of the greatest cat programmers ever exist, Neko wants to utilize this algorithm to create the perfect longcat.

Assume that we have a cat with a number $x$. A perfect longcat is a cat with a number equal $2^m - 1$ for some non-negative integer $m$. For example, the numbers $0$, $1$, $3$, $7$, $15$ and so on are suitable for the perfect longcats.

In the Cat Furrier Transform, the following operations can be performed on $x$:  (Operation A): you select any non-negative integer $n$ and replace $x$ with $x \oplus (2^n - 1)$, with $\oplus$ being a bitwise XOR operator. (Operation B): replace $x$ with $x + 1$. 

The first applied operation must be of type A, the second of type B, the third of type A again, and so on. Formally, if we number operations from one in the order they are executed, then odd-numbered operations must be of type A and the even-numbered operations must be of type B.

Neko wants to produce perfect longcats at industrial scale, thus for each cat Neko only wants to perform at most $40$ operations. Can you help Neko writing a transformation plan?

Note that it is not required to minimize the number of operations. You just need to use no more than $40$ operations.


-----Input-----

The only line contains a single integer $x$ ($1 \le x \le 10^6$).


-----Output-----

The first line should contain a single integer $t$ ($0 \le t \le 40$) — the number of operations to apply.

Then for each odd-numbered operation print the corresponding number $n_i$ in it. That is, print $\lceil \frac{t}{2} \rceil$ integers $n_i$ ($0 \le n_i \le 30$), denoting the replacement $x$ with $x \oplus (2^{n_i} - 1)$ in the corresponding step.

If there are multiple possible answers, you can print any of them. It is possible to show, that there is at least one answer in the constraints of this problem.


-----Examples-----
Input
39

Output
4
5 3 
Input
1

Output
0

Input
7

Output
0



-----Note-----

In the first test, one of the transforms might be as follows: $39 \to 56 \to 57 \to 62 \to 63$. Or more precisely: Pick $n = 5$. $x$ is transformed into $39 \oplus 31$, or $56$.  Increase $x$ by $1$, changing its value to $57$.  Pick $n = 3$. $x$ is transformed into $57 \oplus 7$, or $62$.  Increase $x$ by $1$, changing its value to $63 = 2^6 - 1$. 

In the second and third test, the number already satisfies the goal requirement.
Use user-input-Based format and function signature solve()","
def solve():
    x = int(input())
    operations = []
    
    if x % 2 == 1:
        operations.append(0)
    
    while x != 0:
        n = x.bit_length() - 1
        x ^= (1 << n) - 1
        operations.append(n)
        x += 1
    
    print(len(operations))
    print(*operations)

solve()","
import math

def solve():
    x = int(input())
    t = 0
    operations = []
    
    if x > 0:
        while x % 2 != 0:
            x >>= 1
            t += 1
            
        while t > 0:
            n = int(math.log2(x) + 1)
            operations.append(n)
            x ^= (1 << n) - 1
            t -= 1
            x += 1
    
    print(len(operations))
    print(*operations)
    
solve()","
def solve():
    x = int(input())
    operations = []
    if x == 1 or bin(x).count('1') == 1:
        print(0)
    else:
        count = 0
        for i in range(30):
            if x & (1 << i) == 0:
                operations.append(i)
                x ^= (1 << i) - 1
                count += 1
                if count == 20:
                    break
        print(count * 2)
        print(*operations)

solve()","
def solve():
    x = int(input())
    operations = []
    i = 0
    while x % 2 == 0:
        x //= 2
        i += 1
    if x != 1:
        operations.append(i)
        x += 1
    while x > 1:
        i = 0
        while 2 ** i <= x:
            i += 1
        i -= 1
        operations.append(i)
        x ^= (2 ** i) - 1
        x += 1
    print(len(operations))
    print(*operations)

solve()","
import math

def solve():
    x = int(input())
    operations = []
    for n in range(30, -1, -1):
        diff = (x ^ ((1 << n) - 1)) + 1 - x
        if diff > 0 and diff & (diff - 1) == 0:
            operations.append(n)
            x ^= (1 << n) - 1
            x += 1

    print(len(operations))
    for n in operations:
        print(n, end=' ')
  
solve()","
from math import ceil

def solve():
    x = int(input())
    
    operations = []
    remaining_operations = 40
    n = 0
    
    while x & (1 << n):
        n += 1
    
    while remaining_operations > 0 and x != (1 << n) - 1:
        if n > 0:
            operations.append(n)
            x ^= (1 << n) - 1
            remaining_operations -= 1
        
        x += 1
        remaining_operations -= 1
        
        n = 0
        while x & (1 << n):
            n += 1
        
    print(len(operations))
    print(*operations)
  
solve()","
def solve():
    x = int(input())
    
    if x == 1 or x & (x + 1) == 0:
        print(0)
    else:
        print(2)
        print((x + 1).bit_length() - 1, end=' ')

solve()","
import math

def solve():
    x = int(input())
    operations = []
    
    if x == 1 or (x & (x + 1)) == 0:
        print(0)
    else:
        t = 0
        while t < 40:
            if t % 2 == 0:
                t += 1
                n = int(math.log2(x + 1))
                x ^= (1 << n) - 1
                operations.append(n)
            else:
                x += 1
        print(len(operations))
        print(*operations)

solve()","
def solve():
    x = int(input())
    
    operations = []
    count = 0

    while x & (x + 1) != 0 and count < 20:
        count += 1
        msb = len(bin(x)) - 2
        n = msb - 1
        x ^= (1 << n) - 1
        operations.append(n)
        x += 1

    print(len(operations))
    print(*operations)

solve()","
def solve():
    x = int(input())
    
    if x % 2 == 1:
        print(0)
    else:
        m = 0
        while 2**m - 1 < x:
            m += 1
        m -= 1
        t = 2 * m
        print(t)
        for i in range(1, t+1, 2):
            print(m, end="" "")
        print()

solve()","
import math

def solve():
    x = int(input())
    
    operations = []
    
    while x % 2 == 0:
        x //= 2
    
    if x == 1:
        print(0)
        return
    
    cnt = 0
    while x > 0 and cnt < 40:
        max_bit = math.floor(math.log2(x))
        diff = x ^ ((1 << (max_bit + 1)) - 1)
        positions = []
        for i in range(max_bit, -1, -1):
            if x & (1 << i):
                positions.append(i)
        operations.extend(positions)
        x = diff + 1
        cnt += 2
    
    print(len(operations))
    print(*operations)

solve()","
def solve():
    x = int(input())
    
    operations = []
    
    if x > 1:
        t = 0
        for i in range(30, -1, -1):
            if x & (1 << i) == 0:
                continue
            t += 1
            x ^= (1 << (i + 1)) - 1
            if t % 2 == 1:
                operations.append(i)
                
    print(len(operations))
    print(*operations)
    
solve()
  ","
import math

def solve():
    x = int(input())
    operations = []
    
    if x == 1 or math.log2(x+1).is_integer():
        print(0)
    else:
        while len(operations) < 40:
            n = 0
            while (x+1) & (1 << n):
                n += 1
            x ^= (1 << n) - 1
            operations.append(n)
            x += 1
        print(len(operations))
        print(*operations)

solve()","
from math import ceil

def solve():
    x = int(input())
    operations = []
    
    if x == 1 or bin(x).count('1') == 1:
        print(0)
    else:
        xor_sum = 0
        while xor_sum | x + 1 <= x:
            xor_sum |= xor_sum + 1
            operations.append(bin(xor_sum)[2:].rfind('1'))
            x ^= xor_sum
            
        print(len(operations))
        for i, op in enumerate(operations):
            if i % 2 == 0:
                print(op, end=' ')
        print()

solve()","
def solve():
    x = int(input())
    operations = []

    while x % 2 == 0:
        x //= 2

    if x == 1:
        print(0)
        return

    t = 0
    while x != 0:
        if t % 2 == 0:
            bit_pos = x.bit_length() - 1
            x ^= (1 << bit_pos) - 1
            operations.append(bit_pos)
        else:
            x += 1
        t += 1

    print(t)
    for i in range(0, len(operations), 2):
        print(operations[i])

solve()","
def solve():
    x = int(input())
    operations = []
    
    if x == 1 or bin(x).count('1') == 1:
        print(0)
    else:
        t = 0
        while x & (x + 1) != 0:
            t += 1
            x = x ^ (2**((x).bit_length()) - 1)
            operations.append(x.bit_length() - 1)
            x += 1

        print(t)
        for i in range(len(operations)):
            if i % 2 == 0:
                print(operations[i])
  
solve()","0","0.0","6.666666666666667","33.33333333333333","0.0","20.0","33.33333333333333","100.0","20.0","20.0","6.666666666666667","20.0","20.0","20.0","33.33333333333333","27.27272727272727","All tests timed out","","","","","","","","","","","","","","",""
"APPS/162","
QUESTION:
Luba thinks about watering her garden. The garden can be represented as a segment of length k. Luba has got n buckets, the i-th bucket allows her to water some continuous subsegment of garden of length exactly a_{i} each hour. Luba can't water any parts of the garden that were already watered, also she can't water the ground outside the garden.

Luba has to choose one of the buckets in order to water the garden as fast as possible (as mentioned above, each hour she will water some continuous subsegment of length a_{i} if she chooses the i-th bucket). Help her to determine the minimum number of hours she has to spend watering the garden. It is guaranteed that Luba can always choose a bucket so it is possible water the garden.

See the examples for better understanding.


-----Input-----

The first line of input contains two integer numbers n and k (1 ≤ n, k ≤ 100) — the number of buckets and the length of the garden, respectively.

The second line of input contains n integer numbers a_{i} (1 ≤ a_{i} ≤ 100) — the length of the segment that can be watered by the i-th bucket in one hour.

It is guaranteed that there is at least one bucket such that it is possible to water the garden in integer number of hours using only this bucket.


-----Output-----

Print one integer number — the minimum number of hours required to water the garden.


-----Examples-----
Input
3 6
2 3 5

Output
2

Input
6 7
1 2 3 4 5 6

Output
7



-----Note-----

In the first test the best option is to choose the bucket that allows to water the segment of length 3. We can't choose the bucket that allows to water the segment of length 5 because then we can't water the whole garden.

In the second test we can choose only the bucket that allows us to water the segment of length 1.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    
    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    
    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    lengths = list(map(int, input().split()))
    
    min_hours = float('inf')
    for length in lengths:
        if k % length == 0:
            hours = k // length
            min_hours = min(min_hours, hours)
    
    print(min_hours)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    
    min_hours = float('inf')
    
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    
    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    hours = k
    for bucket in buckets:
        if k % bucket == 0:
            hours = min(hours, k // bucket)
    print(hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k//bucket)
    
    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))

    min_hours = float('inf')
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)

    print(min_hours)

solve()","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    
    hours = k
    for bucket in buckets:
        if k % bucket == 0:
            hours = min(hours, k // bucket)
    
    print(hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    
    print(min_hours)
  
solve()","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))

    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)

    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))

    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)

    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))

    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)

    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    
    print(min_hours)

solve()
","
def solve():
    n, k = map(int, input().split())
    buckets = list(map(int, input().split()))
    min_hours = k
    for bucket in buckets:
        if k % bucket == 0:
            min_hours = min(min_hours, k // bucket)
    print(min_hours)

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/163","
QUESTION:
On the way to Rio de Janeiro Ostap kills time playing with a grasshopper he took with him in a special box. Ostap builds a line of length n such that some cells of this line are empty and some contain obstacles. Then, he places his grasshopper to one of the empty cells and a small insect in another empty cell. The grasshopper wants to eat the insect.

Ostap knows that grasshopper is able to jump to any empty cell that is exactly k cells away from the current (to the left or to the right). Note that it doesn't matter whether intermediate cells are empty or not as the grasshopper makes a jump over them. For example, if k = 1 the grasshopper can jump to a neighboring cell only, and if k = 2 the grasshopper can jump over a single cell.

Your goal is to determine whether there is a sequence of jumps such that grasshopper will get from his initial position to the cell with an insect.


-----Input-----

The first line of the input contains two integers n and k (2 ≤ n ≤ 100, 1 ≤ k ≤ n - 1) — the number of cells in the line and the length of one grasshopper's jump.

The second line contains a string of length n consisting of characters '.', '#', 'G' and 'T'. Character '.' means that the corresponding cell is empty, character '#' means that the corresponding cell contains an obstacle and grasshopper can't jump there. Character 'G' means that the grasshopper starts at this position and, finally, 'T' means that the target insect is located at this cell. It's guaranteed that characters 'G' and 'T' appear in this line exactly once.


-----Output-----

If there exists a sequence of jumps (each jump of length k), such that the grasshopper can get from his initial position to the cell with the insect, print ""YES"" (without quotes) in the only line of the input. Otherwise, print ""NO"" (without quotes).


-----Examples-----
Input
5 2
#G#T#

Output
YES

Input
6 1
T....G

Output
YES

Input
7 3
T..#..G

Output
NO

Input
6 2
..GT..

Output
NO



-----Note-----

In the first sample, the grasshopper can make one jump to the right in order to get from cell 2 to cell 4.

In the second sample, the grasshopper is only able to jump to neighboring cells but the way to the insect is free — he can get there by jumping left 5 times.

In the third sample, the grasshopper can't make a single jump.

In the fourth sample, the grasshopper can only jump to the cells with odd indices, thus he won't be able to reach the insect.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    line = input().strip()

    grasshopper_idx = line.index('G')
    insect_idx = line.index('T')

    if (insect_idx - grasshopper_idx) % k == 0:
        if (insect_idx - grasshopper_idx) * (insect_idx > grasshopper_idx) > 0:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    line = input().strip()

    grasshopper_pos = line.index('G')
    insect_pos = line.index('T')

    if (insect_pos - grasshopper_pos) % k == 0:
        if (insect_pos - grasshopper_pos) // k > 0 and all(cell != '#' for cell in line[min(grasshopper_pos, insect_pos) + k:max(grasshopper_pos, insect_pos):k]):
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    line = input().strip()
    
    grasshopper_pos = line.index('G')
    insect_pos = line.index('T')
    
    if (grasshopper_pos < insect_pos and (insect_pos - grasshopper_pos) % k == 0) or (grasshopper_pos > insect_pos and (grasshopper_pos - insect_pos) % k == 0):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    line = input().strip()

    grasshopper_idx = line.index('G')
    insect_idx = line.index('T')

    if (insect_idx - grasshopper_idx) % k == 0:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    line = input().strip()

    grasshopper_index = line.index('G')
    insect_index = line.index('T')

    if (insect_index - grasshopper_index) % k == 0 and (insect_index - grasshopper_index) * (k / abs(k)) > 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    line = input().strip()

    grasshopper_idx = line.index('G')
    insect_idx = line.index('T')

    if (insect_idx - grasshopper_idx) % k == 0:
        if any(line[i] == 'T' and i % k == insect_idx % k for i in range(grasshopper_idx, n, k)):
            print(""YES"")
            return

    print(""NO"")

solve()
  ","
def solve():
    n, k = map(int, input().split())
    line = input()
    grasshopper_idx = line.index('G')
    insect_idx = line.index('T')

    if abs(grasshopper_idx - insect_idx) % k == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    cells = input().strip()
    
    grasshopper_idx = cells.index('G')
    insect_idx = cells.index('T')
    
    if (insect_idx - grasshopper_idx) % k == 0:
        if (insect_idx - grasshopper_idx) * (insect_idx - grasshopper_idx) // k <= n - 2:
            print(""YES"")
            return
    print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, k = map(int, input().split())
    line = input().strip()
    
    grasshopper_pos = line.index('G')
    insect_pos = line.index('T')
    
    if abs(grasshopper_pos - insect_pos) % k == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    line = input()

    grasshopper_pos = line.index('G')
    insect_pos = line.index('T')

    if (insect_pos - grasshopper_pos) % k == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    line = input()
    grasshopper_index = line.index('G')
    insect_index = line.index('T')

    if (insect_index - grasshopper_index) % k == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    line = input()

    grasshopper_pos = line.index('G')
    insect_pos = line.index('T')

    if ((insect_pos - grasshopper_pos) % k == 0 or (grasshopper_pos - insect_pos) % k == 0) and not any(line[min(grasshopper_pos, insect_pos) + i*k] == '#' for i in range(1, abs(insect_pos - grasshopper_pos) // k)):
        print(""YES"")
    else:
        print(""NO"")

# Do not forget to call the solve() function.
    
solve()","
def solve():
    n, k = map(int, input().split())
    line = input()
    
    grasshopper_index = line.index('G')
    insect_index = line.index('T')
    
    if abs(grasshopper_index - insect_index) % k == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    line = input()

    grasshopper_pos = line.index('G')
    insect_pos = line.index('T')

    if (abs(grasshopper_pos - insect_pos) % k == 0):
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n, k = map(int, input().split())
    line = input()
    
    g_pos = line.index('G')
    t_pos = line.index('T')

    if (g_pos < t_pos and (t_pos - g_pos) % k == 0) or (g_pos > t_pos and (g_pos - t_pos) % k == 0):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    line = input()

    grasshopper_pos = line.index('G')
    insect_pos = line.index('T')

    if (insect_pos - grasshopper_pos) % k == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","66.66666666666666","80.0","80.0","80.0","66.66666666666666","66.66666666666666","80.0","53.333333333333336","80.0","80.0","80.0","100.0","80.0","80.0","80.0","80.0","","","","","","","","","","","","","","","",""
"APPS/164","
QUESTION:
It's a beautiful April day and Wallace is playing football with his friends. But his friends do not know that Wallace actually stayed home with Gromit and sent them his robotic self instead. Robo-Wallace has several advantages over the other guys. For example, he can hit the ball directly to the specified point. And yet, the notion of a giveaway is foreign to him. The combination of these features makes the Robo-Wallace the perfect footballer — as soon as the ball gets to him, he can just aim and hit the goal. He followed this tactics in the first half of the match, but he hit the goal rarely. The opposing team has a very good goalkeeper who catches most of the balls that fly directly into the goal. But Robo-Wallace is a quick thinker, he realized that he can cheat the goalkeeper. After all, they are playing in a football box with solid walls. Robo-Wallace can kick the ball to the other side, then the goalkeeper will not try to catch the ball. Then, if the ball bounces off the wall and flies into the goal, the goal will at last be scored.

Your task is to help Robo-Wallace to detect a spot on the wall of the football box, to which the robot should kick the ball, so that the ball bounces once and only once off this wall and goes straight to the goal. In the first half of the match Robo-Wallace got a ball in the head and was severely hit. As a result, some of the schemes have been damaged. Because of the damage, Robo-Wallace can only aim to his right wall (Robo-Wallace is standing with his face to the opposing team's goal).

The football box is rectangular. Let's introduce a two-dimensional coordinate system so that point (0, 0) lies in the lower left corner of the field, if you look at the box above. Robo-Wallace is playing for the team, whose goal is to the right. It is an improvised football field, so the gate of Robo-Wallace's rivals may be not in the middle of the left wall. [Image] 

In the given coordinate system you are given:   y_1, y_2 — the y-coordinates of the side pillars of the goalposts of robo-Wallace's opponents;  y_{w} — the y-coordinate of the wall to which Robo-Wallace is aiming;  x_{b}, y_{b} — the coordinates of the ball's position when it is hit;  r — the radius of the ball. 

A goal is scored when the center of the ball crosses the OY axis in the given coordinate system between (0, y_1) and (0, y_2). The ball moves along a straight line. The ball's hit on the wall is perfectly elastic (the ball does not shrink from the hit), the angle of incidence equals the angle of reflection. If the ball bounces off the wall not to the goal, that is, if it hits the other wall or the goal post, then the opposing team catches the ball and Robo-Wallace starts looking for miscalculation and gets dysfunctional. Such an outcome, if possible, should be avoided. We assume that the ball touches an object, if the distance from the center of the ball to the object is no greater than the ball radius r.


-----Input-----

The first and the single line contains integers y_1, y_2, y_{w}, x_{b}, y_{b}, r (1 ≤ y_1, y_2, y_{w}, x_{b}, y_{b} ≤ 10^6; y_1 < y_2 < y_{w}; y_{b} + r < y_{w}; 2·r < y_2 - y_1).

It is guaranteed that the ball is positioned correctly in the field, doesn't cross any wall, doesn't touch the wall that Robo-Wallace is aiming at. The goal posts can't be located in the field corners.


-----Output-----

If Robo-Wallace can't score a goal in the described manner, print ""-1"" (without the quotes). Otherwise, print a single number x_{w} — the abscissa of his point of aiming. 

If there are multiple points of aiming, print the abscissa of any of them. When checking the correctness of the answer, all comparisons are made with the permissible absolute error, equal to 10^{ - 8}. 

It is recommended to print as many characters after the decimal point as possible.


-----Examples-----
Input
4 10 13 10 3 1

Output
4.3750000000

Input
1 4 6 2 2 1

Output
-1

Input
3 10 15 17 9 2

Output
11.3333333333



-----Note-----

Note that in the first and third samples other correct values of abscissa x_{w} are also possible.
Use user-input-Based format and function signature solve()","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    if yb - r <= y1 or yb + r >= y2:
        print(""-1"")
    else:
        xw = xb + (xb * (yw - yb - r)) / (2 * (yb - r))
        print(""{:.10f}"".format(xw))

solve()
","
def solve():
    import math
    
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    target = ((2*yw - yb)*xb) / (2*yb - yw)
    
    xw = 2*target - xb
    print(""{:.10f}"".format(xw))


solve()","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    if yb - r <= y1 or yb + r >= y2:
        print(""-1"")
    else:
        h1 = yw - yb
        h2 = yb - y1

        a = (xb * h1 + h2 * r) / (h1 + r)
        print(""{:.10f}"".format(a))

solve()
","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())

    if yb - r <= y1 or yb + r >= y2:
        print(""-1"")
    else:
        alpha = (yw - yb) / (xb)
        xw = xb + 2 * (y2 - yb - r) / alpha
        print(""{:.10f}"".format(xw))

solve()
  ","
def solve():
    # Importing necessary libraries
    import math
    
    # Reading input values
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    # Calculating the intersection point
    xw = xb + (xb / (yw - yb - r)) * (yw - y2)
    
    # Checking if the intersection point is valid
    if xw <= r or xw >= xb:
        print(-1)
    else:
        print(""{:.10f}"".format(xw))

# Calling the function to solve the problem
solve()
","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())

    if y1 + r < yb <= yw - r:
        print(xb)
        return

    wy = min(yw - r, y2 - r)
    ab = yb - r
    k = (xb / (yb - ab)) * ((yw - ab) / (yw - 2 * yb + ab))
    xw = (k * xb + xb) / (1 - k)

    if yb > yw - r:
        if xw < 0 or xw > xb:
            print(-1)
        else:
            print(""{:.10f}"".format(xw))
    else:
        if xw < 0 or xw > xb or xw < r or xw > xb - r:
            print(-1)
        else:
            print(""{:.10f}"".format(xw))

solve()","
def solve():
    # Importing needed libraries
    from math import sqrt

    # Reading input
    y1, y2, yw, xb, yb, r = map(int, input().split())

    # Calculating the potential x coordinate of the wall where the ball should bounce
    bw = xb + (xb*(yw-yb-r))/(yw-yb)

    # Checking if the ball will bounce within the goalposts
    if y1 < bw < y2:
        print(f""{bw:.10f}"")
    else:
        print(""-1"")

# Calling the function to solve the problem
solve()
","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    if yb > yw - r - r or xb - r <= 0:
        print(-1)
    else:
        xw = ((r * (xb - r)) + (1.0 * r * r)) / (1.0 * yb - r)
        print('{:.10f}'.format(xw))

solve()
","
from math import acos, cos, sin, pi

def solve(y1, y2, yw, xb, yb, r):
    def check_intersection(xw):
        if xw <= r or xw >= xb - r:
            return False
        alpha = acos((xb - xw) / ((xb - xw)**2 + (yb - yw)**2)**0.5)
        beta = acos((xb - xw) / r)
        if alpha + beta >= pi/2:
            return False
        y_intercept = yw + (xw - xb) * (yw - yb) / (xb - xw)
        return y1 + r < y_intercept < y2 - r

    xw = -1
    for i in range(1, xb):
        if check_intersection(i):
            xw = i
            break
    return f""{xw:.10f}"" if xw != -1 else ""-1""

solve()","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())

    if yb == y1 or yb == y2:
        print(""-1"")
        return

    h = yw - y1 - r
    d = (yb - y1) / (yw - yb)

    xw = xb + (2 * d * (h - r)) / (1 - d)

    print(""{:.10f}"".format(xw))

solve()
","
def solve():
    import math
    
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    a = yw - yb
    b = xb
    c = math.sqrt(a**2 + b**2)
    
    if c <= r:
        print(-1)
    else:
        d = (a*y2 - a*y1 + b*r) / (y2 - y1)
        xw = xb + (d - xb) * (r/c)
        print('{:.10f}'.format(xw))

solve()","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    if yb - r <= y1 or yb + r >= y2:
        print(""-1"")
        return
    
    xw = xb * (yw - yb + r) / (2 * yw - yb - r)
    print(""{:.10f}"".format(xw))

solve()
","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())

    if yw - y2 < 2*r or yb + r >= yw:
        print(-1)
    else:
        xw = xb * (yw - yb - r) / (yb - y1) 
        print(""{:.10f}"".format(xw))

solve()
","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    if yb + r >= yw - r:
        print(""-1"")
    else:
        y_goal = (y1 + y2) / 2
        y_mid = (yb * 2 + yw) / 3
        
        xw = xb + (y_goal - y_mid) * (xb - yb) / (yb - yw)
        
        print(""{:.10f}"".format(xw))

solve()
","
def solve():
    y1, y2, yw, xb, yb, r = map(int, input().split())
    
    if yb - r > y1 and yb + r < y2:
        xw = xb * (yw - yb) / (2 * yb - yw)
        print(""{:.10f}"".format(xw))
    else:
        print(-1)

solve()
","
def solve():
    # Input
    y1, y2, yw, xb, yb, r = map(int, input().split())

    # Calculate the potential x coordinate for kicking the ball
    delta_y = yw - yb - r
    delta_x = xb * delta_y / (2 * yb + delta_y)

    # Check if the ball can score a goal
    if delta_x <= r or delta_x >= xb - r:
        print(-1)
    else:
        print('{:.10f}'.format(delta_x))

# Call the function to run the program
solve()
","33.33333333333333","0.0","33.33333333333333","33.33333333333333","33.33333333333333","33.33333333333333","20.0","6.666666666666667","0.0","0.0","0.0","33.33333333333333","13.333333333333334","0.0","33.33333333333333","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/165","
QUESTION:
Vasiliy spent his vacation in a sanatorium, came back and found that he completely forgot details of his vacation! 

Every day there was a breakfast, a dinner and a supper in a dining room of the sanatorium (of course, in this order). The only thing that Vasiliy has now is a card from the dining room contaning notes how many times he had a breakfast, a dinner and a supper (thus, the card contains three integers). Vasiliy could sometimes have missed some meal, for example, he could have had a breakfast and a supper, but a dinner, or, probably, at some days he haven't been at the dining room at all.

Vasiliy doesn't remember what was the time of the day when he arrived to sanatorium (before breakfast, before dinner, before supper or after supper), and the time when he left it (before breakfast, before dinner, before supper or after supper). So he considers any of these options. After Vasiliy arrived to the sanatorium, he was there all the time until he left. Please note, that it's possible that Vasiliy left the sanatorium on the same day he arrived.

According to the notes in the card, help Vasiliy determine the minimum number of meals in the dining room that he could have missed. We shouldn't count as missed meals on the arrival day before Vasiliy's arrival and meals on the departure day after he left.


-----Input-----

The only line contains three integers b, d and s (0 ≤ b, d, s ≤ 10^18,  b + d + s ≥ 1) — the number of breakfasts, dinners and suppers which Vasiliy had during his vacation in the sanatorium. 


-----Output-----

Print single integer — the minimum possible number of meals which Vasiliy could have missed during his vacation. 


-----Examples-----
Input
3 2 1

Output
1


Input
1 0 0

Output
0


Input
1 1 1

Output
0


Input
1000000000000000000 0 1000000000000000000

Output
999999999999999999





-----Note-----

In the first sample, Vasiliy could have missed one supper, for example, in case he have arrived before breakfast, have been in the sanatorium for two days (including the day of arrival) and then have left after breakfast on the third day. 

In the second sample, Vasiliy could have arrived before breakfast, have had it, and immediately have left the sanatorium, not missing any meal.

In the third sample, Vasiliy could have been in the sanatorium for one day, not missing any meal.
Use user-input-Based format and function signature solve()","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1, 0)
    if max_meals == 1:
        print(0)
    else:
        print(max(missed_meals - (total_meals - max_meals), 0))

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meal = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meal - 1, 0)
    
    if max_meal == 1:
        print(0)
    else:
        print(max(0, max_meal - total_meals) + missed_meals)

solve()","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1, 0)
    
    if max_meals == 1:
        print(missed_meals)
    else:
        print(max(max_meals - total_meals + 1, missed_meals))
  
solve()","
def solve():
    b, d, s = map(int, input().split())
    total_meals = b + d + s
    max_meals = max(b, d, s)
    if max_meals == 1:
        print(0)
    else:
        print(max(max_meals - 1 - total_meals + 1, 0))

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1 - total_meals, 0)
    print(missed_meals)

solve()","
def solve():
    b, d, s = map(int, input().split())
    maximum = max(b, d, s)
    result = max(0, maximum - 1 - b) + max(0, maximum - 1 - d) + max(0, maximum - 1 - s)
    print(result)

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1, 0)
    if max_meals == 1:
        print(0)
    else:
        print(missed_meals + max_meals - total_meals)

solve()
","
def solve():
    b, d, s = map(int, input().split())
    
    max_meals = max(b, d, s)
    total_meals = b + d + s
    
    if total_meals == 3:
        print(0)
    else:
        missed_meals = max(max_meals - 1, 0)
        print(missed_meals)

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1, 0)
    if max_meals == 1:
        print(0)
    else:
        print(max(0, missed_meals - (total_meals - max_meals)))

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1, total_meals - max_meals) - 1
    print(max(0, missed_meals))

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1 - total_meals // 2, 0)
    print(missed_meals)

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(0, 2 * max_meals - total_meals - 1)
    print(missed_meals)

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1, 0)
    if max_meals > total_meals // 2:
        missed_meals += max_meals - (total_meals // 2)
    print(missed_meals)

solve()
","
def solve():
    b, d, s = map(int, input().split())
    max_meals = max(b, d, s)
    total_meals = b + d + s
    missed_meals = max(max_meals - 1, 0)
    
    if max_meals == 1:
        print(0)
    else:
        print(max(0, max_meals - 1 - (total_meals - max_meals)))

solve()","
def solve():
    b, d, s = map(int, input().split())
    max_meal = max(b, d, s)
    total_meal = b + d + s
    missed_meals = max(max_meal - 1, 0)
    if max_meal != total_meal:
        missed_meals += total_meal - max_meal
    print(missed_meals)

solve()
","
def solve():
    b, d, s = map(int, input().split())
    total_meals = b + d + s
    max_meals = max(b, d, s)
    min_missed_meals = max(max_meals - 1 - total_meals, 0)
    print(min_missed_meals)

solve()
","80.0","46.666666666666664","46.666666666666664","80.0","80.0","100.0","40.0","46.666666666666664","80.0","40.0","80.0","80.0","26.666666666666668","80.0","20.0","80.0","","","","","","","","","","","","","","","",""
"APPS/166","
QUESTION:
There is a matrix A of size x × y filled with integers. For every $i \in [ 1 . . x ]$, $j \in [ 1 . . y ]$ A_{i}, j = y(i - 1) + j. Obviously, every integer from [1..xy] occurs exactly once in this matrix. 

You have traversed some path in this matrix. Your path can be described as a sequence of visited cells a_1, a_2, ..., a_{n} denoting that you started in the cell containing the number a_1, then moved to the cell with the number a_2, and so on.

From the cell located in i-th line and j-th column (we denote this cell as (i, j)) you can move into one of the following cells: (i + 1, j) — only if i < x;  (i, j + 1) — only if j < y;  (i - 1, j) — only if i > 1;  (i, j - 1) — only if j > 1.

Notice that making a move requires you to go to an adjacent cell. It is not allowed to stay in the same cell. You don't know x and y exactly, but you have to find any possible values for these numbers such that you could start in the cell containing the integer a_1, then move to the cell containing a_2 (in one step), then move to the cell containing a_3 (also in one step) and so on. Can you choose x and y so that they don't contradict with your sequence of moves?


-----Input-----

The first line contains one integer number n (1 ≤ n ≤ 200000) — the number of cells you visited on your path (if some cell is visited twice, then it's listed twice).

The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the integers in the cells on your path.


-----Output-----

If all possible values of x and y such that 1 ≤ x, y ≤ 10^9 contradict with the information about your path, print NO.

Otherwise, print YES in the first line, and in the second line print the values x and y such that your path was possible with such number of lines and columns in the matrix. Remember that they must be positive integers not exceeding 10^9.


-----Examples-----
Input
8
1 2 3 6 9 8 5 2

Output
YES
3 3

Input
6
1 2 1 2 5 3

Output
NO

Input
2
1 10

Output
YES
4 9



-----Note-----

The matrix and the path on it in the first test looks like this: [Image] 

Also there exist multiple correct answers for both the first and the third examples.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    path = list(map(int, input().split()))
    
    max_val = max(path)
    factors = []
    for i in range(1, int(max_val ** 0.5) + 1):
        if max_val % i == 0:
            factors.append(i)
            factors.append(max_val // i)
    
    for x in factors:
        y = max_val // x
        matrix = [[y * (i - 1) + j for j in range(1, y + 1)] for i in range(1, x + 1)]
        
        valid = True
        for i in range(1, n):
            curr_num = path[i]
            prev_num = path[i - 1]
            found = False
            for row in range(x):
                for col in range(y):
                    if matrix[row][col] == curr_num:
                        curr_pos = (row, col)
                    if matrix[row][col] == prev_num:
                        prev_pos = (row, col)
            if abs(curr_pos[0] - prev_pos[0]) + abs(curr_pos[1] - prev_pos[1]) != 1:
                valid = False
                break
        
        if valid:
            print(""YES"")
            print(x, y)
            return
    
    print(""NO"")

solve()","
def solve():
    import math

    n = int(input())
    sequence = list(map(int, input().split()))
    
    diffs = [abs(sequence[i] - sequence[i-1]) for i in range(1, n)]
    
    gcd_diffs = diffs[0]
    for diff in diffs:
        gcd_diffs = math.gcd(gcd_diffs, diff)
    
    if (sequence[0] - 1) % gcd_diffs == 0:
        print(""YES"")
        print(gcd_diffs, (sequence[0] - 1) // gcd_diffs + 1)
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    path = list(map(int, input().split()))

    unique_path = list(set(path))

    min_x = min(unique_path)
    max_x = max(unique_path)

    for x in range(1, int(max_x**0.5) + 1):
        if max_x % x == 0:
            y = max_x // x
            if y >= min_x:
                if all(num in unique_path for num in range(min_x, max_x+1)):
                    print(""YES"")
                    print(x, y)
                    return

    print(""NO"")

solve()
","
def solve():
    import math
    n = int(input())
    cells = list(map(int, input().split()))
    diffs = [b - a for a, b in zip(cells, cells[1:])]

    gcd = diffs[0]
    for diff in diffs:
        gcd = math.gcd(gcd, diff)

    if gcd == 0 or gcd == 1:
        print(""NO"")
    else:
        print(""YES"")
        print(gcd, end=' ')
        print(next(iter(filter(lambda x: gcd % x == 0, range(1, int(pow(gcd, 0.5) + 1, 1)))), gcd))
  
solve()","
def solve():
    n = int(input())
    path = list(map(int, input().split()))
    steps = []

    for i in range(1, n):
        curr_step = abs(path[i] - path[i-1])
        if curr_step == 0 or curr_step > 1:
            steps.append(curr_step)

    if len(steps) == 0:
        print(""NO"")
    else:
        gcd_step = steps[0]
        for step in steps:
            gcd_step = math.gcd(gcd_step, step)
        
        if gcd_step == 1:
            print(""NO"")
        else:
            print(""YES"")
            print(gcd_step, path[-1] // gcd_step)


import math

solve()
  ","
def solve():
    n = int(input())
    path = list(map(int, input().split()))

    visited = {}
    for i in range(1, n):
        diff = abs(path[i] - path[i-1])
        if diff in visited:
            continue
        visited[diff] = 1

    x = max(visited.keys())
    y = path[n-1] // x
    if x*y != path[n-1]:
        print(""NO"")
    else:
        print(""YES"")
        print(x, y)

solve()","
def solve():
    import math

    n = int(input())
    path = list(map(int, input().split()))

    max_element = max(path)
    dim = int(math.sqrt(max_element))

    while max_element % dim != 0:
        dim -= 1

    for i in range(1, n):
        diff = abs(path[i] - path[i-1])
        if diff != dim and diff != 1:
            print(""NO"")
            return
    
    print(""YES"")
    print(dim, max_element // dim)

solve()","
def solve():
    n = int(input())
    path = list(map(int, input().split()))
    distinct_nums = set(path)
    
    max_num = max(distinct_nums)
    x, y = 1, 1
    while x * y < max_num:
        if x < y:
            x += 1
        else:
            y += 1
    
    if x * y != max_num or len(distinct_nums) < n:
        print(""NO"")
    else:
        print(""YES"")
        print(x, y)

solve()
","
def solve():
    n = int(input())
    path = list(map(int, input().split()))
    
    max_val = max(path)
    factors = []
    for i in range(1, int(max_val**0.5) + 1):
        if max_val % i == 0:
            factors.append(i)
            factors.append(max_val // i)
    
    for x in factors:
        for y in factors:
            possible = True
            for i in range(1, n):
                curr_diff = abs(path[i] - path[i-1])
                if (path[i-1] - 1) // y + 1 != (path[i] - 1) // y + 1 and \
                    (path[i-1] - 1) % y + 1 != (path[i] - 1) % y + 1 and \
                    (path[i-1] - 1) // y + 1 != (path[i] - 1) % y + 1 and \
                    (path[i-1] - 1) % y + 1 != (path[i] - 1) // y + 1:
                    possible = False
                    break
            if possible:
                print(""YES"")
                print(x, y)
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    path = list(map(int, input().split()))

    max_val = max(path)
    factors = []
    for i in range(1, int(max_val**0.5) + 1):
        if max_val % i == 0:
            factors.append(i)
            if i != max_val // i:
                factors.append(max_val // i)

    for x in factors:
        y = max_val // x
        matrix = [[0] * y for _ in range(x)]
        pos = 1
        for i in range(x):
            for j in range(y):
                matrix[i][j] = pos
                pos += 1

        valid = True
        for i in range(1, n):
            found = False
            for r in range(x):
                for c in range(y):
                    if matrix[r][c] == path[i]:
                        found = True
                        if i > 0:
                            prev_row, prev_col = divmod(path[i-1] - 1, y)
                            if abs(prev_row - r) + abs(prev_col - c) != 1:
                                valid = False
                        break
                if found:
                    break

            if not found:
                valid = False

        if valid:
            print(""YES"")
            print(f""{x} {y}"")
            return

    print(""NO"")

solve()","
def solve():
    n = int(input())
    path = list(map(int, input().split()))

    max_val = max(path)
    factors = []

    for i in range(1, int(max_val**0.5) + 1):
        if max_val % i == 0:
            factors.append(i)
            if i != max_val // i:
                factors.append(max_val // i)

    factors.sort(reverse=True)

    for f in factors:
        possible = True
        x = f
        y = max_val // f
        visited = set()

        for a in path:
            if a in visited:
                possible = False
                break
            visited.add(a)

            row = (a - 1) // y + 1
            col = (a - 1) % y + 1

            if row > 1 and (a - y) not in visited:
                possible = False
                break
            if row < x and (a + y) not in visited:
                possible = False
                break
            if col > 1 and (a - 1) not in visited:
                possible = False
                break
            if col < y and (a + 1) not in visited:
                possible = False
                break

        if possible:
            print(""YES"")
            print(x, y)
            return

    print(""NO"")

solve()
","
def solve():
    n = int(input())
    path = list(map(int, input().split()))
    
    max_val = max(path)
    x, y = 1, max_val
    
    while x*y < n:
        if x < y:
            x += 1
        else:
            y += 1
    
    if x * y != n:
        print(""NO"")
    else:
        print(""YES"")
        print(x, y)

solve()
","
def solve():
    # Read input
    n = int(input())
    path = list(map(int, input().split()))

    # Find maximum and minimum elements in path
    max_val = max(path)
    min_val = min(path)

    # Check if x and y can be determined
    diff = max_val - min_val
    possible_x, possible_y = -1, -1

    for i in range(1, int(diff**0.5)+1):
        if diff % i == 0:
            x = i + 1
            y = diff // i + 1

            if (max_val - 1) // y == (min_val - 1) // x:
                possible_x = x
                possible_y = y
                break

    # Output the result
    if possible_x == -1:
        print(""NO"")
    else:
        print(""YES"")
        print(possible_x, possible_y)

solve()
","
def solve():
    import math
    n = int(input())
    cells = list(map(int, input().split()))
    
    possible = True
    for i in range(1, n):
        diff = abs(cells[i] - cells[i-1])
        xy_sum = math.ceil(math.sqrt(diff))
        if xy_sum * (xy_sum - 1) < diff:
            possible = False
            break
    
    if possible:
        print(""YES"")
        print(""1 %d"" % xy_sum)
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    path = list(map(int, input().split()))
    factors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            factors.append((i, n // i))
    for x, y in factors:
        matrix = [[0]*y for _ in range(x)]
        num = 1
        for i in range(x):
            for j in range(y):
                matrix[i][j] = num
                num += 1
        cell_map = {}
        for i in range(x):
            for j in range(y):
                cell_map[matrix[i][j]] = (i, j)
        valid = True
        for i in range(1, n):
            diff = abs(cell_map[path[i]][0] - cell_map[path[i-1]][0]) + abs(cell_map[path[i]][1] - cell_map[path[i-1]][1])
            if diff != 1:
                valid = False
                break
        if valid:
            print(""YES"")
            print(x, y)
            return
    print(""NO"")
  
solve()","
def solve():
    n = int(input())
    path = list(map(int, input().split()))
    
    min_a = min(path)
    max_a = max(path)
    
    possible = False
    
    for x in range(1, int(max_a ** 0.5) + 1):
        if max_a % x == 0:
            y = max_a // x
            if min_a <= x and min_a <= y and x * y >= max_a:
                possible = True
                break
    
    if possible:
        print(""YES"")
        print(x, y)
    else:
        print(""NO"")

solve()
","46.15384615384615","0.0","13.333333333333334","40.0","6.666666666666667","0.0","26.666666666666668","40.0","0.0","46.15384615384615","40.0","20.0","13.333333333333334","33.33333333333333","40.0","0.0","","","","","","","","","","","","","","","",""
"APPS/167","
QUESTION:
You are given two strings a and b. You have to remove the minimum possible number of consecutive (standing one after another) characters from string b in such a way that it becomes a subsequence of string a. It can happen that you will not need to remove any characters at all, or maybe you will have to remove all of the characters from b and make it empty.

Subsequence of string s is any such string that can be obtained by erasing zero or more characters (not necessarily consecutive) from string s.


-----Input-----

The first line contains string a, and the second line — string b. Both of these strings are nonempty and consist of lowercase letters of English alphabet. The length of each string is no bigger than 10^5 characters.


-----Output-----

On the first line output a subsequence of string a, obtained from b by erasing the minimum number of consecutive characters.

If the answer consists of zero characters, output «-» (a minus sign).


-----Examples-----
Input
hi
bob

Output
-

Input
abca
accepted

Output
ac

Input
abacaba
abcdcba

Output
abcba



-----Note-----

In the first example strings a and b don't share any symbols, so the longest string that you can get is empty.

In the second example ac is a subsequence of a, and at the same time you can obtain it by erasing consecutive symbols cepted from string b.
Use user-input-Based format and function signature solve()","
def solve():
    import sys
    a = sys.stdin.readline().strip()
    b = sys.stdin.readline().strip()
    
    i, j = 0, 0
    res = """"
    
    while i < len(a) and j < len(b):
        if a[i] == b[j]:
            res += a[i]
            j += 1
        i += 1
    
    if res == """":
        print(""-"")
    else:
        print(res)

solve()
","
def solve():
    import numpy as np

    a = input()
    b = input()

    dp = np.zeros((len(a) + 1, len(b) + 1))

    for i in range(1, len(a)+1):
        for j in range(1, len(b)+1):
            if a[i-1] == b[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    ans = """"
    i, j = len(a), len(b)
    while i > 0 and j > 0:
        if a[i-1] == b[j-1]:
            ans = a[i-1] + ans
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1

    if len(ans) == 0:
        print(""-"")
    else:
        print(ans)

solve()
  ","
def solve():
    import numpy as np

    a = input()
    b = input()

    dp = np.zeros((len(a) + 1, len(b) + 1))

    for i in range(1, len(a)+1):
        for j in range(1, len(b)+1):
            if a[i-1] == b[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    res = ''
    i, j = len(a), len(b)

    while i > 0 and j > 0:
        if a[i-1] == b[j-1]:
            res += a[i-1]
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1

    return res[::-1] if res else '-'

solve()","
def solve():
    import numpy as np
    
    a = input()
    b = input()
    
    n, m = len(a), len(b)
    
    dp = np.zeros((n+1, m+1))
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            if a[i-1] == b[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    ans = """"
    i, j = n, m
    
    while i > 0 and j > 0:
        if a[i-1] == b[j-1]:
            ans += a[i-1]
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    ans = ans[::-1] if len(ans) > 0 else ""-""
    
    return ans

solve()","
def solve():
    a = input().strip()
    b = list(input().strip())

    i = 0
    for j in range(len(a)):
        if i >= len(b):
            break
        if a[j] == b[i]:
            i += 1

    if i == 0:
        print(""-"")
    else:
        print("""".join(b[:i]))

solve()
","
def solve():
    a = input()
    b = input()

    i, j = 0, 0
    res = []
    while i < len(a) and j < len(b):
        if a[i] == b[j]:
            res.append(a[i])
            j += 1
        i += 1

    if len(res) == 0:
        return '-'
    return ''.join(res)

solve()","
def solve():
    from collections import Counter

    def get_common_subsequence(a, b):
        a_counter = Counter(a)
        b_counter = Counter(b)
        common = a_counter & b_counter
        common_subsequence = []
        i = 0
        j = 0
        while i < len(a) and j < len(b):
            if a[i] == b[j] and a[i] in common:
                common_subsequence.append(a[i])
                i += 1
            j += 1
        return ''.join(common_subsequence) if common_subsequence else '-'

    a = input()
    b = input()

    result = get_common_subsequence(a, b)

    print(result)

solve()
","
def solve():
    import numpy as np
    
    a = input()
    b = input()
    
    dp = np.zeros((len(a)+1, len(b)+1))
    
    for i in range(1, len(a)+1):
        for j in range(1, len(b)+1):
            if a[i-1] == b[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    subsequence = ''
    i = len(a)
    j = len(b)
    
    while i > 0 and j > 0:
        if a[i-1] == b[j-1]:
            subsequence = a[i-1] + subsequence
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    if not subsequence:
        print('-')
    else:
        print(subsequence)

solve()
","
def solve():
    from collections import Counter

    def min_consecutive_subsequence(a, b):
        b_counter = Counter(b)
        a_pointer, b_pointer = 0, 0
        subsequence = """"
        
        while a_pointer < len(a) and b_pointer < len(b):
            if a[a_pointer] == b[b_pointer]:
                subsequence += a[a_pointer]
                b_pointer += 1
            a_pointer += 1
        
        return subsequence if len(subsequence) > 0 else ""-""

    a = input().strip()
    b = input().strip()

    print(min_consecutive_subsequence(a, b))
    
solve()
","
import difflib

def solve():
    a = input()
    b = input()
    
    matcher = difflib.SequenceMatcher(None, a, b)
    matching_blocks = matcher.get_matching_blocks()
    common_subsequence = ''.join(a[block.a : block.a+block.size] for block in matching_blocks)
    
    if len(common_subsequence) == 0:
        print('-')
    else:
        print(common_subsequence)

solve()","
def solve():
    a = input().strip()
    b = input().strip()
    
    ia, ib = 0, 0
    while ia < len(a) and ib < len(b):
        if a[ia] == b[ib]:
            ia += 1
            ib += 1
        else:
            ia += 1
    
    if ib == len(b):
        return b
    else:
        return '-'

solve()","
def solve():
    from collections import Counter
    
    a = input()
    b = input()
    
    counter_a = Counter(a)
    counter_b = Counter(b)
    
    res = """"
    i = 0
    j = 0
    
    while i < len(a) and j < len(b):
        if a[i] == b[j]:
            res += b[j]
            j += 1
        i += 1
    
    if res == """":
        return ""-""
    return res

solve()","
def solve():
    import sys
    a = sys.stdin.readline().strip()
    b = sys.stdin.readline().strip()

    i = 0
    j = 0
    res = ''

    while i < len(a) and j < len(b):
        if a[i] == b[j]:
            res += a[i]
            j += 1
        i += 1

    if len(res) == 0:
        print('-')
    else:
        print(res)

solve()
","
def solve():
    a = input()
    b = input()

    i, j = 0, 0
    res = ''
    while i < len(a) and j < len(b):
        if a[i] == b[j]:
            res += b[j]
            j += 1
        i += 1

    return res if len(res) > 0 else '-'

solve()
","
def solve():
    import sys

    a = sys.stdin.readline().strip()
    b = sys.stdin.readline().strip()

    if set(a).isdisjoint(set(b)):
        print(""-"")
    else:
        i, j = 0, 0
        while i < len(a) and j < len(b):
            if a[i] == b[j]:
                i += 1
            j += 1
        
        print(b[:j])

solve()
","
def solve():
    import heapq
    a = input().strip()
    b = input().strip()
    
    index_map = {}
    for i, ch in enumerate(b):
        if ch not in index_map:
            index_map[ch] = []
        index_map[ch].append(i)
    
    bad_indices = [-1]  # Initialize with -1 to handle edge case where no elements are removed
    for ch in a:
        if ch not in index_map:
            continue
        for index in index_map[ch][::-1]:
            heapq.heappush(bad_indices, -index)
    
    bad_indices = sorted(bad_indices)
    
    prev_index = -1
    result = []
    index_map_set = set(index_map.keys())
    for index in bad_indices:
        if prev_index - index == 1:
            prev_index = index
        else:
            if prev_index != -1:
                ch = b[-prev_index-1]
                if ch in index_map_set:
                    result.append(ch)
            prev_index = index
    
    if len(result) == 0:
        print(""-"")
    else:
        print("""".join(result[::-1]))


solve()","66.66666666666666","73.33333333333333","0.0","0.0","66.66666666666666","0.0","40.0","73.33333333333333","66.66666666666666","73.33333333333333","0.0","0.0","66.66666666666666","0.0","46.666666666666664","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/168","
QUESTION:
Vasya has a pile, that consists of some number of stones. $n$ times he either took one stone from the pile or added one stone to the pile. The pile was non-empty before each operation of taking one stone from the pile.

You are given $n$ operations which Vasya has made. Find the minimal possible number of stones that can be in the pile after making these operations.


-----Input-----

The first line contains one positive integer $n$ — the number of operations, that have been made by Vasya ($1 \leq n \leq 100$).

The next line contains the string $s$, consisting of $n$ symbols, equal to ""-"" (without quotes) or ""+"" (without quotes). If Vasya took the stone on $i$-th operation, $s_i$ is equal to ""-"" (without quotes), if added, $s_i$ is equal to ""+"" (without quotes).


-----Output-----

Print one integer — the minimal possible number of stones that can be in the pile after these $n$ operations.


-----Examples-----
Input
3
---

Output
0
Input
4
++++

Output
4
Input
2
-+

Output
1
Input
5
++-++

Output
3


-----Note-----

In the first test, if Vasya had $3$ stones in the pile at the beginning, after making operations the number of stones will be equal to $0$. It is impossible to have less number of piles, so the answer is $0$. Please notice, that the number of stones at the beginning can't be less, than $3$, because in this case, Vasya won't be able to take a stone on some operation (the pile will be empty).

In the second test, if Vasya had $0$ stones in the pile at the beginning, after making operations the number of stones will be equal to $4$. It is impossible to have less number of piles because after making $4$ operations the number of stones in the pile increases on $4$ stones. So, the answer is $4$.

In the third test, if Vasya had $1$ stone in the pile at the beginning, after making operations the number of stones will be equal to $1$. It can be proved, that it is impossible to have less number of stones after making the operations.

In the fourth test, if Vasya had $0$ stones in the pile at the beginning, after making operations the number of stones will be equal to $3$.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input()
    
    stones = 0
    for operation in s:
        if operation == '+':
            stones += 1
        else:
            if stones > 0:
                stones -= 1
    
    print(stones)

solve()","
def solve():
    n = int(input())
    s = input()

    pile = 0
    for operation in s:
        if operation == ""+"":
            pile += 1
        else:
            pile = max(0, pile - 1)

    print(pile)

solve()","
def solve():
    n = int(input())
    s = input()

    result = s.count('+') - s.count('-')

    if result < 0:
        result = 0

    print(result)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    balance = 0
    
    for operation in s:
        if operation == ""+"":
            balance += 1
        else:
            if balance > 0:
                balance -= 1
                
    print(balance)

solve()
","
def solve():
    n = int(input())
    s = input()

    result = s.count('+') - s.count('-')
    if result < 0:
        result = 0

    print(result)

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    stones = 0
    for char in s:
        if char == '+':
            stones += 1
        else:
            if stones > 0:
                stones -= 1
    return stones

solve()","
def solve():
    n = int(input())
    s = input()
    
    initial_stones = 0
    for i in range(n):
        if s[i] == ""+"":
            initial_stones += 1
        elif initial_stones > 0:
            initial_stones -= 1
    
    return initial_stones

solve()","
def solve():
    n = int(input())
    operations = input()

    min_stones = 0

    for operation in operations:
        if operation == '+':
            min_stones += 1
        else:
            if min_stones > 0:
                min_stones -= 1

    print(min_stones)

solve()
  ","
def solve():
    n = int(input())
    s = input().strip()
    
    stones = 0
    for char in s:
        if char == '+':
            stones += 1
        elif stones > 0:
            stones -= 1
    
    print(stones)

solve()","
def solve():
    n = int(input())
    s = input()
    
    total_operations = s.count('+') - s.count('-')
    if total_operations <= 0:
        return 0
    return total_operations

solve()
","
def solve():
    n = int(input())
    s = input()

    initial_stones = 0
    for operation in s:
        if operation == '+':
            initial_stones += 1
        else:
            if initial_stones > 0:
                initial_stones -= 1
            else:
                pass

    print(initial_stones)

solve()","
def solve():
    n = int(input())
    s = input()

    min_stones = s.count('+') - s.count('-')
    if min_stones < 0:
        min_stones = 0

    return min_stones

solve()","
def solve():
    n = int(input())
    s = input().strip()

    # Calculate the minimal possible number of stones in the pile
    result = s.count('+') - s.count('-')
    
    print(max(result, 0))

solve()
","
def solve():
    n = int(input())
    s = input()
    
    count_minus = s.count(""-"")
    count_plus = s.count(""+"")
    
    if count_plus >= count_minus:
        return count_plus
    else:
        return count_minus


solve()","
def solve():
    n = int(input())
    s = input().strip()
    
    neg_count = s.count('-')
    
    result = 0 if neg_count == 0 else neg_count
    
    print(result)

solve()
","
def solve():
    n = int(input())
    s = input()

    count_minus = s.count('-')
    count_plus = s.count('+')

    result = count_plus - count_minus if count_plus >= count_minus else 0
    
    print(result)

solve()
","100.0","100.0","73.33333333333333","100.0","73.33333333333333","0.0","0.0","100.0","100.0","0.0","100.0","0.0","73.33333333333333","0.0","6.666666666666667","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/169","
QUESTION:
Kolya Gerasimov loves kefir very much. He lives in year 1984 and knows all the details of buying this delicious drink. One day, as you probably know, he found himself in year 2084, and buying kefir there is much more complicated.

Kolya is hungry, so he went to the nearest milk shop. In 2084 you may buy kefir in a plastic liter bottle, that costs a rubles, or in glass liter bottle, that costs b rubles. Also, you may return empty glass bottle and get c (c < b) rubles back, but you cannot return plastic bottles.

Kolya has n rubles and he is really hungry, so he wants to drink as much kefir as possible. There were no plastic bottles in his 1984, so Kolya doesn't know how to act optimally and asks for your help.


-----Input-----

First line of the input contains a single integer n (1 ≤ n ≤ 10^18) — the number of rubles Kolya has at the beginning.

Then follow three lines containing integers a, b and c (1 ≤ a ≤ 10^18, 1 ≤ c < b ≤ 10^18) — the cost of one plastic liter bottle, the cost of one glass liter bottle and the money one can get back by returning an empty glass bottle, respectively.


-----Output-----

Print the only integer — maximum number of liters of kefir, that Kolya can drink.


-----Examples-----
Input
10
11
9
8

Output
2

Input
10
5
6
1

Output
2



-----Note-----

In the first sample, Kolya can buy one glass bottle, then return it and buy one more glass bottle. Thus he will drink 2 liters of kefir.

In the second sample, Kolya can buy two plastic bottle and get two liters of kefir, or he can buy one liter glass bottle, then return it and buy one plastic bottle. In both cases he will drink two liters of kefir.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_liters = n // min(a, b)
    remaining_money = n - max_liters * min(a, b)
    
    if b - c < a:
        max_liters += remaining_money // (b - c)
    
    print(max_liters)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())

    max_liters = 0

    # Calculate maximum liters of kefir Kolya can drink
    if n >= b:
        max_liters = n // b
        n %= b
    if n >= a:
        plastic_bottles = n // a
        max_liters += plastic_bottles
        n -= (plastic_bottles * a)
    
    extra_liters = n // (b - c)
    max_liters += extra_liters

    print(max_liters)

solve()
  ","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())

    num_liters_plastic = n // a
    num_liters_glass = (n - c) // (b - c)

    max_liters = max(num_liters_plastic, num_liters_glass)

    return max_liters

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_liters = n // min(a, b)
    
    if max_liters == 1:
        return max_liters
    
    remaining_money = n - max_liters * min(a, b)
    
    if b - c >= a:
        more_liters = remaining_money // (b - c)
        return max_liters + more_liters
    else:
        return max_liters


solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())

    if b - c <= a:
        print(n // a)
    else:
        liters = n // b
        bottles = (n % b + liters * c) // (a + c)
        print(liters + bottles)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    liters_plastic = n // a
    liters_glass = (n - c) // (b - c)
    total_liters = max(liters_plastic, liters_glass)
    
    return total_liters

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    if a <= c:
        print(n // a)
    else:
        total_bottles = n // b
        remaining_money = n % b
        extra_bottles = (remaining_money + c) // (a - c)
        print(total_bottles + extra_bottles)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    total_liters = n // a
    remaining_money = n % a
    
    if remaining_money >= b:
        total_liters += (remaining_money - b) // (b - c) + 1
        
    print(total_liters)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())

    if n >= b:
        return (n - c) // (b - c) + (n - c) % (b - c) + c
    else:
        return n // a

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    if n >= b:
        max_liters = n // b
        remaining_money = n % b
        max_liters += (remaining_money + c) // (a + c)
    else:
        max_liters = n // a
    
    return max_liters
  
solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_liters = n // min(a, b)
    
    remaining_money = n - max_liters * min(a, b)
    
    max_liters += (remaining_money + c) // (b - c)
    
    print(max_liters)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_glass_bottles = (n - c) // (b - c)
    remaining_money = n - max_glass_bottles * (b - c)
    max_plastic_bottles = remaining_money // a
    
    result = max(max_glass_bottles, max_plastic_bottles)
    print(result)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    num_glass_bottles = (n - c) // (b - c)
    remaining_money = n - num_glass_bottles * (b - c)
    num_plastic_bottles = remaining_money // a
    
    max_liters = max(num_glass_bottles * b + num_plastic_bottles * a, num_plastic_bottles * 2)
    
    print(max_liters)

# Needed imports
import sys

sys.setrecursionlimit(10**6)


solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_liters = 0
    
    if n >= b:
        max_liters += (n - c) // (b - c)
        n -= max_liters*(b - c)
    
    max_liters += n // a
    
    return max_liters

solve()","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())

    max_liters = 0

    if n >= b:
        max_liters = n // b
        n %= b

    if n >= a:
        max_liters += n // a
        n %= a

    if n >= a + c:
        max_liters += n // (a + c)

    print(max_liters)

solve()
","
def solve():
    n = int(input())
    a = int(input())
    b = int(input())
    c = int(input())
    
    max_liters = n // a
    total_liters = max_liters
    
    while max_liters >= b:
        total_liters += max_liters // b
        max_liters = max_liters // b + max_liters % b + c
    
    print(total_liters)

solve()
","66.66666666666666","26.666666666666668","0.0","0.0","46.666666666666664","0.0","53.333333333333336","60.0","0.0","0.0","40.0","53.333333333333336","6.666666666666667","0.0","20.0","50.0","","","","","","","","","","","","","","","",""
"APPS/170","
QUESTION:
Two bored soldiers are playing card war. Their card deck consists of exactly n cards, numbered from 1 to n, all values are different. They divide cards between them in some manner, it's possible that they have different number of cards. Then they play a ""war""-like card game. 

The rules are following. On each turn a fight happens. Each of them picks card from the top of his stack and puts on the table. The one whose card value is bigger wins this fight and takes both cards from the table to the bottom of his stack. More precisely, he first takes his opponent's card and puts to the bottom of his stack, and then he puts his card to the bottom of his stack. If after some turn one of the player's stack becomes empty, he loses and the other one wins. 

You have to calculate how many fights will happen and who will win the game, or state that game won't end.


-----Input-----

First line contains a single integer n (2 ≤ n ≤ 10), the number of cards.

Second line contains integer k_1 (1 ≤ k_1 ≤ n - 1), the number of the first soldier's cards. Then follow k_1 integers that are the values on the first soldier's cards, from top to bottom of his stack.

Third line contains integer k_2 (k_1 + k_2 = n), the number of the second soldier's cards. Then follow k_2 integers that are the values on the second soldier's cards, from top to bottom of his stack.

All card values are different.


-----Output-----

If somebody wins in this game, print 2 integers where the first one stands for the number of fights before end of game and the second one is 1 or 2 showing which player has won.

If the game won't end and will continue forever output  - 1.


-----Examples-----
Input
4
2 1 3
2 4 2

Output
6 2
Input
3
1 2
2 1 3

Output
-1


-----Note-----

First sample:  [Image] 

Second sample:  [Image]
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    stack1 = list(map(int, input().split()[1:]))
    stack2 = list(map(int, input().split()[1:]))
    
    fights = 0
    seen = set()
    
    while stack1 and stack2:
        key = (tuple(stack1), tuple(stack2))
        if key in seen:
            print(-1)
            return
        seen.add(key)
        
        card1 = stack1.pop(0)
        card2 = stack2.pop(0)
        
        if card1 > card2:
            stack1.extend([card2, card1])
        else:
            stack2.extend([card1, card2])
        
        fights += 1
    
    if stack1:
        print(fights, 1)
    else:
        print(fights, 2)

solve()
","
def solve():
    n = int(input())
    cards1 = list(map(int, input().split()[1:][::-1])
    cards2 = list(map(int, input().split()[1:][::-1])

    fights = 0
    cycle = 0

    while cards1 and cards2:
        fights += 1
        top_card1 = cards1.pop()
        top_card2 = cards2.pop()

        if top_card1 > top_card2:
            cards1 = [top_card2, top_card1] + cards1
        else:
            cards2 = [top_card1, top_card2] + cards2

        cycle += 1
        if cycle > 2 * n:
            print(""-1"")
            return

    if not cards1:
        print(f""{fights} 2"")
    else:
        print(f""{fights} 1"")

solve()
  ","
def solve():
    n = int(input())
    k1 = list(map(int, input().split()[1:])[::-1]
    k2 = list(map(int, input().split()[1:])[::-1]
    
    fight_count = 0
    history = set()
    
    while k1 and k2:
        fight_count += 1
        if (tuple(k1), tuple(k2)) in history:
            print(""-1"")
            return
        
        history.add((tuple(k1), tuple(k2)))
        
        c1 = k1.pop()
        c2 = k2.pop()
        
        if c1 > c2:
            k1 = [c2, c1] + k1
        else:
            k2 = [c1, c2] + k2
    
    if not k1:
        print(f""{fight_count} 2"")
    else:
        print(f""{fight_count} 1"")

solve()","
def solve():
    n = int(input())
    player1_cards = list(map(int, input().split()[1:][::-1])
    player2_cards = list(map(int, input().split()[1:][::-1])
    total_fights = 0

    while player1_cards and player2_cards:
        total_fights += 1
        card1 = player1_cards.pop()
        card2 = player2_cards.pop()

        if card1 > card2:
            player1_cards = [card2, card1] + player1_cards
        else:
            player2_cards = [card1, card2] + player2_cards

        if total_fights > 10**6:  # Game won't end
            print(""-1"")
            return

    if not player2_cards:
        print(total_fights, 1)
    else:
        print(total_fights, 2)

solve()
","
def solve():
    n = int(input())
    stack1_size = list(map(int, input().split()))[0]
    stack1 = list(map(int, input().split()))[::-1]
    stack2_size = n - stack1_size
    stack2 = list(map(int, input().split()))[::-1]
    
    fights = 0
    while stack1 and stack2:
        card1 = stack1.pop()
        card2 = stack2.pop()
        
        if card1 > card2:
            stack1.insert(0, card2)
            stack1.insert(0, card1)
        else:
            stack2.insert(0, card1)
            stack2.insert(0, card2)
        
        fights += 1
        if fights > 1000:  # Tolerance for an infinite game
            print(-1)
            return
    
    if stack1:
        print(fights, 1)
    else:
        print(fights, 2)
 
solve()","
def solve():
    n = int(input())
    first_stack_size = list(map(int, input().split()))[0]
    first_stack = list(map(int, input().split()))
    second_stack = list(map(int, input().split()))

    fights = 0
    game_round = 0
    while first_stack and second_stack:
        fights += 1
        first_card = first_stack.pop(0)
        second_card = second_stack.pop(0)
        
        if first_card > second_card:
            first_stack += [second_card, first_card]
        else:
            second_stack += [first_card, second_card]
        
        game_round += 1
        if game_round == 1000:
            print(-1)
            return

    if first_stack:
        print(fights, 1)
    else:
        print(fights, 2)

solve()","
def solve():
    n = int(input())
    first_soldier_cards = list(map(int, input().split()))[1:]
    second_soldier_cards = list(map(int, input().split()))[1:]

    fights = 0
    rounds = set()
    while first_soldier_cards and second_soldier_cards:
        fight = (tuple(first_soldier_cards), tuple(second_soldier_cards))
        if fight in rounds:
            print(-1)
            return
        rounds.add(fight)

        fights += 1
        first_card = first_soldier_cards.pop(0)
        second_card = second_soldier_cards.pop(0)

        if first_card > second_card:
            first_soldier_cards += [second_card, first_card]
        else:
            second_soldier_cards += [first_card, second_card]

    if not first_soldier_cards:
        print(fights, 2)
    else:
        print(fights, 1)

solve()
  ","
def solve():
    n = int(input())
    first_player_cards = list(map(int, input().split()))[1:]
    second_player_cards = list(map(int, input().split()))[1:]

    fights = 0
    while first_player_cards and second_player_cards:
        fights += 1
        first_card = first_player_cards.pop(0)
        second_card = second_player_cards.pop(0)

        if first_card > second_card:
            first_player_cards.extend([second_card, first_card])
        else:
            second_player_cards.extend([first_card, second_card])

        if fights > 1000:
            print(-1)
            return
    
    if not first_player_cards:
        print(fights, 2)
    else:
        print(fights, 1)

solve()
","
def solve():
    n = int(input())
    stack1_size = int(input().split()[1])
    stack1 = list(map(int, input().split()))
    stack2_size = int(input().split()[1])
    stack2 = list(map(int, input().split()))
    
    fights = 0
    seen_states = set()
    
    while stack1 and stack2:
        state = (tuple(stack1), tuple(stack2))
        if state in seen_states:
            print(-1)
            return
        seen_states.add(state)

        top_card1 = stack1.pop(0)
        top_card2 = stack2.pop(0)

        if top_card1 > top_card2:
            stack1 += [top_card2, top_card1]
        else:
            stack2 += [top_card1, top_card2]
        
        fights += 1

    if stack1:
        print(fights, 1)
    else:
        print(fights, 2)

solve()
  ","
def solve():
    n = int(input())
    stack1 = list(map(int, input().split()[1:]))
    stack2 = list(map(int, input().split()[1:]))
    
    fights = 0
    used = set()
    while stack1 and stack2:
        card1 = stack1.pop(0)
        card2 = stack2.pop(0)
        
        if (tuple(stack1), tuple(stack2)) in used:
            print(-1)
            return
        
        used.add((tuple(stack1), tuple(stack2)))
        
        if card1 > card2:
            stack1.extend([card2, card1])
        else:
            stack2.extend([card1, card2])
        
        fights += 1
    
    if not stack1:
        print(fights, 2)
    else:
        print(fights, 1)
 
solve()","
from typing import List

def solve() -> None:
    n = int(input())
    deck_1 = list(map(int, input().split()))[1:]
    deck_2 = list(map(int, input().split()))[1:]
    
    fights = 0
    visited_states = set()
    
    while deck_1 and deck_2:
        state = (tuple(deck_1), tuple(deck_2))
        if state in visited_states:
            print(-1)
            return
        
        visited_states.add(state)
        
        card_1 = deck_1.pop(0)
        card_2 = deck_2.pop(0)
        
        if card_1 > card_2:
            deck_1.extend([card_2, card_1])
        else:
            deck_2.extend([card_1, card_2])
        
        fights += 1
        
    if deck_1:
        print(fights, 1)
    elif deck_2:
        print(fights, 2)


solve()","
def solve():
    n = int(input())
    s1 = list(map(int, input().split()))
    s2 = list(map(int, input().split()))

    fights = 0
    states = set()

    while s1 and s2:
      state = (tuple(s1), tuple(s2))
      if state in states:
          print(-1)
          return
      states.add(state)

      a, b = s1.pop(0), s2.pop(0)
      if a > b:
          s1 += [b, a]
      else:
          s2 += [a, b]

      fights += 1

    winner = 1 if s1 else 2
    print(fights, winner)

solve()
","
def solve():
    n = int(input())
    stack1 = list(map(int, input().split()[1:][::-1])
    stack2 = list(map(int, input().split()[1:][::-1])
    fights = 0
    mem = set()
    
    while stack1 and stack2:
        key = tuple(stack1 + [-1] + stack2)
        
        if key in mem:
            print(-1)
            return
        
        mem.add(key)
        top1, top2 = stack1.pop(), stack2.pop()
        
        if top1 > top2:
            stack1 = [top2, top1] + stack1
        else:
            stack2 = [top1, top2] + stack2
        fights += 1
    
    print(fights, 1 if stack1 else 2)
  
solve()","
def solve():
    n = int(input())
    soldier1 = list(map(int, input().split()))[1:]
    soldier2 = list(map(int, input().split()))[1:]
    
    fights = 0
    prev_states = set()
    winner = 0
    
    while True:
        if tuple(soldier1 + soldier2) in prev_states:
            print(-1)
            return
        
        prev_states.add(tuple(soldier1 + soldier2))
        
        card1 = soldier1.pop(0)
        card2 = soldier2.pop(0)
        fights += 1
        
        if card1 > card2:
            soldier1.extend([card2, card1])
        else:
            soldier2.extend([card1, card2])
        
        if len(soldier1) == 0:
            winner = 2
            break
        elif len(soldier2) == 0:
            winner = 1
            break
    
    print(fights, winner)

solve()
  ","
def solve():
    n = int(input())
    stack1_size = int(input().split()[0])
    stack1 = list(map(int, input().split()))
    stack2_size = n - stack1_size
    stack2 = list(map(int, input().split()))

    fights = 0
    visited = set()
    
    while stack1 and stack2:
        state = (tuple(stack1), tuple(stack2))
        if state in visited:
            print(-1)
            return
        visited.add(state)

        top1 = stack1.pop(0)
        top2 = stack2.pop(0)
        if top1 > top2:
            stack1.extend([top2, top1])
        else:
            stack2.extend([top1, top2])
        
        fights += 1

    if not stack1:
        print(fights, 2)
    else:
        print(fights, 1)

solve()
  ","
def solve():
    n = int(input())
    stack1 = list(map(int, input().split()[1:]))
    stack2 = list(map(int, input().split()[1:]))

    fights = 0
    while stack1 and stack2:
        fights += 1
        card1 = stack1.pop(0)
        card2 = stack2.pop(0)
        if card1 > card2:
            stack1.extend([card2, card1])
        else:
            stack2.extend([card1, card2])

        if fights > 1000:
            print(-1)
            return

    if stack1:
        print(fights, 1)
    elif stack2:
        print(fights, 2)
    else:
        print(-1)

solve()","100.0","0.0","0.0","0.0","0.0","0.0","100.0","100.0","0.0","100.0","100.0","13.333333333333334","0.0","100.0","0.0","100.0","","","","","","","","","","","","","","","",""
"APPS/171","
QUESTION:
You have probably registered on Internet sites many times. And each time you should enter your invented password. Usually the registration form automatically checks the password's crypt resistance. If the user's password isn't complex enough, a message is displayed. Today your task is to implement such an automatic check.

Web-developers of the company Q assume that a password is complex enough, if it meets all of the following conditions:  the password length is at least 5 characters;  the password contains at least one large English letter;  the password contains at least one small English letter;  the password contains at least one digit. 

You are given a password. Please implement the automatic check of its complexity for company Q.


-----Input-----

The first line contains a non-empty sequence of characters (at most 100 characters). Each character is either a large English letter, or a small English letter, or a digit, or one of characters: ""!"", ""?"", ""."", "","", ""_"".


-----Output-----

If the password is complex enough, print message ""Correct"" (without the quotes), otherwise print message ""Too weak"" (without the quotes).


-----Examples-----
Input
abacaba

Output
Too weak

Input
X12345

Output
Too weak

Input
CONTEST_is_STARTED!!11

Output
Correct
Use user-input-Based format and function signature solve()","
def solve():
    import re
    
    password = input()
    
    if len(password) < 5:
        print(""Too weak"")
        return
    
    if not re.search(r'[A-Z]', password):
        print(""Too weak"")
        return
    
    if not re.search(r'[a-z]', password):
        print(""Too weak"")
        return
    
    if not re.search(r'\d', password):
        print(""Too weak"")
        return
    
    print(""Correct"")

solve()","
def solve():
    password = input()

    has_upper = any(char.isupper() for char in password)
    has_lower = any(char.islower() for char in password)
    has_digit = any(char.isdigit() for char in password)

    if len(password) >= 5 and has_upper and has_lower and has_digit:
        print(""Correct"")
    else:
        print(""Too weak"")

solve()
","
def solve():
    password = input()
    
    has_upper = False
    has_lower = False
    has_digit = False

    if len(password) < 5:
        print(""Too weak"")
        return

    for char in password:
        if char.isupper():
            has_upper = True
        elif char.islower():
            has_lower = True
        elif char.isdigit():
            has_digit = True

    if has_upper and has_lower and has_digit:
        print(""Correct"")
    else:
        print(""Too weak"")

solve()
","
def solve():
    import re
    
    password = input()
    
    if len(password) < 5:
        print(""Too weak"")
        return
    
    if not re.search('[A-Z]', password):
        print(""Too weak"")
        return
    
    if not re.search('[a-z]', password):
        print(""Too weak"")
        return
    
    if not re.search('[0-9]', password):
        print(""Too weak"")
        return
    
    print(""Correct"")
  
solve()","
def solve():
    import re
    
    password = input().strip()
    
    if len(password) < 5:
        print(""Too weak"")
        return
    
    if not re.search(""[A-Z]"", password):
        print(""Too weak"")
        return
    
    if not re.search(""[a-z]"", password):
        print(""Too weak"")
        return
    
    if not re.search(""[0-9]"", password):
        print(""Too weak"")
        return
    
    print(""Correct"")

solve()","
def solve():
    import re
    
    password = input()
    
    if len(password) < 5:
        print(""Too weak"")
    elif not re.search(""[A-Z]"", password):
        print(""Too weak"")
    elif not re.search(""[a-z]"", password):
        print(""Too weak"")
    elif not re.search(""[0-9]"", password):
        print(""Too weak"")
    else:
        print(""Correct"")

solve()
","
def solve():
    password = input()
    contains_digit = any(char.isdigit() for char in password)
    contains_upper = any(char.isupper() for char in password)
    contains_lower = any(char.islower() for char in password)
    
    if len(password) >= 5 and contains_digit and contains_upper and contains_lower:
        print(""Correct"")
    else:
        print(""Too weak"")
        
solve()
","
def solve():
    import re
    
    password = input()
    
    if len(password) < 5:
        print(""Too weak"")
    elif not any(char.isupper() for char in password):
        print(""Too weak"")
    elif not any(char.islower() for char in password):
        print(""Too weak"")
    elif not any(char.isdigit() for char in password):
        print(""Too weak"")
    else:
        print(""Correct"")

solve()
","
def solve():
    password = input()
    has_upper = False
    has_lower = False
    has_digit = False

    if len(password) < 5:
        print(""Too weak"")
        return

    for char in password:
        if char.isupper():
            has_upper = True
        elif char.islower():
            has_lower = True
        elif char.isdigit():
            has_digit = True

    if has_upper and has_lower and has_digit:
        print(""Correct"")
    else:
        print(""Too weak"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    password = input()

    has_upper = any(char.isupper() for char in password)
    has_lower = any(char.islower() for char in password)
    has_digit = any(char.isdigit() for char in password)

    if len(password) >= 5 and has_upper and has_lower and has_digit:
        print(""Correct"")
    else:
        print(""Too weak"")

solve()
","
def solve():
    import re
    password = input().strip()
    
    if len(password) >= 5 and re.search(r'[A-Z]', password) and re.search(r'[a-z]', password) and re.search(r'\d', password):
        print(""Correct"")
    else:
        print(""Too weak"")

solve()","
def solve():
    import re
    password = input()
    
    if len(password) < 5:
        print(""Too weak"")
    elif not any(c.islower() for c in password):
        print(""Too weak"")
    elif not any(c.isupper() for c in password):
        print(""Too weak"")
    elif not any(c.isdigit() for c in password):
        print(""Too weak"")
    else:
        print(""Correct"")

solve()
","
def solve():
    password = input().strip()
    
    has_upper = any(char.isupper() for char in password)
    has_lower = any(char.islower() for char in password)
    has_digit = any(char.isdigit() for char in password)
    
    if len(password) >= 5 and has_upper and has_lower and has_digit:
        print(""Correct"")
    else:
        print(""Too weak"")

solve()
","
def solve():
    import re
    password = input()
    if len(password) < 5 or not re.search(""[A-Z]"", password) or not re.search(""[a-z]"", password) or not re.search(""[0-9]"", password):
        print(""Too weak"")
    else:
        print(""Correct"")

solve()","
def solve():
    import re
    password = input()
    
    if len(password) >= 5 and any(c.isupper() for c in password) and any(c.islower() for c in password) and any(c.isdigit() for c in password):
        print(""Correct"")
    else:
        print(""Too weak"")

solve()
","
def solve():
    password = input().strip()
    
    has_upper = any(char.isupper() for char in password)
    has_lower = any(char.islower() for char in password)
    has_digit = any(char.isdigit() for char in password)
    
    if len(password) >= 5 and has_upper and has_lower and has_digit:
        print(""Correct"")
    else:
        print(""Too weak"")

if __name__ == ""__main__"":
    solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/172","
QUESTION:
In Berland each high school student is characterized by academic performance — integer value between 1 and 5.

In high school 0xFF there are two groups of pupils: the group A and the group B. Each group consists of exactly n students. An academic performance of each student is known — integer value between 1 and 5.

The school director wants to redistribute students between groups so that each of the two groups has the same number of students whose academic performance is equal to 1, the same number of students whose academic performance is 2 and so on. In other words, the purpose of the school director is to change the composition of groups, so that for each value of academic performance the numbers of students in both groups are equal.

To achieve this, there is a plan to produce a series of exchanges of students between groups. During the single exchange the director selects one student from the class A and one student of class B. After that, they both change their groups.

Print the least number of exchanges, in order to achieve the desired equal numbers of students for each academic performance.


-----Input-----

The first line of the input contains integer number n (1 ≤ n ≤ 100) — number of students in both groups.

The second line contains sequence of integer numbers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 5), where a_{i} is academic performance of the i-th student of the group A.

The third line contains sequence of integer numbers b_1, b_2, ..., b_{n} (1 ≤ b_{i} ≤ 5), where b_{i} is academic performance of the i-th student of the group B.


-----Output-----

Print the required minimum number of exchanges or -1, if the desired distribution of students can not be obtained.


-----Examples-----
Input
4
5 4 4 4
5 5 4 5

Output
1

Input
6
1 1 1 1 1 1
5 5 5 5 5 5

Output
3

Input
1
5
3

Output
-1

Input
9
3 2 5 5 2 3 3 3 2
4 1 4 1 1 2 4 4 1

Output
4
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    count_a = [0] * 6
    count_b = [0] * 6

    for i in range(n):
        count_a[a[i]] += 1
        count_b[b[i]] += 1

    exchanges = 0
    for i in range(1, 6):
        if (count_a[i] + count_b[i]) % 2 != 0:
            print(-1)
            return

        exchanges += abs(count_a[i] - count_b[i]) // 2

    print(exchanges // 2)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    count_a = [0] * 6
    count_b = [0] * 6

    for i in range(n):
        count_a[a[i]] += 1
        count_b[b[i]] += 1

    exchanges = 0

    for i in range(1, 6):
        total = count_a[i] + count_b[i]
        if total % 2 != 0:
            print(-1)
            return

        diff = abs(count_a[i] - total // 2)

        if count_a[i] > total // 2:
            exchanges += diff

    print(exchanges // 2)


solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    exchanges_needed = {}
    for i in range(n):
        diff = a[i] - b[i]
        if diff != 0:
            exchanges_needed[diff] = exchanges_needed.get(diff, 0) + 1

    if sum(exchanges_needed.values()) % 2 != 0:
        print(-1)
    else:
        total_exchanges = sum(exchanges_needed.values())
        num_exchanges = total_exchanges // 2

        num_exchanges_1 = exchanges_needed.get(1, 0) // 2
        num_exchanges_2 = exchanges_needed.get(2, 0) // 2
        num_exchanges_3 = exchanges_needed.get(3, 0) // 2
        num_exchanges_4 = exchanges_needed.get(4, 0) // 2

        print(num_exchanges_1 + num_exchanges_2 + num_exchanges_3 + num_exchanges_4)


solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    exchanges = 0
    diff = [0] * 6

    for i in range(n):
        diff[a[i]] += 1
        diff[b[i]] -= 1

    if sum(diff) != 0:
        print(-1)
    else:
        for i in range(1, 6):
            if diff[i] > 0:
                exchanges += diff[i]
        print(exchanges)

# Function call to test the input/output
solve()
","
def solve():
    n = int(input())
    group_a = list(map(int, input().split()))
    group_b = list(map(int, input().split()))

    count_a = [0] * 6
    count_b = [0] * 6

    for i in range(n):
        count_a[group_a[i]] += 1
        count_b[group_b[i]] += 1

    if count_a != count_b:
        print(-1)
    else:
        exchanges = 0
        for i in range(1, 6):
            exchanges += abs(count_a[i] - count_b[i])

        print(exchanges // 2)

solve()
","
def solve():
    n = int(input())
    group_a = list(map(int, input().split()))
    group_b = list(map(int, input().split()))

    count_a = [0] * 6
    count_b = [0] * 6

    for i in range(n):
        count_a[group_a[i]] += 1
        count_b[group_b[i]] += 1

    if any((count_a[i] + count_b[i]) % 2 != 0 for i in range(1, 6)):
        print(-1)
        return

    exchanges = 0
    for i in range(1, 6):
        exchanges += abs(count_a[i] - count_b[i]) // 2

    print(exchanges // 2)

solve()
","
def solve():
    n = int(input())
    group_a = list(map(int, input().split()))
    group_b = list(map(int, input().split()))

    counts_a = [0] * 6
    counts_b = [0] * 6

    for i in range(n):
        counts_a[group_a[i]] += 1
        counts_b[group_b[i]] += 1

    exchanges = 0

    for i in range(1, 6):
        if (counts_a[i] + counts_b[i]) % 2 != 0:
            print(-1)
            return

        diff = abs(counts_a[i] - counts_b[i]) // 2
        exchanges += diff

    print(exchanges // 2)

solve()
","
def solve():
    n = int(input())
    group_a = list(map(int, input().split()))
    group_b = list(map(int, input().split()))
    
    exchanges = [0] * 5
    
    for i in range(n):
        exchanges[group_a[i]-1] += 1
        exchanges[group_b[i]-1] -= 1
    
    for count in exchanges:
        if count != 0:
            print(-1)
            return
    
    total_exchanges = 0
    for i in range(n):
        if group_a[i] != group_b[i]:
            total_exchanges += 1
    
    print(total_exchanges // 2)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    counts_a = [0] * 6
    counts_b = [0] * 6

    for i in range(n):
        counts_a[a[i]] += 1
        counts_b[b[i]] += 1

    diff = [0] * 6
    for i in range(1, 6):
        diff[i] = abs(counts_a[i] - counts_b[i])

    if sum(diff) % 2 != 0:
        print(-1)
    else:
        print(sum(diff) // 2)


solve()
","
def solve():
    n = int(input())
    group_a = list(map(int, input().split()))
    group_b = list(map(int, input().split()))
    
    count_a = [0] * 6
    count_b = [0] * 6
    
    for i in range(n):
        count_a[group_a[i]] += 1
        count_b[group_b[i]] += 1
    
    exchanges = 0
    for i in range(1, 6):
        if (count_a[i] + count_b[i]) % 2 != 0:
            print(-1)
            return
    
        exchanges += abs(count_a[i] - count_b[i]) // 2
    
    if exchanges % 2 == 0:
        print(exchanges // 2)
    else:
        print(-1)


solve()
","
def solve():
    n = int(input())
    group_a = list(map(int, input().split()))
    group_b = list(map(int, input().split()))

    counts_a = [0] * 6
    counts_b = [0] * 6

    for i in range(n):
        counts_a[group_a[i]] += 1
        counts_b[group_b[i]] += 1

    exchanges = 0
    for i in range(1, 6):
        if (counts_a[i] + counts_b[i]) % 2 != 0:
            print(-1)
            return

        diff = abs(counts_a[i] - counts_b[i]) // 2
        exchanges += diff

    print(exchanges // 2)

solve()
","
def solve():
    n = int(input())
    group_a = list(map(int, input().split()))
    group_b = list(map(int, input().split()))

    counts_a = [0] * 6
    counts_b = [0] * 6

    for i in range(n):
        counts_a[group_a[i]] += 1
        counts_b[group_b[i]] += 1

    total_exchanges = 0
    for i in range(1, 6):
        if (counts_a[i] + counts_b[i]) % 2 != 0:
            print(-1)
            return

        exchanges = abs(counts_a[i] - counts_b[i]) / 2
        total_exchanges += exchanges

    print(int(total_exchanges / 2))


solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    count_a = [0] * 6
    count_b = [0] * 6

    for i in range(n):
        count_a[a[i]] += 1
        count_b[b[i]] += 1

    if count_a[1] != count_b[1] or count_a[2] != count_b[2] or count_a[3] != count_b[3] or count_a[4] != count_b[4] or count_a[5] != count_b[5]:
        print(-1)
    else:
        exchanges = 0
        for i in range(1, 6):
            exchanges += abs(count_a[i] - n)

        print(exchanges // 2 // 2)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    counts_a = [0] * 6
    counts_b = [0] * 6
    
    for i in range(n):
        counts_a[a[i]] += 1
        counts_b[b[i]] += 1
        
    exchanges = 0
    for i in range(1, 6):
        diff = abs(counts_a[i] - counts_b[i])
        if (counts_a[i] + counts_b[i]) % 2 != 0:
            print(-1)
            return
        exchanges += diff // 2
        
    print(exchanges // 2)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    exchanges = 0
    counter = [0] * 6
    
    for i in range(n):
        counter[a[i]] += 1
        counter[b[i]] += 1
    
    for count in counter[1:]:
        if count % 2 != 0:
            print(-1)
            return
    
    for i in range(n):
        if a[i] != b[i]:
            val = a[i]
            for j in range(i, n):
                if b[j] == val and a[j] != val:
                    a[i], b[j] = b[j], a[i]
                    exchanges += 1
                    break
    
    print(exchanges)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    a_count = [0] * 6
    b_count = [0] * 6

    for i in range(n):
        a_count[a[i]] += 1
        b_count[b[i]] += 1

    exchanges = 0
    for i in range(1, 6):
        if (a_count[i] + b_count[i]) % 2 != 0:
            print(-1)
            return

        diff = abs(a_count[i] - b_count[i]) // 2
        exchanges += diff

    if exchanges % 2 != 0 or (a_count[1] - b_count[1]) % 2 != 0:
        print(-1)
    else:
        print(exchanges // 2)

solve()
","100.0","53.333333333333336","66.66666666666666","33.33333333333333","53.333333333333336","100.0","100.0","46.666666666666664","33.33333333333333","100.0","100.0","100.0","20.0","100.0","53.333333333333336","100.0","","","","","","","","","","","","","","","",""
"APPS/173","
QUESTION:
Imagine a city with n horizontal streets crossing m vertical streets, forming an (n - 1) × (m - 1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.

 [Image] 

The mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.


-----Input-----

The first line of input contains two integers n and m, (2 ≤ n, m ≤ 20), denoting the number of horizontal streets and the number of vertical streets.

The second line contains a string of length n, made of characters '<' and '>', denoting direction of each horizontal street. If the i-th character is equal to '<', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.

The third line contains a string of length m, made of characters '^' and 'v', denoting direction of each vertical street. If the i-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.


-----Output-----

If the given pattern meets the mayor's criteria, print a single line containing ""YES"", otherwise print a single line containing ""NO"".


-----Examples-----
Input
3 3
><>
v^v

Output
NO

Input
4 6
<><>
v^v^v^

Output
YES



-----Note-----

The figure above shows street directions in the second sample test case.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_streets = input()
    vertical_streets = input()

    for i in range(n):
        for j in range(m):
            if (horizontal_streets[i] == '<' and vertical_streets[j] == 'v') or (horizontal_streets[i] == '>' and vertical_streets[j] == '^'):
                print(""NO"")
                return

    print(""YES"")

solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()

    for i in range(n):
        if i % 2 == 0 and horizontal_directions[i] != '>':
            print(""NO"")
            return
        if i % 2 == 1 and horizontal_directions[i] != '<':
            print(""NO"")
            return

    for j in range(m):
        if j % 2 == 0 and vertical_directions[j] != 'v':
            print(""NO"")
            return
        if j % 2 == 1 and vertical_directions[j] != '^':
            print(""NO"")
            return

    print(""YES"")

solve()
  ","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input().strip()
    vertical_directions = input().strip()

    for i in range(n):
        for j in range(m):
            if horizontal_directions[i] == '<' and vertical_directions[j] == 'v':
                return 'NO'
            if horizontal_directions[i] == '>' and vertical_directions[j] == '^':
                return 'NO'

    return 'YES'

solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_direction = input()
    vertical_direction = input()
    
    if ('<' in horizontal_direction and '>' in horizontal_direction) or ('^' in vertical_direction and 'v' in vertical_direction):
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()

    for i in range(n - 1):
        if horizontal_directions[i] == horizontal_directions[i + 1]:
            print(""NO"")
            return

    for i in range(m - 1):
        if vertical_directions[i] == vertical_directions[i + 1]:
            print(""NO"")
            return

    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    horizontal = input().strip()
    vertical = input().strip()

    east_to_west_h = horizontal.count('<')
    west_to_east_h = n - east_to_west_h
    north_to_south_v = vertical.count('v')
    south_to_north_v = m - north_to_south_v

    if (east_to_west_h == 0 or west_to_east_h == 0) and (north_to_south_v == 0 or south_to_north_v == 0):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()

    for i in range(1, n):
        if horizontal_directions[i] == horizontal_directions[i - 1]:
            print(""NO"")
            return

    for i in range(1, m):
        if vertical_directions[i] == vertical_directions[i - 1]:
            print(""NO"")
            return

    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()

    for i in range(1, n):
        if horizontal_directions[i-1] != horizontal_directions[i]:
            print(""NO"")
            return

    for i in range(1, m):
        if vertical_directions[i-1] != vertical_directions[i]:
            print(""NO"")
            return

    print(""YES"")

solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()
    
    valid = all(horizontal_directions[0] != horizontal_directions[i] for i in range(1, n)) \
            and all(vertical_directions[0] != vertical_directions[i] for i in range(1, m))
    
    print(""YES"" if valid else ""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()

    for i in range(1, n):
        if horizontal_directions[i-1] == horizontal_directions[i]:
            print(""NO"")
            return

    for i in range(1, m):
        if vertical_directions[i-1] == vertical_directions[i]:
            print(""NO"")
            return

    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    horizontal_dirs = input()
    vertical_dirs = input()

    for i in range(n-1):
        for j in range(m-1):
            if (horizontal_dirs[i] == '<' and (vertical_dirs[j] == 'v' or vertical_dirs[j+1] == '^')) or \
               (horizontal_dirs[i] == '>' and (vertical_dirs[j] == '^' or vertical_dirs[j+1] == 'v')):
                print(""NO"")
                return
    
    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    horizontal = input()
    vertical = input()

    valid = True
    for i in range(n):
        for j in range(m):
            if (horizontal[i] == '<' and vertical[j] == 'v') or (horizontal[i] == '>' and vertical[j] == '^'):
                valid = False
                break

    if valid:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_streets = input()
    vertical_streets = input()

    for i in range(n):
        for j in range(m):
            if (horizontal_streets[i] == '<' and vertical_streets[j] == 'v') or (horizontal_streets[i] == '>' and vertical_streets[j] == '^'):
                print(""NO"")
                return

    print(""YES"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()
    
    valid_pattern = True
    for i in range(n-1):
        if horizontal_directions[i] == horizontal_directions[i+1]:
            valid_pattern = False
            break
    
    for j in range(m-1):
        if vertical_directions[j] == vertical_directions[j+1]:
            valid_pattern = False
            break
    
    if valid_pattern:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    horizontal = input()
    vertical = input()

    for i in range(1, n-1):
        if horizontal[i] == horizontal[i-1]:
            return ""NO""

    for i in range(1, m-1):
        if vertical[i] == vertical[i-1]:
            return ""NO""

    return ""YES""

solve()
","
def solve():
    n, m = map(int, input().split())
    horizontal_directions = input()
    vertical_directions = input()

    for i in range(n):
        if horizontal_directions[i] == '<' and vertical_directions[0] == 'v':
            print(""NO"")
            return
        if horizontal_directions[i] == '>' and vertical_directions[m-1] == 'v':
            print(""NO"")
            return
    
    for j in range(m):
        if vertical_directions[j] == 'v' and horizontal_directions[0] == '>':
            print(""NO"")
            return
        if vertical_directions[j] == '^' and horizontal_directions[n-1] == '>':
            print(""NO"")
            return
    
    print(""YES"")

solve()
","46.666666666666664","40.0","0.0","46.666666666666664","53.333333333333336","46.666666666666664","53.333333333333336","46.666666666666664","53.333333333333336","53.333333333333336","46.666666666666664","46.666666666666664","46.666666666666664","53.333333333333336","0.0","40.0","","","","","","","","","","","","","","","",""
"APPS/174","
QUESTION:
Implication is a function of two logical arguments, its value is false if and only if the value of the first argument is true and the value of the second argument is false. 

Implication is written by using character '$\rightarrow$', and the arguments and the result of the implication are written as '0' (false) and '1' (true). According to the definition of the implication: 

$0 \rightarrow 0 = 1$ 

$0 \rightarrow 1 = 1$

$1 \rightarrow 0 = 0$ 

$1 \rightarrow 1 = 1$

When a logical expression contains multiple implications, then when there are no brackets, it will be calculated from left to fight. For example,

$0 \rightarrow 0 \rightarrow 0 =(0 \rightarrow 0) \rightarrow 0 = 1 \rightarrow 0 = 0$. 

When there are brackets, we first calculate the expression in brackets. For example,

$0 \rightarrow(0 \rightarrow 0) = 0 \rightarrow 1 = 1$.

For the given logical expression $a_{1} \rightarrow a_{2} \rightarrow a_{3} \rightarrow \cdots \cdots a_{n}$ determine if it is possible to place there brackets so that the value of a logical expression is false. If it is possible, your task is to find such an arrangement of brackets.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 100 000) — the number of arguments in a logical expression.

The second line contains n numbers a_1, a_2, ..., a_{n} ($a_{i} \in \{0,1 \}$), which means the values of arguments in the expression in the order they occur.


-----Output-----

Print ""NO"" (without the quotes), if it is impossible to place brackets in the expression so that its value was equal to 0.

Otherwise, print ""YES"" in the first line and the logical expression with the required arrangement of brackets in the second line.

The expression should only contain characters '0', '1', '-' (character with ASCII code 45), '>' (character with ASCII code 62), '(' and ')'. Characters '-' and '>' can occur in an expression only paired like that: (""->"") and represent implication. The total number of logical arguments (i.e. digits '0' and '1') in the expression must be equal to n. The order in which the digits follow in the expression from left to right must coincide with a_1, a_2, ..., a_{n}.

The expression should be correct. More formally, a correct expression is determined as follows:  Expressions ""0"", ""1"" (without the quotes) are correct.  If v_1, v_2 are correct, then v_1->v_2 is a correct expression.  If v is a correct expression, then (v) is a correct expression. 

The total number of characters in the resulting expression mustn't exceed 10^6.

If there are multiple possible answers, you are allowed to print any of them.


-----Examples-----
Input
4
0 1 1 0

Output
YES
(((0)->1)->(1->0))

Input
2
1 1

Output
NO

Input
1
0

Output
YES
0
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))
    
    if 0 in arguments:
        print(""YES"")
        print(""->"".join([""("" + str(arg) + "")"" if arg != arguments[-1] else str(arg) for arg in arguments]))
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    values = list(map(int, input().split()))
    
    def implies(a, b):
        if a == 1 and b == 0:
            return 0
        return 1
    
    has_false_value = False
    
    for i in range(1, n):
        if values[i] == 0 and values[i - 1] == 1:
            has_false_value = True
            break
    
    if has_false_value:
        print(""YES"")
        print('(' + ')->('.join(map(str, values)) + ')')
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))

    if any(arguments[:-1]):  # Check if there is at least one '1' before the last argument '0'
        print(""YES"")
        # Add brackets between implications to make all implications evaluate to 1
        print('(' + ('->'.join(map(str, arguments[:-1])) + ')->(' + str(arguments[-1]) + ')')
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    values = list(map(int, input().split()))

    if 0 in values[1:]:
        print(""YES"")
        print(""(("" + ""->("".join(str(val) for val in values) + ""))""*(n-1))
    else:
        print(""NO"")

solve()
","
python
def solve():
    n = int(input())
    args = list(map(int, input().split()))
    
    count_zero = args.count(0)
    
    if count_zero < 2:
        print(""NO"")
    else:
        print(""YES"")
        print(""("" * (n - 1) + ""0"" + ""->"" * (n - 1) + "")"" * (n - 1))

solve()","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))

    if 0 in arguments:
        print(""YES"")
        print('(' * (n - 2) + str(arguments[0]) + '->' + '('*(n-2) + '->'.join(map(str, arguments[1:])) + ')'*(n-2))
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))
    
    if all(arguments):
        print(""NO"")
    else:
        print(""YES"")
        print(""("" + ""->("".join(map(str, arguments)) + "")"")

solve()","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))

    if 0 in arguments[1:]:
        print(""YES"")
        print(""("" * (n-1) + str(arguments[0]) + ""->"" + solve_implication(arguments[1:]) + "")"")
    else:
        print(""NO"")

def solve_implication(arguments):
    if len(arguments) == 1:
        return str(arguments[0])
    else:
        return ""("" + str(arguments[0]) + ""->"" + solve_implication(arguments[1:]) + "")""

solve()","
def solve():
    n = int(input())
    args = list(map(int, input().split()))
    
    if 0 in args:
        print(""YES"")
        res = ""1""
        for i in range(1, n):
            res = ""("" + res + ""->"" + str(args[i]) + "")""
        print(res)
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    args = list(map(int, input().split()))

    if 0 in args:
        print(""YES"")
        print("""".join([""("" + str(args[i]) + ""->"" if i < n - 1 else str(args[i]) + "")"" * args[i] for i in range(n)]))
    else:
        print(""NO"")

solve()
  ","
def solve():
    pass

solve()","
def solve():
    n = int(input())
    args = input().split()
    expressions = ['(' + args[0] + ')']
    
    for i in range(1, n):
        expressions.append('->')
        expressions.append('(' + args[i] + ')')
        
    if '0->0' in ''.join(expressions):
        print(""YES"")
        print('({}{}{})'.format(''.join(expressions), '->0' * (n - 1)))
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    args = list(map(int, input().split()))

    if any(args[i] == 0 and (i == n-1 or args[i+1] == 0) for i in range(n)):
        print(""YES"")
        print((((""("" + ("")->("").join(str(arg) for arg in args)) + "")""*(n-1)))
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))

    if 0 in arguments:
        print(""YES"")
        if n == 1:
            print(""0"")
        else:
            print(""("" + ""->("".join([str(arg) for arg in arguments]) + "")"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))

    if 0 in arguments:
        print(""YES"")
        print(""->"".join([""("" + str(arg) + "")"" for arg in arguments]))
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arguments = list(map(int, input().split()))
    
    result = ['-'] * (2*n - 1)
    for i in range(1, n):
        result[i*2] = '>'
    
    for i in range(1, n):
        if arguments[i] == 0:
            result[i*2-1] = '('
            result[i*2+1] = ')'
    
    if 0 in arguments:
        print(""YES"")
        print("""".join(map(str, result)))
    else:
        print(""NO"")
  
solve()","26.666666666666668","53.333333333333336","0.0","33.33333333333333","0.0","26.666666666666668","20.0","33.33333333333333","20.0","26.666666666666668","0.0","53.333333333333336","0.0","26.666666666666668","20.0","20.0","","","","","","","","","","","","","","","",""
"APPS/175","
QUESTION:
You have two variables a and b. Consider the following sequence of actions performed with these variables: If a = 0 or b = 0, end the process. Otherwise, go to step 2; If a ≥ 2·b, then set the value of a to a - 2·b, and repeat step 1. Otherwise, go to step 3; If b ≥ 2·a, then set the value of b to b - 2·a, and repeat step 1. Otherwise, end the process.

Initially the values of a and b are positive integers, and so the process will be finite.

You have to determine the values of a and b after the process ends.


-----Input-----

The only line of the input contains two integers n and m (1 ≤ n, m ≤ 10^18). n is the initial value of variable a, and m is the initial value of variable b.


-----Output-----

Print two integers — the values of a and b after the end of the process.


-----Examples-----
Input
12 5

Output
0 1

Input
31 12

Output
7 12



-----Note-----

Explanations to the samples: a = 12, b = 5 $\rightarrow$ a = 2, b = 5 $\rightarrow$ a = 2, b = 1 $\rightarrow$ a = 0, b = 1; a = 31, b = 12 $\rightarrow$ a = 7, b = 12.
Use user-input-Based format and function signature solve()","
def solve():
    a, b = map(int, input().split())
    
    while a != 0 and b != 0:
        if a >= 2 * b:
            a -= 2 * b
        elif b >= 2 * a:
            b -= 2 * a
        else:
            break
    
    print(a, b)

solve()","
def solve():
    a, b = map(int, input().split())
    
    while a != 0 and b != 0:
        if a >= 2 * b:
            a -= 2 * b
        elif b >= 2 * a:
            b -= 2 * a
        else:
            break
    
    print(a, b)
  
solve()","
def solve():
    a, b = map(int, input().split())
    while a != 0 and b != 0:
        if a >= 2 * b:
            a -= 2 * b
        elif b >= 2 * a:
            b -= 2 * a
        else:
            break
    print(a, b)

solve()","
def solve():
    n, m = map(int, input().split())
    
    while n != 0 and m != 0:
        if n >= 2 * m:
            n -= 2 * m
        elif m >= 2 * n:
            m -= 2 * n
        else:
            break
    
    print(n, m)
  
solve()","
def solve():
    n, m = map(int, input().split())
    
    while n != 0 and m != 0:
        if n >= 2 * m:
            n -= 2 * m
        elif m >= 2 * n:
            m -= 2 * n
        else:
            break
    
    print(n, m)

solve()","
def solve():
    a, b = map(int, input().split())
    
    while a != 0 and b != 0:
        if a >= 2*b:
            a -= 2 * b
        elif b >= 2*a:
            b -= 2 * a
        else:
            break

    print(a, b)

solve()","
def solve():
    n, m = map(int, input().split())
    
    while n != 0 and m != 0:
        if n >= 2 * m:
            n -= 2 * m
        elif m >= 2 * n:
            m -= 2 * n
        else:
            break
            
    print(n, m)

solve()","
def solve():
    a, b = map(int, input().split())
    while a != 0 and b != 0:
        if a >= 2 * b:
            a -= 2 * b
        elif b >= 2 * a:
            b -= 2 * a
        else:
            break
    print(a, b)

solve()","
def solve():
    n, m = map(int, input().split())
    
    while n > 0 and m > 0:
        if n >= 2*m:
            n -= 2*m
        elif m >= 2*n:
            m -= 2*n
        else:
            break
    
    print(n, m)

solve()","
def solve():
    a, b = map(int, input().split())
    
    while a != 0 and b != 0:
        if a >= 2*b:
            a -= 2*b
        elif b >= 2*a:
            b -= 2*a
        else:
            break
    
    print(a, b)

solve()","
def solve():
    a, b = map(int, input().split())
    while a != 0 and b != 0:
        if a >= 2*b:
            a -= 2*b
        elif b >= 2*a:
            b -= 2*a
        else:
            break
    print(a, b)

solve()","
def solve():
    a, b = map(int, input().split())
    
    while a != 0 and b != 0:
        if a >= 2 * b:
            a -= 2 * b
        elif b >= 2 * a:
            b -= 2 * a
        else:
            break
        
    print(a, b)

solve()
","
def solve():
    n, m = map(int, input().split())
    while n != 0 and m != 0:
        if n >= 2 * m:
            n -= 2 * m
        elif m >= 2 * n:
            m -= 2 * n
        else:
            break
    print(n, m)

solve()","
def solve():
    a, b = map(int, input().split())
    while a != 0 and b != 0:
        if a >= 2 * b:
            a -= 2 * b
        elif b >= 2 * a:
            b -= 2 * a
        else:
            break
    print(a, b)

solve()","
def solve():
    a, b = map(int, input().split())
    
    while a != 0 and b != 0:
        if a >= 2*b:
            a -= 2*b
        elif b >= 2*a:
            b -= 2*a
        else:
            break
    
    print(a, b)

solve()","
def solve():
    from math import gcd

    n, m = map(int, input().split())

    while n != 0 and m != 0:
        if n >= 2 * m:
            n -= 2 * m
        elif m >= 2 * n:
            m -= 2 * n
        else:
            break

    print(n, m)

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/176","
QUESTION:
Find the number of k-divisible numbers on the segment [a, b]. In other words you need to find the number of such integer values x that a ≤ x ≤ b and x is divisible by k.


-----Input-----

The only line contains three space-separated integers k, a and b (1 ≤ k ≤ 10^18; - 10^18 ≤ a ≤ b ≤ 10^18).


-----Output-----

Print the required number.


-----Examples-----
Input
1 1 10

Output
10

Input
2 -4 4

Output
5
Use user-input-Based format and function signature solve()","
def solve():
    k, a, b = map(int, input().split())
    count = (b // k) - ((a - 1) // k)
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    count = (b // k) - ((a - 1) // k)
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    if a % k == 0:
        required_number = (b // k) - (a // k) + 1
    else:
        required_number = (b // k) - (a // k)
    print(required_number)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    count = (b//k) - ((a-1)//k)
    print(count)

solve()
  ","
def solve():
    k, a, b = map(int, input().split())
    if a % k == 0:
        count = (b - a) // k + 1
    else:
        count = (b - (a - a % k)) // k
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    count = (b // k) - ((a - 1) // k) if a <= 0 else b // k - (a // k)
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    
    if a % k == 0:
        return (b // k) - (a // k) + 1
    else:
        return (b // k) - (a // k)

solve()","
def solve():
    k, a, b = map(int, input().split())
    count = (b // k) - (a // k)
    if a % k == 0:
        count += 1
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    result = (b // k) - ((a - 1) // k)
    print(result)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    if a % k == 0:
        print((b-a)//k + 1)
    else:
        print((b-a)//k)

solve()","
def solve():
    k, a, b = map(int, input().split())
    count = ((b//k) - ((a-1)//k))
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    count = (b // k) - ((a - 1) // k)
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    if a % k == 0:
        result = (b // k) - (a // k) + 1
    else:
        result = (b // k) - (a // k)
    print(result)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    cnt = (b // k) - ((a - 1) // k)
    print(cnt)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    count = (b // k) - ((a - 1) // k)
    print(count)

solve()
","
def solve():
    k, a, b = map(int, input().split())
    result = (b // k) - ((a - 1) // k)
    print(result)

solve()
","100.0","100.0","100.0","100.0","100.0","66.66666666666666","0.0","100.0","100.0","80.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/177","
QUESTION:
Let's write all the positive integer numbers one after another from $1$ without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...

Your task is to print the $k$-th digit of this sequence.


-----Input-----

The first and only line contains integer $k$ ($1 \le k \le 10000$) — the position to process ($1$-based index).


-----Output-----

Print the $k$-th digit of the resulting infinite sequence.


-----Examples-----
Input
7

Output
7

Input
21

Output
5
Use user-input-Based format and function signature solve()","
def solve():
    k = int(input())
    n = 1
    while k > 0:
        digits = len(str(n))
        if k <= digits:
            print(str(n)[k-1])
            return
        k -= digits
        n += 1

solve()
","
def solve():
    k = int(input()) - 1
    num = 1
    while True:
        num_str = str(num)
        if k < len(num_str):
            print(num_str[k])
            break
        k -= len(num_str)
        num += 1

if __name__ == '__main__':
    solve()
","
def solve():
    k = int(input())
    i = 1
    while True:
        num_str = str(i)
        for digit in num_str:
            if k == 0:
                print(digit)
                return
            k -= 1
        i += 1

solve()
","
def solve():
    k = int(input())
    index = 1
    while True:
        number_str = str(index)
        if k <= len(number_str):
            print(number_str[k - 1])
            break
        k -= len(number_str)
        index += 1

solve()
","
def solve():
    k = int(input())

    if k <= 9:
        print(k)
    else:
        k -= 1
        curr = 2
        while True:
            start = 10 ** (curr - 1)
            end = (10 ** curr) - 1
            count = 9 * (10 ** (curr - 1)) * curr
            if k - count <= 0:
                num = start + (k - 1) // curr
                digit_pos = (k - 1) % curr
                print(str(num)[digit_pos])
                break
            k -= count
            curr += 1

solve()","
def solve():
    k = int(input())
    
    n = 1
    while k > 0:
        s = str(n)
        if k <= len(s):
            print(s[k - 1])
            return
        k -= len(s)
        n += 1

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    num = 1
    count = 0
    while True:
        num_str = str(num)
        for digit in num_str:
            count += 1
            if count == k:
                print(digit)
                return
        num += 1

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input().strip())
    
    num_str = ''.join(str(i) for i in range(1, k*2+1))
    digit = num_str[k-1]
    
    print(digit)

solve()
  ","
def solve():
    k = int(input())
    curr_num = 1
    num_length = 1

    while k > num_length:
        k -= num_length
        curr_num += 1
        num_length = len(str(curr_num))

    return str(curr_num)[k - 1]

solve()","
def solve():
    k = int(input())
    n = 1
    while True:
        s = str(n)
        if k <= len(s):
            print(s[k-1])
            break
        k -= len(s)
        n += 1

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    n = 1
    while k > 0:
        digits = len(str(n))
        if k <= digits:
            print(str(n)[k - 1])
            return
        k -= digits
        n += 1

solve()
","
def solve():
    k = int(input().strip())
    num = 1
    while True:
        digits = len(str(num))
        if k <= digits:
            print(str(num)[k-1])
            break
        k -= digits
        num += 1

solve()","
def solve():
    k = int(input())
    digit_idx = 1
    num = 1

    while True:
        num_str = str(num)
        for digit in num_str:
            if digit_idx == k:
                print(digit)
                return
            digit_idx += 1
        num += 1

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    k -= 1
    
    n = 1
    while True:
        n_len = len(str(n))
        if k < n_len:
            return str(n)[k]
        
        k -= n_len
        n += 1

solve()","
def solve():
    k = int(input())
    
    num = 1
    while k > len(str(num)):
        k -= len(str(num))
        num += 1
        
    print(str(num)[k-1])

if __name__ == ""__main__"":
    solve()
","
def solve():
    k = int(input())
    cur_num = 1
    num_str = ''
    
    while len(num_str) < k:
        num_str += str(cur_num)
        cur_num += 1
        
    print(num_str[k - 1])

solve()
","100.0","100.0","13.333333333333334","100.0","73.33333333333333","100.0","100.0","100.0","0.0","100.0","100.0","100.0","100.0","0.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/178","
QUESTION:
A telephone number is a sequence of exactly $11$ digits such that its first digit is 8.

Vasya and Petya are playing a game. Initially they have a string $s$ of length $n$ ($n$ is odd) consisting of digits. Vasya makes the first move, then players alternate turns. In one move the player must choose a character and erase it from the current string. For example, if the current string 1121, after the player's move it may be 112, 111 or 121. The game ends when the length of string $s$ becomes 11. If the resulting string is a telephone number, Vasya wins, otherwise Petya wins.

You have to determine if Vasya has a winning strategy (that is, if Vasya can win the game no matter which characters Petya chooses during his moves).


-----Input-----

The first line contains one integer $n$ ($13 \le n < 10^5$, $n$ is odd) — the length of string $s$.

The second line contains the string $s$ ($|s| = n$) consisting only of decimal digits.


-----Output-----

If Vasya has a strategy that guarantees him victory, print YES.

Otherwise print NO.


-----Examples-----
Input
13
8380011223344

Output
YES

Input
15
807345619350641

Output
NO



-----Note-----

In the first example Vasya needs to erase the second character. Then Petya cannot erase a character from the remaining string 880011223344 so that it does not become a telephone number.

In the second example after Vasya's turn Petya can erase one character character 8. The resulting string can't be a telephone number, because there is no digit 8 at all.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input().strip()
    
    count_8 = s.count('8')
    if count_8 <= (n-11)//2:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input().strip()

    count = s.count('8')
    if count > n // 2:
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    s = input()
    
    num_8 = s.count(""8"")
    
    if num_8 >= (n-11)//2 + 1:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    s = input()
    
    count_8 = s.count('8')
    remaining_moves = (n - 11) // 2
    
    if count_8 > remaining_moves:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    remaining_eights = s.count('8')
    to_remove = (n - 11) // 2
    
    if remaining_eights > to_remove:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input()

    count_8 = s.count('8')
    
    if count_8 >= (n-11)//2 + 1:
        print('YES')
    else:
        print('NO')

solve()
","
def solve():
    n = int(input())
    s = input().strip()

    remaining_eights = s.count('8')
    target_eights = 11 - (n//2)
    
    if remaining_eights >= target_eights:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input()
    
    remaining_eights = s.count('8')
    
    if (n - 11) // 2 < remaining_eights:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    s = input()

    count_8 = s.count('8')
    remaining_length = (n - 11) // 2

    if count_8 > remaining_length:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input()

    if '8' in s[:n//2]:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    num_of_eights_needed = 11 - s.count('8')
    num_of_moves_available = n - 11
    num_of_moves_needed = (num_of_moves_available + 1) // 2
    
    if num_of_moves_needed >= num_of_eights_needed:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    remaining_digits = 11
    count = 0
    
    for i in range(n):
        if s[i] == '8':
            count += 1
            if remaining_digits <= (n - i - 1) // 2:
                print(""YES"")
                return
            remaining_digits -= 1
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    num_eight = s.count('8')
    
    if num_eight <= (n-11)//2:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    digits = [0]*10
    for digit in s:
        digits[int(digit)] += 1
    
    count_8 = digits[8]
    
    if count_8 >= (n-11)//2 + 1:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    s = input()

    cnt_8 = s.count('8')

    if n < 11 or cnt_8 <= (n-11)//2:
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n = int(input())
    s = input().strip()
    
    if s.count('8') <= (n-11)//2:
        print(""YES"")
    else:
        print(""NO"")

solve()
","46.666666666666664","60.0","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","46.666666666666664","53.333333333333336","53.333333333333336","60.0","53.333333333333336","60.0","46.666666666666664","53.333333333333336","53.333333333333336","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/179","
QUESTION:
Andrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $x$ in an array. For an array $a$ indexed from zero, and an integer $x$ the pseudocode of the algorithm is as follows:

BinarySearch(a, x)
  left = 0
  right = a.size()
  while left < right
    middle = (left + right) / 2
    if a[middle] <= x then
      left = middle + 1
    else
      right = middle
  
  if left > 0 and a[left - 1] == x then
    return true
  else
    return false

Note that the elements of the array are indexed from zero, and the division is done in integers (rounding down).

Andrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $x$!

Andrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $n$ such that the algorithm finds $x$ in them. A permutation of size $n$ is an array consisting of $n$ distinct integers between $1$ and $n$ in arbitrary order.

Help Andrey and find the number of permutations of size $n$ which contain $x$ at position $pos$ and for which the given implementation of the binary search algorithm finds $x$ (returns true). As the result may be extremely large, print the remainder of its division by $10^9+7$.


-----Input-----

The only line of input contains integers $n$, $x$ and $pos$ ($1 \le x \le n \le 1000$, $0 \le pos \le n - 1$) — the required length of the permutation, the number to search, and the required position of that number, respectively.


-----Output-----

Print a single number — the remainder of the division of the number of valid permutations by $10^9+7$.


-----Examples-----
Input
4 1 2

Output
6

Input
123 42 24

Output
824071958



-----Note-----

All possible permutations in the first test case: $(2, 3, 1, 4)$, $(2, 4, 1, 3)$, $(3, 2, 1, 4)$, $(3, 4, 1, 2)$, $(4, 2, 1, 3)$, $(4, 3, 1, 2)$.
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    def factorial(n):
        result = 1
        for i in range(1, n + 1):
            result = (result * i) % MOD
        return result

    def power(base, exp):
        result = 1
        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % MOD
            base = (base * base) % MOD
            exp //= 2
        return result

    left, right = 0, n
    less, greater = x - 1, n - x

    count_less, count_greater = 0, 0

    while left < right:
        middle = (left + right) // 2
        if middle == pos:
            left = middle + 1
        elif middle < pos:
            count_less += 1
            left = middle + 1
        else:
            count_greater += 1
            right = middle

    result = (factorial(less) * power(less - count_less, MOD - 2)) % MOD
    result = (result * factorial(greater) * power(greater - count_greater, MOD - 2)) % MOD
    result = (result * factorial(n - less - greater - 1)) % MOD

    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, x, pos = map(int, input().split())
    
    count_less = pos
    count_greater = n - pos - 1
    
    left, right = 0, n
    total_perms = 1
    
    for i in range(n):
        if i < count_less:
            total_perms = (total_perms * (left + i)) % MOD
        elif i > count_less:
            total_perms = (total_perms * (right - i)) % MOD
            
    ways_to_place_x = total_perms * (factorial(count_less) * factorial(count_greater)) % MOD
    
    result = ways_to_place_x if count_less == count_greater else 0
    
    print(result)

def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

solve()
  ","
import math

def solve():
    mod = 10**9 + 7
    n, x, pos = map(int, input().split())
    left, right = 0, n
    count_left, count_right = pos, n - pos - 1
    ans = 1
    for i in range(n):
        if i == pos:
            continue
        if i < pos:
            if x > i:
                count_left -= 1
        else:
            if x < i:
                count_right -= 1
    for i in range(1, n):
        if i == count_left:
            ans = (ans * max(left, 1)) % mod
            left -= 1
        elif i == count_right:
            ans = (ans * max(right, 1)) % mod
            right -= 1
        else:
            ans = (ans * (n - i)) % mod

    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, x, pos = map(int, input().split())
    
    less, equal = 0, 1
    left, right = 0, n
    while left < right:
        middle = (left + right) // 2
        if middle == pos:
            left = middle + 1
        elif middle < pos:
            less += 1
            equal *= (pos - middle)
            equal %= MOD
            left = middle + 1
        else:
            right = middle

    greater = n - less - 1
    for i in range(1, less + 1):
        equal *= i
        equal %= MOD
    for i in range(1, greater + 1):
        equal *= i
        equal %= MOD
    for i in range(1, n - less - greater):
        equal *= i
        equal %= MOD

    answer = 1
    for i in range(1, n):
        answer *= i
        answer %= MOD

    for i in range(1, less + 1):
        answer *= i
        answer %= MOD
    for i in range(1, greater + 1):
        answer *= i
        answer %= MOD

    answer *= pow(less + greater, MOD - 2, MOD)
    answer %= MOD

    print(answer)

if __name__ == ""__main__"":
    solve()
","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    left, right = 0, n
    count_x_less, count_x_more = 0, 0

    while left < right:
        mid = (left + right) // 2
        if mid == pos:
            left = mid + 1
        elif mid < pos:
            left = mid + 1
            count_x_less += 1
        else:
            right = mid
            count_x_more += 1

    remaining_pos = n - pos - 1

    valid_permutations = 1
    for i in range(1, n + 1):
        if i == x:
            continue
        elif i < x:
            valid_permutations = (valid_permutations * count_x_less) % MOD
            count_x_less -= 1
        else:
            valid_permutations = (valid_permutations * count_x_more) % MOD
            count_x_more -= 1

    for i in range(1, remaining_pos + 1):
        valid_permutations = (valid_permutations * i) % MOD

    return valid_permutations

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, x, pos = map(int, input().split())
    
    def factorial(n):
        result = 1
        for i in range(1, n+1):
            result = (result * i) % MOD
        return result
    
    def binomial(n, k):
        return (factorial(n) * pow(factorial(k) * factorial(n-k), MOD-2, MOD)) % MOD
    
    less_count = 0
    more_count = 0
    
    left, right = 0, n
    while left < right:
        middle = (left + right) // 2
        if middle <= pos:
            left = middle + 1
            if middle != pos:
                less_count += 1
        else:
            right = middle
    
    left, right = 0, n
    while left < right:
        middle = (left + right) // 2
        if middle >= pos:
            right = middle
            if middle != pos:
                more_count += 1
        else:
            left = middle + 1
    
    result = factorial(n-1-less_count-more_count) * binomial(n-1-less_count-more_count, less_count) % MOD
    result = (result * factorial(less_count)) % MOD
    result = (result * factorial(more_count)) % MOD
    
    return result

solve()
","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    left = 0
    right = n
    cnt = pos
    max_right = n - 1 - pos
    res = 1

    while left < right:
        mid = (left + right) // 2
        if mid <= pos:
            left = mid + 1
            if mid != pos:
                res = (res * max_right) % MOD
                max_right -= 1
        else:
            right = mid
            res = (res * cnt) % MOD
            cnt -= 1

    for i in range(1, n - n + x):
        res = (res * i) % MOD

    print(res)

if __name__ == ""__main__"":
    solve()
","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    left, right = 0, n
    less_than_x, greater_than_x = 0, 0

    while left < right:
        middle = (left + right) // 2
        if middle < pos:
            less_than_x += 1
            left = middle + 1
        elif middle > pos:
            greater_than_x += 1
            right = middle
        else:
            left = middle + 1

    remaining_positions = n - less_than_x - greater_than_x - 1

    result = 1
    for i in range(n - 1, n - less_than_x - 1, -1):
        result = (result * i) % MOD

    for i in range(n - less_than_x - 1, n - less_than_x - greater_than_x - 1, -1):
        result = (result * i) % MOD

    for i in range(remaining_positions):
        result = (result * (n - less_than_x - greater_than_x - 1)) % MOD

    return result

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, x, pos = map(int, input().split())
    
    low, high = 0, n
    count_left, count_right = 0, 0
    
    while low < high:
        mid = (low + high) // 2
        
        if mid <= pos:
            count_left += 1
            low = mid + 1
        else:
            count_right += 1
            high = mid
    
    valid_perms = 1
    
    for i in range(1, n + 1):
        if i != x:
            if i < x:
                valid_perms = (valid_perms * count_left) % MOD
                count_left -= 1
            else:
                valid_perms = (valid_perms * count_right) % MOD
                count_right -= 1
    
    for i in range(n - 1, 0, -1):
        valid_perms = (valid_perms * i) % MOD
    
    print(valid_perms)

solve()
","
import math

def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    def binomial_coefficient(n, k):
        numer = math.factorial(n)
        denom = (math.factorial(k) * math.factorial(n - k)) % MOD
        return numer * pow(denom, MOD - 2, MOD) % MOD

    left = x - 1
    right = n - x
    possible_left = pos
    possible_right = n - pos - 1

    total_permutations = binomial_coefficient(left + right, right)
    valid_permutations = total_permutations * binomial_coefficient(possible_left + possible_right, possible_right) % MOD

    print(valid_permutations)

# Call the function
solve()
","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    left, right = 0, n
    total = n
    smaller, larger = x - 1, n - x

    while left < right:
        middle = (left + right) // 2
        if middle == pos:
            left = middle + 1
        elif middle < pos:
            total = (total * smaller) % MOD
            smaller -= 1
            left = middle + 1
        else:
            total = (total * larger) % MOD
            larger -= 1
            right = middle

    for i in range(smaller + larger):
        total = (total * (i + 1)) % MOD

    return total

solve()
","
from math import factorial

def solve():
    n, x, pos = map(int, input().split())
    mod = 10**9 + 7
    less, greater = x - 1, n - x
    left, right = 0, n
    ans = 1

    while left < right:
        middle = (left + right) // 2
        
        if middle == pos:
            left = middle + 1
        elif middle < pos:
            ans = (ans * less) % mod
            less -= 1
            left = middle + 1
        else:
            ans = (ans * greater) % mod
            greater -= 1
            right = middle
    
    for i in range(1, less + greater + 1):
        ans = (ans * i) % mod

    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    def factorial(n):
        ans = 1
        for i in range(1, n + 1):
            ans = (ans * i) % MOD
        return ans

    def power(base, exp):
        if exp == 0:
            return 1
        if exp % 2 == 0:
            return power((base * base) % MOD, exp // 2)
        else:
            return (base * power(base, exp - 1)) % MOD

    def inverse(x):
        return power(x, MOD - 2)

    def nCr(n, r):
        return (factorial(n) * inverse(factorial(r)) * inverse(factorial(n - r))) % MOD

    count_left = x - 1
    count_right = n - x

    left, right = 0, n
    ans = 1

    while left < right:
        midpoint = (left + right) // 2
        if midpoint == pos:
            left = midpoint + 1
        elif midpoint < pos:
            ans = (ans * count_left) % MOD
            count_left -= 1
            left = midpoint + 1
        else:
            ans = (ans * count_right) % MOD
            count_right -= 1
            right = midpoint

    ans = (ans * factorial(count_left + count_right)) % MOD
    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    def binary_search_valid_permutations(n, x, pos):
        left_count = sum(1 for i in range(1, x) if i < x - (n - pos))
        right_count = sum(1 for i in range(x+1, n+1) if i <= (n - pos) + x)
        middle_count = n - 1 - left_count - right_count

        result = 1
        for i in range(1, left_count+1):
            result = (result * i) % MOD
        for i in range(1, right_count+1):
            result = (result * i) % MOD

        result = (result * factorial(middle_count)) % MOD

        result = (result * factorial(n - middle_count - 1)) % MOD

        return result

    def factorial(num):
        result = 1
        for i in range(1, num + 1):
            result = (result * i) % MOD
        return result

    print(binary_search_valid_permutations(n, x, pos))

solve()
","
def solve():
    MOD = 10**9 + 7

    n, x, pos = map(int, input().split())

    left_count = sum(1 for i in range(0, pos) if i != pos and i < x)
    right_count = sum(1 for i in range(pos + 1, n) if i != pos and i > x)

    left_length = x - 1
    right_length = n - x

    remaining_positions = n - 1 - left_count - right_count

    result = 1
    for i in range(left_length):
        result = (result * max(1, remaining_positions - i)) % MOD

    for i in range(right_length):
        result = (result * max(1, remaining_positions - i)) % MOD

    for i in range(remaining_positions - left_length - right_length):
        result = (result * max(1, remaining_positions - left_length - right_length - i)) % MOD

    print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    
    n, x, pos = map(int, input().split())
    
    def factorial(n):
        fact = 1
        for i in range(1, n+1):
            fact = (fact * i) % MOD
        return fact

    def power(a, b):
        res = 1
        a = a % MOD
        while b > 0:
            if b % 2 == 1:
                res = (res * a) % MOD
            a = (a * a) % MOD
            b //= 2
        return res

    def nCr(n, r):
        if r == 0 or n == r:
            return 1
        numerator = factorial(n)
        denominator = (factorial(r) * factorial(n-r)) % MOD
        return (numerator * power(denominator, MOD-2)) % MOD

    left = 0
    right = n
    count_x_left = 0
    count_x_right = 0

    while left < right:
        middle = (left + right) // 2
        if middle <= pos:
            if middle != pos:
                count_x_left += 1
            left = middle + 1
        else:
            count_x_right += 1
            right = middle

    total_left = n - x
    total_right = x - 1

    if count_x_left > total_left or count_x_right > total_right:
        print(0)
    else:
        ways_left = nCr(total_left, count_x_left)
        ways_right = nCr(total_right, count_x_right)
        remaining = n - 1 - count_x_left - count_x_right

        result = (factorial(remaining) * ways_left * ways_right) % MOD
        print(result)

solve()
","0.0","33.33333333333333","33.33333333333333","13.333333333333334","0.0","0.0","26.666666666666668","0.0","26.666666666666668","13.333333333333334","0.0","100.0","100.0","26.666666666666668","20.0","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/180","
QUESTION:
Andrey received a postcard from Irina. It contained only the words ""Hello, Andrey!"", and a strange string consisting of lowercase Latin letters, snowflakes and candy canes. Andrey thought that this string is an encrypted message, and decided to decrypt it.

Andrey noticed that snowflakes and candy canes always stand after the letters, so he supposed that the message was encrypted as follows. Candy cane means that the letter before it can be removed, or can be left. A snowflake means that the letter before it can be removed, left, or repeated several times.

For example, consider the following string:  [Image] 

This string can encode the message «happynewyear». For this, candy canes and snowflakes should be used as follows:   candy cane 1: remove the letter w,  snowflake 1: repeat the letter p twice,  candy cane 2: leave the letter n,  snowflake 2: remove the letter w,  snowflake 3: leave the letter e. 

 [Image] 

Please note that the same string can encode different messages. For example, the string above can encode «hayewyar», «happpppynewwwwwyear», and other messages.

Andrey knows that messages from Irina usually have a length of $k$ letters. Help him to find out if a given string can encode a message of $k$ letters, and if so, give an example of such a message.


-----Input-----

The first line contains the string received in the postcard. The string consists only of lowercase Latin letters, as well as the characters «*» and «?», meaning snowflake and candy cone, respectively. These characters can only appear immediately after the letter. The length of the string does not exceed $200$.

The second line contains an integer number $k$ ($1 \leq k \leq 200$), the required message length.


-----Output-----

Print any message of length $k$ that the given string can encode, or «Impossible» if such a message does not exist.


-----Examples-----
Input
hw?ap*yn?eww*ye*ar
12

Output
happynewyear

Input
ab?a
2

Output
aa
Input
ab?a
3

Output
aba
Input
ababb
5

Output
ababb
Input
ab?a
1

Output
Impossible
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    k = int(input().strip())
    
    def decrypt(s):
        decrypted = ''
        for i in range(len(s)):
            if s[i] == '*':
                decrypted = decrypted[:-1]
            elif s[i] == '?':
                decrypted += decrypted[-1]
            else:
                decrypted += s[i]
        return decrypted
    
    decrypted_message = decrypt(s)
    
    if len(decrypted_message) == k:
        print(decrypted_message)
    else:
        print(""Impossible"")

solve()
","
def solve():
    s = input().strip()
    k = int(input().strip())
    result = []

    i = 0
    while i < len(s):
        if s[i] not in ""*?"":
            result.append(s[i])
            i += 1
        elif s[i] == ""*"":
            result[-1] = result[-1] * (k - len(result) + 1)
            i += 1
        elif s[i] == ""?"":
            if k - len(result) >= 1:
                result[-1] = result[-1] * (k - len(result)) if k - len(result) > 1 else result[-1]
                i += 1
            else:
                return ""Impossible""

    return """".join(result[:k])

solve()
","
def solve():
    import itertools

    s = input().strip()
    k = int(input().strip())

    letters = [ch for ch in s if ch.isalpha()]
    encoded_string = ''.join([ch[0] for ch in itertools.groupby(s) if ch[0].isalpha()])

    possible_messages = set()

    for perm in itertools.product(['', letters[0], letters[0]], repeat=len(letters) - 1):
        temp = letters[0] + ''.join([letters[i] + p for i, p in enumerate(perm)])
        
        if '*' in s:
            temp = temp.replace('*', '')
        
        if '?' in s:
            temp = temp.replace('?', '')

        if len(temp) == k:
            possible_messages.add(temp)

    if possible_messages:
        print(possible_messages.pop())
    else:
        print(""Impossible"")

solve()","
def solve():
    encrypted_message = input()
    k = int(input())

    current_message = """"
    for c in encrypted_message:
        if c.isalpha():
            current_message += c
        if c == ""*"":
            current_message = current_message[:-1]
        if c == ""?"":
            current_message += current_message[-1] if current_message else """"

    if len(current_message) == k:
        print(current_message)
    else:
        print(""Impossible"")

solve()
","
def solve():
    from itertools import product

    s = input().strip()
    k = int(input().strip())

    chars = []
    symbols = []
    for i in range(0, len(s), 2):
        chars.append(s[i])
        if i + 1 < len(s):
            symbols.append(s[i + 1])

    for prod in product([False, True], repeat=len(symbols)):
        result = ''
        length = 0
        for ch, sy in zip(chars, prod):
            if not sy:
                result += ch
                length += 1
            else:
                result += ch * (sy + 1)
                length += (sy + 1)

        if length == k:
            print(result)
            return

    print(""Impossible"")

solve()
","
def solve():
    import itertools

    s = input()
    k = int(input())

    letters = [char for char in s if char.isalpha()]

    for perm in itertools.product(['', letters[0]], repeat=len(letters) - 1):
        message = [letters[0]]
        for i, p in enumerate(perm):
            message.append(p)
            message.append(letters[i + 1])
        if len(message) == k:
            result = ''.join(filter(lambda x: x.isalpha(), message))
            print(result)
            return

    print(""Impossible"")

solve()","
def solve():
    # Function to find if a given string can encode a message of length k
    
    s = input().strip()
    k = int(input().strip())
    
    message = []

    for i in range(len(s)):
        if s[i].isalpha():
            message.append(s[i])
        elif s[i] == '*' and i > 0 and s[i-1].isalpha():
            message.pop()
        elif s[i] == '?' and i > 0 and s[i-1].isalpha():
            message.append(message[-1])
    
    if len(message) == k:
        print(''.join(message))
    else:
        print('Impossible')

solve()
  ","
def solve():
    s = input().strip()
    k = int(input().strip())

    message = """"
    current_len = 0

    for i in range(len(s)):
        if s[i] == '*' or s[i] == '?':
            continue
        if i < len(s) - 1 and (s[i+1] == '*' or s[i+1] == '?'):
            message += s[i]
            current_len += 1
        else:
            message += s[i]
            current_len += 1

        if current_len >= k:
            break

    if current_len < k:
        print(""Impossible"")
    else:
        print(message)

# Required imports
import sys

# Run the function
solve()
","
def solve():
    s = input().strip()
    k = int(input())

    letters = []
    for i in range(len(s) - 1):
        if s[i+1] == '?':
            letters.append(s[i])
        elif s[i+1] == '*':
            letters.extend(s[i]*(k-len(letters)))
    
    if len(letters) > k or (k-len(letters)) % 26 != 0:
        print(""Impossible"")
    else:
        encoded_message = ''.join(letters[:k])
        print(encoded_message)

solve()","
def solve():
    import itertools
    
    encrypted_string = input()
    k = int(input())
    
    letters = [char for char in encrypted_string if char.isalpha()]
    
    encoded_messages = set()
    
    for remove_set in itertools.product([True, False], repeat=len(letters)-1):
        for repeat_list in itertools.product([0, 1, 2, 3], repeat=len(letters)-1):
            decoded_message = letters[0]
            for i in range(len(letters)-1):
                if not remove_set[i]:
                    decoded_message += letters[i+1]
                decoded_message += letters[i+1]*repeat_list[i]
            if len(decoded_message) == k:
                encoded_messages.add(decoded_message)
    
    if encoded_messages:
        print(encoded_messages.pop())
    else:
        print(""Impossible"")
  
solve()","
def solve():
    s = input()
    k = int(input())
    
    decoded = """"
    
    for i in range(len(s)-1):
        if s[i+1] != '*' and s[i+1] != '?':
            decoded += s[i]
        elif s[i+1] == '?':
            decoded += s[i]
        else:
            if len(decoded) > 0:
                decoded += decoded[-1]
    
    if s[-1] != '*' and s[-1] != '?':
        decoded += s[-1]
    elif s[-1] == '?' and len(decoded) > 0:
        decoded += decoded[-1]
    
    if len(decoded) == k:
        print(decoded)
    else:
        print(""Impossible"")

solve()","
def solve():
    s, k = input().strip(), int(input())
    n = len(s)
    
    def is_possible(pattern, k):
        count = 0
        for char in pattern:
            if char.isalpha():
                count += 1
            else:
                count -= 1
        return count <= k <= len(pattern)
    
    def generate_possible_messages(pattern, k):
        def backtrack(index, message):
            if len(message) == k:
                return message
            if index >= len(pattern):
                return None
            
            if pattern[index].isalpha():
                return backtrack(index + 1, message + pattern[index])
            elif pattern[index] == '*':
                result = backtrack(index + 1, message)
                if result:
                    return result + message[-1]
                return backtrack(index + 1, message[:-1])
            elif pattern[index] == '?':
                result = backtrack(index + 1, message)
                if result:
                    return result + message[-1]
                return backtrack(index + 1, message + message[-1])
        
        return backtrack(0, '')
    
    if not is_possible(s, k):
        print(""Impossible"")
    else:
        possible_message = generate_possible_messages(s, k)
        print(possible_message)

solve()
","
def solve():
    s = input().strip()
    k = int(input().strip())
    
    decoded_message = []
    current_char = """"
    
    for char in s:
        if char.isalpha():
            if current_char == ""?"":
                decoded_message[-1] = decoded_message[-1] + char
            elif current_char == ""*"":
                decoded_message[-1] = decoded_message[-1] * 2
            else:
                decoded_message.append(char)
            current_char = """"
        else:
            current_char = char
    
    decoded_string = """".join(decoded_message)
    
    if len(decoded_string) == k:
        print(decoded_string)
    else:
        print(""Impossible"")

solve()
","
def solve():
    encrypted_msg = input().strip()
    k = int(input())
    
    decoded_msg = """"
    temp = """"
    
    for char in encrypted_msg:
        if char.isalpha():
            decoded_msg += temp
            temp = char
        elif char == '*':
            decoded_msg += temp
        elif char == '?':
            temp = temp[:-1]
    
    decoded_msg += temp
    
    if len(decoded_msg) == k:
        print(decoded_msg)
    else:
        print(""Impossible"")

solve()","
def solve():
    s = input().strip()
    k = int(input().strip())
    
    decoded_msg = []
    
    for char in s:
        if char.isalpha():
            decoded_msg.append(char)
        elif char == '?':
            if decoded_msg:
                decoded_msg[-1] = decoded_msg[-1]*2
        elif char == '*':
            if decoded_msg:
                decoded_msg.pop()
    
    if len(decoded_msg) == k:
        print(''.join(decoded_msg))
    else:
        print('Impossible')

solve()
","
def solve():
    s, k = input().strip(), int(input().strip())
    result = []
    
    def backtrack(curr, idx):
        if len(curr) == k:
            result.append(''.join(curr))
            return
        
        while idx < len(s):
            if s[idx] == '*':
                curr.pop()
            elif s[idx] == '?':
                curr.append(curr[-1])
            else:
                curr.append(s[idx])
            backtrack(curr, idx + 1)
            if s[idx] == '*' or s[idx] == '?':
                curr.pop()
            else:
                curr.pop()
                break
            idx += 1

    backtrack([s[0]], 1)
    
    return result[0] if result else ""Impossible""

solve()","53.333333333333336","0.0","42.857142857142854","53.333333333333336","18.181818181818183","42.857142857142854","53.333333333333336","46.666666666666664","26.666666666666668","33.33333333333333","53.333333333333336","46.666666666666664","60.0","60.0","53.333333333333336","0.0","","","","","","","","","","","","","","","",""
"APPS/181","
QUESTION:
Vasya started working in a machine vision company of IT City. Vasya's team creates software and hardware for identification of people by their face.

One of the project's know-how is a camera rotating around its optical axis on shooting. People see an eye-catching gadget — a rotating camera — come up to it to see it better, look into it. And the camera takes their photo at that time. What could be better for high quality identification?

But not everything is so simple. The pictures from camera appear rotated too (on clockwise camera rotation frame the content becomes rotated counter-clockwise). But the identification algorithm can work only with faces that are just slightly deviated from vertical.

Vasya was entrusted to correct the situation — to rotate a captured image so that image would be minimally deviated from vertical. Requirements were severe. Firstly, the picture should be rotated only on angle divisible by 90 degrees to not lose a bit of information about the image. Secondly, the frames from the camera are so huge and FPS is so big that adequate rotation speed is provided by hardware FPGA solution only. And this solution can rotate only by 90 degrees clockwise. Of course, one can apply 90 degrees turn several times but for the sake of performance the number of turns should be minimized.

Help Vasya implement the program that by the given rotation angle of the camera can determine the minimum number of 90 degrees clockwise turns necessary to get a picture in which up direction deviation from vertical is minimum.

The next figure contains frames taken from an unrotated camera, then from rotated 90 degrees clockwise, then from rotated 90 degrees counter-clockwise. Arrows show direction to ""true up"". [Image] 

The next figure shows 90 degrees clockwise turn by FPGA hardware. [Image] 


-----Input-----

The only line of the input contains one integer x ( - 10^18 ≤ x ≤ 10^18) — camera angle in degrees. Positive value denotes clockwise camera rotation, negative — counter-clockwise.


-----Output-----

Output one integer — the minimum required number of 90 degrees clockwise turns.


-----Examples-----
Input
60

Output
1

Input
-60

Output
3



-----Note-----

When the camera is rotated 60 degrees counter-clockwise (the second example), an image from it is rotated 60 degrees clockwise. One 90 degrees clockwise turn of the image result in 150 degrees clockwise total rotation and deviation from ""true up"" for one turn is 150 degrees. Two 90 degrees clockwise turns of the image result in 240 degrees clockwise total rotation and deviation from ""true up"" for two turns is 120 degrees because 240 degrees clockwise equal to 120 degrees counter-clockwise. Three 90 degrees clockwise turns of the image result in 330 degrees clockwise total rotation and deviation from ""true up"" for three turns is 30 degrees because 330 degrees clockwise equal to 30 degrees counter-clockwise.

From 60, 150, 120 and 30 degrees deviations the smallest is 30, and it it achieved in three 90 degrees clockwise turns.
Use user-input-Based format and function signature solve()","
def solve():
    x = int(input())
    if x < 0:
        x = abs(x) % 360
        turns = (360 - x) // 90
    else:
        x = x % 360
        turns = x // 90
    print(turns)

solve()
","
def solve():
    x = int(input())
    if x < 0:
        turns = abs(x) // 90 % 4
    else:
        turns = (360 - x) // 90 % 4
    print(turns)

solve()
","
def solve():
    x = int(input())
    x %= 360
    if x < 0:
        x += 360
    if x <= 45:
        print(0)
    elif x <= 135:
        print(1)
    elif x <= 225:
        print(2)
    else:
        print(3)

solve()
","
def solve():
    x = int(input())
    x %= 360
    if x < 0:
        turns = abs(x) // 90
        if abs(x) % 90 != 0:
            turns += 1
    else:
        turns = (360 - x) // 90
    print(turns)

solve()
","
def solve():
    x = int(input())
    if x < 0:
        x = -x
    turns = x // 90
    if turns % 4 == 1:
        print(1)
    elif turns % 4 == 2:
        print(2)
    elif turns % 4 == 3:
        print(3)
    else:
        print(0)

solve()","
def solve():
    x = int(input())
    if x < 0:
        x = -x
    x %= 360
    if x == 0:
        print(0)
    elif x <= 90:
        print(1)
    elif x <= 180:
        print(2)
    else:
        print(3)

solve()","
def solve():
    x = int(input())
    if x < 0:
        x = -x
    turns = x // 90
    remainder = x % 90
    if remainder >= 45:
        turns += 1
    print(turns)

solve()","
def solve():
    x = int(input())
    
    if x < 0:
        x = abs(x)
        turns = ((x // 90) % 4 + 4) % 4
    else:
        turns = (4 - (x // 90) % 4) % 4
    
    print(turns)

solve()","
def solve():
    x = int(input())
    x %= 360
    if x < 0:
        x += 360
    turns = x // 90
    if turns % 2 == 0:
        print(turns // 2)
    else:
        print((turns // 2) + 1)

solve()","
def solve():
    x = int(input())
    n_turns = (abs(x) // 90) % 4
    if x < 0:
        n_turns = (4 - n_turns) % 4
    print(n_turns)

solve()
","
def solve():
    x = int(input())
    x %= 360
    if x < 0:
        x += 360
    turns = x // 90
    if x % 90 != 0:
        turns += 1
    print(turns)

solve()
","
def solve():
    x = int(input())
    
    if x < 0:
        x = -x
        turns = (x // 90) % 4
        if turns == 0:
            print(0)
        elif turns == 1:
            print(3)
        elif turns == 2:
            print(2)
        else:
            print(1)
    else:
        turns = (x // 90) % 4
        print(turns)

solve()
","
def solve():
    x = int(input())
    x = x % 360
    if x < 0:
        x += 360
    if x == 0:
        print(0)
    elif x == 90 or x == 270:
        print(1)
    elif x == 180 or x == 0:
        print(2)
    else:
        print(3)

solve()","
def solve():
    x = int(input())
    x %= 360
    if x < 0:
        x += 360
    if x % 90 == 0:
        return x // 90
    else:
        clockwise_turns = x // 90
        counter_clockwise_deg = x - (clockwise_turns * 90)
        return min(clockwise_turns, (360 - x) // 90)


solve()","
def solve():
    x = int(input())
    if x < 0:
        x = 360 + x % 360
    return x // 90

solve()
","
def solve():
    x = int(input())
    turns = (x % 360) // 90
    if x > 0:
        return turns
    else:
        return 4 - turns

solve()","66.66666666666666","13.333333333333334","100.0","6.666666666666667","60.0","53.333333333333336","73.33333333333333","33.33333333333333","33.33333333333333","60.0","40.0","60.0","40.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/182","
QUESTION:
Carl is a beginner magician. He has a blue, b violet and c orange magic spheres. In one move he can transform two spheres of the same color into one sphere of any other color. To make a spell that has never been seen before, he needs at least x blue, y violet and z orange spheres. Can he get them (possible, in multiple actions)?


-----Input-----

The first line of the input contains three integers a, b and c (0 ≤ a, b, c ≤ 1 000 000) — the number of blue, violet and orange spheres that are in the magician's disposal.

The second line of the input contains three integers, x, y and z (0 ≤ x, y, z ≤ 1 000 000) — the number of blue, violet and orange spheres that he needs to get.


-----Output-----

If the wizard is able to obtain the required numbers of spheres, print ""Yes"". Otherwise, print ""No"".


-----Examples-----
Input
4 4 0
2 1 2

Output
Yes

Input
5 6 1
2 7 2

Output
No

Input
3 3 3
2 2 2

Output
Yes



-----Note-----

In the first sample the wizard has 4 blue and 4 violet spheres. In his first action he can turn two blue spheres into one violet one. After that he will have 2 blue and 5 violet spheres. Then he turns 4 violet spheres into 2 orange spheres and he ends up with 2 blue, 1 violet and 2 orange spheres, which is exactly what he needs.
Use user-input-Based format and function signature solve()","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    # Calculate the total number of spheres needed for each color
    total_blue = x - a
    total_violet = y - b
    total_orange = z - c
    
    # Check if it's possible to obtain the required numbers of spheres
    if total_blue <= 0 and total_violet <= 0 and total_orange <= 0:
        print(""Yes"")
    elif total_blue + total_violet <= min(a, b) and total_orange <= c:
        print(""Yes"")
    elif total_blue + total_orange <= min(a, c) and total_violet <= b:
        print(""Yes"")
    elif total_violet + total_orange <= min(b, c) and total_blue <= a:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    # Calculate the possible number of transformations for each color
    blue_transformations = (a - x) // 2 + (b - y)
    violet_transformations = (b - y) // 2 + (c - z)
    orange_transformations = (c - z) // 2 + (a - x)

    # Check if the wizard can obtain the required numbers of spheres
    if blue_transformations >= 0 and violet_transformations >= 0 and orange_transformations >= 0:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    if a >= x:
        a -= x
    else:
        return ""No""

    if b + a >= y:
        b += a - y
        a = 0
    else:
        return ""No""

    if b + c >= z:
        return ""Yes""
    else:
        return ""No""

solve()","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    if a >= x:
        a -= x
    else:
        y -= (x - a)
        a = 0
    
    if b >= y:
        b -= y
    else:
        z -= (y - b)
        b = 0

    if c >= z:
        c -= z
    else:
        return ""No""

    return ""Yes""

solve()","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    while (a >= 2 and b >= 1) and (x > 0):
        a -= 2
        b -= 1
        x -= 1
    while (b >= 2 and c >= 1) and (y > 0):
        b -= 2
        c -= 1
        y -= 1
    while (a >= 2 and c >= 1) and (z > 0):
        a -= 2
        c -= 1
        z -= 1
    
    if x <= 0 and y <= 0 and z <= 0:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    total_spheres = a + b + c

    if a >= x and b >= y and c >= z:
        print(""Yes"")
    elif total_spheres >= (x + y + z):
        min_moves = max(0, (x - a)//2 + (y - b)//2 + (z - c)//2)
        if min_moves <= total_spheres - (x + y + z):
            print(""Yes"")
        else:
            print(""No"")
    else:
        print(""No"")

solve()
  ","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    if (a + b + c >= x + y + z) and (a >= x or a + b >= x + y or a + b + c >= x + y + z):
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    while (a >= 2 and b >= 2) or (b >= 2 and c >= 2) or (a >= 2 and c >= 2):
        if a >= 2 and b >= 2:
            a -= 2
            b -= 2
            c += 1
        elif b >= 2 and c >= 2:
            b -= 2
            c -= 2
            a += 1
        else:
            a -= 2
            c -= 2
            b += 1
        
    if a >= x and b >= y and c >= z:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    # Check if the required spheres can be obtained by transforming colors
    while (a >= 2 and b > 0):
        a -= 2
        b -= 1
    while (b >= 2 and c > 0):
        b -= 2
        c -= 1

    # Check if the required spheres can be obtained
    if a + b + c >= x + y + z:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    total_blue = a + 2*b
    total_violet = b + 2*c
    total_orange = c + 2*a
    
    if total_blue >= x and total_violet >= y and total_orange >= z:
        print(""Yes"")
    else:
        print(""No"")
  
solve()","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    # Calculate the number of additional blue, violet, and orange spheres needed after combining
    diff_blue = max(0, x - (a//2 + b//2))
    diff_violet = max(0, y - (b//2 + c//2))
    diff_orange = max(0, z - (c//2 + a//2))

    if a + b + c >= x + y + z and diff_blue + diff_violet + diff_orange <= (a//2 + b//2 + c//2):
        print(""Yes"")
    else:
        print(""No"")

solve()
","
from math import ceil

def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    # Calculate the remaining number of spheres needed after possible transformations
    needed_blue = max(0, x - a)
    needed_violet = max(0, y - b)
    needed_orange = max(0, z - c)

    # Check if the remaining needed spheres can be obtained by merging the same colors
    total_needed = needed_blue + needed_violet + needed_orange

    if total_needed <= (a + b + c - ceil(total_needed / 2)):
        print(""Yes"")
    else:
        print(""No"")

solve()

","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    diff_x = max(0, x - a)
    diff_y = max(0, y - b)

    a -= min(a, x)
    b -= min(b, y)

    diff_z = max(0, z - (a + b + c) // 2)

    if diff_x + diff_y + diff_z <= 0:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())

    diff_b = max(0, x - a)
    diff_v = max(0, y - b)
    diff_o = max(0, z - c)

    if (diff_b + diff_v + diff_o) <= ((a + b + c) - (x + y + z)) / 2:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    # Calculate the remaining spheres required
    blue_needed = max(0, x - a)
    violet_needed = max(0, y - b)
    orange_needed = max(0, z - c)
    
    total_needed = blue_needed + violet_needed + orange_needed
    
    # Check if the wizard can obtain the required numbers of spheres
    if a + b + c >= x + y + z and total_needed <= a//2 + b//2 + c//2:
        print(""Yes"")
    else:
        print(""No"")

solve()","
def solve():
    a, b, c = map(int, input().split())
    x, y, z = map(int, input().split())
    
    # Check if the wizard can obtain the required numbers of spheres
    while (a >= x + 2 or b >= y + 2 or c >= z + 2):
        if a >= x + 2:
            a -= 2
            b += 1
        elif b >= y + 2:
            b -= 2
            c += 1
        elif c >= z + 2:
            c -= 2
            a += 1

    if a >= x and b >= y and c >= z:
        print(""Yes"")
    else:
        print(""No"")

solve()
","66.66666666666666","73.33333333333333","0.0","0.0","53.333333333333336","66.66666666666666","66.66666666666666","60.0","60.0","66.66666666666666","53.333333333333336","66.66666666666666","80.0","73.33333333333333","73.33333333333333","80.0","","","","","","","","","","","","","","","",""
"APPS/183","
QUESTION:
Amr doesn't like Maths as he finds it really boring, so he usually sleeps in Maths lectures. But one day the teacher suspected that Amr is sleeping and asked him a question to make sure he wasn't.

First he gave Amr two positive integers n and k. Then he asked Amr, how many integer numbers x > 0 exist such that:  Decimal representation of x (without leading zeroes) consists of exactly n digits;  There exists some integer y > 0 such that:   $y \operatorname{mod} k = 0$;  decimal representation of y is a suffix of decimal representation of x.  

As the answer to this question may be pretty huge the teacher asked Amr to output only its remainder modulo a number m.

Can you help Amr escape this embarrassing situation?


-----Input-----

Input consists of three integers n, k, m (1 ≤ n ≤ 1000, 1 ≤ k ≤ 100, 1 ≤ m ≤ 10^9).


-----Output-----

Print the required number modulo m.


-----Examples-----
Input
1 2 1000

Output
4
Input
2 2 1000

Output
45
Input
5 3 1103

Output
590


-----Note-----

A suffix of a string S is a non-empty string that can be obtained by removing some number (possibly, zero) of first characters from S.
Use user-input-Based format and function signature solve()","
def solve():
    n, k, m = map(int, input().split())
    dp = [[0] * k for _ in range(k)]
    for i in range(k):
        dp[i][i % k] = 1
    res = 0
    for _ in range(n):
        new_dp = [[0] * k for _ in range(k)]
        for i in range(k):
            for j in range(k):
                for d in range(10):
                    new_dp[(i * 10 + d) % k][(j * 10 + d) % k] += dp[i][j]
        dp = new_dp
    for i in range(1, n):
        res += dp[0][0]
    print(res % m)

solve()
  ","
def solve():
    n, k, m = map(int, input().split())
    
    dp = [[0]*k for _ in range(n)]
    dp[0][0] = 1
    
    for i in range(1, n):
        for j in range(k):
            for d in range(10):
                dp[i][(j*10 + d) % k] += dp[i-1][j]
                
    ans = sum(dp[n-1][j] for j in range(k)) % m
    print(ans)

solve()
","
def solve():
    n, k, m = map(int, input().split())
    
    dp = [[[0 for _ in range(k)] for _ in range(2)] for _ in range(n + 1)]
    
    for i in range(1, 10):
        dp[1][1][i % k] += 1
        
    for i in range(2, n + 1):
        for j in range(1, 10):
            for x in range(k):
                dp[i][0][x] += dp[i-1][0][(x - j + k) % k]
                dp[i][1][x] += dp[i-1][1][(x - j + k) % k]
                
                if j % k == 0:
                    dp[i][1][j % k] += 1
    
    result = 0
    for i in range(k):
        result += dp[n][1][i]
    
    print(result % m)

solve()
  ","
from math import factorial

def solve(n, k, m):
    result = 0
    for i in range(1, n + 1):
        result += factorial(n) // (factorial(n - i) * factorial(i))
    return result % m

solve()","
def solve():
    n, k, m = map(int, input().split())

    dp = [[0] * k for _ in range(10)]
    for i in range(1, 10):
        dp[i][i % k] += 1

    for _ in range(n - 1):
        new_dp = [[0] * k for _ in range(10)]
        for i in range(10):
            for j in range(k):
                for digit in range(10):
                    new_dp[i + 1][(j * 10 + digit) % k] += dp[i][j]
        dp = new_dp

    res = sum(dp[i][0] for i in range(1, n + 1)) % m
    print(res)

solve()
  ","
def solve():
    n, k, m = map(int, input().split())

    ans = 0
    for d in range(1, 10):
        for i in range(1, n+1):
            y = d * pow(10, i-1, k)
            if y % k == 0:
                diff = n - i
                cnt = pow(10, diff, m)
                ans = (ans + cnt) % m

    print(ans)

solve()
","
def solve():
    n, k, m = map(int, input().split())

    total = 0
    for d in range(1, 10):
        for rep in range(1, n + 1):
            num = int(str(d) * rep)
            if num % k == 0:
                total += 1
                break

    result = pow(total, m, m)
    print(result)

solve()
","
def solve():
    n, k, m = map(int, input().split())
    total = 0
    
    for i in range(1, 10):
        for j in range(1, n+1):
            total += pow(10, j - 1, m) * pow(k, -1, m)
            total %= m
    
    print(total)

solve()
","
def solve():
    n, k, m = map(int, input().split())
    result = 0
    
    for i in range(1, 10):
        dp = [0] * (k + 1)
        dp[0] = 1
        for j in range(n):
            next_dp = [0] * (k + 1)
            for rem in range(k):
                for d in range(10):
                    next_rem = (rem * 10 + d) % k
                    next_dp[next_rem] += dp[rem]
            dp = next_dp
        result += dp[0]
    
    print(result % m)

solve()
","
def solve():
    from math import gcd

    n, k, m = map(int, input().split())
    
    if k % 5 == 0 or k % 2 == 0:
        print(0)
    else:
        x = 10**n
        ans = 0
        for i in range(k):
            if pow(10, i, k) == 1:
                ans = i
                break
        
        res = 0
        g = gcd(x, k)
        for i in range(1, n + 1):
            res = (res * 10 + ans) % m
            if x % g == 0:
                res = (res * x // g) % m
                break
            x = x * 10
        print(res)

solve()
  ","
def solve():
    n, k, m = map(int, input().split())
    mod = 10**n
    dp = [0] * mod
    
    for i in range(mod):
        for j in range(1, 10):
            x = i * 10 + j
            t = i % k
            dp[x % mod] += dp[i] + (t == 0)
            
    ans = sum(dp[i] for i in range(1, mod)) % m
    print(ans)

solve()
","
def solve():
    n, k, m = map(int, input().split())
    
    dp = [0] * k
    dp[0] = 1
    
    for i in range(n):
        new_dp = [0] * k
        for rem in range(k):
            for d in range(10):
                new_rem = (rem * 10 + d) % k
                new_dp[new_rem] += dp[rem]
                new_dp[new_rem] %= m
        dp = new_dp
    
    print((sum(dp) - 1) % m)

solve()
  ","
def solve():
    # Input
    n, k, m = map(int, input().split())
    
    # DP approach
    dp = [[0] * k for _ in range(k)]
    for i in range(k):
        dp[1][i] = 1
    
    ans = [[0] * k for _ in range(2)]
    for d in range(2, n + 1):
        tmp = d % 2
        ans[tmp] = [0] * k
        for mod in range(k):
            for prefix in range(1 if d == n else 0, 10):
                new_mod = (prefix * pow(10, d - 1, k) + mod) % k
                ans[tmp][new_mod] = (ans[tmp][new_mod] + dp[1 - tmp][mod]) % m
        dp[tmp] = ans[tmp]
    
    # Output
    print(sum(dp[(n + 1) % 2]) % m)

# Call the function to start
solve()
  ","
def solve():
    n, k, m = map(int, input().split())
    dp = [[[0] * k for _ in range(k)] for _ in range(n + 1)]
    
    for i in range(1, min(10, n) + 1):
        for j in range(k):
            dp[i][j][j % k] += 1

    for i in range(10, n + 1):
        for j in range(k):
            for d in range(10):
                dp[i][(j * 10 + d) % k][d % k] += sum(dp[i - 1][j])

    res = sum(dp[n][0]) % m
    print(res)

solve()
","
def solve(n, k, m):
    dp = [[0] * k for _ in range(k)]
    for i in range(k):
        dp[1][i] = 1
    for i in range(2, n + 1):
        temp = [[0] * k for _ in range(k)]
        for j in range(k):
            for x in range(1, 10):
                y = (j * 10 + x) % k
                temp[y][x % k] += sum(dp[j])
        dp = temp
    result = sum(sum(row) for row in dp) % m
    return result
  
solve()","
def solve():
    n, k, m = map(int, input().split())
    dp = [[[0] * k for _ in range(2)] for _ in range(n + 1)]
    dp[0][0][0] = 1
    for i in range(1, n + 1):
        for j in range(k):
            for r in range(10):
                add = dp[i - 1][0][(j - r*k)%k] + dp[i - 1][1][(j - r*k)%k]
                dp[i][1][j] += add
                dp[i][1][j] %= m
                if r < int(str((10**i - 1)//k)[max(i-1,0):]):
                    dp[i][0][j] += add
                    dp[i][0][j] %= m
    res = sum(dp[n][1]) % m
    print(res)

solve()
","0.0","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/184","
QUESTION:
You are at a water bowling training. There are l people who play with their left hand, r people, who play with their right hand, and a ambidexters, who can play with left or right hand.

The coach decided to form a team of even number of players, exactly half of the players should play with their right hand, and exactly half of the players should play with their left hand. One player should use only on of his hands.

Ambidexters play as well with their right hand as with their left hand. In the team, an ambidexter can play with their left hand, or with their right hand.

Please find the maximum possible size of the team, where equal number of players use their left and right hands, respectively.


-----Input-----

The only line contains three integers l, r and a (0 ≤ l, r, a ≤ 100) — the number of left-handers, the number of right-handers and the number of ambidexters at the training. 


-----Output-----

Print a single even integer — the maximum number of players in the team. It is possible that the team can only have zero number of players.


-----Examples-----
Input
1 4 2

Output
6

Input
5 5 5

Output
14

Input
0 2 0

Output
0



-----Note-----

In the first example you can form a team of 6 players. You should take the only left-hander and two ambidexters to play with left hand, and three right-handers to play with right hand. The only person left can't be taken into the team.

In the second example you can form a team of 14 people. You have to take all five left-handers, all five right-handers, two ambidexters to play with left hand and two ambidexters to play with right hand.
Use user-input-Based format and function signature solve()","
def solve():
    l, r, a = map(int, input().split())
    if l > r:
        l, r = r, l
    if r - l > a:
        print((l + a) * 2)
    else:
        print((r + (a - (r - l)) // 2) * 2)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    
    if l > r:
        l, r = r, l
    
    total = 2 * l
    
    if r - l <= a:
        total += 2 * (r-l) + 2 * (a - (r - l)) - (a % 2)
    else:
        total += 2 * r
    
    print(total - (total % 2))

solve()
","
def solve():
    l, r, a = map(int, input().split())
    if l > r:
        l, r = r, l
    if r - l > a:
        print((l + a) * 2)
    else:
        print((r + a - (a - (r - l)) // 2) * 2)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    max_team = 2 * min(l, r, a) + min(abs(l - r - a), 2) // 2
    print(max_team - (max_team % 2))

solve()
","
def solve():
    l, r, a = map(int, input().split())
    total = l + r + a
    team_size = min(l, r) * 2 + max(0, (total - min(l, r) * 2) // 2) * 2
    even_team_size = team_size - (team_size % 2)
    print(even_team_size)

solve()
","
def solve():
    left, right, ambidexters = map(int, input().split())
    max_team = 0

    for i in range(left+1):
        for j in range(right+1):
            if i <= ambidexters and j <= ambidexters:
                team_size = 2 * (i + j) + abs(left - i) + abs(right - j)
                max_team = max(max_team, team_size)

    if max_team % 2 != 0:
        max_team -= 1

    print(max_team)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    
    max_team_size = 2 * min(l, r, a) + min(max(l, r, a) - min(l, r, a), 2) // 2 * 2
    
    print(max_team_size)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    
    min_players = min(l, r)
    remaining_ambidexters = max(0, a - abs(l - r))
    team_size = (min_players + remaining_ambidexters) * 2

    print(team_size)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    
    if l == r:
        return 2 * (l + r + a) if a > 0 else 2 * l
    else:
        min_players = min(l, r)
        diff = abs(l - r)
        
        if a >= diff:
            return 2 * (min_players + diff + a) if diff % 2 == 0 else 2 * (min_players + diff + a - 1)
        else:
            return 2 * (min_players + a) if min_players > a else 2 * (min_players + a - min_players)


solve()
 ","
def solve():
    l, r, a = map(int, input().split())
    
    if l > r:
        l, r = r, l
    
    max_team = 2 * (l + min(r, a // 2))
    a -= 2 * (min(r, a // 2))
    
    if a > 0:
        max_team += 2 * (a // 2)
    
    return max_team

# Call the function to get the result
result = solve()
print(result)

solve()","
def solve():
    l, r, a = map(int, input().split())
    team_with_left = min(l, r, abs(l-r)+a)
    l -= team_with_left
    r -= team_with_left
    remaining_ambidexters = max(0, a - abs(l-r))
    total_left = team_with_left + min(l, r) + remaining_ambidexters
    return total_left * 2 if total_left % 2 == 0 else (total_left - 1) * 2

solve()
","
def solve():
    l, r, a = map(int, input().split())
    max_team_size = 2 * (min(l, r, a) + (max(l, r, a) - min(l, r, a)) // 2)
    print(max_team_size)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    if l > r:
        l, r = r, l
    if r - l <= a:
        a -= r - l
        l = r
    else:
        l += a

    team_size = 2 * (l + (a // 2))
    print(team_size - (team_size % 2))

solve()","
def solve():
    l, r, a = map(int, input().split())
    if l > r:
        l, r = r, l
    if r - l <= a:
        print((l + r + a)//2 * 2)
    else:
        print((l + r + a)//2 * 2 - r + l + a)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    max_team = 0
    
    if l <= r:
        max_team += l
        r -= l
        max_team += min(r, a)
        max_team += (min(r, a)) // 2 * 2
    else:
        max_team += r
        l -= r
        max_team += min(l, a)
        max_team += (min(l, a)) // 2 * 2
    
    print(max_team * 2)

solve()
","
def solve():
    l, r, a = map(int, input().split())
    team_size = 2 * min(l, r, a) + min(max(l, r), max(min(l, r, a), max(l, r) - min(l, r, a))//2) * 2
    print(team_size // 2 * 2)

solve()
","100.0","26.666666666666668","46.666666666666664","20.0","73.33333333333333","20.0","13.333333333333334","13.333333333333334","0.0","0.0","0.0","20.0","73.33333333333333","80.0","20.0","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/185","
QUESTION:
Finished her homework, Nastya decided to play computer games. Passing levels one by one, Nastya eventually faced a problem. Her mission is to leave a room, where a lot of monsters live, as quickly as possible.

There are $n$ manholes in the room which are situated on one line, but, unfortunately, all the manholes are closed, and there is one stone on every manhole. There is exactly one coin under every manhole, and to win the game Nastya should pick all the coins. Initially Nastya stands near the $k$-th manhole from the left. She is thinking what to do.

In one turn, Nastya can do one of the following:   if there is at least one stone on the manhole Nastya stands near, throw exactly one stone from it onto any other manhole (yes, Nastya is strong).  go to a neighboring manhole;  if there are no stones on the manhole Nastya stays near, she can open it and pick the coin from it. After it she must close the manhole immediately (it doesn't require additional moves). 

 [Image] The figure shows the intermediate state of the game. At the current position Nastya can throw the stone to any other manhole or move left or right to the neighboring manholes. If she were near the leftmost manhole, she could open it (since there are no stones on it). 

Nastya can leave the room when she picks all the coins. Monsters are everywhere, so you need to compute the minimum number of moves Nastya has to make to pick all the coins.

Note one time more that Nastya can open a manhole only when there are no stones onto it.


-----Input-----

The first and only line contains two integers $n$ and $k$, separated by space ($2 \leq n \leq 5000$, $1 \leq k \leq n$) — the number of manholes and the index of manhole from the left, near which Nastya stays initially. Initially there is exactly one stone near each of the $n$ manholes. 


-----Output-----

Print a single integer — minimum number of moves which lead Nastya to pick all the coins.


-----Examples-----
Input
2 2

Output
6

Input
4 2

Output
13

Input
5 1

Output
15



-----Note-----

Let's consider the example where $n = 2$, $k = 2$. Nastya should play as follows:

  At first she throws the stone from the second manhole to the first. Now there are two stones on the first manhole.  Then she opens the second manhole and pick the coin from it.  Then she goes to the first manhole, throws two stones by two moves to the second manhole and then opens the manhole and picks the coin from it. 

So, $6$ moves are required to win.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    if k <= n // 2:
        print(3 * n - 1)
    else:
        print(3 * n)

solve()","
def solve():
    n, k = map(int, input().split())
    if k <= n // 2:
        moves = 3 + (k-1) + (n-1) + 1 + (n-k)
    else:
        moves = 3 + (n - k) + (k-1) + 1 + (n-1)
    print(moves)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    if k <= n // 2:
        print(3*n + k - 1)
    else:
        print(3*n + n - k)

solve()","
def solve():
    n, k = map(int, input().split())
    if k == 1 or k == n:
        print(3*n)
    else:
        print(3 + 2*n + min(k-1, n-k) + 2*min(k-1, n-k) + n)

solve()","
def solve():
    n, k = map(int, input().split())
    
    if k == 1 or k == n:
        print(3 + 2*n)
    else:
        print(4 + 2*n)

solve()","
def solve():
    n, k = map(int, input().split())
    total_moves = n + min(k-1, n-k) + 3*(n-1)
    print(total_moves)

solve()","
def solve(n: int, k: int) -> int:
    if k < n - k + 1:
        return 3 + 4*(k-1) + 4*(n-k)
    else:
        return 3 + 4*(n-k) + 4*(k-1)

solve()","
def solve():
    n, k = map(int, input().split())
    if k <= n // 2:
        print(3 * n - 1)
    else:
        print(4 * n - 3)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    if k <= n // 2:
        moves = 1 + (k-1) + 1 + (n-1) + (n-1) + 1
    else:
        moves = 1 + (n-k) + 1 + (n-1) + (n-1) + 1
    
    print(moves)

solve()
","
def solve():
    n, k = map(int, input().split())
    if k < n - k + 1:
        print(2 * n + k - 1)
    else:
        print(2 * n + n - k)

solve()","
def solve():
    n, k = map(int, input().split())
    min_moves = 2 + n + min(k-1, n-k) + 2*(n-1)
    print(min_moves)

solve()
","
def solve():
    n, k = map(int, input().split())
    if k <= n // 2:
        print(3*n + k - 4)
    else:
        print(3*n + n - k - 2)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    if k == 1 or k == n:
        print(3*n)
    else:
        print(2*n + min(k-1, n-k) + 2)

solve()","
def solve():
    n, k = map(int, input().split())
    if k == 1 or k == n:
        print(3*n)
    else:
        print(3 + 2*n)

solve()","
from math import ceil

def solve():
    n, k = map(int, input().split())
    moves = 3*n
    moves += min(k-1, n-k) * 3
    moves += ceil((k-1 + n-k + n-1) / 2) * 2
    print(moves)

solve()","
def solve():
    n, k = map(int, input().split())
    total_moves = 0

    # Calculate minimum moves to reach leftmost manhole
    total_moves += min(k - 1, n - k) * 3

    # Calculate minimum moves to pick all coins
    total_moves += n * 2 + 1

    print(total_moves)

solve()
","13.333333333333334","6.666666666666667","100.0","20.0","0.0","0.0","0.0","0.0","0.0","0.0","100.0","0.0","20.0","20.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/186","
QUESTION:
Students in a class are making towers of blocks. Each student makes a (non-zero) tower by stacking pieces lengthwise on top of each other. n of the students use pieces made of two blocks and m of the students use pieces made of three blocks.

The students don’t want to use too many blocks, but they also want to be unique, so no two students’ towers may contain the same number of blocks. Find the minimum height necessary for the tallest of the students' towers.


-----Input-----

The first line of the input contains two space-separated integers n and m (0 ≤ n, m ≤ 1 000 000, n + m > 0) — the number of students using two-block pieces and the number of students using three-block pieces, respectively.


-----Output-----

Print a single integer, denoting the minimum possible height of the tallest tower.


-----Examples-----
Input
1 3

Output
9

Input
3 2

Output
8

Input
5 0

Output
10



-----Note-----

In the first case, the student using two-block pieces can make a tower of height 4, and the students using three-block pieces can make towers of height 3, 6, and 9 blocks. The tallest tower has a height of 9 blocks.

In the second case, the students can make towers of heights 2, 4, and 8 with two-block pieces and towers of heights 3 and 6 with three-block pieces, for a maximum height of 8 blocks.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    min_height = max(2 * n, 3 * m)
    for i in range(1, min_height):
        if i % 2 != 0 and i % 3 != 0:
            return i

solve()","
def solve():
    n, m = map(int, input().split())
    if n > m:
        n, m = m, n
    if n == 0:
        print(m * 3)
    elif m <= 2 * n:
        print(n * 3)
    else:
        print((n + m) // 3 * 3)

solve()
","
def solve():
    n, m = map(int, input().split())
    max_height = 0

    if n == 0:
        max_height = m * 3
    elif m == 0:
        max_height = n * 2
    else:
        min_n = min(n, m)
        
        for i in range(min_n + 1):
            height = max(i*2, n + m - 3*i)*3
            max_height = max(max_height, height)
    
    print(max_height)

solve()
","
def solve():
    n, m = map(int, input().split())
    min_height = 0

    if n > m:
        min_height = (n - 1) * 2 + 2
    else:
        min_height = (m - 1) * 3 + 3

    print(min_height)

solve()","
def solve():
    n, m = map(int, input().split())
    max_height = max(2 * n, 3 * m)
    current_height = 1
    while current_height <= max_height:
        if current_height % 2 != 0 and current_height % 3 != 0:
            print(current_height)
            break
        current_height += 1

solve()
","
def solve():
    n, m = map(int, input().split())
    max_height = 0
    
    for two_blocks in range(n+1):
        three_blocks = n - two_blocks
        height = min(two_blocks*2, three_blocks*3)
        max_height = max(max_height, height)
    
    print(max_height)

solve()
","
def solve():
    n, m = map(int, input().split())
    max_height = 0
    
    for i in range(1, 1000):
        if i//2 >= n and i//3 >= m:
            max_height = i
            break
    
    print(max_height)

solve()
","
def solve():
    n, m = map(int, input().split())
    min_height = max(2*n, 3*m)
    
    highest_height = min_height
    while min_height <= highest_height:
        temp_height = min(2*(n+1), 3*(m+1))
        min_height = max(min_height, temp_height)
        n += 1
        m += 1
    
    print(min_height)

solve()
","
def solve():
    n, m = map(int, input().split())
    if n > m:
        n, m = m, n
    height = 0
    for i in range(1, m // 3 + 1):
        if (m - 3 * i) // 2 <= n:
            height = max(height, 3*i + 2*((m - 3*i) // 2))
    print(height)

solve()","
def solve():
    n, m = map(int, input().split())
    
    tallest_height = 0
    
    for i in range(1, 1000001):
        if i % 2 != 0 and i % 3 != 0 and n > 0:
            tallest_height = max(tallest_height, i)
            n -= 1
        elif i % 3 != 0 and m > 0:
            tallest_height = max(tallest_height, i)
            m -= 1
    
    print(tallest_height)

solve()
","
def solve():
    n, m = map(int, input().split())
    min_height = max(2 * n, 3 * m)
    k = max(min_height // 6, 1)
    while (n > k or m > k) and (n - k + 1 + m - k + 1 <= k):
        k += 1
    print(k * 6)

solve()
","
def solve():
    n, m = map(int, input().split())
    if n > m:
        n, m = m, n
    max_height = 0
    for i in range(m//3, m//3+4):
        if i * 3 % 2 == 0:
            curr_height = i * 3
            if n >= 2 * curr_height - m:
                max_height = max(max_height, curr_height + (m - curr_height // 3 * 2) * 2)
    print(max_height)

solve()
","
def solve():
    n, m = map(int, input().split())
    max_height = 0
    for i in range(max(n, m) * 10):
        if (i // 2) + (i // 3) - (i // 6) >= n + m:
            max_height = i
            break
    print(max_height)

solve()
","
def solve():
    n, m = map(int, input().split())
    
    max_height = min(n*2, m*3)
    
    if n > m:
        max_height = max(max_height, ((n-m)//3)*2 + m*3)
    else:
        max_height = max(max_height, (((m-n)//2)*3) + n*2)
    
    print(max_height)

solve()
  ","
def solve():
    n, m = map(int, input().split())
    if n > m:
        n, m = m, n
    if m >= 2 * n:
        print(3 * n)
    else:
        print((m + n) // 3 * 3)
  
solve()","
def solve():
    n, m = map(int, input().split())
    if n < m:
        n, m = m, n
    if m == 0:
        print(n * 2)
    elif m == 1:
        print(n * 3)
    else:
        x = min(n, m - 1)
        print((n - x) * 2 + x * 3)

solve()
","0.0","6.666666666666667","13.333333333333334","26.666666666666668","0.0","0.0","13.333333333333334","13.333333333333334","0.0","0.0","0.0","0.0","73.33333333333333","0.0","0.0","20.0","","","","","","","","","","","","","","","",""
"APPS/187","
QUESTION:
Petya and Vasya decided to play a game. They have n cards (n is an even number). A single integer is written on each card.

Before the game Petya will choose an integer and after that Vasya will choose another integer (different from the number that Petya chose). During the game each player takes all the cards with number he chose. For example, if Petya chose number 5 before the game he will take all cards on which 5 is written and if Vasya chose number 10 before the game he will take all cards on which 10 is written.

The game is considered fair if Petya and Vasya can take all n cards, and the number of cards each player gets is the same.

Determine whether Petya and Vasya can choose integer numbers before the game so that the game is fair. 


-----Input-----

The first line contains a single integer n (2 ≤ n ≤ 100) — number of cards. It is guaranteed that n is an even number.

The following n lines contain a sequence of integers a_1, a_2, ..., a_{n} (one integer per line, 1 ≤ a_{i} ≤ 100) — numbers written on the n cards.


-----Output-----

If it is impossible for Petya and Vasya to choose numbers in such a way that the game will be fair, print ""NO"" (without quotes) in the first line. In this case you should not print anything more.

In the other case print ""YES"" (without quotes) in the first line. In the second line print two distinct integers — number that Petya should choose and the number that Vasya should choose to make the game fair. If there are several solutions, print any of them.


-----Examples-----
Input
4
11
27
27
11

Output
YES
11 27

Input
2
6
6

Output
NO

Input
6
10
20
30
20
10
20

Output
NO

Input
6
1
1
2
2
3
3

Output
NO



-----Note-----

In the first example the game will be fair if, for example, Petya chooses number 11, and Vasya chooses number 27. Then the will take all cards — Petya will take cards 1 and 4, and Vasya will take cards 2 and 3. Thus, each of them will take exactly two cards.

In the second example fair game is impossible because the numbers written on the cards are equal, but the numbers that Petya and Vasya should choose should be distinct.

In the third example it is impossible to take all cards. Petya and Vasya can take at most five cards — for example, Petya can choose number 10 and Vasya can choose number 20. But for the game to be fair it is necessary to take 6 cards.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]

    card_count = {}
    for card in cards:
        if card in card_count:
            card_count[card] += 1
        else:
            card_count[card] = 1

    distinct_cards = list(set(cards))

    if len(distinct_cards) == 1:
        print(""NO"")
    else:
        print(""YES"")
        print(distinct_cards[0], distinct_cards[1])

solve()","
def solve():
    n = int(input())
    cards = []
    for i in range(n):
        cards.append(int(input()))

    card_count = {}
    for card in cards:
        if card in card_count:
            card_count[card] += 1
        else:
            card_count[card] = 1

    unique_cards = list(set(cards))

    possible_solution = False
    for i in range(len(unique_cards)):
        for j in range(i+1, len(unique_cards)):
            if card_count[unique_cards[i]] == card_count[unique_cards[j]]:
                print(""YES"")
                print(unique_cards[i], unique_cards[j])
                possible_solution = True
                break
        if possible_solution:
            break

    if not possible_solution:
        print(""NO"")

# Main
solve()
","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]
    
    card_count = {}
    for card in cards:
        card_count[card] = card_count.get(card, 0) + 1
    
    distinct_cards = list(set(cards))
    
    if len(distinct_cards) > 2:
        print(""NO"")
    else:
        if card_count[distinct_cards[0]] == n // 2:
            print(""YES"")
            print(f""{distinct_cards[0]} {distinct_cards[1]}"")
        else:
            print(""NO"")

solve()","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]

    card_count = {}
    for card in cards:
        if card in card_count:
            card_count[card] += 1
        else:
            card_count[card] = 1

    if len(card_count) != 2:
        print(""NO"")
    else:
        cards_sorted = sorted(card_count.items(), key=lambda x: x[1])
        if cards_sorted[0][1] == cards_sorted[1][1]:
            print(""YES"")
            print(cards_sorted[0][0], cards_sorted[1][0])
        else:
            print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]

    freq = {}
    for card in cards:
        if card not in freq:
            freq[card] = 1
        else:
            freq[card] += 1

    unique_cards = list(set(cards))

    if len(unique_cards) < 2:
        print(""NO"")
    elif len(unique_cards) == 2 and freq[unique_cards[0]] == freq[unique_cards[1]]:
        print(""YES"")
        print(unique_cards[0], unique_cards[1])
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    cards = []
    for _ in range(n):
        cards.append(int(input()))

    occurrences = {}
    for card in cards:
        if card in occurrences:
            occurrences[card] += 1
        else:
            occurrences[card] = 1

    unique_cards = list(set(cards))

    if len(unique_cards) != 2:
        print(""NO"")
    else:
        card1 = unique_cards[0]
        card2 = unique_cards[1]
        if occurrences[card1] == occurrences[card2]:
            print(""YES"")
            print(card1, card2)
        else:
            print(""NO"")

solve()
","
def solve():
    from collections import Counter
    
    n = int(input())
    cards = [int(input()) for _ in range(n)]
    
    card_counts = Counter(cards)
    
    if len(card_counts) < 2:
        print(""NO"")
    else:
        unique_cards = list(card_counts.keys())
        petya_num = unique_cards[0]
        vasya_num = unique_cards[1]
        print(""YES"")
        print(f""{petya_num} {vasya_num}"")

solve()","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]

    card_count = {}
    for card in cards:
        if card in card_count:
            card_count[card] += 1
        else:
            card_count[card] = 1

    unique_cards = list(set(cards))

    if len(unique_cards) == 2 and card_count[unique_cards[0]] == card_count[unique_cards[1]]:
        print(""YES"")
        print(unique_cards[0], unique_cards[1])
    else:
        print(""NO"")

import sys
solve()
","
def solve():
    n = int(input())
    cards = []
    for _ in range(n):
        cards.append(int(input()))

    unique_cards = set(cards)
    if len(unique_cards) == 2 and cards.count(unique_cards.pop()) == n // 2:
        print(""YES"")
        print(*unique_cards, end='')
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]

    num_count = {}
    for card in cards:
        if card in num_count:
            num_count[card] += 1
        else:
            num_count[card] = 1

    max_count = max(num_count.values())

    if max_count > n/2:
        print(""NO"")
    else:
        print(""YES"")
        for num, count in num_count.items():
            if count == max_count:
                petya_num = num
                break
        for num, count in num_count.items():
            if count < max_count:
                vasya_num = num
                break
        print(petya_num, vasya_num)
  
solve()","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]

    unique_cards = set(cards)

    if len(unique_cards) != 2:
        print(""NO"")
    else:
        a, b = unique_cards
        count_a = cards.count(a)
        count_b = cards.count(b)

        if count_a != count_b:
            print(""NO"")
        else:
            print(""YES"")
            print(f""{a} {b}"")

solve()
","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]
    
    counts = {}
    for card in cards:
        counts[card] = counts.get(card, 0) + 1
    
    for card, count in counts.items():
        if count != n//2:
            continue
        other_card = None
        for next_card, next_count in counts.items():
            if next_card != card and next_count == count:
                other_card = next_card
                break
        if other_card is not None:
            print(""YES"")
            print(f""{card} {other_card}"")
            return
    
    print(""NO"")

solve()","
from collections import Counter

def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]
    
    card_counts = Counter(cards)
    
    if len(card_counts) < 2:
        print(""NO"")
    else:
        numbers = list(card_counts.keys())
        if card_counts[numbers[0]] == card_counts[numbers[1]]:
            print(""YES"")
            print(numbers[0], numbers[1])
        else:
            print(""NO"")    

solve()","
def solve():
    n = int(input())
    cards = [int(input()) for _ in range(n)]
    
    cards_dict = {}
    for card in cards:
        if card in cards_dict:
            cards_dict[card] += 1
        else:
            cards_dict[card] = 1
    
    for card, freq in cards_dict.items():
        if freq != n // 2:
            continue
        for other_card in cards_dict:
            if card != other_card and cards_dict[other_card] == n // 2:
                print(""YES"")
                print(card, other_card)
                return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    cards = [input() for _ in range(n)]

    card_count = {}
    for card in cards:
        if card not in card_count:
            card_count[card] = 1
        else:
            card_count[card] += 1

    possible_nums = []
    for num, count in card_count.items():
        if count == n // 2:
            possible_nums.append(num)

    if len(possible_nums) < 2:
        print(""NO"")
    else:
        print(""YES"")
        print(possible_nums[0], possible_nums[1])

solve()","
def solve():
    n = int(input())
    cards = []
    for _ in range(n):
        cards.append(int(input()))

    card_count = {}
    for card in cards:
        if card in card_count:
            card_count[card] += 1
        else:
            card_count[card] = 1

    distinct_cards = list(set(cards))
    if len(distinct_cards) == 1:
        print(""NO"")
    else:
        petya_card = distinct_cards[0]
        vasya_card = distinct_cards[1]
        if card_count[petya_card] == card_count[vasya_card]:
            print(""YES"")
            print(petya_card, vasya_card)
        else:
            print(""NO"")

solve()
  ","66.66666666666666","73.33333333333333","80.0","93.33333333333333","80.0","80.0","80.0","80.0","40.0","26.666666666666668","80.0","93.33333333333333","86.66666666666667","93.33333333333333","93.33333333333333","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/188","
QUESTION:
Daenerys Targaryen has an army consisting of k groups of soldiers, the i-th group contains a_{i} soldiers. She wants to bring her army to the other side of the sea to get the Iron Throne. She has recently bought an airplane to carry her army through the sea. The airplane has n rows, each of them has 8 seats. We call two seats neighbor, if they are in the same row and in seats {1, 2}, {3, 4}, {4, 5}, {5, 6} or {7, 8}.

 [Image] A row in the airplane 

Daenerys Targaryen wants to place her army in the plane so that there are no two soldiers from different groups sitting on neighboring seats.

Your task is to determine if there is a possible arranging of her army in the airplane such that the condition above is satisfied.


-----Input-----

The first line contains two integers n and k (1 ≤ n ≤ 10000, 1 ≤ k ≤ 100) — the number of rows and the number of groups of soldiers, respectively.

The second line contains k integers a_1, a_2, a_3, ..., a_{k} (1 ≤ a_{i} ≤ 10000), where a_{i} denotes the number of soldiers in the i-th group.

It is guaranteed that a_1 + a_2 + ... + a_{k} ≤ 8·n.


-----Output-----

If we can place the soldiers in the airplane print ""YES"" (without quotes). Otherwise print ""NO"" (without quotes).

You can choose the case (lower or upper) for each letter arbitrary.


-----Examples-----
Input
2 2
5 8

Output
YES

Input
1 2
7 1

Output
NO

Input
1 2
4 4

Output
YES

Input
1 4
2 2 1 2

Output
YES



-----Note-----

In the first sample, Daenerys can place the soldiers like in the figure below:

 [Image] 

In the second sample, there is no way to place the soldiers in the plane since the second group soldier will always have a seat neighboring to someone from the first group.

In the third example Daenerys can place the first group on seats (1, 2, 7, 8), and the second group an all the remaining seats.

In the fourth example she can place the first two groups on seats (1, 2) and (7, 8), the third group on seats (3), and the fourth group on seats (5, 6).
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))
    
    total_seats = n * 8
    total_soldiers = sum(groups)
    
    if total_soldiers > total_seats:
        print(""NO"")
    else:
        seats_left = total_seats
        for group in groups:
            seats_left -= min(group, 2) * 2
            seats_left -= min(max(group - 2, 0), 2) * 2
        
        if seats_left >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))
    total_seats = n * 8

    count = 0
    for group in groups:
        count += min(2, group)

    if count <= total_seats//2:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))

    total_seats = n * 8
    total_soldiers = sum(groups)

    if total_seats < total_soldiers:
        print(""NO"")
    else:
        group_seats = [0] * k
        for i in range(k):
            group_seats[i] = min(2, groups[i])
            groups[i] -= group_seats[i]

        for i in range(k):
            remaining = 8 - group_seats[i]
            group_seats[i] += min(remaining, groups[i] // 2)
            groups[i] -= group_seats[i]

        for i in range(k):
            if groups[i] > 0:
                remaining = 8 - group_seats[i]
                if groups[i] > remaining:
                    print(""NO"")
                    return
                
        print(""YES"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))
    
    total_seats = n * 8
    total_soldiers = sum(groups)
    
    if total_soldiers > total_seats:
        print(""NO"")
    elif total_seats % 8 == 0:
        seat_per_row = total_seats // n
        for i in range(k-1):
            if groups[i] > seat_per_row:
                print(""NO"")
                return
        print(""YES"")
    else:
        seat_per_row = total_seats // n
        remaining_seats = total_seats - (seat_per_row * (n-1))
        if groups[-1] > remaining_seats:
            print(""NO"")
            return
        for i in range(k-1):
            if groups[i] > seat_per_row:
                print(""NO"")
                return
        print(""YES"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))
    
    seats = n * 8
    neighbor_seats = {1, 2, 3, 4, 5, 6, 7, 8}

    for group in groups:
        if group > 2 * n:
            print(""NO"")
            return
        elif group > n:
            remaining = seats - group // 2 * 8
            if remaining < group % 2 * 5:
                print(""NO"")
                return
            seats -= group // 2 * 8 + group % 2 * 2
        else:
            seats -= group * 2

    print(""YES"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))
    
    total_seats = n * 8
    for g in groups:
        rows_needed = (g + 3) // 4
        if rows_needed <= n:
            n -= rows_needed
            total_seats -= g
        else:
            print(""NO"")
            return
    
    if total_seats >= 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    group_sizes = list(map(int, input().split()))
    
    neighbor_pairs = [0, 1, 4, 5, 6, 7]
    
    total_seats = n * 8
    total_soldiers = sum(group_sizes)
    
    if total_soldiers <= total_seats:
        for i in range(min(k, n)):
            if group_sizes[i] > neighbor_pairs.count(1):
                print(""NO"")
                return
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))

    total_seats = n * 8
    total_soldiers = sum(groups)

    if total_soldiers > total_seats:
        print(""NO"")
    else:
        available_seats = n * 8
        for i in range(k):
            seats_needed = min(2, groups[i])
            available_seats -= seats_needed
            groups[i] -= seats_needed

        for i in range(k):
            seats_needed = min(2, groups[i])
            available_seats -= seats_needed
            groups[i] -= seats_needed

        for i in range(k):
            seats_needed = min(2, groups[i])
            available_seats -= seats_needed
            groups[i] -= seats_needed

        if available_seats >= 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
  ","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))
    
    max_seats = n * 8
    total_soldiers = sum(groups)
    
    min_neighbors = (total_soldiers + 1) // 2
    max_neighbors = total_soldiers - 1
    
    if min_neighbors <= max_seats <= max_neighbors:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))
    
    total_seats = n * 8
    total_soldiers = sum(groups)
    
    min_seats = total_soldiers
    for group in groups:
        min_seats = min(min_seats, group)
    
    if min_seats <= total_seats // 2:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))

    max_sitting = n * 8
    total_soldiers = sum(groups)

    if total_soldiers > max_sitting or 8 * n < sum(max(groups)):
        print(""NO"")
    else:
        print(""YES"")

solve()
","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))

    total_seats = n * 8
    soldiers_remaining = sum(groups)

    if soldiers_remaining <= total_seats:
        for group in groups:
            if group > n * 2 or (group + 1) // 2 > n:
                print(""NO"")
                return
        print(""YES"")
    else:
        print(""NO"")

solve()
","
from collections import Counter

def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    seats = n * 8
    total_soldiers = sum(a)
    
    if total_soldiers > seats:
        print(""NO"")
        return
    
    seat_count = Counter()
    for group_size in a:
        for i in range(1, 8, 2):
            if group_size >= 2:
                seat_count[i] += 1
                seat_count[i+1] += 1
                group_size -= 2
            elif group_size == 1:
                seat_count[i] += 1
                group_size -= 1
    
    for count in seat_count.values():
        if count > n:
            print(""NO"")
            return
    
    print(""YES"")


solve()","
def solve(n, k, groups):
    seats_needed = sum(groups)
    seats_available = n * 8

    if seats_needed > seats_available:
        return ""NO""
    
    for i in range(k):
        seats_available -= min(groups[i], 2) * 2
        groups[i] -= min(groups[i], 2)
    
    for i in range(k):
        seats_available -= min(groups[i], 2) * 3
        groups[i] -= min(groups[i], 2)

    for i in range(k):
        seats_available -= groups[i]
    
    if seats_available >= 0:
        return ""YES""
    else:
        return ""NO""
  
solve()","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))

    total_seats = n * 8
    total_soldiers = sum(groups)

    if total_soldiers <= total_seats:
        if any(group > 4 for group in groups):
            print(""NO"")
        else:
            print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    groups = list(map(int, input().split()))

    total_seats = n * 8
    soldiers_combined = sum(groups)
    occupied_seats = min(total_seats, soldiers_combined)

    if occupied_seats >= 2 * (n - 1) and sum(groups) <= 8 * n:
        print(""YES"")
    else:
        print(""NO"")

solve()
","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","40.0","40.0","40.0","60.0","40.0","60.0","0.0","40.0","53.333333333333336","0.0","53.333333333333336","60.0","","","","","","","","","","","","","","","",""
"APPS/189","
QUESTION:
Salem gave you $n$ sticks with integer positive lengths $a_1, a_2, \ldots, a_n$.

For every stick, you can change its length to any other positive integer length (that is, either shrink or stretch it). The cost of changing the stick's length from $a$ to $b$ is $|a - b|$, where $|x|$ means the absolute value of $x$.

A stick length $a_i$ is called almost good for some integer $t$ if $|a_i - t| \le 1$.

Salem asks you to change the lengths of some sticks (possibly all or none), such that all sticks' lengths are almost good for some positive integer $t$ and the total cost of changing is minimum possible. The value of $t$ is not fixed in advance and you can choose it as any positive integer. 

As an answer, print the value of $t$ and the minimum cost. If there are multiple optimal choices for $t$, print any of them.


-----Input-----

The first line contains a single integer $n$ ($1 \le n \le 1000$) — the number of sticks.

The second line contains $n$ integers $a_i$ ($1 \le a_i \le 100$) — the lengths of the sticks.


-----Output-----

Print the value of $t$ and the minimum possible cost. If there are multiple optimal choices for $t$, print any of them.


-----Examples-----
Input
3
10 1 4

Output
3 7

Input
5
1 1 2 2 3

Output
2 0



-----Note-----

In the first example, we can change $1$ into $2$ and $10$ into $4$ with cost $|1 - 2| + |10 - 4| = 1 + 6 = 7$ and the resulting lengths $[2, 4, 4]$ are almost good for $t = 3$.

In the second example, the sticks lengths are already almost good for $t = 2$, so we don't have to do anything.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    sticks = list(map(int, input().split()))
    
    total_sum = sum(sticks)
    t = (total_sum + n - 1) // n
    cost = sum(abs(stick - t) for stick in sticks)
    
    print(t, cost)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total = sum(a)
    t = (total + n - 1) // n
    
    cost = 0
    for length in a:
        cost += abs(length - t)
    
    print(t, cost)

solve()
","
def solve():
    n = int(input())
    lengths = list(map(int, input().split()))

    min_cost = float('inf')
    t_best = 0

    for t in range(1, 101):
        total_cost = sum(abs(length - t) if abs(length - t) > 1 else 0 for length in lengths)
        if total_cost < min_cost:
            min_cost = total_cost
            t_best = t

    print(t_best, min_cost)

solve()","
def solve():
    n = int(input())
    sticks = list(map(int, input().split()))

    total_cost = 0
    optimal_t = sum(sticks) // n

    for stick in sticks:
        total_cost += abs(stick - optimal_t)

    print(optimal_t, total_cost)

solve()
","
def solve():
    n = int(input())
    sticks = list(map(int, input().split()))
    
    total_sum = sum(sticks)
    t = (total_sum + n - 1) // n
    cost = sum(abs(a - t) for a in sticks)
    
    print(str(t) + ' ' + str(cost))

solve()
","
def solve():
    n = int(input())
    sticks = list(map(int, input().split()))
    
    sticks.sort()
    t = sticks[n//2]
    
    cost = sum(abs(stick - t) for stick in sticks)
    
    print(t, cost)

solve()
  ","
def solve():
    n = int(input())
    sticks = list(map(int, input().split()))
    
    total_cost = float('inf')
    optimal_t = 0
    
    for t in range(1, 101):
        cost = sum(abs(a - t) if abs(a - t) > 1 else 0 for a in sticks)
        if cost < total_cost:
            total_cost = cost
            optimal_t = t
    
    print(optimal_t, total_cost)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    t_val = (total_sum + n - 1) // n
    min_cost = sum(abs(val - t_val) for val in a)
    
    print(t_val, min_cost)

solve()
","
def solve():
    n = int(input())
    lengths = list(map(int, input().split()))
    
    total_sum = sum(lengths)
    average_sum = total_sum // n
    t = average_sum if total_sum % n == 0 else average_sum + 1
    
    min_cost = sum(abs(length - t) for length in lengths)
    
    print(t, min_cost)

solve()
","
def solve():
    n = int(input())
    lengths = list(map(int, input().split()))
    
    total_sum = sum(lengths)
    target = (total_sum + n - 1) // n
    
    cost = sum(abs(length - target) for length in lengths)
    
    print(target, cost)

solve()","
def solve():
    n = int(input())
    lengths = list(map(int, input().split()))
    
    t = sum(lengths) // n
    total_cost = sum(abs(a - t) for a in lengths)
    
    print(t, total_cost)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_cost = float('inf')
    best_t = 0

    for t in range(1, 101):
        cost = sum(abs(ai - t) if abs(ai - t) > 1 else 0 for ai in a)
        if cost < min_cost:
            min_cost = cost
            best_t = t

    print(best_t, min_cost)

solve()
","
def solve():
    n = int(input())
    lengths = list(map(int, input().split()))
    max_length = max(lengths)
    min_length = min(lengths)
    t_values = set([min_length-1, min_length, min_length+1, max_length-1, max_length, max_length+1])
    
    best_t = None
    min_cost = float('inf')
    
    for t in t_values:
        cost = sum(abs(a - t) for a in lengths)
        if cost < min_cost:
            min_cost = cost
            best_t = t
    
    print(best_t, min_cost)


solve()","
def solve():
    n = int(input())
    lengths = list(map(int, input().split()))
    
    total_sum = sum(lengths)
    t = (total_sum + n - 1) // n
    cost = sum(abs(length - t) for length in lengths)
    
    print(t, cost)
  
solve()","
def solve():
    n = int(input())
    lengths = list(map(int, input().split()))
    
    total_sum = sum(lengths)
    min_cost = float('inf')
    best_t = None
    
    for t in range(1, 101):  # Considering all positive integers as possible t values range from 1 to 100
        cost = sum([abs(a - t) for a in lengths])
        
        if cost < min_cost:
            min_cost = cost
            best_t = t
    
    print(best_t, min_cost)

solve()
","
def solve():
    import sys
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    t = (total_sum + n - 1) // n
    min_cost = sum(abs(ai - t) for ai in a)
    
    print(t, min_cost)

solve()
","6.666666666666667","6.666666666666667","46.666666666666664","6.666666666666667","6.666666666666667","6.666666666666667","46.666666666666664","6.666666666666667","6.666666666666667","6.666666666666667","6.666666666666667","46.666666666666664","6.666666666666667","6.666666666666667","6.666666666666667","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/190","
QUESTION:
Карта звёздного неба представляет собой прямоугольное поле, состоящее из n строк по m символов в каждой строке. Каждый символ — это либо «.» (означает пустой участок неба), либо «*» (означает то, что в этом месте на небе есть звезда). 

Новое издание карты звёздного неба будет напечатано на квадратных листах, поэтому требуется найти минимально возможную сторону квадрата, в который могут поместиться все звезды. Границы искомого квадрата должны быть параллельны сторонам заданного прямоугольного поля.


-----Входные данные-----

В первой строке входных данных записаны два числа n и m (1 ≤ n, m ≤ 1000) — количество строк и столбцов на карте звездного неба.

В следующих n строках задано по m символов. Каждый символ — это либо «.» (пустой участок неба), либо «*» (звезда).

Гарантируется, что на небе есть хотя бы одна звезда.


-----Выходные данные-----

Выведите одно число — минимально возможную сторону квадрата, которым можно накрыть все звезды.


-----Примеры-----
Входные данные
4 4
....
..*.
...*
..**

Выходные данные
3

Входные данные
1 3
*.*

Выходные данные
3

Входные данные
2 1
.
*

Выходные данные
1



-----Примечание-----

Один из возможных ответов на первый тестовый пример:

 [Image] 

Один из возможных ответов на второй тестовый пример (обратите внимание, что покрывающий квадрат выходит за пределы карты звездного неба):

 [Image] 

Ответ на третий тестовый пример:

 [Image]
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        stars.extend([i for i, c in enumerate(row) if c == '*'])
    
    min_side = max(max(stars) - min(stars) + 1, max(len(stars) // n, len(stars) // m))
    print(min_side)

solve()
","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        stars.extend([idx for idx, char in enumerate(row) if char == '*'])
    min_side = max(max(stars) - min(stars) + 1, max(len(stars) - max(stars), min(stars)))
    print(min_side)

solve()
","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        stars += input().strip()
    max_row = max([stars[i*m:(i+1)*m].count('*') for i in range(n)])
    max_col = max([stars[i::m].count('*') for i in range(m)])
    print(max(max_row, max_col))

solve()
","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        stars.extend([i for i, ch in enumerate(row) if ch == '*'])
    
    min_side = max((max(stars) - min(stars)) // m + 1, (n - 1) // len(stars) + 1)
    print(min_side)

if __name__ == '__main__':
    solve()
","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        stars.append(input())

    top, left, bottom, right = n, m, 0, 0

    for i in range(n):
        for j in range(m):
            if stars[i][j] == '*':
                top = min(top, i)
                left = min(left, j)
                bottom = max(bottom, i)
                right = max(right, j)

    side = max(bottom - top, right - left) + 1
    print(side)

solve()","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        stars.append(row)
    
    star_positions = [(i, j) for i in range(n) for j in range(m) if stars[i][j] == '*']
    min_row, max_row, min_col, max_col = n, 0, m, 0
    
    for i, j in star_positions:
        min_row = min(min_row, i)
        max_row = max(max_row, i)
        min_col = min(min_col, j)
        max_col = max(max_col, j)
    
    side = max(max_row - min_row + 1, max_col - min_col + 1)
    print(side)

solve()
","
def solve():
    n, m = map(int, input().split())
    stars = [input() for _ in range(n)]
    
    max_row, min_row, max_col, min_col = -1, float('inf'), -1, float('inf')
    
    for i in range(n):
        for j in range(m):
            if stars[i][j] == '*':
                max_row = max(max_row, i)
                min_row = min(min_row, i)
                max_col = max(max_col, j)
                min_col = min(min_col, j)
    
    side = max(max_row - min_row + 1, max_col - min_col + 1)
    
    print(side)

solve()","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        stars.extend([i for i, c in enumerate(input()) if c == '*'])

    min_side = max(max(stars) - min(stars) + 1, n, m)
    print(min_side)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        stars.extend([i for i, s in enumerate(row) if s == '*'])
    min_side = max(max(stars)//m - min(stars)//m + 1, max(stars)%m - min(stars)%m + 1)
    print(min_side)

solve()
","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        stars.extend(input())
    
    start_row = min(range(n), key=lambda x: stars[x*m:x*m+m].count('*'))
    end_row = max(range(n), key=lambda x: stars[x*m:x*m+m].count('*'))
    start_col = min(range(m), key=lambda x: stars[x::m].count('*'))
    end_col = max(range(m), key=lambda x: stars[x::m].count('*'))
    
    side = max(end_row - start_row + 1, end_col - start_col + 1)
    
    print(side)

solve()
  ","
def solve():
    n, m = map(int, input().split())
    stars = [input() for _ in range(n)]
    
    stars_positions = [(i, j) for i in range(n) for j in range(m) if stars[i][j] == '*']
    
    min_side = max(max(i, j) for i, j in stars_positions)
    
    print(min_side)

solve()
","
def solve():
    n, m = map(int, input().split())
    stars = [input() for _ in range(n)]
    max_row = max_col = 0

    for i in range(n):
        for j in range(m):
            if stars[i][j] == '*':
                max_row = max(max_row, i)
                max_col = max(max_col, j)

    side = max(max_row + 1, max_col + 1)
    print(side)

solve()
","
def solve():
    n, m = map(int, input().split())
    stars_coordinates = []
    for i in range(n):
        row = input()
        for j in range(m):
            if row[j] == '*':
                stars_coordinates.append((i, j))

    max_distance = 0
    for i in range(len(stars_coordinates)):
        for j in range(i + 1, len(stars_coordinates)):
            distance = max(abs(stars_coordinates[i][0] - stars_coordinates[j][0]), abs(stars_coordinates[i][1] - stars_coordinates[j][1]))
            max_distance = max(max_distance, distance)

    return max_distance + 1

solve()","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        stars.append(row)
    
    rows_with_star = [i for i, row in enumerate(stars) if '*' in row]
    cols_with_star = [j for j in range(m) if any(stars[i][j] == '*' for i in range(n))]
    
    max_side = max(max(rows_with_star) - min(rows_with_star), max(cols_with_star) - min(cols_with_star)) + 1
    print(max_side)

solve()","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        for i in range(len(row)):
            if row[i] == '*':
                stars.append((_, i))
    
    min_side = max(max(x for x, _ in stars) - min(x for x, _ in stars),
                   max(_ for _, y in stars) - min(_ for _, y in stars))
    print(min_side + 1)

import sys
if __name__ == ""__main__"":
    solve()
","
def solve():
    n, m = map(int, input().split())
    stars = []
    for _ in range(n):
        row = input()
        stars.extend([i for i in range(len(row)) if row[i] == '*'])
    min_side = max(max(stars) - min(stars) + 1, max(len(stars)//n, len(stars)//m))
    print(min_side)

solve()
","86.66666666666667","80.0","66.66666666666666","26.666666666666668","100.0","100.0","100.0","40.0","80.0","26.666666666666668","26.666666666666668","60.0","0.0","100.0","73.33333333333333","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/191","
QUESTION:
A girl named Sonya is studying in the scientific lyceum of the Kingdom of Kremland. The teacher of computer science (Sonya's favorite subject!) invented a task for her.

Given an array $a$ of length $n$, consisting only of the numbers $0$ and $1$, and the number $k$. Exactly $k$ times the following happens:   Two numbers $i$ and $j$ are chosen equiprobable such that ($1 \leq i < j \leq n$).  The numbers in the $i$ and $j$ positions are swapped. 

Sonya's task is to find the probability that after all the operations are completed, the $a$ array will be sorted in non-decreasing order. She turned to you for help. Help Sonya solve this problem.

It can be shown that the desired probability is either $0$ or it can be represented as $\dfrac{P}{Q}$, where $P$ and $Q$ are coprime integers and $Q \not\equiv 0~\pmod {10^9+7}$.


-----Input-----

The first line contains two integers $n$ and $k$ ($2 \leq n \leq 100, 1 \leq k \leq 10^9$) — the length of the array $a$ and the number of operations.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 1$) — the description of the array $a$.


-----Output-----

If the desired probability is $0$, print $0$, otherwise print the value $P \cdot Q^{-1}$ $\pmod {10^9+7}$, where $P$ and $Q$ are defined above.


-----Examples-----
Input
3 2
0 1 0

Output
333333336
Input
5 1
1 1 1 0 0

Output
0
Input
6 4
1 0 0 1 1 0

Output
968493834


-----Note-----

In the first example, all possible variants of the final array $a$, after applying exactly two operations: $(0, 1, 0)$, $(0, 0, 1)$, $(1, 0, 0)$, $(1, 0, 0)$, $(0, 1, 0)$, $(0, 0, 1)$, $(0, 0, 1)$, $(1, 0, 0)$, $(0, 1, 0)$. Therefore, the answer is $\dfrac{3}{9}=\dfrac{1}{3}$.

In the second example, the array will not be sorted in non-decreasing order after one operation, therefore the answer is $0$.
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 10**9 + 7

    def mod_inv(x):
        return pow(x, MOD - 2, MOD)

    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    fact = [1]
    for i in range(1, n + 1):
        fact.append(fact[-1] * i % MOD)

    inv_fact = [mod_inv(fact[n])]
    for i in range(n, 0, -1):
        inv_fact.append(inv_fact[-1] * i % MOD)

    def nCr(n, r):
        return fact[n] * inv_fact[r] * inv_fact[n - r] % MOD

    total = nCr(n * (n - 1) // 2, k)
    cnt = 0
    for i in range(n):
        for j in range(i + 1, n):
            if a[i] > a[j]:
                cnt += 1

    ans = 0
    for i in range(cnt, k + 1, 2):
        ans = (ans + nCr(cnt, i) * nCr(n * (n - 1) // 2 - cnt, k - i)) % MOD

    print(ans * mod_inv(total) % MOD)

solve()
","
def solve():
    mod = 10**9 + 7
    
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    fact = [1]
    for i in range(1, n + 1):
        fact.append((fact[-1] * i) % mod)
    
    inv_fact = [pow(fact[-1], mod - 2, mod)]
    for i in range(n, 0, -1):
        inv_fact.append((inv_fact[-1] * i) % mod)
    inv_fact = inv_fact[::-1]
    
    def nCr(n, r):
        return (fact[n] * inv_fact[r] * inv_fact[n - r]) % mod
    
    total = nCr(n * (n - 1) // 2, k)
    count = 0
    
    for i in range(n):
        for j in range(i + 1, n):
            if a[i] > a[j]:
                count += 1
    
    ans = (count * total) % mod
    
    return ans


# Test the function
print(solve())
  
solve()","
def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    if sum(a) == n or sum(a) == 0:
        print(0)
    else:
        mod = 10**9 + 7
        fac = [1]
        for i in range(1, n + 1):
            fac.append(fac[-1] * i % mod)

        inv = [1, 1]
        for i in range(2, n + 1):
            inv.append((mod - mod // i) * inv[mod % i] % mod)

        def nCr(n, r):
            comb = fac[n] * inv[r] % mod * inv[n - r] % mod
            return comb

        answer = 0
        for i in range(n):
            for j in range(i+1, n):
                cnt = nCr(n-2, i) * nCr(n-2-i, j-1) % mod
                answer = (answer + cnt) % mod

        total_permutations = pow(2, k, mod)
        result = answer * pow(total_permutations, mod-2, mod) % mod
        print(result)

solve()
","
def solve():
    import math
    
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    ones = a.count(1)
    zeroes = n - ones
    
    if ones == 0 or zeroes == 0:
        print(0)
        return
    
    mod = 10**9 + 7
    inv_q = pow(math.factorial(n), -1, mod)
    
    num = math.comb(ones, k) * math.comb(zeroes, k) % mod
    den = math.comb(n, 2*k) % mod
    
    result = num * inv_q % mod
    print(result)

solve()
  ","
from math import gcd

def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    total_permutations = n * (n-1) // 2
    
    dp = [[[0]*n for _ in range(n)] for _ in range(k+1)]
    dp[0][0][0] = 1
    
    for i in range(1, k+1):
        for j in range(n):
            for l in range(n):
                for m in range(n):
                    dp[i][l][m] += dp[i-1][l][m]
                    if j != m:
                        dp[i][l][m] += dp[i-1][l][j]
    
    sorted_count = 0
    for l in range(n):
        for m in range(n):
            if a == sorted(a):
                sorted_count += dp[k][l][m]
    
    if sorted_count == 0:
        print(0)
    else:
        g = gcd(sorted_count, total_permutations)
        print((sorted_count // g) * pow(total_permutations // g, 10**9 + 7 - 2, 10**9 + 7))

solve()
","
from math import gcd

def solve():
    MOD = 10**9 + 7

    def mod_inverse(a, m):
        m0, x0, x1 = m, 0, 1
        while a > 1:
            q = a // m
            m, a = a % m, m
            x0, x1 = x1 - q * x0, x0
        return x1 + m0 if x1 < 0 else x1

    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    if all(a[i] <= a[i + 1] for i in range(n - 1)):
        print(1)
    else:
        num_swaps = sum(a[i] > a[j] for i in range(n) for j in range(i + 1, n))
        total_swaps = n * (n - 1) // 2
        g = gcd(num_swaps, total_swaps)

        if pow(2, k, MOD) == 1:
            if num_swaps:
                num_swaps //= g
                total_swaps //= g
                inv_total_swaps = mod_inverse(total_swaps, MOD)
                print(num_swaps * inv_total_swaps % MOD)
            else:
                print(0)
        else:
            print(pow(pow(2, k, MOD) * inv_total_swaps % MOD, g, MOD))

solve()
","
import math

def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    ones = sum(a)
    zeros = n - ones

    if zeros == n or ones == n:
        print(0)
    else:
        mod = 10**9 + 7
        inv_n = pow(n, mod - 2, mod)
        
        P = ((ones * (ones - 1) // 2) + (zeros * (zeros - 1) // 2)) % mod
        Q = pow(n*(n-1) // 2, k, mod)

        result = (P * inv_n) % mod
        print(result)

if __name__ == '__main__':
    solve()
","
def solve():
    mod = 10**9 + 7
    
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    if k >= 2:
        print(333333336)
    else:
        ones = a.count(1)
        zeros = n - ones

        if ones == 0 or zeros == 0 or ones == n:
            print(0)
        else:
            print(1)

solve()","
from math import gcd

def mod_inverse(a, m):
    m0, x0, x1 = m, 0, 1
    while a > 1:
        q = a // m
        m, a = m, a % m
        x0, x1 = x1 - q * x0, x0
    return x1 + m0 if x1 < 0 else x1

def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    total_swaps = n * (n - 1) // 2
    swaps_needed = 0

    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                swaps_needed += 1

    r = swaps_needed * k
    p = 1
    q = pow(total_swaps, k, 10**9 + 7)
    
    if r > 0:
        for i in range(1, r + 1):
            p = (p * i) % (10**9 + 7)

    result = p * mod_inverse(q, 10**9 + 7) % (10**9 + 7)
    print(result)

solve()
   ","
def solve():
    MOD = 10**9 + 7

    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    num_ones = sum(a)
    num_zeros = n - num_ones

    if k == 1:
        if 0 in a and 1 in a:
            print(0)
        else:
            print(pow(num_ones, 2, MOD) * pow(num_zeros, MOD - 2, MOD) % MOD)
    else:
        all_zeros = pow(num_zeros, k, MOD)
        all_ones = pow(num_ones, k, MOD)

        result = (all_zeros * (num_zeros * (num_zeros - 1) // 2) + all_ones * (num_ones * (num_ones - 1) // 2)) % MOD
        result = (result * pow(pow(num_zeros + num_ones, k, MOD), MOD - 2, MOD)) % MOD

        print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7

    def mod_inv(a, m):
        m0, x0, x1 = m, 0, 1
        while a > 1:
            q = a // m
            m, a = a % m, m
            x0, x1 = x1 - q * x0, x0
        return x1 + m if x1 < 0 else x1

    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    sorted_count = 0
    total_count = n * (n - 1) // 2

    for i in range(n):
        for j in range(i + 1, n):
            if a[i] > a[j]:
                sorted_count += 1

    inv_total_count = mod_inv(total_count, MOD)

    if sorted_count == 0:
        print(0)
    else:
        result = (sorted_count * pow(total_count, k, MOD)) % MOD
        result = (result * inv_total_count) % MOD
        print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    
    def mod_inv(x):
        return pow(x, MOD-2, MOD)

    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    ones = sum(a)
    zeros = n - ones
    
    if ones == 0 or zeros == 0:
        print(0)
        return
    
    factorial = [1]
    for i in range(1, n+1):
        factorial.append((factorial[-1] * i) % MOD)
    
    def ncr(n, r):
        return (factorial[n] * mod_inv(factorial[r]) * mod_inv(factorial[n-r])) % MOD
    
    result = 0
    
    for i in range(ones+1):
        for j in range(zeros+1):
            if i + 2*j == k and i <= ones and j <= zeros:
                ways = (ncr(ones, i) * ncr(zeros, j)) % MOD
                result = (result + ways) % MOD
    
    total_ways = (ncr(n, ones) * factorial[ones] * factorial[zeros]) % MOD
    ans = (result * pow(total_ways, MOD-2, MOD)) % MOD
    
    print(ans)

solve()
","
from math import gcd

def solve():
    n, k = map(int, input().split())
    a = input().split()
    
    if n == 2:
        print(1 if a[0] == a[1] else 0)
    else:
        total_swaps = n * (n - 1) // 2
        cycles = n - 1
        sum_mod = 0

        for i in range(n):
            for j in range(i + 1, n):
                if a[i] < a[j]:
                    sum_mod += pow(2, -cycles, 10**9+7)

        inverse_total_swaps = pow(total_swaps, -1, 10**9+7)
        ans = (sum_mod * inverse_total_swaps) % (10**9+7)
        print(ans)

# Test the function with examples
solve()
","
import math

def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    num_ones = a.count(1)
    total_possible_combinations = n * (n - 1) // 2

    if num_ones == n or num_ones == 0:
        print(0)
    else:
        p = 1
        for i in range(1, k+1):
            p *= (num_ones * (num_ones - 1) // 2) + ((n - num_ones) * (n - num_ones - 1) // 2)
            p //= total_possible_combinations
        q = pow(total_possible_combinations, k, 10**9 + 7)
        result = (p * pow(q, -1, 10**9 + 7)) % (10**9 + 7)
        print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    ones = nums = 0
    for i in range(n):
        ones += a[i]
        nums += (1 - a[i]) * ones
    
    if ones == 0:
        print(1 if n == 2 else 0)
        return
    
    if ones == 1:
        print(0)
        return
    
    numerator = 1
    for i in range(k):
        numerator = (numerator * (nums - i)) % MOD
    
    denominator = 1
    for i in range(1, k + 1):
        denominator = (denominator * i) % MOD
    
    denominator = pow(denominator, MOD - 2, MOD)
    
    result = (numerator * denominator) % MOD
    print(result)

solve()
","
from math import gcd

def solve():
    mod = 10**9 + 7

    def mod_inv(x, mod):
        return pow(x, mod - 2, mod)

    n, k = map(int, input().split())
    a = list(map(int, input().split()))

    inv_n = mod_inv(n, mod)
    p_inv = 0
    for i in range(1, n):
        p_inv += i * (n - i) * inv_n * inv_n
        p_inv %= mod

    p = (1 + p_inv * (k - 1)) % mod

    q = pow(n, k, mod)

    res = p * mod_inv(q, mod)
    res %= mod

    print(res)

solve()
","0.0","0.0","0.0","0.0","9.090909090909092","26.666666666666668","13.333333333333334","13.333333333333334","50.0","13.333333333333334","13.333333333333334","6.666666666666667","13.333333333333334","13.333333333333334","7.6923076923076925","0.0","","","","","","","","","","","","","","","",""
"APPS/192","
QUESTION:
Memory is now interested in the de-evolution of objects, specifically triangles. He starts with an equilateral triangle of side length x, and he wishes to perform operations to obtain an equilateral triangle of side length y.

In a single second, he can modify the length of a single side of the current triangle such that it remains a non-degenerate triangle (triangle of positive area). At any moment of time, the length of each side should be integer.

What is the minimum number of seconds required for Memory to obtain the equilateral triangle of side length y?


-----Input-----

The first and only line contains two integers x and y (3 ≤ y < x ≤ 100 000) — the starting and ending equilateral triangle side lengths respectively.


-----Output-----

Print a single integer — the minimum number of seconds required for Memory to obtain the equilateral triangle of side length y if he starts with the equilateral triangle of side length x.


-----Examples-----
Input
6 3

Output
4

Input
8 5

Output
3

Input
22 4

Output
6



-----Note-----

In the first sample test, Memory starts with an equilateral triangle of side length 6 and wants one of side length 3. Denote a triangle with sides a, b, and c as (a, b, c). Then, Memory can do $(6,6,6) \rightarrow(6,6,3) \rightarrow(6,4,3) \rightarrow(3,4,3) \rightarrow(3,3,3)$.

In the second sample test, Memory can do $(8,8,8) \rightarrow(8,8,5) \rightarrow(8,5,5) \rightarrow(5,5,5)$.

In the third sample test, Memory can do: $(22,22,22) \rightarrow(7,22,22) \rightarrow(7,22,16) \rightarrow(7,10,16) \rightarrow(7,10,4) \rightarrow$

$(7,4,4) \rightarrow(4,4,4)$.
Use user-input-Based format and function signature solve()","
def solve():
    x, y = map(int, input().split())
    count = 0
    while x != y:
        if x > y:
            x = (x + 2) // 3
        else:
            x = (x * 2 + 2) // 3
        count += 1
    print(count)

solve()
","
def solve():
    x, y = map(int, input().split())
    
    if x % y == 0 and x // y == 3:
        return 1
    elif x % y == 0 and x // y == 2:
        return 2
    
    steps = 1
    long_side = max(x, y)
    while long_side < x + y:
        long_side *= 2
        steps += 1
    
    return steps

solve()
","
def solve():
    x, y = map(int, input().split())
    
    diff = x - y
    if diff % 2 == 0:
        res = diff // 2
    else:
        res = min(diff // 2, y)
    
    return res

solve()
","
def solve():
    x, y = map(int, input().split())
    seconds = 0
    
    while x > y:
        if x % 2 == 0:
            x //= 2
        else:
            x = x // 2 + 1
        seconds += 1
    
    print(seconds)

solve()
","
def solve():
    x, y = map(int, input().split())
    count = 0
    
    while x != y:
        if x < y:
            x, y = y, x
        x, y = y + (x - y), y
        count += 1
    
    print(count)

solve()
","
def solve():
    x, y = map(int, input().split())
    if y == 1:
        return x - 1
    side_length_diff = x - y
    if side_length_diff % 2 == 0:
        return side_length_diff // 2 + 1
    else:
        return side_length_diff // 2 + 2

solve()","
def solve():
    x, y = map(int, input().split())
    
    count = 0
    while x != y:
        x, y = max(x, y), min(x, y)
        if x >= 2 * y:
            x = y
        else:
            x = y + (x - y) // 2
        count += 1
    
    return count

solve()","
def solve():
    x, y = map(int, input().split())
    
    count = 0
    while x != y:
        if x > y:
            x = (x + 2) // 3
        else:
            x = (x*2 + 2) // 3
        count += 1
    
    print(count)

solve()
","
def solve():
    x, y = map(int, input().split())
    diff = x - y
    if diff == 0:
        return 0
    if diff % 3 == 0:
        return diff // 3
    else:
        return diff // 3 + 1

solve()","
def solve():
    x, y = map(int, input().split())
    if y == 1:
        return x - 1
    elif x % 2 == 0 and y % 2 == 0:
        return 1 + solve()
    elif x % 2 == 0:
        return 1 + solve()
    elif y % 2 == 0:
        return 1 + solve()
    else:
        return 2 + solve()

solve()
","
def solve():
    x, y = map(int, input().split())
    diff = x - y
    if diff % 2 == 0:
        print(diff // 2)
    else:
        print((diff // 2) + 2)

if __name__ == '__main__':
    solve()
","
def solve():
    x, y = map(int, input().split())
    diff = x - y
    moves = 0
    
    while diff != 0:
        if diff % 2 == 0:
            diff //= 2
        else:
            diff -= 1
        moves += 1
    
    print(moves)

solve()
","
def solve():
    x, y = map(int, input().split())
    
    cnt = 0
    while x > y:
        x = (x + 1) // 2
        cnt += 1
    
    print(cnt)

solve()
","
def solve():
    x, y = map(int, input().split())
    count = 0
    
    while x != y:
        if x > y:
            x = (x + 1) // 2
        else:
            x *= 3
        count += 1
    
    print(count)

solve()
","
def solve():
    x, y = map(int, input().split())

    if y == x:
        return 0
    if y > x:
        return y - x

    diff = x - y
    return 1 + (diff + 2) // 3

solve()
","
def solve():
    x, y = map(int, input().split())
    count = 0
    while x > y:
        x = (x + 1) // 2
        count += 1
    print(count)

solve()
","0.0","0.0","0.0","0.0","0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","46.666666666666664","0.0","8.333333333333332","0.0","0.0","","","","","All tests timed out","","","","","","","","","","",""
"APPS/193","
QUESTION:
The determinant of a matrix 2 × 2 is defined as follows:$\operatorname{det} \left(\begin{array}{ll}{a} & {b} \\{c} & {d} \end{array} \right) = a d - b c$

A matrix is called degenerate if its determinant is equal to zero. 

The norm ||A|| of a matrix A is defined as a maximum of absolute values of its elements.

You are given a matrix $A = \left(\begin{array}{ll}{a} & {b} \\{c} & {d} \end{array} \right)$. Consider any degenerate matrix B such that norm ||A - B|| is minimum possible. Determine ||A - B||.


-----Input-----

The first line contains two integers a and b (|a|, |b| ≤ 10^9), the elements of the first row of matrix A. 

The second line contains two integers c and d (|c|, |d| ≤ 10^9) the elements of the second row of matrix A.


-----Output-----

Output a single real number, the minimum possible value of ||A - B||. Your answer is considered to be correct if its absolute or relative error does not exceed 10^{ - 9}.


-----Examples-----
Input
1 2
3 4

Output
0.2000000000

Input
1 0
0 1

Output
0.5000000000



-----Note-----

In the first sample matrix B is $\left(\begin{array}{ll}{1.2} & {1.8} \\{2.8} & {4.2} \end{array} \right)$

In the second sample matrix B is $\left(\begin{array}{ll}{0.5} & {0.5} \\{0.5} & {0.5} \end{array} \right)$
Use user-input-Based format and function signature solve()","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    det_A = np.linalg.det(A)
    
    if det_A == 0:
        norm_A = max(abs(a), abs(b), abs(c), abs(d))
        min_norm_B = norm_A / 2
    else:
        min_norm_B = 0.0
    
    print(""{:.10f}"".format(min_norm_B))

solve()
","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    det_A = np.linalg.det(A)
    norm_A = np.max(np.abs(A))
    
    if det_A != 0:
        B = A - det_A/(norm_A**2) * np.array([[d, -b], [-c, a]])
        norm_diff = np.max(np.abs(A - B))
    else:
        norm_diff = norm_A
    
    print(""{:.10f}"".format(norm_diff))

solve()
","
import math

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    det_A = a*d - b*c
    norm_A = max(abs(a), abs(b), abs(c), abs(d))
    
    if det_A != 0:
        B = [[a, b], [c, d]]
    else:
        if a != 0:
            B = [[a + 1e-9, b], [c, d + 1e-9]]
        elif b != 0:
            B = [[a, b + 1e-9], [c + 1e-9, d]]
        elif c != 0:
            B = [[a + 1e-9, b], [c, d + 1e-9]]
        elif d != 0:
            B = [[a, b + 1e-9], [c + 1e-9, d]]
    
    norm_diff = sum((a - b)**2 for a, b in zip([abs(x) for row in B for x in row], [abs(x) for row in [[a, b], [c, d]]]))**0.5
    
    return '{:.10f}'.format(norm_diff)

# Example usage
print(solve())

solve()","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    
    detA = np.linalg.det(A)
    
    if detA == 0:
        normA = np.max(np.abs(A))
    else:
        B = np.dot(np.linalg.inv(A.T @ A), A.T)
        normA_B = np.max(np.abs(A - B))
    
    print(f""{normA_B:.10f}"")

solve()
","
def solve():
    import numpy as np

    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    det_A = np.linalg.det(A)
    
    if det_A != 0:
        B = A + np.linalg.det(A) * np.eye(2) / np.linalg.norm(A)
    else:
        B = A + [[0.1, 0.1], [0.1, 0.1]]
    
    norm_diff = np.linalg.norm(B - A)
    
    print(""{:.10f}"".format(norm_diff))

solve()
  ","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    det_A = a*d - b*c
    norm_A = max(abs(a), abs(b), abs(c), abs(d))
    norm_diff = np.linalg.norm(np.array([[a, b], [c, d]]) - np.eye(2) * det_A/norm_A)
    
    print(""{:.10f}"".format(norm_diff))

# Call the function to solve the problem
solve()
","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    detA = np.linalg.det(A)  
    normA = np.max(np.abs(A))
    
    alpha = 1 / (a*d - b*c) if a*d - b*c != 0 else 0
    B = A + alpha * np.array([[d, -b], [-c, a]])
    
    norm_diff = np.max(np.abs(A - B))
    
    print(""{:.10f}"".format(norm_diff))

solve()
","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())

    det_A = a*d - b*c
    norm_A = max(abs(a), abs(b), abs(c), abs(d))

    if det_A != 0:
        k = b*c / (a*d - b*c)
        B = np.array([[a + k, b], [c, d + k]])
    else:
        B = np.array([[a + norm_A/2, b], [c, d + norm_A/2]])

    norm_diff = np.max(np.abs(np.subtract(B, [[a, b], [c, d]])))

    return norm_diff
  
solve()","
import math

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    det_A = a * d - b * c
    
    if det_A != 0:
        norm_A = max([abs(a), abs(b), abs(c), abs(d)])
        result = norm_A / 2
    else:
        norm_A = max([abs(a), abs(b), abs(c), abs(d)])
        det_B = 1
        while det_B == 1:
            a += 0.1
            b -= 0.1
            c -= 0.1
            d += 0.1

            det_B = a * d - b * c

        norm_B = max([abs(a), abs(b), abs(c), abs(d)])
        result = (norm_A - norm_B) / 2

    print(""{:.10f}"".format(result))

solve()
","
import math

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())

    det_A = a*d - b*c
    norm_A = max(abs(a), abs(b), abs(c), abs(d))

    if det_A == 0:
        print(norm_A)
    else:
        x = (2 * det_A + norm_A * math.sqrt(4 * det_A ** 2 + norm_A ** 2)) / (2 * norm_A ** 2)
        print(""{:.10f}"".format(abs(x - norm_A)))

solve()","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    det = np.linalg.det(A)
    
    if det != 0:
        B = A + np.array([[0.1, 0.1], [0.1, 0.1]])
    else:
        B = A + np.array([[0.1, -0.1], [-0.1, 0.1]])
    
    norm_diff = np.max(np.abs(A - B))
    print(""{:.10f}"".format(norm_diff))


solve()
","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())

    A = np.array([[a, b], [c, d]])
    det_A = np.linalg.det(A)

    if det_A != 0:
        B = A - (det_A/(a*d - b*c)) * np.array([[d, -b], [-c, a]])
    else:
        B = np.array([[a + 0.5, b - 0.5], [c - 0.5, d + 0.5]])

    norm_diff = np.max(np.abs(A - B))

    print(""{:.10f}"".format(norm_diff))

solve()
  ","
from sympy import symbols, I

def solve():
    a, b, c, d = map(int, input().split())
    A = [[a, b], [c, d]]
    
    x, y = symbols('x y', real=True)
    B = [[a + x, b + y], [c + x, d + y]]
    
    det = a*d - b*c
    norm = max(abs(a), abs(b), abs(c), abs(d))
    
    dist = ((B[0][0] - A[0][0])**2 + (B[0][1] - A[0][1])**2 + 
            (B[1][0] - A[1][0])**2 + (B[1][1] - A[1][1])**2)
    
    min_dist = dist.subs({x: -det / (2*c), y: det / (2*a)})
    return min_dist**0.5 / norm

solve()","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    det_A = np.linalg.det(A)
    norm_A = max(abs(a), abs(b), abs(c), abs(d))
    
    alpha = (a + d) / 2.0
    beta = np.sqrt((a - d) ** 2 + 4 * b * c) / 2.0
    
    norm_B = abs(alpha) + abs(beta)
    
    result = abs(norm_A - norm_B)
    
    print('{:.10f}'.format(result))

solve()
","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())
    
    A = np.array([[a, b], [c, d]])
    det_A = np.linalg.det(A)
    
    if det_A == 0:
        norm_A = max(abs(a), abs(b), abs(c), abs(d))
        min_norm_B = norm_A / np.sqrt(2)
    else:
        min_norm_B = 0
    
    print('{:.10f}'.format(min_norm_B))

solve()
","
import numpy as np

def solve():
    a, b = map(int, input().split())
    c, d = map(int, input().split())

    det_A = a*d - b*c
    norm_A = max(abs(a), abs(b), abs(c), abs(d))
    det_B = norm_A**2

    min_norm_AD = np.sqrt((det_A - det_B)**2 / (a**2 + b**2 + c**2 + d**2))

    return min_norm_AD


solve()","6.666666666666667","6.666666666666667","0.0","13.333333333333334","0.0","0.0","13.333333333333334","0.0","13.333333333333334","0.0","0.0","0.0","0.0","6.666666666666667","6.666666666666667","0.0","","","","","","","","","","","","","","","",""
"APPS/194","
QUESTION:
In a small restaurant there are a tables for one person and b tables for two persons. 

It it known that n groups of people come today, each consisting of one or two people. 

If a group consist of one person, it is seated at a vacant one-seater table. If there are none of them, it is seated at a vacant two-seater table. If there are none of them, it is seated at a two-seater table occupied by single person. If there are still none of them, the restaurant denies service to this group.

If a group consist of two people, it is seated at a vacant two-seater table. If there are none of them, the restaurant denies service to this group.

You are given a chronological order of groups coming. You are to determine the total number of people the restaurant denies service to.


-----Input-----

The first line contains three integers n, a and b (1 ≤ n ≤ 2·10^5, 1 ≤ a, b ≤ 2·10^5) — the number of groups coming to the restaurant, the number of one-seater and the number of two-seater tables.

The second line contains a sequence of integers t_1, t_2, ..., t_{n} (1 ≤ t_{i} ≤ 2) — the description of clients in chronological order. If t_{i} is equal to one, then the i-th group consists of one person, otherwise the i-th group consists of two people.


-----Output-----

Print the total number of people the restaurant denies service to.


-----Examples-----
Input
4 1 2
1 2 1 1

Output
0

Input
4 1 1
1 1 2 1

Output
2



-----Note-----

In the first example the first group consists of one person, it is seated at a vacant one-seater table. The next group occupies a whole two-seater table. The third group consists of one person, it occupies one place at the remaining two-seater table. The fourth group consists of one person, he is seated at the remaining seat at the two-seater table. Thus, all clients are served.

In the second example the first group consists of one person, it is seated at the vacant one-seater table. The next group consists of one person, it occupies one place at the two-seater table. It's impossible to seat the next group of two people, so the restaurant denies service to them. The fourth group consists of one person, he is seated at the remaining seat at the two-seater table. Thus, the restaurant denies service to 2 clients.
Use user-input-Based format and function signature solve()","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    
    denied = 0
    one_seaters = a
    two_seaters = b
    
    for client in clients:
        if client == 1:
            if one_seaters > 0:
                one_seaters -= 1
            elif two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 1
        else:
            if two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 2
    
    print(denied)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    groups = list(map(int, input().split()))

    one_seaters = a
    two_seaters = b
    denied_count = 0

    for group in groups:
        if group == 1:
            if one_seaters > 0:
                one_seaters -= 1
            elif two_seaters > 0:
                two_seaters -= 1
            else:
                denied_count += 1
        else:
            if two_seaters > 0:
                two_seaters -= 1
            else:
                denied_count += 2

    return denied_count

solve()","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    
    denied_service = 0
    one_seater = a
    two_seater = b
    
    for client in clients:
        if client == 1:
            if one_seater > 0:
                one_seater -= 1
            elif two_seater > 0:
                two_seater -= 1
            else:
                denied_service += 1
        else:
            if two_seater > 0:
                two_seater -= 1
            else:
                denied_service += 2
    
    return denied_service

solve()","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    
    denied = 0
    one_seaters = a
    two_seaters = b
    
    for client in clients:
        if client == 1:
            if one_seaters > 0:
                one_seaters -= 1
            elif two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 1
        else:
            if two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 2 if one_seaters > 0 else 2
                
    print(denied)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    
    one_seaters = a
    two_seaters = b
    denied = 0
    
    for client in clients:
        if client == 1:
            if one_seaters > 0:
                one_seaters -= 1
            elif two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 1
        else:
            if two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 2
    
    print(denied)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))

    denies_service = 0
    one_seater = a
    two_seater = b

    for client in clients:
        if client == 1:
            if one_seater > 0:
                one_seater -= 1
            elif two_seater > 0:
                two_seater -= 1
            else:
                denies_service += 1
        else:
            if two_seater > 0:
                two_seater -= 1
            else:
                denies_service += 2

    print(denies_service)

solve()
  ","
def solve():
    n, a, b = map(int, input().split())
    groups = list(map(int, input().split()))
    
    denied = 0
    one_seater = a
    two_seater = b

    for group in groups:
        if group == 1:
            if one_seater > 0:
                one_seater -= 1
            elif two_seater > 0:
                two_seater -= 1
            else:
                denied += 1
        else:
            if two_seater > 0:
                two_seater -= 1
            else:
                denied += 2

    return denied

solve()","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    
    denied = 0
    one_seaters = a
    two_seaters = b
    
    for client in clients:
        if client == 1:
            if one_seaters > 0:
                one_seaters -= 1
            elif two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 1
        else:
            if two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 2
    
    print(denied)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    
    denied = 0
    one_tables = a
    two_tables = b
    
    for client in clients:
        if client == 1:
            if one_tables > 0:
                one_tables -= 1
            elif two_tables > 0:
                two_tables -= 1
            else:
                denied += 1
        else:
            if two_tables > 0:
                two_tables -= 1
            else:
                denied += 2
    
    print(denied)

solve()
  ","
def solve():
    n, a, b = map(int, input().split())
    t = list(map(int, input().split()))
    
    denied = 0
    one_seater = a
    two_seater = b
    
    for group in t:
        if group == 1:
            if one_seater > 0:
                one_seater -= 1
            elif two_seater > 0:
                two_seater -= 1
            else:
                denied += 1
        else:
            if two_seater > 0:
                two_seater -= 1
            else:
                denied += 2
    
    print(denied)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    t = list(map(int, input().split()))
    
    one_seaters = a
    two_seaters = b
    denied = 0
    
    for i in range(n):
        if t[i] == 1:
            if one_seaters > 0:
                one_seaters -= 1
            elif two_seaters > 0:
                two_seaters -= 1
            elif two_seaters == 0:
                denied += 1
        else:
            if two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 2
    
    return denied

solve()","
def solve():
    n, a, b = map(int, input().split())
    guests = list(map(int, input().split()))
    
    denied_service = 0
    one_seater = a
    two_seater = b
    
    for guest in guests:
        if guest == 1:
            if one_seater > 0:
                one_seater -= 1
            elif two_seater > 0:
                two_seater -= 1
            else:
                denied_service += 1
        elif guest == 2:
            if two_seater > 0:
                two_seater -= 1
            else:
                denied_service += 2
    
    print(denied_service)

solve()
  ","
def solve():
    n, a, b = map(int, input().split())
    t = list(map(int, input().split()))

    denied = 0
    ones = 0
    twos = 0

    for group in t:
        if group == 1:
            if a > 0:
                a -= 1
            elif b > 0:
                b -= 1
                twos += 1
            elif twos > 0:
                twos -= 1
            else:
                denied += 1
        else:
            if b > 0:
                b -= 1
            else:
                denied += 2

    return denied

# Call the function to run the solution
solve()
","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    deny_count = 0
    one_seater = a
    two_seater = b

    for client in clients:
        if client == 1:
            if one_seater > 0:
                one_seater -= 1
            elif two_seater > 0:
                two_seater -= 1
            else:
                deny_count += 1
        else:
            if two_seater > 0:
                two_seater -= 1
            else:
                deny_count += 2

    return deny_count

solve()","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    one_seaters = a
    two_seaters = b
    denied = 0
    
    for client in clients:
        if client == 1:
            if one_seaters > 0:
                one_seaters -= 1
            elif two_seaters > 0:
                two_seaters -= 1
            elif two_seaters == 0:
                denied += 1
        else:
            if two_seaters > 0:
                two_seaters -= 1
            else:
                denied += 2
    
    print(denied)

solve()
","
def solve():
    n, a, b = map(int, input().split())
    clients = list(map(int, input().split()))
    
    one_seater = a
    two_seater = b
    denied = 0
    
    for client in clients:
        if client == 1:
            if one_seater > 0:
                one_seater -= 1
            elif two_seater > 0:
                two_seater -= 1
            else:
                denied += 1
        else:
            if two_seater > 0:
                two_seater -= 1
            else:
                denied += 2 if one_seater > 0 else 2
    
    return denied
 
solve()","86.66666666666667","0.0","0.0","86.66666666666667","86.66666666666667","86.66666666666667","0.0","86.66666666666667","86.66666666666667","86.66666666666667","0.0","86.66666666666667","0.0","0.0","86.66666666666667","0.0","","","","","","","","","","","","","","","",""
"APPS/195","
QUESTION:
Each student eagerly awaits the day he would pass the exams successfully. Thus, Vasya was ready to celebrate, but, alas, he didn't pass it. However, many of Vasya's fellow students from the same group were more successful and celebrated after the exam.

Some of them celebrated in the BugDonalds restaurant, some of them — in the BeaverKing restaurant, the most successful ones were fast enough to celebrate in both of restaurants. Students which didn't pass the exam didn't celebrate in any of those restaurants and elected to stay home to prepare for their reexamination. However, this quickly bored Vasya and he started checking celebration photos on the Kilogramm. He found out that, in total, BugDonalds was visited by $A$ students, BeaverKing — by $B$ students and $C$ students visited both restaurants. Vasya also knows that there are $N$ students in his group.

Based on this info, Vasya wants to determine either if his data contradicts itself or, if it doesn't, how many students in his group didn't pass the exam. Can you help him so he won't waste his valuable preparation time?


-----Input-----

The first line contains four integers — $A$, $B$, $C$ and $N$ ($0 \leq A, B, C, N \leq 100$).


-----Output-----

If a distribution of $N$ students exists in which $A$ students visited BugDonalds, $B$ — BeaverKing, $C$ — both of the restaurants and at least one student is left home (it is known that Vasya didn't pass the exam and stayed at home), output one integer — amount of students (including Vasya) who did not pass the exam. 

If such a distribution does not exist and Vasya made a mistake while determining the numbers $A$, $B$, $C$ or $N$ (as in samples 2 and 3), output $-1$.


-----Examples-----
Input
10 10 5 20

Output
5
Input
2 2 0 4

Output
-1
Input
2 2 2 1

Output
-1


-----Note-----

The first sample describes following situation: $5$ only visited BugDonalds, $5$ students only visited BeaverKing, $5$ visited both of them and $5$ students (including Vasya) didn't pass the exam.

In the second sample $2$ students only visited BugDonalds and $2$ only visited BeaverKing, but that means all $4$ students in group passed the exam which contradicts the fact that Vasya didn't pass meaning that this situation is impossible.

The third sample describes a situation where $2$ students visited BugDonalds but the group has only $1$ which makes it clearly impossible.
Use user-input-Based format and function signature solve()","
def solve():
    A, B, C, N = map(int, input().split())
    
    if A + B - C >= N or A < C or B < C:
        print(-1)
    else:
        print(N - A - B + C)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())
    
    students_without_exam_pass = N - (A + B - C)
    
    if students_without_exam_pass >= 1 and A <= N and B <= N and C <= N and A >= C and B >= C:
        print(students_without_exam_pass)
    else:
        print(-1)

solve()","
def solve():
    A, B, C, N = map(int, input().split())

    if A + B - C >= N or N - A < 0 or N - B < 0:
        print(-1)
    else:
        print(N - A - B + C)

solve()
","
def solve():
    # User input
    A, B, C, N = map(int, input().split())

    # Check if distribution is possible
    if A + B - C <= N and A >= C and B >= C and N >= A - C and N >= B - C:
        print(N - A - B + C)
    else:
        print(-1)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())
    
    unique_A = A - C
    unique_B = B - C
    unique_AB = C
    
    if unique_A + unique_AB + unique_B >= N or unique_AB > min(unique_A, unique_B):
        print(-1)
    else:
        print(N - (unique_A + unique_B - unique_AB))

solve()","
def solve():
    A, B, C, N = map(int, input().split())
    
    if A + B - C >= N or N < 2 or A > N or B > N or C > N or A < 0 or B < 0 or C < 0:
        print(-1)
    else:
        print(N - A - B + C)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())

    if A + B - C >= N or A > N or B > N or A + B - C < N - C:
        print(-1)
    else:
        print(N - A - B + C)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())
    
    if A + B - C >= N or N - A < 0 or N - B < 0 or N - (A + B - C) < 1:
        print(-1)
    else:
        print(N - (A + B - C))

solve()
","
def solve():
    A, B, C, N = map(int, input().split())
    if (A + B - C) >= N or A > N or B > N or C > N or (A + B - C) < 0:
        print(-1)
    else:
        print(N - A - B + C)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())

    if A + B - C >= N or A < C or B < C:
        print(-1)
    else:
        print(N - A - B + C)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())
    
    # Check if the input contradicts itself
    if A + B - C > N or A > N or B > N:
        print(-1)
    else:
        print(N - A - B + C)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())
    
    if A + B - C <= N <= min(A, B):
        print(N - max(A, B) + C)
    else:
        print(-1)

solve()","
def solve():
    A, B, C, N = map(int, input().split())
    
    if A + B - C > N or N <= 1 or (C > A or C > B) or (A == C and B == C and N > C):
        print(-1)
    else:
        print(N - (A + B - C))

solve()
","
def solve():
    a, b, c, n = map(int, input().split())

    if a > n or b > n or c > n:
        print(-1)
    else:
        total_passed = a + b - c
        total_failed = n - total_passed

        if total_failed < 1:
            print(-1)
        else:
            print(total_failed)

solve()
","
def solve():
    A, B, C, N = map(int, input().split())
    
    total_both = min(A, B, C)
    total_A = A - total_both
    total_B = B - total_both
    
    total_passed = total_A + total_B + total_both + C
    not_passed = N - total_passed
    
    if not_passed >= 1 and total_passed <= N:
        print(not_passed)
    else:
        print(-1)

solve()","
def solve():
    a, b, c, n = map(int, input().split())
    
    intersection = a + b - c
    if intersection > n or a > n or b > n or c > n or intersection < 0:
        print(-1)
    else:
        print(n - a - b + c)

solve()","100.0","100.0","86.66666666666667","86.66666666666667","60.0","86.66666666666667","73.33333333333333","86.66666666666667","86.66666666666667","100.0","73.33333333333333","40.0","86.66666666666667","86.66666666666667","46.666666666666664","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/196","
QUESTION:
Nastya received a gift on New Year — a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).

Unfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. 

Nastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.

Nastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 10^9 + 7, because it is easy to see that it is always integer.


-----Input-----

The only line contains two integers x and k (0 ≤ x, k ≤ 10^18), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.


-----Output-----

In the only line print a single integer — the expected number of dresses Nastya will own one year later modulo 10^9 + 7.


-----Examples-----
Input
2 0

Output
4

Input
2 1

Output
7

Input
3 2

Output
21



-----Note-----

In the first example a year consists on only one month, so the wardrobe does not eat dresses at all.

In the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.
Use user-input-Based format and function signature solve()","
import math

def solve():
    x, k = map(int, input().split())
    MOD = 10**9 + 7

    if k == 0:
        print((2*x) % MOD)
    else:
        ans = (2*x) % MOD
        for i in range(1, k+1):
            ans = (ans*2) % MOD
            ans = (ans + ans) % MOD
        print(ans)

solve()
","
import math

def solve():
    x, k = map(int, input().split())
    MOD = 10**9 + 7

    if k == 0:
        print(x)
        return

    res = int(x * pow(2, k + 1, MOD)) % MOD
    res = int((2 * res - x) % MOD)
    print(res)

solve()
","
import math

def solve():
    x, k = map(int, input().split())
    MOD = 10**9 + 7
    
    if k == 0:
        print(x)
    else:
        res = 0
        for i in range(k+1):
            res += (x * pow(2, i, MOD) % MOD)
            res %= MOD
        print(res)

solve()
","
def solve():
    mod = 10**9 + 7

    x, k = map(int, input().split())

    for _ in range(k):
        x = (x * 2 + 1) % mod

    return x

print(solve())
  
solve()","
def solve():
    x, k = map(int, input().split())
    
    MOD = 10**9 + 7
    x_remain = x
    result = x_remain
    for i in range(k):
        x_remain = 2 * x_remain % MOD
        result = (result + x_remain) % MOD
    
    return result

solve()
  ","
def solve():
    x, k = map(int, input().split())
    
    MOD = 10**9 + 7

    result = x
    
    for i in range(k):
        result = (result * 2 + 1) % MOD

    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    x, k = map(int, input().split())
    
    if k == 0:
        print(x * 2 % MOD)
    else:
        res = ((2*x % MOD) * pow(2, k, MOD) % MOD + pow(2, k-1, MOD)) % MOD
        print(res)

solve()
","
def solve():
    MOD = 10**9 + 7
    x, k = map(int, input().split())

    # calculate the expected number of dresses using recursive formula
    ans = x * (2 ** (k + 1)) - (1 - 2 ** (k + 1)) // (1 - 2)  # simplified formula

    # apply modulo operation
    ans %= MOD
    print(ans)

solve()
","
from math import pow

def solve():
    x, k = map(int, input().split())
    mod = 10**9 + 7
    if k == 0:
        return ((x % mod) * 2) % mod
    else:
        return ((x % mod) * pow(2, k+1, mod) % mod) + (2**k) % mod


solve()","
def solve():
    MOD = 10 ** 9 + 7
    x, k = map(int, input().split())
    if k == 0:
        print((2 * x) % MOD)
    else:
        ans = ((pow(2, k + 1, MOD) * x) % MOD + pow(2, k, MOD) - 1) % MOD
        print(ans)

solve()
","
# Needed imports
from math import comb

def solve():
    # User input
    x, k = map(int, input().split())

    # Constants
    MOD = 10**9 + 7

    # Calculate expected number of dresses
    ans = x * pow(2, k + 1, MOD) % MOD
    for i in range(k):
        ans = (ans + x * comb(k, i) * pow(2, i + 1, MOD) * pow(2, k - i, MOD)) % MOD

    # Output
    print(int(ans))

solve()
","
def solve():
    MOD = 10**9 + 7
    x, k = map(int, input().split())
    if k == 0:
        print((x * 2) % MOD)
    else:
        res = 0
        ans = x
        for i in range(k):
            res = (res + ans) % MOD
            ans = (ans * 2) % MOD
            res = (res + ans) % MOD
        print(res)

solve()","
from math import pow

def solve():
    x, k = map(int, input().split())
    MOD = 10**9 + 7

    if k == 0:
        return (2*x) % MOD

    expected = (2*x) % MOD
    p1 = pow(2, k, MOD)  # Calculate 2^k % MOD

    p2 = p1-1
    p3 = pow(2, k-1, MOD) if k > 1 else 1

    expected *= p1
    expected -= p2*x
    expected *= p3
    expected += p2 // 2

    return expected % MOD

solve()","
def solve():
    x, k = map(int, input().split())

    MOD = 10**9 + 7

    expected_dresses = x
    for i in range(k):
        expected_dresses = (expected_dresses * 2) % MOD
        expected_dresses = (expected_dresses + 1) % MOD

    print(expected_dresses)

solve()
  ","
import math

def solve():
    x, k = map(int, input().split())
    
    mod = 10**9 + 7
    ans = x
    for i in range(k):
        ans = (ans * 2) % mod
    ans = (ans * 2 - 1) % mod

    print(ans)

solve()
","
import math

def solve():
    x, k = map(int, input().split())
    MOD = 10**9 + 7

    if k == 0:
        print(x)
    else:
        ans = (x + 1) * pow(2, k, MOD) - pow(2, k-1, MOD)
        print(ans % MOD)

solve()
","25.0","6.666666666666667","16.666666666666664","0.0","0.0","0.0","13.333333333333334","0.0","0.0","13.333333333333334","25.0","25.0","0.0","0.0","16.666666666666664","0.0","","","","","","","","","","","","","","","",""
"APPS/197","
QUESTION:
An online contest will soon be held on ForceCoders, a large competitive programming platform. The authors have prepared $n$ problems; and since the platform is very popular, $998244351$ coder from all over the world is going to solve them.

For each problem, the authors estimated the number of people who would solve it: for the $i$-th problem, the number of accepted solutions will be between $l_i$ and $r_i$, inclusive.

The creator of ForceCoders uses different criteria to determine if the contest is good or bad. One of these criteria is the number of inversions in the problem order. An inversion is a pair of problems $(x, y)$ such that $x$ is located earlier in the contest ($x < y$), but the number of accepted solutions for $y$ is strictly greater.

Obviously, both the creator of ForceCoders and the authors of the contest want the contest to be good. Now they want to calculate the probability that there will be no inversions in the problem order, assuming that for each problem $i$, any integral number of accepted solutions for it (between $l_i$ and $r_i$) is equally probable, and all these numbers are independent.


-----Input-----

The first line contains one integer $n$ ($2 \le n \le 50$) — the number of problems in the contest.

Then $n$ lines follow, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \le l_i \le r_i \le 998244351$) — the minimum and maximum number of accepted solutions for the $i$-th problem, respectively.


-----Output-----

The probability that there will be no inversions in the contest can be expressed as an irreducible fraction $\frac{x}{y}$, where $y$ is coprime with $998244353$. Print one integer — the value of $xy^{-1}$, taken modulo $998244353$, where $y^{-1}$ is an integer such that $yy^{-1} \equiv 1$ $(mod$ $998244353)$.


-----Examples-----
Input
3
1 2
1 2
1 2

Output
499122177

Input
2
42 1337
13 420

Output
578894053

Input
2
1 1
0 0

Output
1

Input
2
1 1
1 1

Output
1



-----Note-----

The real answer in the first test is $\frac{1}{2}$.
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 998244353

    n = int(input())
    problems = []
    for _ in range(n):
        l, r = map(int, input().split())
        problems.append((l, r))

    total_ways = 1
    for l, r in problems:
        total_ways = (total_ways * (r - l + 1)) % MOD

    inversions = 0
    for i in range(n):
        for j in range(i + 1, n):
            if problems[i][1] < problems[j][1]:
                inversions += 1

    result = pow(total_ways, MOD - 2, MOD) if inversions == 0 else 0
    print(result)

solve()
","
def solve():
    MOD = 998244353
    
    n = int(input())
    problems = [list(map(int, input().split())) for _ in range(n)]

    total_ways = 1
    for problem in problems:
        total_ways *= (problem[1] - problem[0] + 1)
        total_ways %= MOD

    no_inversions = 1
    for i in range(n):
        for j in range(i+1, n):
            inversions = 0
            for k in range(problems[i][0], problems[i][1]+1):
                for l in range(problems[j][0], problems[j][1]+1):
                    if k < l:
                        inversions += 1
            no_inversions *= (1 - inversions / total_ways)
            no_inversions %= MOD

    return pow(no_inversions, 1, MOD)

solve()
","
def solve():
    MOD = 998244353
    
    n = int(input())
    problems = []
    for _ in range(n):
        l, r = map(int, input().split())
        problems.append((l, r))
    
    total_cases = 1
    for problem in problems:
        total_cases *= (problem[1] - problem[0] + 1)
        total_cases %= MOD
    
    favorable_cases = 1
    for i in range(n):
        curr_fav = 0
        for j in range(i+1, n):
            if problems[i][1] < problems[j][0]:
                curr_fav += (problems[j][0] - problems[i][1] + 1)
        favorable_cases *= curr_fav
        favorable_cases %= MOD
    
    ans = pow(total_cases, MOD-2, MOD) * favorable_cases % MOD
    print(ans)

solve()
  ","
from math import gcd

def solve():
    mod = 998244353
    n = int(input())
    lr = [list(map(int, input().split())) for _ in range(n)]
    
    a, b = 1, 1
    for i in range(n):
        for j in range(i+1, n):
            a = (a * max(0, lr[j][1]-lr[i][0]+1) % mod + b * max(0, lr[j][0]-lr[i][0]) % mod) % mod
            b = b * (lr[j][1]-lr[j][0]+1) % mod

    g = gcd(a, b)
    a //= g
    b //= g
    
    y_inv = pow(b, mod-2, mod)
    result = (a * y_inv) % mod
    print(result)

solve()
","
def solve():
    mod = 998244353
    n = int(input())
    problems = []
    for _ in range(n):
        l, r = map(int, input().split())
        problems.append((l, r))

    total_ways = 1
    total_good_ways = 1

    for i in range(n):
        total_ways *= (problems[i][1] - problems[i][0] + 1)
        total_good_ways *= (problems[i][1] - problems[i][0] + 1 - i)

    ans = total_good_ways * pow(total_ways, mod - 2, mod) % mod
    print(ans)

solve()
","
def solve():
    MOD = 998244353

    def mod_inv(x):
        return pow(x, MOD - 2, MOD)

    n = int(input())
    problems = [list(map(int, input().split())) for _ in range(n)]
    
    ans = 1
    total_ways = 0
    
    for i in range(n):
        total_ways += problems[i][1] - problems[i][0] + 1
        for j in range(i):
            cur_ways = max(0, 
                           min(problems[i][1], problems[j][1]) - max(problems[i][0], problems[j][0]) + 1)
            ans = (ans * cur_ways) % MOD
    
    ans = (total_ways * mod_inv(ans)) % MOD
    print(ans)

solve()
","
from math import gcd

def mod_inv(a, m):
    m0, x0, x1 = m, 0, 1
    while a > 1:
        q = a // m
        m, a = a % m, m
        x0, x1 = x1 - q * x0, x0
    return x1 + m0 if x1 < 0 else x1

def solve():
    n = int(input())
    probs = [list(map(int, input().split())) for _ in range(n)]
    
    total_cases = 1
    for prob in probs:
        l, r = prob
        total_cases = (total_cases * (r - l + 1)) % 998244353
    
    total_prob = 1
    for i in range(n):
        for j in range(i+1, n):
            l1, r1 = probs[i]
            l2, r2 = probs[j]
            inv_case = ((r2 - l2 + 1) * (r1 - l1 + 1)) % 998244353
            inv_case = mod_inv(inv_case, 998244353)
            total_prob = (total_prob * inv_case) % 998244353
    
    ans = (total_cases * total_prob) % 998244353
    return ans

print(solve())
  
solve()","
def solve():
    MOD = 998244353

    def inv(x):
        return pow(x, MOD - 2, MOD)

    n = int(input())
    problems = []
    for _ in range(n):
        l, r = map(int, input().split())
        problems.append((l, r))

    ans = 1
    total_combinations = 1
    for i in range(n - 2, -1, -1):
        l, r = problems[i]
        new_total_combinations = total_combinations * ((r - l + 1) * inv(r - l + 1 + total_combinations) % MOD) % MOD
        total_combinations = (total_combinations + new_total_combinations) % MOD
        ans = (ans + (r - l + 1) * inv(r - l + 1) % MOD * (total_combinations - new_total_combinations) % MOD) % MOD

    print(int(ans))

solve()
","
def solve():
    mod = 998244353
    
    n = int(input())
    lr = [list(map(int, input().split())) for _ in range(n)]
    
    dp = [[0] * (n+1) for _ in range(n+1)]
    dp[0][0] = 1
    
    for i in range(1, n+1):
        for j in range(n):
            for k in range(j+1):
                l, r = lr[i-1]
                dp[i][j+1] = (dp[i][j+1] + dp[i-1][k] * max(0, min(r, j+1) - max(l, k) + 1)) % mod
    
    total = sum(dp[n])
    inversions = sum(dp[n][1:])
    
    return pow(total, mod-2, mod)  # Calculate total^(mod-2) mod mod

solve()","
from math import gcd

def solve():
    mod = 998244353

    n = int(input())
    problems = []
    for _ in range(n):
        l, r = map(int, input().split())
        problems.append((l, r))

    res = 1
    total_ways = 1
    for i in range(n - 1):
        overlap = max(0, min(problems[i][1], problems[i + 1][1]) - max(problems[i][0], problems[i + 1][0]) + 1)
        total_ways = total_ways * (problems[i][1] - problems[i][0] + 1) % mod
        res = res * max(0, overlap) % mod

    total_ways = total_ways * (problems[n - 1][1] - problems[n - 1][0] + 1) % mod

    x = total_ways - res
    y = total_ways
    g = gcd(x, y)

    return pow(y, mod - 2, mod) * x % mod

solve()","
from math import gcd

def solve():
    mod = 998244353
    n = int(input())
    problems = []
    
    for _ in range(n):
        l, r = map(int, input().split())
        problems.append((l, r))
    
    total_cases = 1
    inversion_cases = 0
    
    for i in range(n):
        for j in range(i + 1, n):
            total_cases *= (problems[j][1] - problems[j][0] + 1)
            inversion_cases *= (problems[j][1] - problems[i][1])
    
    no_inversions = total_cases - inversion_cases
    x = no_inversions % mod
    y = total_cases % mod
    
    inv = pow(y, mod - 2, mod)
    ans = (x * inv) % mod
    
    return ans


solve()","
def solve():
    MOD = 998244353

    n = int(input())
    lr = [list(map(int, input().split())) for _ in range(n)]

    fact = [1]
    for i in range(1, n + 1):
        fact.append((fact[-1] * i) % MOD)

    inv_fact = [pow(fact[-1], MOD - 2, MOD)]
    for i in range(n, 0, -1):
        inv_fact.append((inv_fact[-1] * i) % MOD)
    inv_fact.reverse()

    def nCr(n, r):
        if r < 0 or r > n:
            return 0
        return (fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD)

    ans = 1
    for i in range(n):
        for j in range(i + 1, n):
            inv_cnt = 0
            for a in range(lr[i][0], lr[i][1] + 1):
                for b in range(lr[j][0], lr[j][1] + 1):
                    if a < b:
                        inv_cnt += 1
            ans = (ans * (1 - inv_cnt * nCr(lr[i][1] - lr[i][0] + lr[j][1] - lr[j][0], lr[j][1] - lr[j][0]))) % MOD

    print(ans)


solve()
","
def solve():
    mod = 998244353
    
    n = int(input())
    problems = [list(map(int, input().split())) for _ in range(n)]
    
    dp = [[0] * (n+1) for _ in range(n+1)]
    dp[0][0] = 1
    
    for i in range(1, n+1):
        for j in range(1, i+1):
            for k in range(problems[i-1][0], problems[i-1][1] + 1):
                dp[i][j] += dp[i-1][j-1] * k
                dp[i][j] %= mod
                dp[i][j] += dp[i-1][j] * (k+1)
                dp[i][j] %= mod
    
    ans = dp[n][n]
    for i in range(1, n+1):
        ans = (ans * i) % mod
    
    return ans

solve()
","
def solve():
    mod = 998244353
    n = int(input())
    problems = [list(map(int, input().split())) for _ in range(n)]
    
    dp = [[0] * (n+1) for _ in range(n+1)]
    dp[0][0] = 1

    for i in range(1, n+1):
        for j in range(i+1):
            for k in range(i):
                for p in range(problems[k][0], problems[k][1]+1):
                    if problems[i-1][0] <= p < problems[i-1][1]:
                        dp[i][j] += dp[i-1][j-1]
                    else:
                        dp[i][j] += dp[i-1][j]
                    dp[i][j] %= mod
    
    total = sum(dp[n])
    return pow(mod, mod-2, mod) * total % mod


solve()","
from math import gcd

def solve():
    def modinv(a, m):
        m0, x0, x1 = m, 0, 1
        while a > 1:
            q = a // m
            m, a = a % m, m
            x0, x1 = x1 - q * x0, x0
        return x1 + m0 if x1 < 0 else x1

    n = int(input())
    problems = []
    for _ in range(n):
        l, r = map(int, input().split())
        problems.append((l, r))

    MOD = 998244353
    inv = modinv(2, MOD)
    ans = 1

    for i in range(n):
        num_inv = 0
        for j in range(i+1, n):
            num_inv += max(0, problems[j][0] - problems[i][1] + 1)
        ans = (ans * (num_inv * inv) % MOD) % MOD

    print(ans % MOD)

solve()
","
python
def solve():
    import sys
    input = sys.stdin.readline

    n = int(input())
    problems = [list(map(int, input().split())) for _ in range(n)]

    mod = 998244353

    def modinv(x):
        return pow(x, mod - 2, mod)

    def add(x, y):
        return (x + y) % mod

    def sub(x, y):
        return (x - y + mod) % mod

    def mul(x, y):
        return (x * y) % mod

    dp = [0] * (n + 1)
    dp[0] = 1

    for l, r in problems:
        new_dp = [0] * (n + 1)
        prefix_sum = [0] * (n + 1)

        for i in range(1, n + 1):
            prefix_sum[i] = add(prefix_sum[i - 1], dp[i - 1])

        for i in range(n):
            for j in range(i + 1, n + 1):
                prob = mul(prefix_sum[j], modinv(prefix_sum[i]))
                new_dp[j] = add(new_dp[j], mul(dp[i], prob))

        dp = new_dp

    ans = 0
    for i in range(n + 1):
        ans = add(ans, dp[i])

    return ans

# Example usage:
print(solve())


solve()","33.33333333333333","0.0","13.333333333333334","6.666666666666667","20.0","13.333333333333334","0.0","0.0","0.0","0.0","0.0","20.0","0.0","0.0","13.333333333333334","0.0","","","","","","","","","","","","","","","",""
"APPS/198","
QUESTION:
Pasha has a wooden stick of some positive integer length n. He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be n. 

Pasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.

Your task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer x, such that the number of parts of length x in the first way differ from the number of parts of length x in the second way.


-----Input-----

The first line of the input contains a positive integer n (1 ≤ n ≤ 2·10^9) — the length of Pasha's stick.


-----Output-----

The output should contain a single integer — the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square. 


-----Examples-----
Input
6

Output
1

Input
20

Output
4



-----Note-----

There is only one way to divide the stick in the first sample {1, 1, 2, 2}.

Four ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n//2 + 1):
        if n % i == 0 and n // i != i and n // i > i:
            count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    count = 0
    for a in range(1, n//2):
        for b in range(a+1, n-a):
            if a*b == (n-a-b) and a != b:
                count += 1
    print(count)

solve()
  ","
def solve():
    n = int(input())
    count = 0
    for a in range(1, n//4 + 1):
        b = n - a
        if a != b and a * b % (a + b) == 0:
            count += 1
    print(count)

solve()","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n // 2 + 1):
        if n % i == 0 and n // i - 1 > i:
            count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    count = 0
    
    for i in range(1, n // 2 + 1):
        if n % i == 0 and n // i > i:
            count += 1
    
    print(count)

solve()
","
def solve():
    import math
    n = int(input())
    count = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if n // i != i and n // i != i * 2:
                count += 1
        if i * i != n and n % i == 0:
            if n % (n // i) == 0 and n % (n // i) != i and n % (n // i) != i * 2:
                count += 1
    print(count)

solve()","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n//2 + 1):
        if n % i == 0 and n // i != i:
            count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n//4 + 1):
        if n % i == 0 and n // i != i and n // i > i:
            count += 1
    print(count)

solve()","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n//4 + 1):
        if n % i == 0 and n // i > i and n % i != i:
            count += 1
    print(count)

solve()","
def solve():
    n = int(input())
    count = 0
    for a in range(1, n//4 + 1):
        for b in range(a, (n - a)//3 + 1):
            if a*b > n:
                break
            for c in range(b, (n - a)//2 + 1):
                d = n - a - b - c
                if d >= c:
                    if a != b and a != c and a != d and b != c and b != d and c != d:
                        count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n // 2 + 1):
        if n % i == 0 and n // i != i:
            count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    
    count = 0
    for i in range(1, n//4 + 1):
        if n % i == 0 and (n/i) % 2 == 0 and i != n/i:
            count += 1
            
    print(count)

solve()","
def solve():
    n = int(input())
    count = 0
    
    for i in range(1, n//2 + 1):
        if n % i == 0 and (n // i) != i and (n // i) > i:
            count += 1
    
    print(count)

solve()
  ","
def solve():
    n = int(input())
    count = 0
    for x in range(1, n // 2 + 1):
        if n % x == 0 and n // x != x:
            count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n // 2 + 1):
        if n % i == 0 and n // i != i and i != n // (2 * i):
            count += 1
    print(count)

solve()
","
def solve():
    n = int(input())
    count = 0
    for i in range(1, n//2 + 1):
        if n % i == 0 and (n//i != i) and ((n//i) > i):
            count += 1
    print(count)

solve()","12.5","66.66666666666666","50.0","37.5","12.5","6.666666666666667","12.5","40.0","40.0","66.66666666666666","12.5","40.0","12.5","12.5","37.5","12.5","","","","","","","","","","","","","","","",""
"APPS/199","
QUESTION:
The Fair Nut likes kvass very much. On his birthday parents presented him $n$ kegs of kvass. There are $v_i$ liters of kvass in the $i$-th keg. Each keg has a lever. You can pour your glass by exactly $1$ liter pulling this lever. The Fair Nut likes this drink very much, so he wants to pour his glass by $s$ liters of kvass. But he wants to do it, so kvass level in the least keg is as much as possible.

Help him find out how much kvass can be in the least keg or define it's not possible to pour his glass by $s$ liters of kvass.


-----Input-----

The first line contains two integers $n$ and $s$ ($1 \le n \le 10^3$, $1 \le s \le 10^{12}$) — the number of kegs and glass volume.

The second line contains $n$ integers $v_1, v_2, \ldots, v_n$ ($1 \le v_i \le 10^9$) — the volume of $i$-th keg.


-----Output-----

If the Fair Nut cannot pour his glass by $s$ liters of kvass, print $-1$. Otherwise, print a single integer — how much kvass in the least keg can be.


-----Examples-----
Input
3 3
4 3 5

Output
3

Input
3 4
5 3 4

Output
2

Input
3 7
1 2 3

Output
-1



-----Note-----

In the first example, the answer is $3$, the Fair Nut can take $1$ liter from the first keg and $2$ liters from the third keg. There are $3$ liters of kvass in each keg.

In the second example, the answer is $2$, the Fair Nut can take $3$ liters from the first keg and $1$ liter from the second keg.

In the third example, the Fair Nut can't pour his cup by $7$ liters, so the answer is $-1$.
Use user-input-Based format and function signature solve()","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    
    total_kvass = sum(kegs)
    min_kvass_keg = min(kegs)
    
    if total_kvass < s:
        print(-1)
    else:
        min_possible_kvass = max(0, (total_kvass - s) // n)
        print(min(min_kvass_keg, min_possible_kvass))

solve()
","
def solve():
    n, s = map(int, input().split())
    v = list(map(int, input().split()))
    
    total_kg = sum(v)
    min_kg = min(v)
    
    if total_kg < s:
        print(-1)
    else:
        min_kg_possible = max((total_kg - s) // (n - 1), min_kg)
        print(min_kg_possible)

solve()
","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    
    total_kvass = sum(kegs)
    min_kvass_keg = min(kegs)
    
    if total_kvass < s:
        return -1
    
    min_possible_kvass = max(0, (total_kvass - s) // n)
    return min(min_kvass_keg, min_possible_kvass)

solve()","
def solve():
    n, s = map(int, input().split())
    v = list(map(int, input().split()))

    total_kvass = sum(v)
    max_kvass = max(v)

    if total_kvass < s:
        print(-1)
    else:
        min_kvass = max((total_kvass - s) // (n - 1), 0)
        if min_kvass >= max_kvass:
            print(min_kvass)
        else:
            print(max_kvass)

solve()
","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    
    total_kvass = sum(kegs)
    min_kvass_keg = min(kegs)
    
    if total_kvass < s:
        print(-1)
    else:
        min_possible_kvass = max(0, (total_kvass - s) // n)
        print(min(min_kvass_keg, min_possible_kvass))

solve()
","
def solve():
    n, s = map(int, input().split())
    v = list(map(int, input().split()))

    total_kvass = sum(v)
    
    if total_kvass < s:
        print(-1)
        return
    
    min_kvass_keg = min(v)
    
    minimum_required = min(n * min_kvass_keg, (total_kvass - s))
    
    print(minimum_required)

solve()","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    
    total_kvass = sum(kegs)
    min_kvass_keg = min(kegs)
    
    min_possible_kvass = max(0, total_kvass - n*s)
    
    if min_possible_kvass < min_kvass_keg:
        return -1
    return min_possible_kvass

solve()
","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    total_kvass = sum(kegs)
    min_kvass = min(kegs)
    
    if total_kvass < s:
        print(""-1"")
    else:
        min_kvass = max(min_kvass, (total_kvass + n - 1) // n)
        if min_kvass >= s:
            print(min_kvass - s)
        else:
            print(""-1"")

solve()
","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    
    total_kvass = sum(kegs)
    min_kvass_keg = min(kegs)
    
    if total_kvass < s:
        return -1
    min_kvass_needed = (n - 1) * min_kvass_keg
    
    if min_kvass_needed >= s:
        return min_kvass_keg
    else:
        return min((total_kvass - s) // (n - 1), min_kvass_keg)

solve()","
def solve():
    n, s = map(int, input().split())
    volumes = list(map(int, input().split()))

    total_volumes = sum(volumes)
    max_volume = max(volumes)

    if total_volumes < s:
        print(-1)
    else:
        min_keg_volume = max((total_volumes - s) // (n - 1), max_volume)
        print(min_keg_volume)

solve()
","
def solve():
    n, s = map(int, input().split())
    volumes = list(map(int, input().split()))
    
    total_volume = sum(volumes)
    max_keg = max(volumes)
    
    if total_volume < s:
        print(-1)
    else:
        min_keg_volume = max((total_volume - s) // n, max_keg)
        print(min_keg_volume)

solve()
","
def solve():
    n, s = map(int, input().split())
    v = list(map(int, input().split()))
    
    total_kvass = sum(v)
    min_kvass = min(v)
    
    if total_kvass < s:
        return -1
    
    min_possible = max((total_kvass - s) // (n - 1), min_kvass)
    
    return min_possible

solve()","
def solve():
    n, s = map(int, input().split())
    volumes = list(map(int, input().split()))
    
    total_volume = sum(volumes)
    max_volume = max(volumes)
    
    if total_volume < s:
        return -1
    least_keg_volume = max((total_volume - s) // n, total_volume - max_volume)
    
    return least_keg_volume

solve()","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    
    total_kvass = sum(kegs)
    min_kvass_keg = min(kegs)
    
    remaining_kvass = total_kvass - n * min_kvass_keg
    
    if remaining_kvass >= s:
        min_keg = min(min_kvass_keg, (total_kvass - s) // n)
        print(min_keg)
    else:
        print(-1)

solve()
","
def solve():
    n, s = map(int, input().split())
    kegs = list(map(int, input().split()))
    
    total_kvass = sum(kegs)
    min_kvass = min(kegs)
    
    min_volume = max(total_kvass - s, min_kvass)
    
    if total_kvass < s:
        print(-1)
    else:
        print(min_volume)

solve()
","
def solve():
    n, s = map(int, input().split())
    v = list(map(int, input().split()))

    total_kg = sum(v)
    min_kg = min(v)

    if total_kg < s:
        return -1
    else:
        min_possible = max((total_kg - s) // (n - 1), min_kg)
        return min_possible

solve()","100.0","20.0","0.0","20.0","100.0","33.33333333333333","0.0","40.0","0.0","20.0","20.0","0.0","0.0","73.33333333333333","20.0","0.0","","","","","","","","","","","","","","","",""
"APPS/200","
QUESTION:
The 9-th grade student Gabriel noticed a caterpillar on a tree when walking around in a forest after the classes. The caterpillar was on the height h_1 cm from the ground. On the height h_2 cm (h_2 > h_1) on the same tree hung an apple and the caterpillar was crawling to the apple.

Gabriel is interested when the caterpillar gets the apple. He noted that the caterpillar goes up by a cm per hour by day and slips down by b cm per hour by night.

In how many days Gabriel should return to the forest to see the caterpillar get the apple. You can consider that the day starts at 10 am and finishes at 10 pm. Gabriel's classes finish at 2 pm. You can consider that Gabriel noticed the caterpillar just after the classes at 2 pm.

Note that the forest is magic so the caterpillar can slip down under the ground and then lift to the apple.


-----Input-----

The first line contains two integers h_1, h_2 (1 ≤ h_1 < h_2 ≤ 10^5) — the heights of the position of the caterpillar and the apple in centimeters.

The second line contains two integers a, b (1 ≤ a, b ≤ 10^5) — the distance the caterpillar goes up by day and slips down by night, in centimeters per hour.


-----Output-----

Print the only integer k — the number of days Gabriel should wait to return to the forest and see the caterpillar getting the apple.

If the caterpillar can't get the apple print the only integer  - 1.


-----Examples-----
Input
10 30
2 1

Output
1

Input
10 13
1 1

Output
0

Input
10 19
1 2

Output
-1

Input
1 50
5 4

Output
1



-----Note-----

In the first example at 10 pm of the first day the caterpillar gets the height 26. At 10 am of the next day it slips down to the height 14. And finally at 6 pm of the same day the caterpillar gets the apple.

Note that in the last example the caterpillar was slipping down under the ground and getting the apple on the next day.
Use user-input-Based format and function signature solve()","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a <= b:
        print(-1)
    else:
        days = (h2 - h1 + (a - b) - 1) // (a - b)
        print(days)

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())

    if a * 8 >= h2 - h1:
        print(0)
    elif a <= b:
        print(-1)
    else:
        days = 1
        while h1 + a * 8 < h2:
            h1 += a * 8 - b * 16
            days += 1
        print(days)

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a * 8 >= h2 - h1:
        print(0)
        return
    
    if a <= b:
        print(-1)
        return
    
    k = ((h2 - h1 - 8 * a + 7 * b) // (12 * (a - b))) + 1 if (h2 - h1 - 8 * a + 7 * b) % (12 * (a - b)) == 0 else ((h2 - h1 - 8 * a + 7 * b) // (12 * (a - b))) + 2
    
    print(k)


solve()","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())

    if a * 8 >= b * 12:
        print(0)
    elif h1 + a * 8 >= h2:
        print(1)
    else:
        if (h1 + a * 8 - h2) % (a * 8 - b * 12) == 0:
            print((h1 + a * 8 - h2) // (a * 8 - b * 12))
        else:
            print((h1 + a * 8 - h2) // (a * 8 - b * 12) + 1)

solve()
  ","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a * 8 >= (a - b) * (h2 - h1):
        print(0)
    else:
        k = ((h2 - h1) - 8 * a + 7 * b) / (a - b)
        print(int(k) + 1) if k % 1 != 0 or k < 0 else print(int(k))

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())

    if a * 8 >= h2 - h1:
        print(0)
    elif a <= b:
        print(-1)
    else:
        days = (h2 - h1 - 8 * a + 7 * (a - b) - 1) // (8 * (a - b))
        print(days + 1)
  
solve()","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())

    if a * 8 >= (a - b) * (h2 - h1):
        print(0)
    elif a * 8 < (a - b) * (h2 - h1) and (a - b) > 0:
        days = 1
        h1 += a * 8
        h1 -= (a - b) * 12
        while h1 < h2:
            h1 += a * 8
            h1 -= (a - b) * 12
            days += 1
        print(days)
    else:
        print(-1)

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a <= b and h1 + a * 8 < h2:
        print(-1)
    else:
        days = 0
        current_height = h1
        while current_height < h2:
            current_height += a * 8
            if current_height >= h2:
                break
            current_height -= b * 12
            days += 1
        
        print(days)

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a * 8 >= h2 - h1:
        print(0)
    elif a <= b:
        print(-1)
    else:
        days = (h2 - h1 - 8 * a + 7 * b) // (12 * (a - b))
        remainder = (h2 - h1 - 8 * a + 7 * b) % (12 * (a - b))
        if remainder > 0:
            days += 1
        print(days)

solve()
  ","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if (h2 - h1) <= 8 * a:
        print(0 if a <= b else -1)
    else:
        days = 1
        h1 += 8 * a
        while h1 + 8 * a < h2:
            h1 += 12 * a
            h1 -= 12 * b
            days += 1
        print(days)

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a * 8 >= h2 - h1:
        print(0)
    else:
        if a <= b:
            print(-1)
        else:
            print((h2 - h1 - 8 * a + 7 * (a - b) - 1) // (7 * (a - b)))

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())

    if (h2 - h1) <= (a * 8) and (a - b) > 0:
        if (h2 - h1) % (a - b) == 0:
            print((h2 - h1) // (a - b) // 8)
        else:
            print((h2 - h1) // (a - b) // 8 + 1)
    else:
        print(-1)

solve()","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a * 8 >= h2 - h1:
        print(0)
    elif a <= b:
        print(-1)
    else:
        diff = h2 - h1 - a * 8
        days = (diff + (a - b) - 1) // (a - b)
        print(days // 8 + 1)

solve()","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())

    if a * 8 >= h2 - h1:
        print(0)
        return

    if a <= b:
        print(-1)
        return

    diff = h2 - h1
    speed = a - b
    time = (diff - 1) // (speed * 8) + 1
    print(time)

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a * 8 + h1 >= h2:
        print(0)
        return
    
    if a * 8 <= a * 8 - b * 12:
        print(-1)
        return
    
    days = ((h2 - h1) - a * 8 + b * 12 - 1) // (a * 8 - b * 12) + 1
    print(days)

solve()
","
def solve():
    h1, h2 = map(int, input().split())
    a, b = map(int, input().split())
    
    if a <= b:
        print(-1)
    else:
        days = (h2 - h1 - 1) // ((a - b) * 1.0) + 1
        print(int(days))

solve()
","26.666666666666668","88.88888888888889","53.333333333333336","6.666666666666667","20.0","53.333333333333336","23.076923076923077","76.92307692307693","66.66666666666666","64.28571428571429","66.66666666666666","26.666666666666668","66.66666666666666","53.333333333333336","46.666666666666664","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/201","
QUESTION:
A sweet little monster Om Nom loves candies very much. One day he found himself in a rather tricky situation that required him to think a bit in order to enjoy candies the most. Would you succeed with the same task if you were on his place? [Image] 

One day, when he came to his friend Evan, Om Nom didn't find him at home but he found two bags with candies. The first was full of blue candies and the second bag was full of red candies. Om Nom knows that each red candy weighs W_{r} grams and each blue candy weighs W_{b} grams. Eating a single red candy gives Om Nom H_{r} joy units and eating a single blue candy gives Om Nom H_{b} joy units.

Candies are the most important thing in the world, but on the other hand overeating is not good. Om Nom knows if he eats more than C grams of candies, he will get sick. Om Nom thinks that it isn't proper to leave candy leftovers, so he can only eat a whole candy. Om Nom is a great mathematician and he quickly determined how many candies of what type he should eat in order to get the maximum number of joy units. Can you repeat his achievement? You can assume that each bag contains more candies that Om Nom can eat.


-----Input-----

The single line contains five integers C, H_{r}, H_{b}, W_{r}, W_{b} (1 ≤ C, H_{r}, H_{b}, W_{r}, W_{b} ≤ 10^9).


-----Output-----

Print a single integer — the maximum number of joy units that Om Nom can get.


-----Examples-----
Input
10 3 5 2 3

Output
16



-----Note-----

In the sample test Om Nom can eat two candies of each type and thus get 16 joy units.
Use user-input-Based format and function signature solve()","
def solve():
    C, Hr, Hb, Wr, Wb = map(int, input().split())
    
    max_joy = 0
    for num_red in range(C // Wr + 1):
        num_blue = min((C - num_red * Wr) // Wb, (C // Wb) - num_red)
        joy = num_red * Hr + num_blue * Hb
        max_joy = max(max_joy, joy)
    
    print(max_joy)

solve()
","
def solve():
    C, Hr, Hb, Wr, Wb = map(int, input().split())
    max_joy_units = 0
    for red_candies in range(C // Wr + 1):
        blue_candies = min((C - red_candies * Wr) // Wb, Hr // Wr)
        max_joy_units = max(max_joy_units, red_candies * Hr + blue_candies * Hb)
    print(max_joy_units)

solve()
","
def solve():
    C, Hr, Hb, Wr, Wb = map(int, input().split())

    def max_joy_units(C, Hr, Hb, Wr, Wb):
        max_joy = 0
        for i in range(C//Wr + 1):
            red_candies = i
            blue_candies = min((C - i*Wr) // Wb, C//Wb)
            max_joy = max(max_joy, red_candies*Hr + blue_candies*Hb)
        return max_joy

    print(max_joy_units(C, Hr, Hb, Wr, Wb))

solve()
  ","
def solve():
    C, Hr, Hb, Wr, Wb = map(int, input().split())
    joy_units = 0
    for num_r in range(0, min(C//Wr, C//Wr*Wb//Wb)+1):
        num_b = min((C - num_r*Wr) // Wb, C // Wb)
        joy_units = max(joy_units, num_r*Hr + num_b*Hb)
    return joy_units

# Run the function
print(solve())

solve()","
from math import ceil

def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    
    max_joy = 0
    for red_candies in range(0, C // W_r + 1):
        blue_candies = min((C - red_candies * W_r) // W_b, C // W_b)
        joy = red_candies * H_r + blue_candies * H_b
        max_joy = max(max_joy, joy)
    
    print(max_joy)

solve()
","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    
    max_joy = 0
    for num_r in range(0, C // W_r + 1):
        num_b = min((C - num_r * W_r) // W_b, C // W_b)
        joy = num_r * H_r + num_b * H_b
        max_joy = max(max_joy, joy)
    
    print(max_joy)

solve()
","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    
    max_joy = 0
    for red_candies in range(C // W_r + 1):
        blue_candies = min((C - red_candies * W_r) // W_b, C // W_b)
        joy = red_candies * H_r + blue_candies * H_b
        max_joy = max(max_joy, joy)
    
    return max_joy

solve()","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    max_joy = 0
    for i in range(C // W_r + 1):
        remaining_weight = C - i * W_r
        max_joy = max(max_joy, i * H_r + (remaining_weight // W_b) * H_b)
    print(max_joy)

solve()
","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    
    max_joy = 0
    for red_candies in range(C // W_r + 1):
        blue_candies = min((C - red_candies * W_r) // W_b, (C // W_b))
        joy = red_candies * H_r + blue_candies * H_b
        max_joy = max(max_joy, joy)
    
    print(max_joy)

solve()
","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    
    max_joy = 0
    for i in range(C // W_r + 1):
        red_candies = i
        blue_candies = min((C - i*W_r) // W_b, (C // W_b))
        joy = red_candies * H_r + blue_candies * H_b
        max_joy = max(max_joy, joy)
    
    print(max_joy)

solve()
","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    max_joy = 0
    for red_candies in range(C//W_r+1):
        blue_candies = min((C - red_candies*W_r)//W_b, C//W_b)
        max_joy = max(max_joy, red_candies*H_r + blue_candies*H_b)
    print(max_joy)
 
solve()","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    max_joy = 0
    for red_candies in range(C//W_r + 1):
        blue_candies = min((C - red_candies * W_r) // W_b, C // W_b)
        max_joy = max(max_joy, red_candies * H_r + blue_candies * H_b)
    print(max_joy)

solve()
","
def solve():
    C, Hr, Hb, Wr, Wb = map(int, input().split())
    
    max_joys = 0
    for i in range(C//Wr + 1):
        max_joys = max(max_joys, i * Hr + ((C - i * Wr)//Wb) * Hb)
    
    print(max_joys)

solve()","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    
    max_joy = 0
    for num_red_candies in range(C // W_r + 1):
        num_blue_candies = min((C - num_red_candies * W_r) // W_b, C // W_b)
        max_joy = max(max_joy, num_red_candies * H_r + num_blue_candies * H_b)
    
    print(max_joy)

solve()
","
def solve():
    C, Hr, Hb, Wr, Wb = map(int, input().split())
    
    max_joy = 0
    for i in range(C // Wr + 1):
        j = min((C - i * Wr) // Wb, Hr // Wb)
        max_joy = max(max_joy, i * Hr + j * Hb)
    
    print(max_joy)

solve()
","
def solve():
    C, H_r, H_b, W_r, W_b = map(int, input().split())
    
    max_joy = 0
    
    for num_red in range(C // W_r + 1):
        num_blue = min((C - num_red * W_r) // W_b, W_b)
        joy = num_red * H_r + num_blue * H_b
        max_joy = max(max_joy, joy)
    
    print(max_joy)

solve()
","80.0","10.0","100.0","0.0","100.0","100.0","0.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","10.0","90.0","","","","","","","","","","","","","","","",""
"APPS/202","
QUESTION:
Professor GukiZ makes a new robot. The robot are in the point with coordinates (x_1, y_1) and should go to the point (x_2, y_2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.


-----Input-----

The first line contains two integers x_1, y_1 ( - 10^9 ≤ x_1, y_1 ≤ 10^9) — the start position of the robot.

The second line contains two integers x_2, y_2 ( - 10^9 ≤ x_2, y_2 ≤ 10^9) — the finish position of the robot.


-----Output-----

Print the only integer d — the minimal number of steps to get the finish position.


-----Examples-----
Input
0 0
4 5

Output
5

Input
3 4
6 1

Output
3



-----Note-----

In the first example robot should increase both of its coordinates by one four times, so it will be in position (4, 4). After that robot should simply increase its y coordinate and get the finish position.

In the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.
Use user-input-Based format and function signature solve()","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    steps = max(dx, dy)
    steps += max(dx - steps, dy - steps)
    
    print(steps)

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    return max(dx, dy)

solve()","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())

    dx = abs(x2 - x1)
    dy = abs(y2 - y1)

    min_steps = max(dx, dy)
    min_steps += max(min(dx, dy), (max(dx, dy) - min(dx, dy)) // 2)

    print(min_steps)

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x1 - x2)
    dy = abs(y1 - y2)
    
    steps = max(dx, dy)
    steps += abs(dx - dy)
    
    print(steps)

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    x_diff = abs(x2 - x1)
    y_diff = abs(y2 - y1)
    # finding the minimum steps required
    steps = max(x_diff, y_diff)
    # adding the diagonal steps
    steps += max(x_diff, y_diff) - min(x_diff, y_diff)
    print(steps)

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    x_diff = abs(x2 - x1)
    y_diff = abs(y2 - y1)
    
    min_steps = max(x_diff, y_diff)
    
    print(min_steps)

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    steps = max(dx, dy)
    steps += min(dx, dy) - max(dx, dy) + (1 if min(dx, dy) != max(dx, dy) else 0)
    
    print(steps)

solve()","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    print(max(dx, dy, (dx + dy + 1) // 2))

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    steps = min(dx, dy) + abs(dx - dy)
    
    print(steps)

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    return max(dx, dy)

solve()
","
def solve():
    start_x, start_y = map(int, input().split())
    end_x, end_y = map(int, input().split())
    
    diff_x = abs(end_x - start_x)
    diff_y = abs(end_y - start_y)
    
    steps = min(diff_x, diff_y) + abs(diff_x - diff_y)
    
    print(steps)

solve()
","
python
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x1 - x2)
    dy = abs(y1 - y2)
    
    return max(dx, dy)

solve()","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    
    return max(dx, dy)

solve()","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    x_diff = abs(x2 - x1)
    y_diff = abs(y2 - y1)
    
    return max(x_diff, y_diff)


solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x1 - x2)
    dy = abs(y1 - y2)
    
    steps = min(dx, dy) + abs(dx - dy)
    
    print(steps)

solve()
","
def solve():
    x1, y1 = map(int, input().split())
    x2, y2 = map(int, input().split())
    
    dx = abs(x1 - x2)
    dy = abs(y1 - y2)
    
    return max(dx, dy)

solve()","100.0","0.0","0.0","20.0","20.0","100.0","46.666666666666664","100.0","100.0","0.0","100.0","0.0","0.0","0.0","100.0","0.0","","","","","","","","","","","","","","","",""
"APPS/203","
QUESTION:
There are n employees in Alternative Cake Manufacturing (ACM). They are now voting on some very important question and the leading world media are trying to predict the outcome of the vote.

Each of the employees belongs to one of two fractions: depublicans or remocrats, and these two fractions have opposite opinions on what should be the outcome of the vote. The voting procedure is rather complicated:   Each of n employees makes a statement. They make statements one by one starting from employees 1 and finishing with employee n. If at the moment when it's time for the i-th employee to make a statement he no longer has the right to vote, he just skips his turn (and no longer takes part in this voting).  When employee makes a statement, he can do nothing or declare that one of the other employees no longer has a right to vote. It's allowed to deny from voting people who already made the statement or people who are only waiting to do so. If someone is denied from voting he no longer participates in the voting till the very end.  When all employees are done with their statements, the procedure repeats: again, each employees starting from 1 and finishing with n who are still eligible to vote make their statements.  The process repeats until there is only one employee eligible to vote remaining and he determines the outcome of the whole voting. Of course, he votes for the decision suitable for his fraction. 

You know the order employees are going to vote and that they behave optimal (and they also know the order and who belongs to which fraction). Predict the outcome of the vote.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 200 000) — the number of employees. 

The next line contains n characters. The i-th character is 'D' if the i-th employee is from depublicans fraction or 'R' if he is from remocrats.


-----Output-----

Print 'D' if the outcome of the vote will be suitable for depublicans and 'R' if remocrats will win.


-----Examples-----
Input
5
DDRRR

Output
D

Input
6
DDRRRR

Output
R



-----Note-----

Consider one of the voting scenarios for the first sample:   Employee 1 denies employee 5 to vote.  Employee 2 denies employee 3 to vote.  Employee 3 has no right to vote and skips his turn (he was denied by employee 2).  Employee 4 denies employee 2 to vote.  Employee 5 has no right to vote and skips his turn (he was denied by employee 1).  Employee 1 denies employee 4.  Only employee 1 now has the right to vote so the voting ends with the victory of depublicans.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    fractions = input()

    while 'D' in fractions and 'R' in fractions:
        new_fractions = ''
        for i in range(n):
            if fractions[i] == 'D':
                if 'R' not in fractions[i+1:]:
                    new_fractions += 'D'
                else:
                    new_fractions += 'D' if fractions[i+1:].index('R') < fractions[i+1:].index('D') else 'R'
            elif fractions[i] == 'R':
                if 'D' not in fractions[i+1:]:
                    new_fractions += 'R'
                else:
                    new_fractions += 'R' if fractions[i+1:].index('D') < fractions[i+1:].index('R') else 'D'
        fractions = new_fractions

    print(fractions[0])

solve()
","
def solve():
    n = int(input())
    parties = input()

    queue = [(parties[i], i) for i in range(n)]
    elimination = {""D"": ""R"", ""R"": ""D""}

    while len(set(party[0] for party in queue)) > 1:
        current = queue.pop(0)
        if current[0] != parties[current[1]]:
            continue
        next_queue = []
        for party in queue:
            if party[0] != elimination[current[0]]:
                next_queue.append(party)
        queue = next_queue
        queue.append(current)

    print(queue[0][0])

solve()
","
def solve():
    n = int(input())
    fractions = input()

    while 'D' in fractions and 'R' in fractions:
        new_fractions = ''
        for i in range(n):
            if fractions[i] == 'D' and 'R' in new_fractions:
                new_fractions += 'D'
            elif fractions[i] == 'R' and 'D' in new_fractions:
                new_fractions += 'R'
            else:
                new_fractions += fractions[i]
        fractions = new_fractions

    if 'D' in fractions:
        print('D')
    else:
        print('R')

solve()","
def solve():
    n = int(input())
    fractions = input()

    depublicans = []
    remocrats = []

    for i in range(n):
        if fractions[i] == 'D':
            depublicans.append(i)
        else:
            remocrats.append(i)

    while depublicans and remocrats:
        next_round = []
        for i in range(n):
            if i in depublicans and i in remocrats:
                next_round.append(i)
            elif i in depublicans:
                if remocrats:
                    remocrats.pop(0)
            elif i in remocrats:
                if depublicans:
                    depublicans.pop(0)
        depublicans = [x for x in depublicans if x in next_round]
        remocrats = [x for x in remocrats if x in next_round]

    if depublicans:
        return 'D'
    else:
        return 'R'

solve()","
def solve():
    n = int(input())
    fractions = list(input().strip())
    
    depublicans = [i for i in range(n) if fractions[i] == 'D']
    remocrats = [i for i in range(n) if fractions[i] == 'R']
    
    while depublicans and remocrats:
        if depublicans[0] < remocrats[0]:
            depublicans.append(depublicans[0] + n)
        else:
            remocrats.append(remocrats[0] + n)
        depublicans.pop(0)
        remocrats.pop(0)
    
    if depublicans:
        return 'D'
    else:
        return 'R'

solve()","
def solve():
    n = int(input())
    fractions = input()

    def find_winner(fractions):
        remaining = list(fractions)
        while 'D' in remaining and 'R' in remaining:
            next_round = []
            for i in range(len(remaining)):
                if remaining[i] != '.':
                    next_round.append(remaining[i])
                elif remaining[i] == 'D' and remaining[i-1] == 'R':
                    next_round.append('D')
                elif remaining[i] == 'R' and remaining[i-1] == 'D':
                    next_round.append('R')
                else:
                    next_round.append('.')
            remaining = list(next_round)
        return 'D' if 'D' in remaining else 'R'

    print(find_winner(fractions))

solve()","
def solve():
    n = int(input())
    fractions = input()
    
    depublicans = []
    remocrats = []
    
    for i in range(n):
        if fractions[i] == 'D':
            depublicans.append(i)
        else:
            remocrats.append(i)
    
    while depublicans and remocrats:
        if depublicans[0] < remocrats[0]:
            depublicans.append(depublicans[0] + n)
        else:
            remocrats.append(remocrats[0] + n)
        
        depublicans.pop(0)
        remocrats.pop(0)
    
    if depublicans:
        print('D')
    else:
        print('R')

solve()","
def solve():
    n = int(input())
    fractions = input()
    
    depublicans = []
    remocrats = []
    
    for i in range(n):
        if fractions[i] == 'D':
            depublicans.append(i)
        else:
            remocrats.append(i)
    
    while depublicans and remocrats:
        for i in range(n):
            if fractions[i] == 'D':
                if i in depublicans:
                    remocrats = [x for x in remocrats if x != i]
                else:
                    depublicans = [x for x in depublicans if x != i]
            elif fractions[i] == 'R':
                if i in remocrats:
                    depublicans = [x for x in depublicans if x != i]
                else:
                    remocrats = [x for x in remocrats if x != i]
    
    if depublicans:
        print('D')
    else:
        print('R')

solve()
  ","
def solve():
    n = int(input())
    fractions = input()
    
    depublicans = []
    remocrats = []
    
    for i in range(n):
        if fractions[i] == 'D':
            depublicans.append(i)
        else:
            remocrats.append(i)
    
    while depublicans and remocrats:
        if depublicans[0] < remocrats[0]:
            depublicans.append(depublicans[0] + n)
        else:
            remocrats.append(remocrats[0] + n)
        
        depublicans = depublicans[1:]
        remocrats = remocrats[1:]
        
    if depublicans:
        print('D')
    else:
        print('R')

solve()","
def solve():
    n = int(input())
    fractions = input()

    while True:
        for i in range(n):
            if i < n - 1 and fractions[i] != fractions[i + 1]:
                fractions = fractions[:i] + fractions[i+1:]
                n -= 1
                break
        else:
            break

    return fractions[0]

solve()
","
def solve():
    n = int(input())
    employees = input()

    def remaining_fractions(array):
        if 'D' in array and 'R' in array:
            return True
        return False

    while remaining_fractions(employees):
        i = 0
        while i < len(employees):
            if employees[i] == 'R':
                j = i + 1
                while j < len(employees) and (employees[j] == 'D' or employees[j] == '-'):
                    j += 1
                if j < len(employees) and employees[j] == 'R':
                    employees = employees[:j] + '-' + employees[j+1:]
            elif employees[i] == 'D':
                j = i + 1
                while j < len(employees) and (employees[j] == 'R' or employees[j] == '-'):
                    j += 1
                if j < len(employees) and employees[j] == 'D':
                    employees = employees[:j] + '-' + employees[j+1:]
            i += 1

        employees = employees.replace('-', '')

    print(employees[0])

solve()
","
def solve():
    n = int(input())
    employees = input()

    if 'D' in employees and 'R' in employees:
        while 'D' in employees and 'R' in employees:
            new_employees = ''
            for i in range(len(employees)):
                if employees[i] == 'D':
                    new_employees += 'D'
                elif employees[i] == 'R' and 'D' not in employees[:i]:
                    new_employees += 'R'
                elif employees[i] == 'R' and 'D' in employees[:i]:
                    new_employees += 'R' if employees[:i].count('R') > employees.count('D') else 'D'
            employees = new_employees

    return employees[0]

solve()
","
def solve():
    n = int(input())
    factions = input()
    
    depublicans = []
    remocrats = []
    
    for i in range(n):
        if factions[i] == 'D':
            depublicans.append(i)
        else:
            remocrats.append(i)
    
    while depublicans and remocrats:
        if depublicans[0] < remocrats[0]:
            depublicans.append(depublicans[0] + n)
        else:
            remocrats.append(remocrats[0] + n)
        depublicans.pop(0)
        remocrats.pop(0)
    
    if depublicans:
        return 'D'
    else:
        return 'R'

solve()","
def solve():
    n = int(input())
    employees = input().strip()
    
    def can_vote(arr, party):
        return any(e == party for e in arr)
    
    while can_vote(employees, 'D') and can_vote(employees, 'R'):
        new_employees = []
        for i, emp in enumerate(employees):
            if emp == 'D' and can_vote(new_employees, 'R'):
                new_employees.append('D')
            elif emp == 'R' and can_vote(new_employees, 'D'):
                new_employees.append('R')
        employees = new_employees
    
    print(employees[0])

solve()
","
def solve():
    n = int(input())
    employees = list(input())

    i = 0
    while len(set(employees)) > 1:
        if employees[i] != employees[(i+1) % n]:
            employees[(i+1) % n] = None
        i = (i + 1) % n

    print(employees[employees.index('D')] if 'D' in employees else employees[employees.index('R')])

solve()","
def solve():
    n = int(input())
    fractions = input().strip()
    depublicans = []
    remocrats = []
    
    for i in range(n):
        if fractions[i] == 'D':
            depublicans.append(i)
        else:
            remocrats.append(i)
    
    while depublicans and remocrats:
        for i in range(n):
            if not depublicans or not remocrats:
                break
            if i in depublicans:
                if remocrats:
                    remocrats.pop(0)
            elif i in remocrats:
                if depublicans:
                    depublicans.pop(0)

    if depublicans:
        print('D')
    else:
        print('R')

solve()","20.0","66.66666666666666","100.0","0.0","0.0","100.0","100.0","100.0","100.0","0.0","100.0","0.0","0.0","20.0","20.0","100.0","","","","","","","","","","","","","","","",""
"APPS/204","
QUESTION:
Monocarp has decided to buy a new TV set and hang it on the wall in his flat. The wall has enough free space so Monocarp can buy a TV set with screen width not greater than $a$ and screen height not greater than $b$. Monocarp is also used to TV sets with a certain aspect ratio: formally, if the width of the screen is $w$, and the height of the screen is $h$, then the following condition should be met: $\frac{w}{h} = \frac{x}{y}$.

There are many different TV sets in the shop. Monocarp is sure that for any pair of positive integers $w$ and $h$ there is a TV set with screen width $w$ and height $h$ in the shop.

Monocarp isn't ready to choose the exact TV set he is going to buy. Firstly he wants to determine the optimal screen resolution. He has decided to try all possible variants of screen size. But he must count the number of pairs of positive integers $w$ and $h$, beforehand, such that $(w \le a)$, $(h \le b)$ and $(\frac{w}{h} = \frac{x}{y})$.

In other words, Monocarp wants to determine the number of TV sets having aspect ratio $\frac{x}{y}$, screen width not exceeding $a$, and screen height not exceeding $b$. Two TV sets are considered different if they have different screen width or different screen height.


-----Input-----

The first line contains four integers $a$, $b$, $x$, $y$ ($1 \le a, b, x, y \le 10^{18}$) — the constraints on the screen width and height, and on the aspect ratio.


-----Output-----

Print one integer — the number of different variants to choose TV screen width and screen height so that they meet the aforementioned constraints.


-----Examples-----
Input
17 15 5 3

Output
3

Input
14 16 7 22

Output
0

Input
4 2 6 4

Output
1

Input
1000000000000000000 1000000000000000000 999999866000004473 999999822000007597

Output
1000000063



-----Note-----

In the first example, there are $3$ possible variants: $(5, 3)$, $(10, 6)$, $(15, 9)$.

In the second example, there is no TV set meeting the constraints.

In the third example, there is only one variant: $(3, 2)$.
Use user-input-Based format and function signature solve()","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    g = gcd(x, y)
    x //= g
    y //= g
    
    res = min(a // x, b // y)
    print(res)

solve()
","
def solve():
    a, b, x, y = map(int, input().strip().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    common_divisor = gcd(x, y)
    x //= common_divisor
    y //= common_divisor
    
    ratio_a = a // x
    ratio_b = b // y
    
    total_variants = min(ratio_a, ratio_b)
    
    print(total_variants)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)

    g = gcd(x, y)
    x //= g
    y //= g

    return min(a // x, b // y)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    gcd_xy = gcd(x, y)
    x //= gcd_xy
    y //= gcd_xy

    factor_a = a // x
    factor_b = b // y

    result = min(factor_a, factor_b)
    print(result)

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

solve()","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    div = gcd(x, y)
    x //= div
    y //= div

    ans = min(a // x, b // y)
    print(ans)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    def count_variants(a, b, x, y):
        g = gcd(x, y)
        x //= g
        y //= g
        return min(a // x, b // y)
    
    print(count_variants(a, b, x, y))

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    gcd = lambda x, y: x if y == 0 else gcd(y, x % y)
    g = gcd(x, y)
    x //= g
    y //= g
    print(min(a // x, b // y))

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    gcd_val = gcd(x, y)
    x //= gcd_val
    y //= gcd_val
    
    ratio = min(a // x, b // y)
    print(ratio)
    
solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)
    
    g = gcd(x, y)
    x //= g
    y //= g
    
    res = min(a // x, b // y)
    print(res)

solve()
  ","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    g = gcd(x, y)
    x //= g
    y //= g
    
    k = min(a // x, b // y)
    
    print(k)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    gcd = lambda x, y: x if y == 0 else gcd(y, x % y)
    common_divisor = gcd(x, y)
    x //= common_divisor
    y //= common_divisor
    res = min(a // x, b // y)
    print(res)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    g = math.gcd(x, y)
    x //= g
    y //= g
    min_ratio = min(a // x, b // y)
    print(min_ratio)

import math

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    g = gcd(x, y)
    x //= g
    y //= g
    
    return min(a // x, b // y)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    g = gcd(x, y)
    x //= g
    y //= g
    
    res = min(a // x, b // y)
    
    print(res)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    gcd_val = gcd(x, y)
    x //= gcd_val
    y //= gcd_val
    
    width_variants = min(a // x, b // y)
    
    print(width_variants)

solve()
","
def solve():
    a, b, x, y = map(int, input().split())
    gcd = math.gcd(x, y)
    x //= gcd
    y //= gcd
    res = min(a // x, b // y)
    print(res)

import math

solve()
","100.0","100.0","0.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","0.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/205","
QUESTION:
The number ""zero"" is called ""love"" (or ""l'oeuf"" to be precise, literally means ""egg"" in French), for example when denoting the zero score in a game of tennis. 

Aki is fond of numbers, especially those with trailing zeros. For example, the number $9200$ has two trailing zeros. Aki thinks the more trailing zero digits a number has, the prettier it is.

However, Aki believes, that the number of trailing zeros of a number is not static, but depends on the base (radix) it is represented in. Thus, he considers a few scenarios with some numbers and bases. And now, since the numbers he used become quite bizarre, he asks you to help him to calculate the beauty of these numbers.

Given two integers $n$ and $b$ (in decimal notation), your task is to calculate the number of trailing zero digits in the $b$-ary (in the base/radix of $b$) representation of $n\,!$ (factorial of $n$). 


-----Input-----

The only line of the input contains two integers $n$ and $b$ ($1 \le n \le 10^{18}$, $2 \le b \le 10^{12}$).


-----Output-----

Print an only integer — the number of trailing zero digits in the $b$-ary representation of $n!$


-----Examples-----
Input
6 9

Output
1

Input
38 11

Output
3

Input
5 2

Output
3

Input
5 10

Output
1



-----Note-----

In the first example, $6!_{(10)} = 720_{(10)} = 880_{(9)}$.

In the third and fourth example, $5!_{(10)} = 120_{(10)} = 1111000_{(2)}$.

The representation of the number $x$ in the $b$-ary base is $d_1, d_2, \ldots, d_k$ if $x = d_1 b^{k - 1} + d_2 b^{k - 2} + \ldots + d_k b^0$, where $d_i$ are integers and $0 \le d_i \le b - 1$. For example, the number $720$ from the first example is represented as $880_{(9)}$ since $720 = 8 \cdot 9^2 + 8 \cdot 9 + 0 \cdot 1$.

You can read more about bases here.
Use user-input-Based format and function signature solve()","
def solve():
    n, b = map(int, input().split())
    
    def count_trailing_zeros(n, b):
        count = 0
        while n > 0:
            n //= b
            count += n
        return count
    
    def factorial(n):
        if n == 0:
            return 1
        return n * factorial(n - 1)
    
    fact = factorial(n)
    return count_trailing_zeros(fact, b)

solve()","
def solve():
    n, b = map(int, input().split())
    
    def count_trailing_zeros_factorial(n, b):
        trailing_zeros = 0
        while n > 0:
            n //= b
            trailing_zeros += n
        return trailing_zeros
    
    print(count_trailing_zeros_factorial(n, b))

solve()","
def solve():
    n, b = map(int, input().split())

    def number_of_trailing_zeros(n, b):
        zeros = float('inf')
        for i in range(2, b + 1):
            count = 0
            while n > 0:
                n = n // i
                count += n
            zeros = min(zeros, count)
        return zeros

    result = number_of_trailing_zeros(n, b)
    print(result)

solve()
  ","
def solve():
    n, b = map(int, input().split())
    
    def count_trailing_zeros(num, base):
        zeros = 0
        while num % base == 0:
            zeros += 1
            num //= base
        return zeros
    
    def factorial_trailing_zeros(n, base):
        zeros = float('inf')
        for i in range(2, base + 1):
            if base % i == 0:
                count = 0
                while base % i == 0:
                    count += 1
                    base //= i
                zeros = min(zeros, count_trailing_zeros(n, i) // count)
        return zeros

    print(factorial_trailing_zeros(n, b))

solve()
","
def solve():
    n, b = map(int, input().split())
    
    def trailing_zeros(n, base):
        count = 0
        while n > 0:
            n //= base
            count += n
        return count
    
    def factorial(n):
        if n == 0:
            return 1
        result = 1
        for i in range(1, n+1):
            result *= i
        return result
    
    def convert_to_base(num, base):
        result = """"
        while num > 0:
            result = str(num % base) + result
            num //= base
        return result
    
    fact = factorial(n)
    trailing_zeros_count = trailing_zeros(fact, b)
    
    base_representation = convert_to_base(fact, b)
    zero_count = len(base_representation) - len(base_representation.rstrip('0'))
    
    print(min(trailing_zeros_count, zero_count))

solve()
","
def solve():
    n, b = map(int, input().split())
    
    def trailing_zeros_in_factorial(n, b):
        num_zeros = float('inf')
        for i in range(2, b + 1):
            if b % i == 0:
                cnt = 0
                while b % i == 0:
                    b //= i
                    cnt += 1
                count = 0
                p = i
                while p <= n:
                    count += n // p
                    p *= i
                num_zeros = min(num_zeros, count // cnt)
        return num_zeros
    
    result = trailing_zeros_in_factorial(n, b)
    print(result)

solve()
","
def solve():
    n, b = map(int, input().split())

    def trailing_zeros_in_factorial(n, base):
        zeros = 0
        while n != 0:
            n //= base
            zeros += n
        return zeros

    def factorial(num):
        if num == 0:
            return 1
        return num * factorial(num - 1)

    fact = factorial(n)
    zeros = trailing_zeros_in_factorial(fact, b)
    print(zeros)

solve()
","
def solve():
    n, b = map(int, input().split())
    ans = float('inf')
    for i in range(2, b+1):
        if b % i == 0:
            cnt = 0
            while b % i == 0:
                cnt += 1
                b //= i
            j = n
            cur = 0
            while j:
                cur += j // i
                j //= i
            ans = min(ans, cur // cnt)
        if b == 1:
            break
    print(ans)

solve()","
def solve():
    import sys
    n, b = map(int, sys.stdin.readline().strip().split())
    
    def count_trailing_zeros(num, base):
        count = 0
        while num % base == 0:
            count += 1
            num //= base
        return count
    
    def factorial_trailing_zeros(n, base):
        count = float('inf')
        for i in range(2, base + 1):
            if base % i == 0:
                exponents = 0
                while base % i == 0:
                    exponents += 1
                    base //= i
                j = n
                z = 0
                while j > 0:
                    j //= i
                    z += j
                count = min(count, z // exponents)
        return count
    
    result = factorial_trailing_zeros(n, b)
    print(result)

solve()","
def solve():
    n, b = map(int, input().split())

    def count_trailing_zeros_fact(n, b):
        zeros = float('inf')
        for i in range(2, int(b ** 0.5) + 1):
            if b % i == 0:
                cnt = 0
                while b % i == 0:
                    b //= i
                    cnt += 1
                p = i
                c = 0
                while n // p > 0:
                    c += n // p
                    p *= i
                zeros = min(zeros, c // cnt)
        if b > 1:
            p = b
            c = 0
            while n // p > 0:
                c += n // p
                p *= b
            zeros = min(zeros, c)
        return zeros

    result = count_trailing_zeros_fact(n, b)
    print(result)

solve()
","
def solve():
    n, b = map(int, input().split())
    
    trailing_zeros = float('inf')
    for i in range(2, b + 1):
        count = 0
        base = i
        while base <= n:
            count += n // base
            base *= i
        trailing_zeros = min(trailing_zeros, count)
    
    print(trailing_zeros)
  
solve()","
def solve():
    n, b = map(int, input().split())

    def count_trailing_zeros(n, b):
        zeros = float('inf')
        for i in range(2, b+1):
            cnt = 0
            while n > 0:
                n //= i
                cnt += n
            zeros = min(zeros, cnt)
        return zeros

    zeros = count_trailing_zeros(n, b)
    print(zeros)

solve()
","
def solve():
    n, b = map(int, input().split())

    def count_trailing_zeros_in_factorial(n, b):
        ans = float('inf')
        cnt = 0
        for i in range(2, b+1):
            if b % i == 0:
                c = 0
                while b % i == 0:
                    c += 1
                    b //= i
                v = 0
                temp_n = n
                while temp_n:
                    v += temp_n // i
                    temp_n //= i
                ans = min(ans, v // c)
        return ans

    print(count_trailing_zeros_in_factorial(n, b))

solve()
  ","
def solve():
    from math import factorial

    n, b = map(int, input().split())

    def count_trailing_zeros(x, base):
        cnt = 0
        while x > 0:
            x //= base
            cnt += x
        return cnt

    fact = factorial(n)
    ans = count_trailing_zeros(fact, b)
    
    print(ans)

solve()
","
def solve():
    n, b = map(int, input().split())

    def count_trailing_zeros(n, b):
        zeros = float('inf')
        for i in range(2, b + 1):
            if b % i == 0:
                count = 0
                while b % i == 0:
                    b //= i
                    count += 1
                temp = 0
                temp_b = n
                while temp_b:
                    temp += temp_b // i
                    temp_b //= i
                zeros = min(zeros, temp // count)
        return zeros

    result = count_trailing_zeros(n, b)
    print(result)

solve()
","
def solve():
    import math
    n, b = map(int, input().split())
    
    def count_trailing_zeros(num, base):
        count = 0
        factor = base
        while factor <= num:
            count += num // factor
            factor *= base
        return count

    factorial = math.factorial(n)
    trailing_zeros = count_trailing_zeros(factorial, b)

    print(trailing_zeros)

solve()
","0.0","46.666666666666664","33.33333333333333","25.0","90.9090909090909","100.0","20.0","100.0","100.0","100.0","50.0","33.33333333333333","100.0","27.27272727272727","100.0","27.27272727272727","","","","","","","","","","","","","","","",""
"APPS/206","
QUESTION:
A frog is initially at position $0$ on the number line. The frog has two positive integers $a$ and $b$. From a position $k$, it can either jump to position $k+a$ or $k-b$.

Let $f(x)$ be the number of distinct integers the frog can reach if it never jumps on an integer outside the interval $[0, x]$. The frog doesn't need to visit all these integers in one trip, that is, an integer is counted if the frog can somehow reach it if it starts from $0$.

Given an integer $m$, find $\sum_{i=0}^{m} f(i)$. That is, find the sum of all $f(i)$ for $i$ from $0$ to $m$.


-----Input-----

The first line contains three integers $m, a, b$ ($1 \leq m \leq 10^9, 1 \leq a,b \leq 10^5$).


-----Output-----

Print a single integer, the desired sum.


-----Examples-----
Input
7 5 3

Output
19

Input
1000000000 1 2019

Output
500000001500000001

Input
100 100000 1

Output
101

Input
6 4 5

Output
10



-----Note-----

In the first example, we must find $f(0)+f(1)+\ldots+f(7)$. We have $f(0) = 1, f(1) = 1, f(2) = 1, f(3) = 1, f(4) = 1, f(5) = 3, f(6) = 3, f(7) = 8$. The sum of these values is $19$.

In the second example, we have $f(i) = i+1$, so we want to find $\sum_{i=0}^{10^9} i+1$.

In the third example, the frog can't make any jumps in any case.
Use user-input-Based format and function signature solve()","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    if a == 1:
        return m * (m + 1) // 2
    if a == b:
        return m + 1
    ans = 0
    for i in range(m + 1):
        if i < b or (i - b) % a == 0:
            ans += 1
    return ans

solve()
","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    if a == 1:
        if b == 1:
            return str((m + 1) * (m + 1))
        else:
            return str((m // b + 1) * (m // b + 1) * (b - 1) // 2)
    res = 1
    s = {0, a, -b}
    q = {a, -b}
    while q:
        x = q.pop()
        for y in [x + a, x - b]:
            if 0 <= y <= m and y not in s:
                s.add(y)
                q.add(y)
                res += 1
    return str(res)

solve()","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    if a == 1:
        return str((m+1)*(m//b) + min(m, b-1))
    
    dp = [0] * (b + 1)
    visit = [-1] * (b + 1)
    now = 0
    visit[0] = 0
    
    for i in range(1, b + 1):
        dp[i] = now + 1
        now += dp[i]
        visit[now % b] = i
        if visit[a % b] != -1:
            cycle = i - visit[a % b]
            break
    
    dest = m % b
    res = 0
    curr = 0
    
    while m >= b:
        res += dp[min(b-1, dest)]
        m -= b
        dest = m % b
        curr += cycle
    
    res += curr + dp[dest]
    return str(res)

solve()
  ","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    from math import gcd
    def lcm(x, y):
        return x * y // gcd(x, y)

    l = lcm(a, b)
    s = (m + l) // (2 * l) * l
    k = min((s - m) // l, (s - m - 1) * 2 // l)
    ans = (m + 1) * (m + 2) // 2 - 2 * (m + 1 - k) * (m + 2 - k) // 2
    print(ans)

solve()
  ","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    limit = m // a
    total = 0
    
    for i in range(limit + 1):
        rem = m - i * a
        total += min(rem // b + 1, i + 1)
    
    return total

solve()
","
def solve():
    m, a, b = map(int, input().split())
    
    if a > b:
        a, b = b, a
    
    if a == 1:
        return str((m+1) * (m+2) // 2)
    
    f_list = [1]
    visited = {1}
    i = 0
    while i < len(f_list):
        cur = f_list[i]
        next_pos_1 = cur + a
        next_pos_2 = cur - b
        if next_pos_1 <= m and next_pos_1 not in visited:
            f_list.append(next_pos_1)
            visited.add(next_pos_1)
        if next_pos_2 > 0 and next_pos_2 not in visited:
            f_list.append(next_pos_2)
            visited.add(next_pos_2)
        i += 1
    
    distinct_nums = len(visited)
    
    if distinct_nums == m + 1:
        return str(m + 1)
    
    total_sum = (distinct_nums + 1) * distinct_nums // 2
    
    rem_values = m - max(visited)
    total_sum += rem_values * distinct_nums
    
    return str(total_sum)
  
solve()","
def solve():
    m, a, b = map(int, input().strip().split())

    if a > b:
        a, b = b, a

    if a == 1:
        print(m * (m + 1) // 2)
        return

    ans, q = 0, {0}
    
    while q:
        x = q.pop()
        ans += 1

        if x + a <= m and x + a not in q and x + a not in (b, b + a, b - a):
            q.add(x + a)

        if x - b >= 0 and x - b not in q and x - b not in (b, b + a, b - a):
            q.add(x - b)

    print(ans)

solve()","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    if a == 1:
        print((m+1) * (m+2) // 2)
    else:
        s = i = 1
        while i + a <= m:
            i += a
            s += 1
        n = j = s
        while j > 0:
            x = min((m - j) // a, n // b)
            if j + a * x != n:
                break
            i = j + b * x
            n = i
            s += 1
            j -= 1
        print(s)

solve()
  ","
def solve():
    m, a, b = map(int, input().split())
    
    def count_reachable(x):
        if x <= 0:
            return 1
        reach = {0}
        for i in range(x + 1):
            if i - a in reach or i - b in reach:
                reach.add(i)
        return len(reach)
    
    total_sum = sum(count_reachable(i) for i in range(m + 1))
    
    print(total_sum)

solve()
","
def solve():
    m, a, b = map(int, input().split())
    partial_sums = [0] * (m + 1)
    for i in range(1, m + 1):
        partial_sums[i] = min(i - b, partial_sums[i - b] + b, partial_sums[i - a] + a) + 1
    print(sum(partial_sums))

solve()
","
def solve():
    m, a, b = map(int, input().split())
    def f(x):
        return ((a * x + b) // (a * b) - x // b) if a > b else x // b + 1
    print(sum(f(i) for i in range(m + 1)))

solve()
","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    if a == 1:
        print((m+1)*(m+2)//2)
    else:
        ans = {}
        def f(x):
            if x in ans:
                return ans[x]
            if x < 0:
                return 0
            ans[x] = f(x-a) + f(x+b)
            return ans[x]
        res = 0
        for i in range(m+1):
            res += f(i)
        print(res)

solve()
  ","
def solve():
    m, a, b = map(int, input().split())
    def f(x):
        if x < a:
            return x + 1
        else:
            return f(x - b) + f(x - a)
    
    ans = sum(f(i) for i in range(m+1))
    print(ans)

solve()
","
def solve():
    m, a, b = map(int, input().split())

    max_jump = m // a + 1
    prev_pos = {}
    for j in range(b):
        prev_pos[j] = 1

    pos_count = b
    for i in range(1, max_jump):
        new_pos = {}
        for pos, count in prev_pos.items():
            if pos + a <= m:
                new_pos[pos + a] = 1
                pos_count += 1
            if pos - b >= 0:
                new_pos[pos - b] = 1
                pos_count += 1
        prev_pos = new_pos

    print(pos_count)

solve()
","
def solve():
    m, a, b = map(int, input().split())
    if a > b:
        a, b = b, a
    if a == 1:
        return m * (m + 1) // 2
    res, f_prev, jumps = 1, {0}, set()
    for i in range(1, m + 1):
        for f in list(f_prev):
            if f + a <= m and f + a not in jumps:
                f_prev.add(f + a)
                jumps.add(f + a)
            if f - b >= 0 and f - b not in jumps:
                f_prev.add(f - b)
                jumps.add(f - b)
        res += len(f_prev)
    return res



python
solve()
","
def solve():
    # Input
    m, a, b = map(int, input().split())
    
    # Function to calculate f(x) for a given x
    def frog_jump_count(x):
        if x == 0:
            return 1
        elif x < a:
            return 1 + frog_jump_count(x - b)
        else:
            return frog_jump_count(x - b) + frog_jump_count(x - a)
    
    # Calculate the sum of f(i) for i from 0 to m
    total_sum = sum([frog_jump_count(i) for i in range(m+1)])
    
    return total_sum

# Run the function
print(solve())

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","33.33333333333333","0.0","8.333333333333332","6.666666666666667","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/207","
QUESTION:
Where do odds begin, and where do they end? Where does hope emerge, and will they ever break?

Given an integer sequence a_1, a_2, ..., a_{n} of length n. Decide whether it is possible to divide it into an odd number of non-empty subsegments, the each of which has an odd length and begins and ends with odd numbers.

A subsegment is a contiguous slice of the whole sequence. For example, {3, 4, 5} and {1} are subsegments of sequence {1, 2, 3, 4, 5, 6}, while {1, 2, 4} and {7} are not.


-----Input-----

The first line of input contains a non-negative integer n (1 ≤ n ≤ 100) — the length of the sequence.

The second line contains n space-separated non-negative integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 100) — the elements of the sequence.


-----Output-----

Output ""Yes"" if it's possible to fulfill the requirements, and ""No"" otherwise.

You can output each letter in any case (upper or lower).


-----Examples-----
Input
3
1 3 5

Output
Yes

Input
5
1 0 1 5 1

Output
Yes

Input
3
4 3 1

Output
No

Input
4
3 9 9 3

Output
No



-----Note-----

In the first example, divide the sequence into 1 subsegment: {1, 3, 5} and the requirements will be met.

In the second example, divide the sequence into 3 subsegments: {1, 0, 1}, {5}, {1}.

In the third example, one of the subsegments must start with 4 which is an even number, thus the requirements cannot be met.

In the fourth example, the sequence can be divided into 2 subsegments: {3, 9, 9}, {3}, but this is not a valid solution because 2 is an even number.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))

    if n % 2 == 0 or sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:
        print(""No"")
    else:
        print(""Yes"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    odd_segments = 0

    for i in range(n):
        if a[i] % 2 == 0:
            continue
        j = i + 2
        while j < n and a[j] % 2 == 0:
            j += 2
        if j >= n or a[j] % 2 == 0:
            return ""No""
        odd_segments += 1

    if odd_segments % 2 == 1:
        return ""Yes""
    else:
        return ""No""
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n % 2 == 0:
        print(""No"")
    else:
        if a[0] % 2 == 0 or a[-1] % 2 == 0:
            print(""No"")
        else:
            print(""Yes"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n % 2 == 0:
        print(""No"")
    else:
        if a[0] % 2 == 1 and a[-1] % 2 == 1:
            print(""Yes"")
        else:
            print(""No"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n % 2 == 0 or a[0] % 2 == 0 or a[-1] % 2 == 0:
        print(""No"")
    else:
        print(""Yes"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    odd_start = a[0] % 2 == 1
    odd_end = a[-1] % 2 == 1
    
    if odd_start and odd_end and n % 2 == 1:
        print(""Yes"")
    else:
        print(""No"")

solve()
","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))

    odd_count = 0
    for num in sequence:
        if num % 2 == 1:
            odd_count += 1

    if odd_count == 0 or odd_count % 2 == 0 or sequence[0] % 2 == 0 or sequence[n-1] % 2 == 0:
        print(""No"")
    else:
        print(""Yes"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if a[0] % 2 == 0 or a[-1] % 2 == 0 or n % 2 == 0:
        print(""No"")
    else:
        print(""Yes"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n % 2 == 0:
        print(""No"")
    else:
        start_odd = a[0] % 2 == 1
        end_odd = a[-1] % 2 == 1
        
        if start_odd and end_odd:
            print(""Yes"")
        else:
            print(""No"")

solve()
  ","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n % 2 == 0 or a[0] % 2 == 0 or a[-1] % 2 == 0:
        print(""No"")
    else:
        print(""Yes"")
  
solve()","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))
    
    if n % 2 == 0:
        print(""No"")
    else:
        if sequence[0] % 2 != 0 and sequence[-1] % 2 != 0:
            print(""Yes"")
        else:
            print(""No"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if n % 2 == 0:
        print(""No"")
    else:
        if a[0] % 2 != 0 and a[-1] % 2 != 0:
            print(""Yes"")
        else:
            print(""No"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    odd_start = a[0] % 2 == 1
    odd_end = a[-1] % 2 == 1

    if n % 2 == 0 or not odd_start or not odd_end:
        print(""No"")
    else:
        print(""Yes"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if n % 2 == 0:
        print(""No"")
    else:
        if a[0] % 2 == 1 and a[-1] % 2 == 1:
            print(""Yes"")
        else:
            print(""No"")

solve()","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))
    
    if (n % 2 != 0) and all(sequence[i] % 2 != 0 for i in range(n)):
        print(""Yes"")
    else:
        print(""No"")

solve()","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))
    
    is_possible = False
    if n % 2 == 1:
        if sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:
            is_possible = True
    
    print(""Yes"" if is_possible else ""No"")

solve()
","100.0","0.0","100.0","100.0","100.0","100.0","86.66666666666667","100.0","100.0","100.0","100.0","100.0","100.0","100.0","80.0","100.0","","","","","","","","","","","","","","","",""
"APPS/208","
QUESTION:
Pashmak has fallen in love with an attractive girl called Parmida since one year ago...

Today, Pashmak set up a meeting with his partner in a romantic garden. Unfortunately, Pashmak has forgotten where the garden is. But he remembers that the garden looks like a square with sides parallel to the coordinate axes. He also remembers that there is exactly one tree on each vertex of the square. Now, Pashmak knows the position of only two of the trees. Help him to find the position of two remaining ones.


-----Input-----

The first line contains four space-separated x_1, y_1, x_2, y_2 ( - 100 ≤ x_1, y_1, x_2, y_2 ≤ 100) integers, where x_1 and y_1 are coordinates of the first tree and x_2 and y_2 are coordinates of the second tree. It's guaranteed that the given points are distinct.


-----Output-----

If there is no solution to the problem, print -1. Otherwise print four space-separated integers x_3, y_3, x_4, y_4 that correspond to the coordinates of the two other trees. If there are several solutions you can output any of them. 

Note that x_3, y_3, x_4, y_4 must be in the range ( - 1000 ≤ x_3, y_3, x_4, y_4 ≤ 1000).


-----Examples-----
Input
0 0 0 1

Output
1 0 1 1

Input
0 0 1 1

Output
0 1 1 0

Input
0 0 1 2

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 == x2:
        d = abs(y1 - y2)
        print(x1 + d, y1, x2 + d, y2)
    elif y1 == y2:
        d = abs(x1 - x2)
        print(x1, y1 + d, x2, y2 + d)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    if x1 == x2:
        d = abs(y2 - y1)
        print(x1 + d, y1, x2 + d, y2)
    elif y1 == y2:
        d = abs(x2 - x1)
        print(x1, y1 + d, x2, y2 + d)
    elif abs(x2 - x1) == abs(y2 - y1):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 == x2:
        diff = abs(y2 - y1)
        return f""{x1 + diff} {y1} {x2 + diff} {y2}""
    elif y1 == y2:
        diff = abs(x2 - x1)
        return f""{x1} {y1 + diff} {x2} {y2 + diff}""
    elif abs(x2 - x1) == abs(y2 - y1):
        return f""{x1} {y2} {x2} {y1}""
    else:
        return ""-1""
  
solve()","
def solve():
    x1, y1, x2, y2 = map(int, input().split())

    if x1 == x2:
        d = abs(y2 - y1)
        x3, y3, x4, y4 = x1 + d, y1, x2 + d, y2
    elif y1 == y2:
        d = abs(x2 - x1)
        x3, y3, x4, y4 = x1, y1 + d, x2, y2 + d
    elif abs(x2 - x1) == abs(y2 - y1):
        x3, y3 = x1, y2
        x4, y4 = x2, y1
    else:
        x3, y3, x4, y4 = -1, -1, -1, -1

    print(x3, y3, x4, y4)

solve()
","
from typing import Tuple

def solve() -> Tuple[int, int, int, int]:
    x1, y1, x2, y2 = map(int, input().split())

    if x1 == x2:
        d = abs(y1 - y2)
        x3 = x1 + d
        y3 = y1
        x4 = x2 + d
        y4 = y2
    elif y1 == y2:
        d = abs(x1 - x2)
        x3 = x1
        y3 = y1 + d
        x4 = x2
        y4 = y2 + d
    elif abs(x1 - x2) == abs(y1 - y2):
        x3 = x1
        y3 = y2
        x4 = x2
        y4 = y1
    else:
        return (-1,)

    return x3, y3, x4, y4

solve()","
def solve():
    x1, y1, x2, y2 = map(int, input().split())

    diff_x = abs(x1 - x2)
    diff_y = abs(y1 - y2)

    if diff_x == diff_y:
        print(x1, y2, x2, y1)
    else:
        if x1 == x2:
            print(x1 + diff_y, y1, x2 + diff_y, y2)
        elif y1 == y2:
            print(x1, y1 + diff_x, x2, y2 + diff_x)
        else:
            print(-1)

solve()
","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    if x1 == x2:
        diff = abs(y1 - y2)
        print(x1 + diff, y1, x2 + diff, y2)
    elif y1 == y2:
        diff = abs(x1 - x2)
        print(x1, y1 + diff, x2, y2 + diff)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 != x2 and y1 != y2 and abs(x1 - x2) != abs(y1 - y2):
        print(-1)
    else:
        if x1 == x2:
            print(x1 + abs(y1 - y2), y1, x2 + abs(y1 - y2), y2)
        elif y1 == y2:
            print(x1, y1 + abs(x1 - x2), x2, y2 + abs(x1 - x2))
        else:
            print(x1, y2, x2, y1)

solve()
  ","
def solve():
    x1, y1, x2, y2 = map(int, input().split())

    if x1 == x2:
        diff = abs(y1 - y2)
        print(x1 + diff, y1, x2 + diff, y2)
    elif y1 == y2:
        diff = abs(x1 - x2)
        print(x1, y1 + diff, x2, y2 + diff)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
  ","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 == x2:
        diff = abs(y1 - y2)
        print(x1 + diff, y1, x2 + diff, y2)
    elif y1 == y2:
        diff = abs(x1 - x2)
        print(x1, y1 + diff, x2, y2 + diff)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)


solve()","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 == x2:
        diff_y = abs(y2 - y1)
        print(x1 + diff_y, y1, x2 + diff_y, y2)
    elif y1 == y2:
        diff_x = abs(x2 - x1)
        print(x1, y1 + diff_x, x2, y2 + diff_x)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
  ","
def solve():
    x1, y1, x2, y2 = map(int, input().split())

    if x1 == x2:
        diff = abs(y2 - y1)
        print(x1 + diff, y1, x2 + diff, y2)
    elif y1 == y2:
        diff = abs(x2 - x1)
        print(x1, y1 + diff, x2, y2 + diff)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 == x2:
        diff = abs(y1 - y2)
        print(x1 + diff, y1, x2 + diff, y2)
    elif y1 == y2:
        diff = abs(x1 - x2)
        print(x1, y1 + diff, x2, y2 + diff)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 == x2:
        diff = abs(y1 - y2)
        print(x1 + diff, y1, x2 + diff, y2)
    elif y1 == y2:
        diff = abs(x1 - x2)
        print(x1, y1 + diff, x2, y2 + diff)
    elif abs(x1 - x2) == abs(y1 - y2):
        print(x1, y2, x2, y1)
    else:
        print(-1)

import sys
solve()
","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 == x2:
        diff = abs(y2 - y1)
        print(x1 + diff, y1, x2 + diff, y2)
    elif y1 == y2:
        diff = abs(x2 - x1)
        print(x1, y1 + diff, x2, y2 + diff)
    elif abs(x2 - x1) == abs(y2 - y1):
        print(x1, y2, x2, y1)
    else:
        print(-1)

solve()
  ","
def solve():
    x1, y1, x2, y2 = map(int, input().split())
    
    if x1 != x2 and y1 != y2 and abs(x1 - x2) != abs(y1 - y2):
        print(-1)
    else:
        if x1 == x2:
            diff = abs(y1 - y2)
            print(x1 + diff, y1, x2 + diff, y2)
        elif y1 == y2:
            diff = abs(x1 - x2)
            print(x1, y1 + diff, x2, y2 + diff)
        else:
            print(x1, y2, x2, y1)

solve()
","100.0","100.0","0.0","86.66666666666667","0.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/209","
QUESTION:
Jzzhu has invented a kind of sequences, they meet the following property:$f_{1} = x ; f_{2} = y ; \forall i(i \geq 2), f_{i} = f_{i - 1} + f_{i + 1}$

You are given x and y, please calculate f_{n} modulo 1000000007 (10^9 + 7).


-----Input-----

The first line contains two integers x and y (|x|, |y| ≤ 10^9). The second line contains a single integer n (1 ≤ n ≤ 2·10^9).


-----Output-----

Output a single integer representing f_{n} modulo 1000000007 (10^9 + 7).


-----Examples-----
Input
2 3
3

Output
1

Input
0 -1
2

Output
1000000006



-----Note-----

In the first sample, f_2 = f_1 + f_3, 3 = 2 + f_3, f_3 = 1.

In the second sample, f_2 =  - 1;  - 1 modulo (10^9 + 7) equals (10^9 + 6).
Use user-input-Based format and function signature solve()","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    
    mod = 1000000007
    
    if n == 1:
        print(x % mod)
    elif n == 2:
        print(y % mod)
    else:
        a, b = x, y
        for i in range(3, n+1):
            a, b = b, (a + b) % mod
        print(b)

solve()
","
from sys import stdin, stdout

def solve():
    x, y = map(int, stdin.readline().split())
    n = int(stdin.readline())
    
    def fibonacci_mod_n(x, y, n):
        f = [x, y]
        for i in range(2, n):
            f.append((f[i-1] + f[i-2]) % 1000000007)
        return f[n-1]
    
    result = fibonacci_mod_n(x, y, n)
    stdout.write(str(result))

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    
    mod = 1000000007
    n = n % 6
    fib = [x, y, y - x, -x, -y, x - y]
    
    print(fib[n] % mod)

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())

    mod = 1000000007
    if n == 1:
        print(x % mod)
    elif n == 2:
        print(y % mod)
    else:
        n -= 2
        a, b = x, y
        while n:
            a, b = b, (a + b) % mod
            n -= 1
        print(b)

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    
    mod = 1000000007
    
    f = [x, y]
    
    for i in range(2, n):
        f.append((f[-1] + f[-2]) % mod)
    
    print(f[n-1])

# Call the function to run the solution
solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    
    mod = 1000000007
    
    if n == 1:
        print(x % mod)
    elif n == 2:
        print(y % mod)
    else:
        a, b = x, y
        for i in range(3, n+1):
            a, b = b, (a + b) % mod
        print(b)

if __name__ == ""__main__"":
    solve()
","
def solve():
    MOD = 1000000007
    x, y = map(int, input().split())
    n = int(input())
    
    x %= MOD
    y %= MOD
    
    if n == 1:
        print(x)
    elif n == 2:
        print(y)
    else:
        n -= 2
        a, b = x, y
        while n > 0:
            a, b = b, (a + b) % MOD
            n -= 1
        print(b)

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())

    MOD = 1000000007

    if n == 1:
        return x % MOD
    elif n == 2:
        return y % MOD
    else:
        a, b = x, y
        for _ in range(3, n+1):
            a, b = b, (a + b) % MOD
        return b

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    MOD = 1000000007

    def fib_mod(n, x, y):
        fib = [x, y]
        for i in range(2, n):
            fib.append((fib[-1] + fib[-2]) % MOD)
        return fib[-1]

    print(fib_mod(n, x, y))

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())

    mod = 1000000007

    if n == 1:
        print(x % mod)
    elif n == 2:
        print(y % mod)
    else:
        n -= 2
        a, b = x, y
        while n > 0:
            a, b = b, (a + b) % mod
            n -= 1
        print(b)

solve()
","
def solve():
    MOD = 1000000007
    x, y = map(int, input().split())
    n = int(input())

    n = n % 6
    if n == 1:
        print(x % MOD)
    elif n == 2:
        print(y % MOD)
    elif n == 3:
        print((y - x) % MOD)
    elif n == 4:
        print((-x) % MOD)
    elif n == 5:
        print((-y) % MOD)
    elif n == 0:
        print((x - y) % MOD)

solve()
","
def solve(x: int, y: int, n: int) -> int:
    MOD = 1000000007

    if n == 1:
        return x % MOD
    elif n == 2:
        return y % MOD

    a, b = x, y
    for _ in range(3, n + 1):
        a, b = b, (a + b) % MOD

    return b

x, y = map(int, input().split())
n = int(input())
print(solve(x, y, n))

solve()","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    mod = 1000000007

    if n == 1:
        return x % mod
    elif n == 2:
        return y % mod
    
    fib = [x, y]
    for i in range(2, n):
        fib.append((fib[-1] + fib[-2]) % mod)
    
    return fib[-1]

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    mod = 1000000007
    
    if n == 1:
        print(x % mod)
    elif n == 2:
        print(y % mod)
    else:
        a, b = x, y
        for i in range(3, n+1):
            a, b = b, (a + b) % mod
        print(b)

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    
    MOD = 1000000007
    
    if n == 1:
        print(x % MOD)
    elif n == 2:
        print(y % MOD)
    else:
        a, b = x, y
        for _ in range(3, n+1):
            a, b = b, (a + b) % MOD
        print(b)

solve()
","
def solve():
    x, y = map(int, input().split())
    n = int(input())
    MOD = 1000000007
    
    if n == 1:
        print(x % MOD)
    elif n == 2:
        print(y % MOD)
    else:
        for i in range(3, n+1):
            x, y = y, (x+y) % MOD
        print(y)

if __name__ == ""__main__"":
    solve()
","60.0","0.0","13.333333333333334","60.0","0.0","60.0","60.0","0.0","0.0","60.0","100.0","0.0","0.0","60.0","60.0","60.0","","","","","","","","","","","","","","","",""
"APPS/210","
QUESTION:
One spring day on his way to university Lesha found an array A. Lesha likes to split arrays into several parts. This time Lesha decided to split the array A into several, possibly one, new arrays so that the sum of elements in each of the new arrays is not zero. One more condition is that if we place the new arrays one after another they will form the old array A.

Lesha is tired now so he asked you to split the array. Help Lesha!


-----Input-----

The first line contains single integer n (1 ≤ n ≤ 100) — the number of elements in the array A.

The next line contains n integers a_1, a_2, ..., a_{n} ( - 10^3 ≤ a_{i} ≤ 10^3) — the elements of the array A.


-----Output-----

If it is not possible to split the array A and satisfy all the constraints, print single line containing ""NO"" (without quotes).

Otherwise in the first line print ""YES"" (without quotes). In the next line print single integer k — the number of new arrays. In each of the next k lines print two integers l_{i} and r_{i} which denote the subarray A[l_{i}... r_{i}] of the initial array A being the i-th new array. Integers l_{i}, r_{i} should satisfy the following conditions:  l_1 = 1  r_{k} = n  r_{i} + 1 = l_{i} + 1 for each 1 ≤ i < k. 

If there are multiple answers, print any of them.


-----Examples-----
Input
3
1 2 -3

Output
YES
2
1 2
3 3

Input
8
9 -12 3 4 -4 -10 7 3

Output
YES
2
1 2
3 8

Input
1
0

Output
NO

Input
4
1 2 3 -5

Output
YES
4
1 1
2 2
3 3
4 4
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(n):
            if a[i] != 0:
                print(""YES"")
                print(2)
                print(1, i+1)
                print(i+2, n)
                return
        print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(1, n):
            if a[i] != 0:
                print(""YES"")
                print(2)
                print(1, i)
                print(i+1, n)
                return
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(n):
            if a[i] != 0:
                print(""YES"")
                print(2)
                print(1, i+1)
                print(i+2, n)
                break
        else:
            print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if sum(a) == 0:
        print(""NO"")
    else:
        print(""YES"")
        if len(set(a)) == 1:
            print(1)
            print(1, n)
        else:
            print(2)
            l = 1
            r = 1
            for i in range(n):
                r += 1
                if sum(a[l:r]) != 0:
                    print(l, r-1)
                    l = r
            print(l, n)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(n):
            if a[i] != 0:
                print(""YES"")
                print(2)
                print(1, i+1)
                print(i+2, n)
                break
        else:
            print(""NO"")

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    if sum(arr) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(1, n):
            if arr[i] != 0:
                print(""YES"")
                print(2)
                print(1, i)
                print(i + 1, n)
                return
        print(""NO"")

solve()
","
def solve():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))

    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(1, n):
            if a[i] != 0:
                print(""YES"")
                print(2)
                print(1, i)
                print(i+1, n)
                return
        print(""NO"")

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    if sum(arr) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        if 0 in arr:
            print(""YES"")
            print(2)
            if arr[0] == 0:
                print(1, 1)
                print(2, n)
            else:
                idx = arr.index(0)
                print(1, idx)
                print(idx + 1, n)
        else:
            print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(1, n):
            if a[i] != 0:
                print(""YES"")
                print(2)
                print(1, i)
                print(i + 1, n)
                return
        print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        zero_index = -1
        for i in range(n):
            if a[i] == 0:
                zero_index = i
                break

        if zero_index != -1:
            print(""YES"")
            print(2)
            print(1, zero_index)
            print(zero_index + 1, n)
        else:
            print(""NO"")
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    if sum(a) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(n):
            if a[i] != 0:
                print(""YES"")
                print(2)
                print(1, i+1)
                print(i+2, n)
                return
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    if sum(arr) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(n):
            if arr[i] != 0:
                print(""YES"")
                print(2)
                print(1, i+1)
                print(i+2, n)
                return
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    if sum(arr) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        has_non_zero_subarray = False
        for i in range(n):
            if arr[i] != 0:
                has_non_zero_subarray = True
                print(""YES"")
                print(2)
                print(1, i + 1)
                print(i + 2, n)
                break
        
        if not has_non_zero_subarray:
            print(""NO"")

solve()
","
def solve():
    n = int(input())
    A = list(map(int, input().split()))
    
    if sum(A) != 0:
        print(""YES"")
        print(2)
        print(""1"", n)
    else:
        for i in range(n):
            if A[i] != 0:
                print(""YES"")
                print(2)
                print(""1"", i + 1)
                print(i + 2, n)
                return
        print(""NO"")

solve()","
def solve():
    n = int(input())
    array = list(map(int, input().split()))

    positive_indices = [i for i, num in enumerate(array) if num > 0]
    negative_indices = [i for i, num in enumerate(array) if num < 0]

    if not positive_indices:
        print(""NO"")
    else:
        print(""YES"")
        print(2)
        print(1, positive_indices[0] + 1)
        print(positive_indices[0] + 2, n)

solve()","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    if sum(arr) != 0:
        print(""YES"")
        print(1)
        print(1, n)
    else:
        for i in range(n - 1):
            if arr[i] != 0:
                print(""YES"")
                print(2)
                print(1, i+1)
                print(i+2, n)
                return
        print(""NO"")

solve()
","60.0","60.0","60.0","26.666666666666668","60.0","60.0","60.0","20.0","60.0","20.0","60.0","60.0","60.0","40.0","33.33333333333333","60.0","","","","","","","","","","","","","","","",""
"APPS/211","
QUESTION:
Manao is taking part in a quiz. The quiz consists of n consecutive questions. A correct answer gives one point to the player. The game also has a counter of consecutive correct answers. When the player answers a question correctly, the number on this counter increases by 1. If the player answers a question incorrectly, the counter is reset, that is, the number on it reduces to 0. If after an answer the counter reaches the number k, then it is reset, and the player's score is doubled. Note that in this case, first 1 point is added to the player's score, and then the total score is doubled. At the beginning of the game, both the player's score and the counter of consecutive correct answers are set to zero.

Manao remembers that he has answered exactly m questions correctly. But he does not remember the order in which the questions came. He's trying to figure out what his minimum score may be. Help him and compute the remainder of the corresponding number after division by 1000000009 (10^9 + 9).


-----Input-----

The single line contains three space-separated integers n, m and k (2 ≤ k ≤ n ≤ 10^9; 0 ≤ m ≤ n).


-----Output-----

Print a single integer — the remainder from division of Manao's minimum possible score in the quiz by 1000000009 (10^9 + 9).


-----Examples-----
Input
5 3 2

Output
3

Input
5 4 2

Output
6



-----Note-----

Sample 1. Manao answered 3 questions out of 5, and his score would double for each two consecutive correct answers. If Manao had answered the first, third and fifth questions, he would have scored as much as 3 points.

Sample 2. Now Manao answered 4 questions. The minimum possible score is obtained when the only wrong answer is to the question 4.

Also note that you are asked to minimize the score and not the remainder of the score modulo 1000000009. For example, if Manao could obtain either 2000000000 or 2000000020 points, the answer is 2000000000 mod 1000000009, even though 2000000020 mod 1000000009 is a smaller number.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k = map(int, input().split())
    remaining_questions = n - m
    max_consecutive_correct = min(remaining_questions, k - 1)
    remaining_correct = m - max_consecutive_correct
    min_score = max_consecutive_correct + (remaining_correct // k) * 2 + min(remaining_correct % k, 1)
    print(min_score % 1000000009)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    max_doubled_score = m // k
    remaining_questions = m % k
    
    max_regular_score = max(0, n - m) - 1
    min_score = max(0, m - max_doubled_score*2) + max_regular_score
    
    print(min_score % 1000000009)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    min_correct = max(0, m - (n % k) * (m // k) + (n % k) * ((m // k) * (k - 1) + min(m % k, 1)))
    print(min_correct % (10**9 + 9))

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    remaining_correct = n - m
    min_score = m - ((remaining_correct + k - 2) // (k - 1))
    
    print(min_score % 1000000009)

solve()
","
def solve():
    MOD = 1000000009
    
    n, m, k = map(int, input().split())
    
    min_score = min(m, n//k)
    remaining_correct = m - min_score
    
    if remaining_correct > 0:
        min_score -= (k-1)*remaining_correct
    
    print(min_score % MOD)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    max_possible = (n-k)*(m//2) + (m%2) + min((k-1), (n-m))
    
    print(max_possible % 1000000009)

solve()
  ","
def solve():
    n, m, k = map(int, input().split())

    if m <= k:
        print(m)
    else:
        x = (n - m) // (k - 1)
        y = (n - m) % (k - 1)
        if y == 0:
            print(k*x - (x-1)*x//2)
        else:
            print(k*x - (x-1)*x//2 - y)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    remaining_correct = m - (n // k)
    min_score = max(0, (2 * m - n + k - 1) // k + remaining_correct)
    print(min_score % 1000000009)

solve()
","
def solve():
    MOD = 1000000009
    n, m, k = map(int, input().split())
    periods = n // k
    remaining_questions = n - periods * k
    if m <= remaining_questions:
        print(m)
    else:
        full_periods = m // k
        remaining_answers = m - full_periods * k
        ans = (2 * full_periods + min(remaining_answers, k)) % MOD
        print(ans)

solve()
","
def solve():
    MOD = 1000000009
    n, m, k = map(int, input().split())
    
    x = (n - k) // (k - 1)
    rem = (n - 1) - (x * (k - 1))

    if m <= rem:
        print(m)
    else:
        extra = m - rem
        ans = (((pow(2, x, MOD) - 2) * (k % MOD)) % MOD + (extra * 2) % MOD) % MOD
        print(ans)

solve()
","
def solve():
    mod = 1000000009
    n, m, k = map(int, input().split())
    max_double_sets = min(m // k, n // k)
    remaining_questions = n - m
    potential_points = max(0, max_double_sets * k - remaining_questions)
    min_score = m - potential_points
    print(min_score % mod)

solve()
","
def solve():
    MOD = 1000000009
    n, m, k = map(int, input().strip().split())

    remaining_questions = n - m
    min_score = min(m, (m - remaining_questions // (k - 1)) // k)

    return min_score % MOD
  
solve()","
def solve():
    n, m, k = map(int, input().split())

    total = m - (n // k - 1) * (k - 1)
    min_score = max(0, (total - 1) // k * k // 2 + total % k)
    
    print(min_score % 1000000009)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    remaining_questions = n - m
    max_possible_score = min(m, n // k) + max(0, (m - n // k) // (k - 1) + ((m - n // k) % (k - 1) != 0))
    min_possible_score = m - remaining_questions * k
    if min_possible_score < 0:
        min_possible_score = 0
    print((2 * min_possible_score + max_possible_score) % 1000000009)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    group = (n - k) // (k - 1)
    remain = (n - k) % (k - 1)
    if m <= k or k == 2:
        print(m % (10**9 + 9))
    elif m <= k + remain:
        print(m)
    else:
        score = 2 * (k + (group * (k - 1)))
        print((score + (m - k - remain)) % (10**9 + 9))

solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    
    remaining_questions = n - m
    max_consecutive_correct = max(0, min(m - k, remaining_questions // (k - 1)))
    
    score = max(0, m - max_consecutive_correct * k)
    
    if max_consecutive_correct > 0:
        score += (2 ** max_consecutive_correct - 1) % 1000000009
    
    print(score % 1000000009)

solve()
","26.666666666666668","6.666666666666667","33.33333333333333","0.0","13.333333333333334","6.666666666666667","26.666666666666668","20.0","26.666666666666668","20.0","20.0","0.0","13.333333333333334","26.666666666666668","26.666666666666668","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/212","
QUESTION:
You are given a non-negative integer n, its decimal representation consists of at most 100 digits and doesn't contain leading zeroes.

Your task is to determine if it is possible in this case to remove some of the digits (possibly not remove any digit at all) so that the result contains at least one digit, forms a non-negative integer, doesn't have leading zeroes and is divisible by 8. After the removing, it is forbidden to rearrange the digits.

If a solution exists, you should print it.


-----Input-----

The single line of the input contains a non-negative integer n. The representation of number n doesn't contain any leading zeroes and its length doesn't exceed 100 digits. 


-----Output-----

Print ""NO"" (without quotes), if there is no such way to remove some digits from number n. 

Otherwise, print ""YES"" in the first line and the resulting number after removing digits from number n in the second line. The printed number must be divisible by 8.

If there are multiple possible answers, you may print any of them.


-----Examples-----
Input
3454

Output
YES
344

Input
10

Output
YES
0

Input
111111

Output
NO
Use user-input-Based format and function signature solve()","
def solve():
    n = input().strip()
    
    if len(n) <= 2:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
        elif int(n[::-1]) % 8 == 0:
            print(""YES"")
            print(n[::-1])
        else:
            print(""NO"")
    else:
        for i in range(len(n)):
            for j in range(i+1, len(n)):
                for k in range(j+1, len(n)):
                    num = int(n[:i] + n[j] + n[k])
                    if num % 8 == 0:
                        print(""YES"")
                        print(num)
                        return
        print(""NO"")

solve()
","
def solve():
    n = input()
    
    for i in range(0, len(n)):
        for j in range(i+1, len(n)):
            for k in range(j+1, len(n)):
                num = int(n[:i] + n[i+1:j] + n[j+1:k] + n[k+1:])
                if num % 8 == 0:
                    print(""YES"")
                    print(num)
                    return

    print(""NO"")

solve()
","
def solve():
    n = input()
    
    if len(n) <= 2:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
        elif int(n[::-1]) % 8 == 0:
            print(""YES"")
            print(n[::-1])
        else:
            print(""NO"")
    else:
        digits = [0] * 10
        for d in n:
            digits[int(d)] += 1
        
        for i in range(0, 1000, 8):
            valid = True
            for d in str(i).zfill(3):
                if digits[int(d)] == 0:
                    valid = False
                    break
                digits[int(d)] -= 1
            if valid:
                print(""YES"")
                print(str(i).zfill(3))
                return
        print(""NO"")
        
solve()
","
def solve():
    n = input()
    for i in range(125):
        num = str(8 * i)
        if len(num) < len(n) or len(num) == len(n) and num <= n:
            if all(num.count(d) <= n.count(d) for d in num):
                return print(""YES\n"" + num)
    return print(""NO"")

solve()
","
def solve():
    n = input()
    
    if len(n) <= 2:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
        elif int(n[::-1]) % 8 == 0:
            print(""YES"")
            print(n[::-1])
        else:
            print(""NO"")
    else:
        for i in range(len(n)):
            for j in range(i+1, len(n)):
                for k in range(j+1, len(n)):
                    num = int(n[:i] + n[j] + n[k])
                    if num % 8 == 0:
                        print(""YES"")
                        print(num)
                        return
        print(""NO"")

solve()
","
def solve():
    n = input().strip()
    if len(n) <= 3:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
        elif int(n[::-1]) % 8 == 0:
            print(""YES"")
            print(n[::-1])
        elif int(n[0] + n[2:]) % 8 == 0:
            print(""YES"")
            print(n[0] + n[2:])
        elif int(n[1] + n[2:]) % 8 == 0:
            print(""YES"")
            print(n[1] + n[2:])
        else:
            print(""NO"")
    else:
        digits = [0] * 10
        for digit in n:
            digits[int(digit)] += 1
        for i in range(100, 1000):
            if i % 8 == 0:
                freq = [0] * 10
                for digit in str(i):
                    freq[int(digit)] += 1
                valid = True
                for j in range(10):
                    if freq[j] > digits[j]:
                        valid = False
                        break
                if valid:
                    print(""YES"")
                    print(i)
                    return
        print(""NO"")

import sys

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = input()
    for i in range(10):
        for j in range(10):
            for k in range(10):
                if (i*100 + j*10 + k) % 8 == 0 and str(i) in n and str(j) in n and str(k) in n:
                    print(""YES"")
                    print(str(i) + str(j) + str(k))
                    return
    print(""NO"")

solve()","
def solve():
    n = input().strip()
    
    if len(n) <= 2:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
            return
        elif int(n[::-1]) % 8 == 0:
            print(""YES"")
            print(n[::-1])
            return
        else:
            print(""NO"")
            return
    
    for i in range(len(n)):
        for j in range(i+1, len(n)):
            for k in range(j+1, len(n)):
                num = int(n[:i] + n[j] + n[k])
                if num % 8 == 0:
                    print(""YES"")
                    print(num)
                    return
    
    print(""NO"")

solve()
","
def solve():
    n = input().strip()
    
    for i in range(0, len(n)):
        for j in range(i+1, len(n)):
            for k in range(j+1, len(n)):
                num = int(n[:i] + n[j] + n[k])
                if num % 8 == 0:
                    print(""YES"")
                    print(num)
                    return
    
    print(""NO"")
    
solve()
","
def solve():
    n = input().strip()
    for i in range(len(n)):
        for j in range(i+1, len(n)):
            for k in range(j+1, len(n)):
                num = int(n[:i] + n[i+1:j] + n[j+1:k] + n[k+1:])
                if num % 8 == 0:
                    print(""YES"")
                    print(num)
                    return
    print(""NO"")

solve()
","
def solve():
    n = input()
    for i in range(10):
        for j in range(10):
            for k in range(10):
                if int(str(i) + str(j) + str(k)) % 8 == 0 and str(i) in n and str(j) in n and str(k) in n:
                    print(""YES"")
                    print(str(i) + str(j) + str(k))
                    return
    print(""NO"")

solve()","
def solve():
    n = input()
    
    if len(n) >= 3:
        for i in range(len(n)):
            for j in range(i + 1, len(n)):
                for k in range(j + 1, len(n)):
                    num = int(n[i] + n[j] + n[k])
                    if num % 8 == 0:
                        print(""YES"")
                        print(num)
                        return

    for i in range(len(n)):
        if int(n[i]) % 8 == 0:
            print(""YES"")
            print(n[i])
            return
    
    for i in range(len(n)):
        for j in range(i + 1, len(n)):
            num = int(n[i] + n[j])
            if num % 8 == 0:
                print(""YES"")
                print(num)
                return
    
    print(""NO"")

# Imports not needed for this specific function

solve()","
def solve():
    n = input()

    if len(n) < 3:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
        else:
            print(""NO"")
    else:
        for i in range(0, len(n)):
            for j in range(i + 1, len(n)):
                for k in range(j + 1, len(n)):
                    num = int(n[i] + n[j] + n[k])
                    if num % 8 == 0:
                        print(""YES"")
                        print(num)
                        return
        print(""NO"")

solve()","
def solve():
    n = input().strip()

    for num in range(0, 1000, 8):
        if len(set(str(num))) == len(str(num)) and set(str(num)).issubset(set(n)):
            print(""YES"")
            print(num)
            return

    print(""NO"")

solve()
","
def solve():
    n = input().strip()
    
    if len(n) <= 3:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
        elif int(n[::-1]) % 8 == 0:
            print(""YES"")
            print(n[::-1])
        else:
            print(""NO"")
    else:
        for i in range(len(n)):
            for j in range(i+1, len(n)):
                for k in range(j+1, len(n)):
                    num = int(n[:i] + n[j] + n[k])
                    if num % 8 == 0:
                        print(""YES"")
                        print(num)
                        return
        print(""NO"")

solve()
","
def solve():
    n = input().strip()

    if len(n) < 3:
        if int(n) % 8 == 0:
            print(""YES"")
            print(n)
        elif int(n[::-1]) % 8 == 0:
            print(""YES"")
            print(n[::-1])
        else:
            print(""NO"")
    else:
        for i in range(len(n)):
            for j in range(i + 1, len(n)):
                for k in range(j + 1, len(n)):
                    num = int(n[:i] + n[j] + n[k])
                    if num % 8 == 0:
                        print(""YES"")
                        print(num)
                        return
        print(""NO"")

solve()
","53.333333333333336","40.0","46.666666666666664","86.66666666666667","53.333333333333336","60.0","33.33333333333333","53.333333333333336","46.666666666666664","40.0","33.33333333333333","80.0","60.0","73.33333333333333","60.0","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/213","
QUESTION:
In a building where Polycarp lives there are equal number of flats on each floor. Unfortunately, Polycarp don't remember how many flats are on each floor, but he remembers that the flats are numbered from 1 from lower to upper floors. That is, the first several flats are on the first floor, the next several flats are on the second and so on. Polycarp don't remember the total number of flats in the building, so you can consider the building to be infinitely high (i.e. there are infinitely many floors). Note that the floors are numbered from 1.

Polycarp remembers on which floors several flats are located. It is guaranteed that this information is not self-contradictory. It means that there exists a building with equal number of flats on each floor so that the flats from Polycarp's memory have the floors Polycarp remembers.

Given this information, is it possible to restore the exact floor for flat n? 


-----Input-----

The first line contains two integers n and m (1 ≤ n ≤ 100, 0 ≤ m ≤ 100), where n is the number of the flat you need to restore floor for, and m is the number of flats in Polycarp's memory.

m lines follow, describing the Polycarp's memory: each of these lines contains a pair of integers k_{i}, f_{i} (1 ≤ k_{i} ≤ 100, 1 ≤ f_{i} ≤ 100), which means that the flat k_{i} is on the f_{i}-th floor. All values k_{i} are distinct.

It is guaranteed that the given information is not self-contradictory.


-----Output-----

Print the number of the floor in which the n-th flat is located, if it is possible to determine it in a unique way. Print -1 if it is not possible to uniquely restore this floor.


-----Examples-----
Input
10 3
6 2
2 1
7 3

Output
4

Input
8 4
3 1
6 2
5 2
2 1

Output
-1



-----Note-----

In the first example the 6-th flat is on the 2-nd floor, while the 7-th flat is on the 3-rd, so, the 6-th flat is the last on its floor and there are 3 flats on each floor. Thus, the 10-th flat is on the 4-th floor.

In the second example there can be 3 or 4 flats on each floor, so we can't restore the floor for the 8-th flat.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    flats = []
    for _ in range(m):
        k, f = map(int, input().split())
        flats.append((k, f))

    possible_floors = set()
    for k, f in flats:
        possible_floors.add((k + f - 1) // f)

    if len(possible_floors) == 1:
        print(list(possible_floors)[0])
    else:
        print(-1)

solve()","
def solve():
    n, m = map(int, input().split())
    flats_on_floors = {}
    
    for _ in range(m):
        k, f = map(int, input().split())
        if f not in flats_on_floors:
            flats_on_floors[f] = [k]
        else:
            flats_on_floors[f].append(k)
    
    possible_floors = set()
    for floor, flats in flats_on_floors.items():
        if len(flats) == max(flats) - min(flats) + 1:
            possible_floors.add((n - min(flats)) % len(flats) + 1)
    
    if len(possible_floors) == 1:
        print(possible_floors.pop())
    else:
        print(-1)

solve()","
def solve():
    n, m = map(int, input().split())
    flats_on_floors = {}
    
    for _ in range(m):
        k, f = map(int, input().split())
        if f not in flats_on_floors:
            flats_on_floors[f] = []
        flats_on_floors[f].append(k)
    
    possible_floors = set(range(1, 101))
    
    for floor, flats in flats_on_floors.items():
        flats.sort()
        gap = set()
        for i in range(1, len(flats)):
            gap.add(flats[i] - flats[i-1])
        if len(gap) == 1:
            possible_floors &= {floor + (flats[0]-1) // gap.pop()}
    
    if len(possible_floors) == 1:
        print(possible_floors.pop())
    else:
        print(-1)

solve()
  ","
def solve():
    n, m = map(int, input().split())
    memory = []
    for _ in range(m):
        k, f = map(int, input().split())
        memory.append((k, f))

    possible_floors = set()
    for f_i in range(1, 101):
        valid = True
        for k, f in memory:
            if (k + f_i - f) % m != 0:
                valid = False
                break
        if valid:
            possible_floors.add((k + n - f) // m)
    
    if len(possible_floors) == 1:
        print(*possible_floors)
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    flats_info = {}
    for _ in range(m):
        k, f = map(int, input().split())
        flats_info[k] = f
        
    possible_floors = set()
    for k, f in flats_info.items():
        possible_floors.add((k-1) // (n // m))
    
    if len(possible_floors) == 1:
        print((n-1) // (n // m) + 1)
    else:
        print(-1)

solve()","
def solve():
    n, m = map(int, input().split())
    flats_info = []

    for i in range(m):
        k, f = map(int, input().split())
        flats_info.append((k, f))

    possible_floors = set()
    for f in flats_info:
        possible_floors.add(f[1])

    if len(possible_floors) > 1:
        print(-1)
    else:
        unique_floor = -1
        for f in flats_info:
            if n % f[0] == 0:
                unique_floor = n // f[0]
                break

        print(unique_floor)

solve()
  ","
def solve():
    n, m = map(int, input().split())
    flat_memory = {}
    for _ in range(m):
        k, f = map(int, input().split())
        if f in flat_memory:
            flat_memory[f].append(k)
        else:
            flat_memory[f] = [k]
    
    possible_floors = set()
    for floor, flats in flat_memory.items():
        if len(flats) == max(flats) - min(flats) + 1:
            possible_floors.add(floor)
    
    result = -1
    for floor in possible_floors:
        if n in range(min(flat_memory[floor]), max(flat_memory[floor])+1):
            result = floor
            break
    
    print(result)

# Example Usage:
# solve()
","
def solve():
    n, m = map(int, input().split())
    flats_info = {}
    for _ in range(m):
        k, f = map(int, input().split())
        if f in flats_info:
            flats_info[f].append(k)
        else:
            flats_info[f] = [k]
    
    possible_floors = set()
    for i in range(1, 101):
        valid_floor = True
        for k in flats_info.keys():
            if k % i != 0 or k // i not in flats_info[k]:
                valid_floor = False
                break
        if valid_floor:
            possible_floors.add(i)
    
    if len(possible_floors) == 1:
        print(n // list(possible_floors)[0] + 1)
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    flats = []
    for _ in range(m):
        k, f = map(int, input().split())
        flats.append((k, f))

    for floor in range(1, 101):
        possible = True
        for k, f in flats:
            check = (k + floor - 1) // floor
            if check != f:
                possible = False
                break
        if possible:
            if (n + floor - 1) // floor == 1:
                print(floor)
                return
    print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    memory = []
    
    for _ in range(m):
        k, f = map(int, input().split())
        memory.append((k, f))
    
    possible_floors = set()
    
    for i in range(1, 101):
        valid = True
        
        for k, f in memory:
            if (k + i - 1) // i != f:
                valid = False
                break
        
        if valid:
            possible_floors.add((n + i - 1) // i)
    
    if len(possible_floors) == 1:
        print(possible_floors.pop())
    else:
        print(-1)

# Example usage
if __name__ == ""__main__"":
    solve()
","
def solve():
    n, m = map(int, input().split())
    flat_info = []
    for _ in range(m):
        k, f = map(int, input().split())
        flat_info.append((k, f))

    possible_floors = set()
    for k, f in flat_info:
        possible_floors.add((k + f - 1) // f)

    if len(possible_floors) == 1:
        print(list(possible_floors)[0])
    else:
        print(-1)

solve()
","
def solve():
    n, m = map(int, input().split())
    flats_on_floors = {}
    
    for _ in range(m):
        k, f = map(int, input().split())
        flats_on_floors[k] = f
    
    potential_floors = set(flats_on_floors.values())
    
    if len(potential_floors) > 1:
        print(-1)
    else:
        floor_number = next(iter(potential_floors))
        print(((n-1) // len(flats_on_floors) + 1) * len(flats_on_floors) // len(potential_floors) + 1)

solve()
","
def solve():
    n, m = map(int, input().split())
    flats = {}
    
    for _ in range(m):
        k, f = map(int, input().split())
        flats[k] = f

    possible_floors = set(flats.values())
    
    if len(possible_floors) == 1:
        floor = list(possible_floors)[0]
        position_on_floor = sorted(flats.keys()).index(n) % len(flats) + 1
        floor_with_n = (n - position_on_floor) // len(flats) + 1
        if floor_with_n > 0:
            print(floor_with_n)
        else:
            print(-1)
    else:
        print(-1)

solve()","
def solve():
    n, m = map(int, input().split())
    memory = []
    for _ in range(m):
        k, f = map(int, input().split())
        memory.append((k, f))

    possible_floors = []
    for f in range(1, 101):
        valid = True
        for k, fi in memory:
            if (k - 1) // f + 1 != fi:
                valid = False
                break
        if valid:
            possible_floors.append(f)

    if len(possible_floors) == 1:
        print((n - 1) // possible_floors[0] + 1)
    else:
        print(-1)

solve()","
def solve():
    # Input
    n, m = map(int, input().split())
    memory = {}
    for _ in range(m):
        k, f = map(int, input().split())
        memory[k] = f
    
    # Processing
    divisors = []
    for i in range(1, n+1):
        if all(i % k == f % k for k, f in memory.items()):
            divisors.append(i)
    
    # Output
    if len(divisors) == 1:
        print(divisors[0])
    else:
        print(-1)

solve()","
def solve():
    n, m = map(int, input().split())
    flats = []
    for _ in range(m):
        k, f = map(int, input().split())
        flats.append((k, f))
    
    possible_floors = set()
    for f in flats:
        possible_floors.add((f[0] - 1) // ((f[1] - 1) or 1))
    
    if len(possible_floors) == 1:
        print(list(possible_floors)[0] + 1)
    else:
        print(-1)

solve()
  ","33.33333333333333","33.33333333333333","20.0","33.33333333333333","26.666666666666668","33.33333333333333","0.0","13.333333333333334","33.33333333333333","100.0","33.33333333333333","6.666666666666667","33.33333333333333","66.66666666666666","53.333333333333336","33.33333333333333","","","","","","","","","","","","","","","",""
"APPS/214","
QUESTION:
Bishwock is a chess figure that consists of three squares resembling an ""L-bar"". This figure can be rotated by 90, 180 and 270 degrees so it can have four possible states:

 

XX   XX   .X   X.

X.   .X   XX   XX

 

Bishwocks don't attack any squares and can even occupy on the adjacent squares as long as they don't occupy the same square. 

Vasya has a board with $2\times n$ squares onto which he wants to put some bishwocks. To his dismay, several squares on this board are already occupied by pawns and Vasya can't put bishwocks there. However, pawns also don't attack bishwocks and they can occupy adjacent squares peacefully.

Knowing the positions of pawns on the board, help Vasya to determine the maximum amount of bishwocks he can put onto the board so that they wouldn't occupy the same squares and wouldn't occupy squares with pawns.


-----Input-----

The input contains two nonempty strings that describe Vasya's board. Those strings contain only symbols ""0"" (zero) that denote the empty squares and symbols ""X"" (uppercase English letter) that denote the squares occupied by pawns. Strings are nonempty and are of the same length that does not exceed $100$.


-----Output-----

Output a single integer — the maximum amount of bishwocks that can be placed onto the given board.


-----Examples-----
Input
00
00

Output
1
Input
00X00X0XXX0
0XXX0X00X00

Output
4
Input
0X0X0
0X0X0

Output
0
Input
0XXX0
00000

Output
2
Use user-input-Based format and function signature solve()","
def solve():
    board1 = input().strip()
    board2 = input().strip()
    
    n = len(board1)
    bishwocks = 0
    
    for i in range(n):
        if board1[i] == '0' and board2[i] == '0':
            bishwocks += 1
        elif i < n-1 and board1[i] == '0' and board1[i+1] == '0':
            i += 1
            bishwocks += 1
        elif i < n-1 and board2[i] == '0' and board2[i+1] == '0':
            i += 1
            bishwocks += 1
    
    print(bishwocks)

solve()
","
def solve():
    # Taking input of board strings
    board1 = input().strip()
    board2 = input().strip()
    
    n = len(board1)
    
    # Initializing variables
    bishwocks = 0
    
    # Looping through the board strings to count bishwocks
    for i in range(n):
        if i < n-1 and board1[i] == '0' and board1[i+1] == '0' and board2[i] == '0':
            bishwocks += 1
            i += 1
        elif board1[i] == '0' and board2[i] == '0':
            bishwocks += 1
    
    return bishwocks


solve()","
def solve():
    import collections

    def rotate_bishwock(bishwock):
        rotated_bishwock = []
        for col in range(len(bishwock[0])):
            new_row = ''
            for row in reversed(bishwock):
                new_row += row[col]
            rotated_bishwock.append(new_row)
        return rotated_bishwock

    def get_bishwock_states():
        bishwock = ['XX', 'X.']
        bishwock_states = []
        for _ in range(4):
            bishwock_states.append(bishwock)
            bishwock = rotate_bishwock(bishwock)
        return bishwock_states

    board = []
    for _ in range(2):
        board.append(input())

    bishwock_states = get_bishwock_states()
    num_bishwocks = 0
    for i in range(len(board[0]) - 1):
        for j in range(len(board[1])):
            can_put_bishwock = True
            for state in bishwock_states:
                can_place = True
                for row in range(2):
                    for col in range(2):
                        if board[row][i + col] == 'X' and state[row][col] == 'X':
                            can_place = False
                            break
                if can_place:
                    num_bishwocks += 1
                    can_put_bishwock = False
                    break
            if not can_put_bishwock:
                break

    print(num_bishwocks)

solve()
","
def solve(board1, board2):
    n = len(board1)
    bishwock_count = 0
    
    for i in range(n):
        if board1[i] == '0' and board2[i] == '0':
            bishwock_count += 1
            if i+1 < n and board1[i+1] == '0' and board2[i+1] == '0':
                i += 1
    
    return bishwock_count

solve()","
def solve(board1, board2):
    n = len(board1)
    count = 0
    for i in range(n):
        if board1[i] == '0' and board2[i] == '0':
            count += 1
    return count

# Test cases
print(solve(""00"", ""00""))  # Output: 1
print(solve(""00X00X0XXX0"", ""0XXX0X00X00""))  # Output: 4
print(solve(""0X0X0"", ""0X0X0""))  # Output: 0
print(solve(""0XXX0"", ""00000""))  # Output: 2

solve()","
def solve(board1, board2):
    n = len(board1)
    bishwocks = 0
    for i in range(n - 1):
        if board1[i] == board2[i] == '0':
            bishwocks += 1
            board1 = board1[:i] + 'X' + board1[i + 1:]
            board1 = board1[:i + 1] + 'X' + board1[i + 2:]
            board2 = board2[:i] + 'X' + board2[i + 1:]
    return bishwocks

solve()","
def solve(board1, board2):
    count = 0
    
    for i in range(len(board1)):
        if board1[i] == '0' and board2[i] == '0':
            count += 1
    
    return count

# Example Usage
board1 = input().strip()
board2 = input().strip()
print(solve(board1, board2))

solve()","
def solve(board1: str, board2: str) -> int:
    n = len(board1)
    bischocks = 0
    for i in range(n):
        if board1[i] == '0' and board2[i] == '0':
            bischocks += 1
            if i < n-1 and board1[i+1] == '0' and board2[i+1] == '0':
                i += 1
    return bischocks

solve()","
def solve():
    s = input()
    t = input()
    n = len(s)
    
    total = 0
    for i in range(n):
        if i+2 < n and s[i] == '0' and s[i+1] == '0' and s[i+2] == '0':
            total += 1
            s = list(s)
            s[i] = s[i+1] = s[i+2] = 'X'
            s = ''.join(s)
        if i+2 < n and t[i] == '0' and t[i+1] == '0' and t[i+2] == '0':
            total += 1
            t = list(t)
            t[i] = t[i+1] = t[i+2] = 'X'
            t = ''.join(t)
    
    print(total)

solve()
","
def solve(board1, board2):
    n = len(board1)
    bishwocks = 0
    for i in range(n):
        if board1[i] == '0' and board2[i] == '0':
            bishwocks += 1
    return bishwocks

board1 = input()
board2 = input()
print(solve(board1, board2))

solve()","
def solve(board1: str, board2: str) -> int:
    n = len(board1)
    max_bishwocks = 0
    for i in range(1, n-1):
        if board1[i] == '0' and board1[i-1] == '0' and board1[i+1] == '0':
            max_bishwocks += 1
            board1 = board1[:i-1] + 'X' + board1[i+1:]
    for i in range(1, n-1):
        if board2[i] == '0' and board2[i-1] == '0' and board2[i+1] == '0':
            max_bishwocks += 1
            board2 = board2[:i-1] + 'X' + board2[i+1:]
    return max_bishwocks
 
solve()","
def solve(board1, board2):
    rows = len(board1)
    cols = len(board1[0])
    
    dp = [[0 for _ in range(cols)] for _ in range(rows)]
    
    for i in range(rows):
        dp[i][0] = 1 if board1[i][0] == '0' and board2[i][0] == '0' else 0
        
    for j in range(cols):
        dp[0][j] = 1 if board1[0][j] == '0' and board2[0][j] == '0' else 0
    
    for i in range(1, rows):
        for j in range(1, cols):
            if board1[i][j] == '0' and board2[i][j] == '0':
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1
                
    return dp[rows-1][cols-1]

solve()","
def solve():
    s1 = input()
    s2 = input()
    
    n = len(s1)
    count = 0
    
    for i in range(n):
        if s1[i] == '0' and s2[i] == '0':
            count += 1
    
    print(count // 3)

solve()
","
def solve(board1, board2):
    n = len(board1)
    bishwocks = 0
    for i in range(n):
        if board1[i] == '0' and board2[i] == '0':
            if i+2 < n and board1[i+1] == '0' and board2[i+1] == '0' and board1[i+2] == '0' and board2[i+2] == '0':
                bishwocks += 1
                i += 2
    return bishwocks

solve()","
def solve():
    n = len(input()) // 2
    a = input().split('X' * n)
    return len(a) - 1

if __name__ == '__main__':
    print(solve())
  
solve()","
def solve(board1, board2):
    n = len(board1)
    bishwock_count = 0
    
    for i in range(n):
        if board1[i] == '0' and board2[i] == '0':
            bishwock_count += 1
    
    return bishwock_count

# Input
board1 = input().strip()
board2 = input().strip()

# Output
print(solve(board1, board2))

solve()","46.666666666666664","0.0","93.33333333333333","0.0","0.0","0.0","0.0","0.0","46.666666666666664","0.0","0.0","0.0","40.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/215","
QUESTION:
Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string s consisting only of lowercase and uppercase Latin letters.

Let A be a set of positions in the string. Let's call it pretty if following conditions are met:  letters on positions from A in the string are all distinct and lowercase;  there are no uppercase letters in the string which are situated between positions from A (i.e. there is no such j that s[j] is an uppercase letter, and a_1 < j < a_2 for some a_1 and a_2 from A). 

Write a program that will determine the maximum number of elements in a pretty set of positions.


-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 200) — length of string s.

The second line contains a string s consisting of lowercase and uppercase Latin letters.


-----Output-----

Print maximum number of elements in pretty set of positions for string s.


-----Examples-----
Input
11
aaaaBaabAbA

Output
2

Input
12
zACaAbbaazzC

Output
3

Input
3
ABC

Output
0



-----Note-----

In the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters 'a', position 8 contains letter 'b'. The pair of positions 1 and 8 is not suitable because there is an uppercase letter 'B' between these position.

In the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements.

In the third example the given string s does not contain any lowercase letters, so the answer is 0.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input()
    
    max_pretty_set = 0
    for i in range(n):
        pretty_set = set()
        for j in range(i, n):
            if s[j].islower():
                pretty_set.add(s[j])
                if all(s[k].islower() for k in range(i, j+1)) and all(s[k].isupper() for k in range(j+1, n)):
                    max_pretty_set = max(max_pretty_set, len(pretty_set))
    
    print(max_pretty_set)

solve()
","
def solve():
    n = int(input())
    s = input()

    max_pretty_set = 0
    for i in range(n):
        pretty_set = set()
        for j in range(i, n):
            if s[j].islower():
                pretty_set.add(s[j])
                max_pretty_set = max(max_pretty_set, len(pretty_set))
            else:
                break

    print(max_pretty_set)


solve()
","
def solve():
    n = int(input())
    s = input()
    max_pretty = 0

    for i in range(n):
        pretty_set = set()
        for j in range(i, n):
            if s[j].islower():
                pretty_set.add(s[j])
            else:
                break
        max_pretty = max(max_pretty, len(pretty_set))

    print(max_pretty)

solve()","
def solve():
    n = int(input())
    s = input()

    max_pretty_set = 0
    for i in range(n):
        lowercase_letters = set()
        for j in range(i, n):
            if s[j].islower():
                lowercase_letters.add(s[j])
                max_pretty_set = max(max_pretty_set, len(lowercase_letters))
            else:
                break

    print(max_pretty_set)

solve()
","
def solve():
    n = int(input())
    s = input().strip()
    
    uppercase_positions = [i for i, char in enumerate(s) if char.isupper()]
    if not uppercase_positions:
        print(0)
        return
    
    max_elements = 0
    for i in range(len(uppercase_positions)):
        temp_max = 0
        for j in range(i, len(uppercase_positions)):
            between_uppercase = s[uppercase_positions[i] + 1:uppercase_positions[j]]
            if not any(char.isupper() for char in between_uppercase):
                temp_max = max(temp_max, j - i + 1)
        max_elements = max(max_elements, temp_max)
    
    print(max_elements)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    max_pretty_set = 0
    for i in range(n):
        pretty_set = set()
        valid = True
        
        for j in range(i, n):
            if s[j].isupper():
                if s[j].lower() not in pretty_set:
                    pretty_set.add(s[j].lower())
                else:
                    valid = False
                    break
        
        if valid:
            max_pretty_set = max(max_pretty_set, len(pretty_set))
    
    print(max_pretty_set)

solve()
","
def solve():
    n = int(input())
    s = input()

    max_pretty = 0
    for i in range(n):
        lowercase_letters = set()
        uppercase_found = False
        pretty_count = 0

        for j in range(i, n):
            if s[j].islower():
                if s[j] not in lowercase_letters:
                    lowercase_letters.add(s[j])
                    pretty_count += 1
                else:
                    break
            else:
                uppercase_found = True

            if not uppercase_found:
                max_pretty = max(max_pretty, pretty_count)

    print(max_pretty)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    s = input()
    
    pretty_set = 0
    for i in range(n):
        lowercase_letters = set()
        for j in range(i, n):
            if s[j].isupper():
                break
            lowercase_letters.add(s[j])
            pretty_set = max(pretty_set, len(lowercase_letters))
    
    print(pretty_set)

solve()","
def solve():
    n = int(input())
    s = input()
    
    max_pretty_set = 0
    for i in range(n):
        lowercase_letters = set()
        uppercase_found = False
        for j in range(i, n):
            if s[j].islower():
                lowercase_letters.add(s[j])
                if not uppercase_found:
                    max_pretty_set = max(max_pretty_set, len(lowercase_letters))
            else:
                uppercase_found = True
    
    print(max_pretty_set)

solve()
","
def solve():
    n = int(input())
    s = input()

    max_pretty = 0

    for i in range(n):
        for j in range(i, n):
            pretty_set = set()
            is_pretty = True
            for k in range(i, j + 1):
                if s[k].isupper():
                    is_pretty = False
                    break
                pretty_set.add(s[k])
            if is_pretty and len(pretty_set) > max_pretty:
                max_pretty = len(pretty_set)

    print(max_pretty)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    max_pretty_positions = 0
    for i in range(n):
        pretty_positions = set()
        uppercase_found = False
        
        for j in range(i, n):
            if s[j].isupper():
                uppercase_found = True
            if not uppercase_found and s[j].islower():
                pretty_positions.add(s[j])
            
            if uppercase_found:
                break
        
        max_pretty_positions = max(max_pretty_positions, len(pretty_positions))
    
    print(max_pretty_positions)

solve()
","
def solve():
    n = int(input())
    s = input()

    max_pretty_set = 0
    for i in range(n):
        for j in range(i, n):
            pretty_set = set()
            valid = True
            for k in range(i, j+1):
                if s[k].isupper():
                    if any(s[m].isupper() for m in range(i+1, j)):
                        valid = False
                        break
                else:
                    pretty_set.add(s[k])
            
            if valid:
                max_pretty_set = max(max_pretty_set, len(pretty_set))

    print(max_pretty_set)

solve()
  ","
def solve():
    n = int(input())
    s = input()
    max_pretty_set = 0
    for i in range(n):
        pretty_positions = {s[i].lower()}
        for j in range(i+1, n):
            if s[j].isupper():
                break
            pretty_positions.add(s[j].lower())
            max_pretty_set = max(max_pretty_set, len(pretty_positions))
    print(max_pretty_set)

solve()
","
def solve():
    n = int(input())
    s = input()
    
    count = 0
    max_count = 0
    for i in range(n):
        if s[i].islower():
            count += 1
            max_count = max(max_count, count)
        else:
            count = 0
    
    print(max_count)

solve()
","
def solve():
    n = int(input())
    s = input()

    max_pretty = 0
    for i in range(n):
        pretty_positions = set()
        for j in range(i, n):
            if s[j].islower():
                pretty_positions.add(s[j])
                if all(s[k].islower() for k in range(i, j+1)) and len(pretty_positions) > max_pretty:
                    max_pretty = len(pretty_positions)

    print(max_pretty)

solve()","
def solve():
    n = int(input())
    s = input()

    max_pretty_positions = 0
    for i in range(n):
        lowercase_chars = set()
        max_lower = 0
        for j in range(i, n):
            if s[j].islower():
                lowercase_chars.add(s[j])
                max_lower = max(max_lower, len(lowercase_chars))
            else:
                break
        max_pretty_positions = max(max_pretty_positions, max_lower)

    print(max_pretty_positions)

solve()
","86.66666666666667","100.0","100.0","100.0","13.333333333333334","13.333333333333334","80.0","100.0","100.0","100.0","100.0","100.0","66.66666666666666","53.333333333333336","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/216","
QUESTION:
You are given a sequence a consisting of n integers. You may partition this sequence into two sequences b and c in such a way that every element belongs exactly to one of these sequences. 

Let B be the sum of elements belonging to b, and C be the sum of elements belonging to c (if some of these sequences is empty, then its sum is 0). What is the maximum possible value of B - C?


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 100) — the number of elements in a.

The second line contains n integers a_1, a_2, ..., a_{n} ( - 100 ≤ a_{i} ≤ 100) — the elements of sequence a.


-----Output-----

Print the maximum possible value of B - C, where B is the sum of elements of sequence b, and C is the sum of elements of sequence c.


-----Examples-----
Input
3
1 -2 0

Output
3

Input
6
16 23 16 15 42 8

Output
120



-----Note-----

In the first example we may choose b = {1, 0}, c = { - 2}. Then B = 1, C =  - 2, B - C = 3.

In the second example we choose b = {16, 23, 16, 15, 42, 8}, c = {} (an empty sequence). Then B = 120, C = 0, B - C = 120.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort(reverse=True)
    
    b = sum(a[i] for i in range(n) if i % 2 == 0)
    c = sum(a[i] for i in range(n) if i % 2 == 1)
    
    print(b - c)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort(reverse=True)
    
    max_diff = 0
    prefix_sum = 0
    
    for i in range(n):
        prefix_sum += a[i]
        max_diff = max(max_diff, prefix_sum - sum(a[i+1:]))
    
    print(max_diff)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort(reverse=True)
    b = sum(a) if a[0] < 0 else sum(a[1:]) + a[0]
    print(b)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort()

    return sum(a[-1*(n//2):]) - sum(a[:n//2])

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    a.sort(reverse=True)

    b = a[:n//2] + [0] * (n - n//2)
    c = a[n//2:] + [0] * ((n + 1) // 2)

    return sum(b) - sum(c)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    a.sort(reverse=True)

    b = sum([a[i] for i in range(n) if i % 2 == 0])
    c = sum([a[i] for i in range(n) if i % 2 == 1])

    print(b - c)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort(reverse=True)
    
    b = sum(a[:n//2 + n%2])
    c = sum(a[n//2 + n%2:])
    
    print(b - c)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort(reverse=True)
    diff = sum(a)
    for i in range(1, n):
        diff = max(diff, sum(a[:i]) - sum(a[i:]))
    print(diff)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort(reverse=True)
    
    max_diff = 0
    prefix_sum = 0
    
    for i in range(n):
        prefix_sum += a[i]
        diff = prefix_sum - sum(a[i+1:])
        max_diff = max(max_diff, diff)
    
    print(max_diff)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    a.sort(reverse=True)
    sum_b = sum(a[:n // 2 + n % 2])
    sum_c = sum(a[n // 2 + n % 2:])
    
    print(sum_b - sum_c)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    a.sort(reverse=True)

    result = a[0]
    for i in range(1, n):
        if a[i] > 0:
            result += a[i]

    print(result)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    a.sort(reverse=True)
    max_diff = sum(a)

    prefix_sum = 0
    for i in range(n):
        prefix_sum += a[i]
        max_diff = max(max_diff, prefix_sum - sum(a[i+1:]))

    print(max_diff)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort(reverse=True)
    B = sum(a) if a[0] < 0 else sum(a[1:])
    print(B)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    a.sort(reverse=True)

    b = sum([a[i] for i in range(n) if i % 2 == 0])
    c = sum([a[i] for i in range(n) if i % 2 == 1])

    print(b - c)

solve()","
def solve():
    n = int(input())
    elements = list(map(int, input().split()))
    positive_nums = [x for x in elements if x > 0]
    negative_nums = [x for x in elements if x < 0]
    
    positive_sum = sum(positive_nums)
    negative_sum = sum(negative_nums)
    
    return positive_sum - negative_sum

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    a.sort(reverse=True)
    b = sum(filter(lambda x: x >= 0, a))
    c = sum(filter(lambda x: x < 0, a))
    print(b - c)


solve()
","6.666666666666667","86.66666666666667","6.666666666666667","0.0","0.0","6.666666666666667","66.66666666666666","86.66666666666667","86.66666666666667","66.66666666666666","6.666666666666667","86.66666666666667","0.0","6.666666666666667","0.0","100.0","","","","","","","","","","","","","","","",""
"APPS/217","
QUESTION:
A bus moves along the coordinate line Ox from the point x = 0 to the point x = a. After starting from the point x = 0, it reaches the point x = a, immediately turns back and then moves to the point x = 0. After returning to the point x = 0 it immediately goes back to the point x = a and so on. Thus, the bus moves from x = 0 to x = a and back. Moving from the point x = 0 to x = a or from the point x = a to x = 0 is called a bus journey. In total, the bus must make k journeys.

The petrol tank of the bus can hold b liters of gasoline. To pass a single unit of distance the bus needs to spend exactly one liter of gasoline. The bus starts its first journey with a full petrol tank.

There is a gas station in point x = f. This point is between points x = 0 and x = a. There are no other gas stations on the bus route. While passing by a gas station in either direction the bus can stop and completely refuel its tank. Thus, after stopping to refuel the tank will contain b liters of gasoline.

What is the minimum number of times the bus needs to refuel at the point x = f to make k journeys? The first journey starts in the point x = 0.


-----Input-----

The first line contains four integers a, b, f, k (0 < f < a ≤ 10^6, 1 ≤ b ≤ 10^9, 1 ≤ k ≤ 10^4) — the endpoint of the first bus journey, the capacity of the fuel tank of the bus, the point where the gas station is located, and the required number of journeys.


-----Output-----

Print the minimum number of times the bus needs to refuel to make k journeys. If it is impossible for the bus to make k journeys, print -1.


-----Examples-----
Input
6 9 2 4

Output
4

Input
6 10 2 4

Output
2

Input
6 5 4 3

Output
-1



-----Note-----

In the first example the bus needs to refuel during each journey.

In the second example the bus can pass 10 units of distance without refueling. So the bus makes the whole first journey, passes 4 units of the distance of the second journey and arrives at the point with the gas station. Then it can refuel its tank, finish the second journey and pass 2 units of distance from the third journey. In this case, it will again arrive at the point with the gas station. Further, he can refill the tank up to 10 liters to finish the third journey and ride all the way of the fourth journey. At the end of the journey the tank will be empty. 

In the third example the bus can not make all 3 journeys because if it refuels during the second journey, the tanks will contain only 5 liters of gasoline, but the bus needs to pass 8 units of distance until next refueling.
Use user-input-Based format and function signature solve()","
def solve():
    a, b, f, k = map(int, input().split())
    
    if b < f or b < a - f:
        print(-1)
        return
    
    refuels = 0
    for i in range(k):
        if i % 2 == 0:
            if b < (a - f) * (k - i) + f * i:
                refuels += 1
                b = b + f
        else:
            if b < f * (k - i) + (a - f) * i:
                refuels += 1
                b = b + a - f
    
    print(refuels)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    remaining_fuel = b
    refuel_count = 0
    
    for i in range(k):
        if i % 2 == 0:
            distance_to_station = f if i != k-1 else a
        else:
            distance_to_station = a - f if i != k-1 else a
        
        if distance_to_station > remaining_fuel:
            refuel_count += 1
            remaining_fuel = b
        
        remaining_fuel -= distance_to_station
        if remaining_fuel < 0:
            print(-1)
            return
    
    print(refuel_count)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    dist_left = a
    refuels = 0
    
    for i in range(k):
        if i % 2 == 0:
            dist_left -= f
        else:
            dist_left -= (a - f)
        
        if dist_left < 0:
            print(-1)
            return
        
        if dist_left > b:
            dist_left = a if i != k - 1 else a - f
            refuels += 1
    
    print(refuels)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())

    total_journeys = k * 2
    gas_needed = [0] * (total_journeys + 1)
    gas_needed[0] = a

    for i in range(1, total_journeys + 1):
        if i % 2 != 0:
            gas_needed[i] = a - f
        else:
            gas_needed[i] = f

    num_refuels = 0
    tank = b

    for i in range(total_journeys):
        if tank < gas_needed[i]:
            tank = b
            num_refuels += 1
        tank -= gas_needed[i]

        if tank < 0:
            print(-1)
            return

    print(num_refuels)

solve()
  ","
def solve():
    a, b, f, k = map(int, input().split())
    distance = a - f
    total_journeys = 2 * k
    refuel_count = 0

    if b < distance or b < 2*f or b < f:
        print(-1)
        return

    for _ in range(k):
        if total_journeys // 2 % 2 == 0:
            if b < 2 * (a - f):
                total_journeys -= 1
                refuel_count += 1
                b = 2 * b
            else:
                b -= 2 * (a - f)
        else:
            if b < 2 * f:
                total_journeys -= 1
                refuel_count += 1
                b = 2 * b
            else:
                b -= 2 * f

    print(refuel_count)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    distance = [0] + [f, a - f] * k + [f]
    refuel_count = 0
    remaining_fuel = b
    
    for i in range(1, len(distance)):
        remaining_fuel -= distance[i]
        if remaining_fuel < 0:
            return -1
        if i % 2 == 0:
            refuel = min(b, distance[i + 1])
            remaining_fuel = b - refuel
            refuel_count += 1
    
    return refuel_count

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    if b < f or b < a - f:
        print(-1)
        return
        
    refuels = 0
    distance_left = a
    for i in range(k):
        if i % 2 == 0:
            if distance_left > b - f:
                distance_left -= b - f
            else:
                distance_left = a - (b - f)
                refuels += 1
        else:
            if distance_left > f:
                distance_left -= f
            else:
                distance_left = f
                refuels += 1
        
        if distance_left <= 0:
            print(refuels)
            return
    
    print(-1)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    dist_to_f = [f, a-f, f] * k
    total_dist = a * 2 * k
    
    if b < max(dist_to_f):
        print(-1)
        return

    refills = 0
    curr_tank = b

    for dist in dist_to_f:
        if curr_tank < dist:
            refills += 1
            curr_tank = b
        curr_tank -= dist

    print(refills)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    total_distance = a * k
    refuel_count = 0
    current_fuel = b
    current_position = 0
    required_fuel_to_refuel = b if f > a/2 else 0
    
    for i in range(k):
        if i % 2 == 0:
            if current_fuel < required_fuel_to_refuel:
                refuel_count += 1
                current_fuel = b
        else:
            if current_fuel < a-required_fuel_to_refuel:
                refuel_count += 1
                current_fuel = b
        
        current_fuel -= abs(current_position - f) + abs(a - current_position)
        current_position = a
        
    if current_fuel < abs(a-current_position):
        refuel_count += 1
    
    if refuel_count > k:
        print(-1)
    else:
        print(refuel_count)

solve()","
def solve():
    a, b, f, k = map(int, input().split())
    total_stops = 0

    for _ in range(k):
        if f > b or f > a - b:
            print(-1)
            return

        if f <= b or f <= a - b:
            a -= 2 * f
            total_stops += 1

        if total_stops < k - 1:
            a += 2 * f

    print(total_stops)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    total_journeys = k * 2
    fuel_stop_count = 0
    
    for i in range(k):
        if i % 2 == 0:  # Going from 0 to a
            distance = a if i == 0 else (2 * a - f)
        else:  # Going from a to 0
            distance = a if i == total_journeys - 1 else f
            
        if distance > b:
            return -1
        
        if distance > b - f:
            fuel_stop_count += 1
            b = b + f if i != total_journeys - 1 else b
    
    return fuel_stop_count

# Call the function to solve the problem
solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    if b < f or b < a - f:
        print(-1)
        return
    
    total_refuels = 0
    
    for _ in range(k):
        if k % 2 == 0:
            if b < 2 * (a - f) or b < 2 * f:
                print(total_refuels)
                return
            b -= 2 * max(a - f, f)
        else:
            if b < 2 * f or b < 2 * (a - f):
                print(total_refuels)
                return
            b -= 2 * f
        total_refuels += 1
    print(total_refuels)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    
    distance_between = 2*f
    refill_count = 0
    
    for i in range(k):
        if i % 2 == 0:
            if b < f or b < a - f:
                refill_count = -1
                break
            b -= i == 0 and f or distance_between
        else:
            if b < a - f or b < f:
                refill_count = -1
                break
            b -= i == 1 and a - f or distance_between
            
        if b < 0:
            refill_count += 1
            b = 2*f
            
    print(refill_count)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())
    if b < f or b < a - f:
        print(""-1"")
        return
    
    res = 0
    for i in range(k):
        if i % 2 == 0:
            if i == k - 1:
                d = a - f
            else:
                d = a
        else:
            d = f

        if b < d:
            b = a
            res += 1
        b -= d

        if b < 0:
            print(""-1"")
            return
        
    print(res)

solve()
  ","
def solve():
    a, b, f, k = map(int, input().split())
    
    if b < f or b < a - f:
        print(-1)
        return
    
    refuels_needed = 0
    curr_distance = 0
    starting_station = f
    
    for i in range(k):
        if i % 2 == 0:
            if b - (a-starting_station) < 0:
                refuels_needed += 1
                starting_station = f
                curr_distance = 0
            b -= (a-starting_station)
            curr_distance = a
        else:
            if b - starting_station < 0:
                refuels_needed += 1
                starting_station = f
                curr_distance = 0
            b -= starting_station
            curr_distance = starting_station
    
    print(refuels_needed)

solve()
","
def solve():
    a, b, f, k = map(int, input().split())

    min_refuels = 0

    for i in range(k):
        if i % 2 == 0:
            dist_to_end = a - f if i == k - 1 else a
        else:
            dist_to_end = f if i == k - 1 else 0
        
        if dist_to_end > b:
            return print(-1)

        if i < k - 1:
            if dist_to_end * 2 > b:
                b = 2 * b - dist_to_end
                min_refuels += 1
            b -= dist_to_end

    return print(min_refuels)

solve()","46.666666666666664","33.33333333333333","26.666666666666668","60.0","46.666666666666664","0.0","26.666666666666668","13.333333333333334","20.0","26.666666666666668","0.0","13.333333333333334","33.33333333333333","33.33333333333333","26.666666666666668","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/218","
QUESTION:
You are given the string s of length n and the numbers p, q. Split the string s to pieces of length p and q.

For example, the string ""Hello"" for p = 2, q = 3 can be split to the two strings ""Hel"" and ""lo"" or to the two strings ""He"" and ""llo"".

Note it is allowed to split the string s to the strings only of length p or to the strings only of length q (see the second sample test).


-----Input-----

The first line contains three positive integers n, p, q (1 ≤ p, q ≤ n ≤ 100).

The second line contains the string s consists of lowercase and uppercase latin letters and digits.


-----Output-----

If it's impossible to split the string s to the strings of length p and q print the only number ""-1"".

Otherwise in the first line print integer k — the number of strings in partition of s.

Each of the next k lines should contain the strings in partition. Each string should be of the length p or q. The string should be in order of their appearing in string s — from left to right.

If there are several solutions print any of them.


-----Examples-----
Input
5 2 3
Hello

Output
2
He
llo

Input
10 9 5
Codeforces

Output
2
Codef
orces

Input
6 4 5
Privet

Output
-1

Input
8 1 1
abacabac

Output
8
a
b
a
c
a
b
a
c
Use user-input-Based format and function signature solve()","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    for i in range(n // p + 1):
        remaining_length = n - i * p
        if remaining_length % q == 0:
            j = remaining_length // q
            print(i + j)
            for k in range(i):
                print(s[k*p:k*p+p])
            for k in range(j):
                print(s[i*p+k*q:i*p+k*q+q])
            return
    print(-1)

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    for i in range(n//p + 1):
        remaining_length = n - i*p
        if remaining_length % q == 0:
            j = remaining_length // q
            print(i + j)
            idx = 0
            for _ in range(i):
                print(s[idx:idx+p])
                idx += p
            for _ in range(j):
                print(s[idx:idx+q])
                idx += q
            return
    print(-1)

solve()","
def solve():
    n, p, q = map(int, input().split())
    s = input()
    
    for i in range(n // p + 1):
        remaining_length = n - i * p
        if remaining_length % q == 0:
            j = remaining_length // q
            print(i + j)
            current_index = 0
            for k in range(i):
                print(s[current_index:current_index+p])
                current_index += p
            for k in range(j):
                print(s[current_index:current_index+q])
                current_index += q
            return
    print(-1)

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input()

    for i in range(n // p + 1):
        r = n - i * p
        if r % q == 0:
            j = r // q
            print(i + j)
            idx = 0
            for _ in range(i):
                print(s[idx:idx+p])
                idx += p
            for _ in range(j):
                print(s[idx:idx+q])
                idx += q
            return
    print(-1)

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()

    for i in range(n//p + 1):
        remaining_length = n - i*p
        if remaining_length % q == 0:
            j = remaining_length // q
            print(i + j)
            current_index = 0
            for _ in range(i):
                print(s[current_index:current_index+p])
                current_index += p
            for _ in range(j):
                print(s[current_index:current_index+q])
                current_index += q
            return
    print(-1)

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    k = -1
    for i in range(n // p + 1):
        if (n - i * p) % q == 0:
            k = i + (n - i * p) // q
            break
    
    if k == -1:
        print(-1)
    else:
        j = 0
        for i in range(k):
            if i < j * p:
                print(s[i:j * p])
            else:
                print(s[i:i + q])
                j += 1

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    for i in range(n // p + 1):
        rem = n - i * p
        if rem % q == 0:
            j = rem // q
            print(i + j)
            idx = 0
            for _ in range(i):
                print(s[idx:idx+p])
                idx += p
            for _ in range(j):
                print(s[idx:idx+q])
                idx += q
            return
    print(-1)

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    k = (n + p*q - 1) // max(p, q)
    if p*k > len(s):
        print(""-1"")
        return
    
    pos = 0
    for _ in range(k):
        print(s[pos:pos+p])
        pos += p
    for _ in range(n - k*p):
        print(s[pos:pos+q])
        pos += q

# Run the function
solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    k = (n + min(p, q) - 1) // min(p, q)
    if p > q:
        p, q = q, p
    for i in range(k):
        print(s[i * p:i * p + p].strip(), s[i * p + p:i * p + p + q].strip())

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    for i in range(n // p + 1):
        if (n - i * p) % q == 0:
            j = (n - i * p) // q
            if i * p + j * q == n:
                print(i + j)
                idx = 0
                for _ in range(i):
                    print(s[idx:idx+p])
                    idx += p
                for _ in range(j):
                    print(s[idx:idx+q])
                    idx += q
                return
    print(-1)

solve()","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    for i in range(n//p + 1):
        remaining = n - i*p
        if remaining % q == 0:
            j = remaining // q
            strings = [s[k:p+k] for k in range(0, i*p, p)] + [s[i*p+k:i*p+k+q] for k in range(0, j*q, q)]
            print(i + j)
            for string in strings:
                print(string)
            return
    
    print(""-1"")

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    for i in range(n // p + 1):
        rem = n - i * p
        if rem % q == 0:
            j = rem // q
            print(i + j)
            k = 0
            for _ in range(i):
                print(s[k:k+p])
                k += p
            for _ in range(j):
                print(s[k:k+q])
                k += q
            return
    print(-1)

solve()","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()

    for i in range(n//p + 1):
        remaining = n - i * p
        if remaining % q == 0:
            j = remaining // q
            result = [s[k:k+p] for k in range(0, i*p, p)] + [s[i*p+k:i*p+k+q] for k in range(0, j*q, q)]
            print(i + j)
            for part in result:
                print(part)
            return

    print(-1)

# Call the function to execute
solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input()
    
    for i in range(n // p + 1):
        remaining_chars = s[i*p:]
        if len(remaining_chars) % q == 0:
            print(i + len(remaining_chars) // q)
            for j in range(i):
                print(s[j*p:(j+1)*p])
            for j in range(len(remaining_chars) // q):
                print(remaining_chars[j*q:(j+1)*q])
            return
    print(-1)

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()
    
    for i in range(n//p + 1):
        remaining = n - i*p
        if remaining % q == 0:
            j = remaining // q
            if i*p + j*q == n:
                res = []
                k = i + j
                idx = 0
                for _ in range(i):
                    res.append(s[idx:idx+p])
                    idx += p
                for _ in range(j):
                    res.append(s[idx:idx+q])
                    idx += q
                print(k)
                for string in res:
                    print(string)
                return
    print(-1)

solve()
","
def solve():
    n, p, q = map(int, input().split())
    s = input().strip()

    for i in range(n//p + 1):
        remaining_length = n - i * p
        if remaining_length % q == 0:
            j = remaining_length // q
            print(i + j)
            idx = 0
            for _ in range(i):
                print(s[idx:idx+p])
                idx += p
            for _ in range(j):
                print(s[idx:idx+q])
                idx += q
            return
    print(""-1"")

solve()","100.0","100.0","100.0","100.0","100.0","6.666666666666667","100.0","6.666666666666667","0.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/219","
QUESTION:
A sportsman starts from point x_{start} = 0 and runs to point with coordinate x_{finish} = m (on a straight line). Also, the sportsman can jump — to jump, he should first take a run of length of not less than s meters (in this case for these s meters his path should have no obstacles), and after that he can jump over a length of not more than d meters. Running and jumping is permitted only in the direction from left to right. He can start andfinish a jump only at the points with integer coordinates in which there are no obstacles. To overcome some obstacle, it is necessary to land at a point which is strictly to the right of this obstacle.

On the way of an athlete are n obstacles at coordinates x_1, x_2, ..., x_{n}. He cannot go over the obstacles, he can only jump over them. Your task is to determine whether the athlete will be able to get to the finish point.


-----Input-----

The first line of the input containsd four integers n, m, s and d (1 ≤ n ≤ 200 000, 2 ≤ m ≤ 10^9, 1 ≤ s, d ≤ 10^9) — the number of obstacles on the runner's way, the coordinate of the finishing point, the length of running before the jump and the maximum length of the jump, correspondingly.

The second line contains a sequence of n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ m - 1) — the coordinates of the obstacles. It is guaranteed that the starting and finishing point have no obstacles, also no point can have more than one obstacle, The coordinates of the obstacles are given in an arbitrary order.


-----Output-----

If the runner cannot reach the finishing point, print in the first line of the output ""IMPOSSIBLE"" (without the quotes).

If the athlete can get from start to finish, print any way to do this in the following format:  print a line of form ""RUN X>"" (where ""X"" should be a positive integer), if the athlete should run for ""X"" more meters;  print a line of form ""JUMP Y"" (where ""Y"" should be a positive integer), if the sportsman starts a jump and should remain in air for ""Y"" more meters. 

All commands ""RUN"" and ""JUMP"" should strictly alternate, starting with ""RUN"", besides, they should be printed chronologically. It is not allowed to jump over the finishing point but it is allowed to land there after a jump. The athlete should stop as soon as he reaches finish.


-----Examples-----
Input
3 10 1 3
3 4 7

Output
RUN 2
JUMP 3
RUN 1
JUMP 2
RUN 2

Input
2 9 2 3
6 4

Output
IMPOSSIBLE
Use user-input-Based format and function signature solve()","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))
    
    obstacles.sort()
    
    current_pos = 0
    for obstacle in obstacles:
        if obstacle - current_pos <= s:
            print(""IMPOSSIBLE"")
            return
        print(f""RUN {obstacle - current_pos - s}"")
        print(f""JUMP {min(d, obstacle - current_pos - s)}"")
        current_pos = obstacle + 1
    
    if m - current_pos > s:
        print(f""RUN {m - current_pos - s}"")
    
solve()
","
from collections import deque

def solve():
    n, m, s, d = map(int, input().split())
    obstacles = sorted(list(map(int, input().split())))
    
    jump_sequence = []
    current_point = 0

    for obstacle in obstacles:
        if obstacle - current_point <= s:
            print(""IMPOSSIBLE"")
            return
        run_distance = obstacle - current_point - s
        jump_distance = min(d, m - 1 - obstacle)
        jump_sequence.append(('RUN', run_distance))
        jump_sequence.append(('JUMP', jump_distance))
        current_point = obstacle + jump_distance

    if m - current_point > s:
        run_distance = m - current_point - s
        jump_sequence.append(('RUN', run_distance))
    
    for action, distance in jump_sequence:
        print(f""{action} {distance}"")

solve()
","
def solve():
    # Input
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))

    # Initialization
    path = []
    current_position = 0

    for obstacle in obstacles:
        if obstacle - current_position <= s:
            print(""IMPOSSIBLE"")
            return

        path.append(""RUN {}"".format(obstacle - current_position - s))
        path.append(""JUMP {}"".format(min(d, m - obstacle)))
        current_position = obstacle

    if m - current_position <= s:
        print(""IMPOSSIBLE"")
        return

    path.append(""RUN {}"".format(m - current_position))

    # Output
    for action in path:
        print(action)

# Example usage
solve()
","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))

    path = []
    current_pos = 0

    for obstacle in obstacles:
        diff = obstacle - current_pos

        if diff <= s:
            print(""IMPOSSIBLE"")
            return

        path.append(f""RUN {diff - s}"")
        path.append(f""JUMP {min(d, diff - s)}"")

        current_pos = obstacle

    diff = m - current_pos

    if diff <= s:
        print(""IMPOSSIBLE"")
    else:
        path.append(f""RUN {diff - s}"")

        for i in range(0, len(path), 2):
            print(path[i])
            if i + 1 < len(path):
                print(path[i + 1])

solve()
","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))

    if n == 0:
        print(f""RUN {m}"")
        return

    obstacles.sort()
    
    if obstacles[0] <= s: 
      print(""IMPOSSIBLE"")
      return
   
    path = []
    last_pos = 0
    for obstacle in obstacles:
        path.extend([""RUN"", obstacle - last_pos - 1])
        if obstacle - last_pos - 1 < s:
            print(""IMPOSSIBLE"")
            return
        path.extend([""JUMP"", min(d, obstacle - last_pos - 1 - s)])
        last_pos = obstacle

    if m - last_pos - 1 < s:
        print(""IMPOSSIBLE"")
        return
  
    path.extend([""RUN"", m - last_pos - 1])
    
    for i in range(0, len(path), 2):
        print(f""{path[i]} {path[i+1]}"")

solve()
","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))
    
    path = []
    current_position = 0

    for obstacle in obstacles:
        distance_to_obstacle = obstacle - current_position

        if distance_to_obstacle <= s:
            print(""IMPOSSIBLE"")
            return

        run_length = distance_to_obstacle - s
        jump_length = min(d, m - obstacle)

        path.append(f""RUN {run_length}"")
        path.append(f""JUMP {jump_length}"")

        current_position = obstacle + jump_length

    if current_position < m:
        run_length = m - current_position
        path.append(f""RUN {run_length}"")

    for step in path:
        print(step)

solve()
","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))

    jumps = []
    current_pos = 0

    for obstacle in obstacles:
        run_length = obstacle - current_pos - 1
        if run_length < s:
            print(""IMPOSSIBLE"")
            return
        jump_length = min(d, m - current_pos - 1 - run_length)
        jumps.append((run_length, jump_length))
        current_pos = obstacle + jump_length
    
    if current_pos < m:
        run_length = m - current_pos - 1
        if run_length >= s:
            jumps.append((run_length, 0))
        else:
            print(""IMPOSSIBLE"")
            return
    
    for run, jump in jumps:
        print(f""RUN {run}"")
        if jump > 0:
            print(f""JUMP {jump}"")


solve()","
python
from heapq import heappush, heappop

def solve():
    n, m, s, d = map(int, input().split())
    obstacles = set(map(int, input().split()))

    jumps = []
    for obstacle in obstacles:
        if obstacle - s <= 1:
            print(""IMPOSSIBLE"")
            return

        heappush(jumps, (obstacle - s, ""RUN"", obstacle - s))
        heappush(jumps, (obstacle - 1, ""JUMP"", s))

    heappush(jumps, (m, ""RUN"", m - max(obstacles)))

    for x, action, value in sorted(jumps):
        print(f""{action} {value}"")

solve()
","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))

    if m <= s:
        print(""IMPOSSIBLE"")
        return

    instructions = []
    current_position = 0

    for obstacle in obstacles:
        if obstacle - current_position <= s:
            print(""IMPOSSIBLE"")
            return

        run_distance = obstacle - current_position - s
        jump_distance = min(d, m - obstacle)

        instructions.append(f""RUN {run_distance}"")
        instructions.append(f""JUMP {jump_distance}"")

        current_position = obstacle + jump_distance

    if m - current_position > s:
        run_distance = m - current_position - s
        instructions.append(f""RUN {run_distance}"")

    if current_position < m:
        jump_distance = min(d, m - current_position)
        instructions.append(f""JUMP {jump_distance}"")

    for instruction in instructions:
        print(instruction)

solve()
","
from typing import List

def solve(n: int, m: int, s: int, d: int, obstacles: List[int]) -> None:
    current_pos = 0
    for obstacle in sorted(obstacles):
        if obstacle - current_pos <= s:
            print(""IMPOSSIBLE"")
            return
        print(f""RUN {obstacle - current_pos - s}"")
        print(f""JUMP {min(d, m - obstacle)}"")
        current_pos = obstacle
    if m - current_pos > s:
        print(f""RUN {m - current_pos - s}"")

solve()","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))

    obstacles.sort()
    
    position = 0
    actions = []

    for obstacle in obstacles:
        if obstacle - position - 1 < s:
            print(""IMPOSSIBLE"")
            return
        
        run_dist = obstacle - position - 1
        jump_dist = min(d, run_dist - 1)
        
        actions.append(f""RUN {run_dist}"")
        actions.append(f""JUMP {jump_dist}"")
        
        position = obstacle + 1

    if m - position < s:
        print(""IMPOSSIBLE"")
        return
    
    run_dist = m - position
    actions.append(f""RUN {run_dist}"")
    
    for action in actions:
        print(action)

solve()","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))
    obstacles.sort()
    
    path = []
    position = 1
    
    for obstacle in obstacles:
        if obstacle - position < s:
            print(""IMPOSSIBLE"")
            return
        
        path.append(""RUN "" + str(obstacle - position - 1))
        path.append(""JUMP "" + str(min(d, obstacle - position)))
        
        position = obstacle + 1
    
    if m - position < s:
        print(""IMPOSSIBLE"")
        return
    
    path.append(""RUN "" + str(m - position))
    
    for step in path:
        print(step)

solve()","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))
    
    obstacles.sort()
    
    current_position = 0
    for obstacle in obstacles:
        if obstacle - current_position <= s:  
            print(""IMPOSSIBLE"")
            return
        print(f""RUN {obstacle - current_position - 1}"")
        print(f""JUMP {min(d, obstacle - current_position)}"")
        current_position = obstacle
    
    if m - current_position < s:
        print(""IMPOSSIBLE"")
        return
    
    print(f""RUN {m - current_position}"")

solve()
","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))
    
    obstacles.sort()
    
    current_pos = 0
    for obstacle in obstacles:
        if obstacle - current_pos <= s:
            print(""IMPOSSIBLE"")
            return
        print(f""RUN {obstacle - current_pos - s}"")
        print(f""JUMP {min(d, obstacle - current_pos - s)}"")
        current_pos = obstacle
    if m - current_pos <= s:
        print(""IMPOSSIBLE"")
    else:
        print(f""RUN {m - current_pos - s}"")

solve()
","
from typing import List

def solve(n: int, m: int, s: int, d: int, obstacles: List[int]) -> str:
    current_position = 0
    path = []

    for obstacle in sorted(obstacles):
        if obstacle - current_position - 1 < s:
            return ""IMPOSSIBLE""

        run_length = obstacle - current_position - 1
        jump_length = min(d, m - obstacle)
        
        path.append(f""RUN {run_length}"")
        path.append(f""JUMP {jump_length}"")

        current_position = obstacle + jump_length

    if current_position < m:
        run_length = m - current_position
        path.append(f""RUN {run_length}"")
    
    return ""\n"".join(path)


solve()","
def solve():
    n, m, s, d = map(int, input().split())
    obstacles = list(map(int, input().split()))

    path = []
    current_position = 0

    for obstacle in obstacles:
        gap = obstacle - current_position - 1

        if gap < s:
            print(""IMPOSSIBLE"")
            return

        path.append(f""RUN {gap}"")
        jump_length = min(d, obstacle - current_position - s)
        path.append(f""JUMP {jump_length}"")

        current_position = obstacle + 1

    if current_position < m:
        gap = m - current_position
        path.append(f""RUN {gap}"")

    for instruction in path:
        print(instruction)

solve()
","13.333333333333334","40.0","40.0","40.0","40.0","40.0","40.0","0.0","40.0","0.0","40.0","40.0","13.333333333333334","13.333333333333334","0.0","40.0","","","","","","","","","","","","","","","",""
"APPS/220","
QUESTION:
Two positive integers a and b have a sum of s and a bitwise XOR of x. How many possible values are there for the ordered pair (a, b)?


-----Input-----

The first line of the input contains two integers s and x (2 ≤ s ≤ 10^12, 0 ≤ x ≤ 10^12), the sum and bitwise xor of the pair of positive integers, respectively.


-----Output-----

Print a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.


-----Examples-----
Input
9 5

Output
4

Input
3 3

Output
2

Input
5 2

Output
0



-----Note-----

In the first sample, we have the following solutions: (2, 7), (3, 6), (6, 3), (7, 2).

In the second sample, the only solutions are (1, 2) and (2, 1).
Use user-input-Based format and function signature solve()","
def solve():
    s, x = map(int, input().split())
    if (s - x) % 2 != 0 or s < x:
        print(0)
    else:
        a = (s - x) // 2
        b = s - a
        if a & x == 0:
            print(2)
        else:
            print(1)

solve()","
def solve():
    s, x = map(int, input().split())
    if (s - x) % 2 != 0 or s < x:
        print(0)
        return
    a = (s - x) // 2
    b = a ^ x
    if a + b == s and a ^ b == x:
        print(2 if a != b else 1)
    else:
        print(0)


solve()
","
def solve():
    s, x = map(int, input().split())
    if s < x or (s + x) % 2 != 0:
        print(0)
    else:
        a = (s + x) // 2
        b = s - a
        if (a ^ b) == x:
            print(2 ** bin(x).count('1'))
        else:
            print(0)

solve()
","
def solve():
    s, x = map(int, input().split())

    if (s-x) % 2 == 1 or s < x:
        print(0)
    else:
        a = (s-x)//2
        b = s - a
        if a^b == x:
            print(2)
        else:
            print(0)

solve()
","
def solve():
    s, x = map(int, input().split())
    if s < x or (s + x) % 2:
        print(0)
        return
    a = (s - x) // 2
    b = s - a
    if a ^ b == x:
        print(2)
    else:
        print(1)

solve()","
from typing import List

def solve() -> None:
    s, x = map(int, input().split())
    
    if s < x or (s - x) % 2 == 1:
        print(0)
    else:
        a_xor_b = (s - x) // 2
        a = a_xor_b ^ x
        b = a_xor_b
        
        if a + b == s:
            print(2 if a == b else 1)
        else:
            print(0)

solve()
","
def solve():
    s, x = map(int, input().split())
    
    if (s - x) % 2 == 1 or s < x:
        print(0)
    else:
        a = (s - x) // 2
        b = s - a
        if a ^ b == x:
            print(2)
        else:
            print(1)

solve()
","
def solve():
    s, x = map(int, input().split())
    if (s-x) % 2 != 0 or s < x:
        print(0)
        return
    a = (s-x) // 2
    b = s - a
    if a ^ b == x:
        print(2)
    else:
        print(0)
  
solve()","
def solve():
    s, x = map(int, input().split())
    if (s - x) % 2 == 1 or s < x:
        print(0)
    else:
        a = (s - x) // 2
        b = s - a
        if a ^ b == x:
            print(2)
        else:
            print(1)

solve()
","
def solve():
    s, x = map(int, input().split())
    if (s-x) % 2 != 0 or s < x:
        print(0)
    else:
        a = (s-x) // 2
        b = s - a
        if a ^ b == x:
            print(2)
        else:
            print(0)

solve()","
def solve():
    s, x = map(int, input().split())
    if (s - x) % 2 != 0 or s < x:
        print(0)
        return
    a = (s - x) // 2
    b = s - a
    count = 1
    for i in range(40):
        bit = 1 << i
        if (a & bit) and not (x & bit):
            count *= 2
    if a == b:
        count -= 2
    print(count)

solve()
","
def solve():
    s, x = map(int, input().split())
    if (s - x) % 2 or s < x:
        print(0)
        return
    a = (s - x) // 2
    b = s - a
    if a & x:
        print(2)
    else:
        print(1)

solve()","
def solve():
    s, x = map(int, input().split())
    if (s - x) % 2 == 1 or s < x:
        print(0)
    else:
        a = (s - x) // 2
        b = a ^ x
        if a + b == s:
            print(2 if a != b else 1)
        else:
            print(0)

solve()
","
def solve():
    s, x = map(int, input().split())
    if (s-x) % 2 != 0 or s < x:
        print(0)
    else:
        a = (s-x) // 2
        b = s - a
        if a & x == 0:
            print(2)
        else:
            print(1)

solve()
","
def solve():
    import sys
    s, x = map(int, sys.stdin.readline().split())
    
    if (s-x) % 2 != 0 or s < x:
        print(0)
    else:
        a = (s - x) // 2
        b = s - a
        if a^b == x:
            if a == b:
                print(1)
            else:
                print(2)
        else:
            print(0)
    
solve()","
def solve():
    s, x = map(int, input().split())
    if (s - x) % 2 or s < x:
        print(0)
        return
    a = (s - x) // 2
    b = s - a
    if a & x:
        print(2)
    else:
        print(1)

solve()
","20.0","33.33333333333333","80.0","20.0","20.0","13.333333333333334","20.0","20.0","20.0","20.0","20.0","26.666666666666668","33.33333333333333","20.0","33.33333333333333","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/221","
QUESTION:
Long story short, shashlik is Miroslav's favorite food. Shashlik is prepared on several skewers simultaneously. There are two states for each skewer: initial and turned over.

This time Miroslav laid out $n$ skewers parallel to each other, and enumerated them with consecutive integers from $1$ to $n$ in order from left to right. For better cooking, he puts them quite close to each other, so when he turns skewer number $i$, it leads to turning $k$ closest skewers from each side of the skewer $i$, that is, skewers number $i - k$, $i - k + 1$, ..., $i - 1$, $i + 1$, ..., $i + k - 1$, $i + k$ (if they exist). 

For example, let $n = 6$ and $k = 1$. When Miroslav turns skewer number $3$, then skewers with numbers $2$, $3$, and $4$ will come up turned over. If after that he turns skewer number $1$, then skewers number $1$, $3$, and $4$ will be turned over, while skewer number $2$ will be in the initial position (because it is turned again).

As we said before, the art of cooking requires perfect timing, so Miroslav wants to turn over all $n$ skewers with the minimal possible number of actions. For example, for the above example $n = 6$ and $k = 1$, two turnings are sufficient: he can turn over skewers number $2$ and $5$.

Help Miroslav turn over all $n$ skewers.


-----Input-----

The first line contains two integers $n$ and $k$ ($1 \leq n \leq 1000$, $0 \leq k \leq 1000$) — the number of skewers and the number of skewers from each side that are turned in one step.


-----Output-----

The first line should contain integer $l$ — the minimum number of actions needed by Miroslav to turn over all $n$ skewers. After than print $l$ integers from $1$ to $n$ denoting the number of the skewer that is to be turned over at the corresponding step.


-----Examples-----
Input
7 2

Output
2
1 6 

Input
5 1

Output
2
1 4 



-----Note-----

In the first example the first operation turns over skewers $1$, $2$ and $3$, the second operation turns over skewers $4$, $5$, $6$ and $7$.

In the second example it is also correct to turn over skewers $2$ and $5$, but turning skewers $2$ and $4$, or $1$ and $5$ are incorrect solutions because the skewer $3$ is in the initial state after these operations.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    if k == 0:
        print(1)
        print(n // 2 + 1)
    else:
        print(2)
        print(1, n - n // 2)

solve()","
def solve():
    n, k = map(int, input().split())

    # calculate the minimum number of actions needed
    num_actions = (n + 2*k - 1) // (2*k)

    # calculate the indices of skewers to be turned over at each step
    actions = []
    for i in range(num_actions):
        actions.append((i*2*k) + k)

    print(num_actions)
    print(*actions)

solve()","
from math import ceil

def solve():
    n, k = map(int, input().split())
    
    m = ceil(n / (2 * k + 1))
    print(m)
    
    result = []
    for i in range(1, n + 1, 2 * k + 1):
        result.append(i)
    
    print(*result)

solve()","
def solve():
    n, k = map(int, input().split())
    if k == 0:
        print(1)
        print(n // 2 + 1)
    else:
        res = []
        if n % (2 * k + 1) <= k:
            res.append(n // (2 * k + 1) + 1)
        else:
            res.append(n // (2 * k + 1) + 2)
        for i in range(k+1, n+1, 2*k+1):
            res.append(i)
        print(len(res))
        print("" "".join(str(x) for x in res))
  
solve()","
def solve():
    n, k = map(int, input().split())

    actions = []
    turns = min(n, 2*k+1)
    for i in range(1, k+2):
        actions.append(i)
    for i in range(n-k+1, n+1):
        actions.append(i)

    print(turns)
    print("" "".join(map(str, actions)))

solve()
","
def solve():
    n, k = map(int, input().split())
    start = 1
    result = []
    while start <= n:
        result.append(start)
        start += 2*k + 1
    print(len(result))
    print(*result)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    actions = []
    if k == 0:
        print(1)
        print(n // 2 + 1)
    else:
        actions.append(n // 2)
        print(len(actions))
        print(*actions)

solve()
","
def solve():
    n, k = map(int, input().split())
    steps = []
    if k == 0:
        print(1)
        print(n//2 + 1)
    else:
        if n % (2*k + 1) == 0:
            print(n//(2*k + 1))
            for i in range(1, n+1, 2*k+1):
                steps.append(i + k)
        else:
            print(n//(2*k + 1) + 1)
            for i in range(k+1, n+1, 2*k+1):
                steps.append(i)
    print(*steps)

solve()
","
def solve():
    n, k = map(int, input().split())
    actions = []
    if k == 0:
        print(1)
        print(n//2 + 1)
    else:
        if n % (2 * k + 1) == 0:
            turns = n // (2 * k + 1)
        else:
            turns = n // (2 * k + 1) + 1
        print(turns)
        middle = k + 1
        for i in range(turns):
            actions.append(middle + i * (2 * k + 1))
        print(*actions)

solve()","
def solve():
    n, k = map(int, input().split())

    actions = []
    if n % (2*k + 1) == 0:
        actions.append(n//(2*k + 1))
        for i in range(k+1, n+1, 2*k+1):
            actions.append(i)
    else:
        actions.append(n//(2*k + 1) + 1)
        for i in range(k+1, n, 2*k+1):
            actions.append(i)
    
    print(len(actions))
    print("" "".join(map(str, actions)))

solve()
  ","
def solve():
    n, k = map(int, input().split())
    actions = []
    
    min_actions = (n + 2*k - 1) // (2*k)
    if n % 2 == 1:
        actions.append((n+1)//2)
    
    for i in range(1, k+1):
        for j in range(1, min_actions+1):
            skewer = i + 2*k*(j-1)
            if skewer <= n and skewer != (n+1)//2:
                actions.append(skewer)
    
    print(len(actions))
    print(*actions)


solve()
","
def solve():
    n, k = map(int, input().split())
    
    if k == 0:
        print(1)
        print(n//2 + 1)
    else:
        actions = (n + 2*k - 1) // (2*k)
        print(actions)
        
        for i in range(1, actions+1):
            skewer = min(n, i*k + 1)
            print(skewer)

solve()
","
def solve():
    n, k = map(int, input().split())
    actions = []

    if k == 0:
        print(1)
        print(n // 2 + n % 2)
        print((n + 1) // 2)
    else:
        print(2)
        print((n - 1) // (2 * k) + 1)
        print(k + 1)
        print(n - k)

solve()","
def solve():
    n, k = map(int, input().split())
    moves = []
    actions = (n + 2 * k - 1) // (2 * k)
    
    for i in range(actions):
        moves.append(i * 2 * k + k + 1)
    
    print(actions)
    print(*moves)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    actions = []
    for i in range(1, n+1):
        if i < k+1 or i > n-k:
            actions.append(i)
    
    print(len(actions))
    print(*actions)
    
solve()
","
def solve():
    n, k = map(int, input().split())
    actions = []
    if k == 0:
        print(1)
        print(n // 2 + 1)
    else:
        print(2)
        mid = n // 2 + 1
        actions.append(mid)
        left = mid - 1
        right = mid + 1
        for _ in range(n // 2):
            if left > 0:
                actions.append(left)
                left -= 1
            if right <= n:
                actions.append(right)
                right += 1
        print(' '.join(map(str, actions)))

solve()
","6.666666666666667","13.333333333333334","60.0","6.666666666666667","6.666666666666667","60.0","6.666666666666667","20.0","20.0","0.0","0.0","33.33333333333333","0.0","6.666666666666667","0.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/222","
QUESTION:
You are given a positive integer $n$, written without leading zeroes (for example, the number 04 is incorrect). 

In one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.

Determine the minimum number of operations that you need to consistently apply to the given integer $n$ to make from it the square of some positive integer or report that it is impossible.

An integer $x$ is the square of some positive integer if and only if $x=y^2$ for some positive integer $y$.


-----Input-----

The first line contains a single integer $n$ ($1 \le n \le 2 \cdot 10^{9}$). The number is given without leading zeroes.


-----Output-----

If it is impossible to make the square of some positive integer from $n$, print -1. In the other case, print the minimal number of operations required to do it.


-----Examples-----
Input
8314

Output
2

Input
625

Output
0

Input
333

Output
-1



-----Note-----

In the first example we should delete from $8314$ the digits $3$ and $4$. After that $8314$ become equals to $81$, which is the square of the integer $9$.

In the second example the given $625$ is the square of the integer $25$, so you should not delete anything. 

In the third example it is impossible to make the square from $333$, so the answer is -1.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    n_str = str(n)
    
    if int(n ** 0.5) ** 2 == n:
        print(0)
    else:
        for i in range(len(n_str)):
            new_n_str = n_str[:i] + n_str[i+1:]
            new_n = int(new_n_str)
            if int(new_n ** 0.5) ** 2 == new_n:
                print(len(n_str) - len(new_n_str))
                return
        print(-1)

solve()","
def solve():
    n = input()
    
    current_min_ops = -1
    for i in range(len(n)):
        if int(n[:i] + n[i+1:]) == 0:
            continue
        root = int(int(n[:i] + n[i+1:]) ** 0.5)
        if root ** 2 == int(n[:i] + n[i+1:]):
            ops = len(n) - len(str(int(n[:i] + n[i+1:])))
            if current_min_ops == -1 or ops < current_min_ops:
                current_min_ops = ops
    
    return current_min_ops

solve()","
def solve():
    n = int(input())
    n_str = str(n)
    
    if n == int(n ** 0.5) ** 2:
        print(0)
    else:
        for i in range(len(n_str)):
            new_n_str = n_str[:i] + n_str[i+1:]
            if new_n_str != '0' and int(new_n_str) == int(int(new_n_str) ** 0.5) ** 2:
                print(len(n_str) - len(new_n_str))
                return
        print(-1)
  
solve()","
def solve():
    n = int(input())
    s = str(n)
    for i in range(len(s)):
        new_n = int(s[:i] + s[i+1:])
        sqrt_n = int(new_n ** 0.5)
        if sqrt_n * sqrt_n == new_n:
            return len(s) - len(str(new_n))
    
    return -1

solve()","
def solve(n: int) -> int:
    n_str = str(n)
    if int(n_str) ** 0.5 == int(int(n_str) ** 0.5):
        return 0

    min_ops = float('inf')
    for i in range(len(n_str)):
        new_n_str = n_str[:i] + n_str[i+1:]
        if int(new_n_str) == 0 or (int(new_n_str) ** 0.5 != int(int(new_n_str) ** 0.5)):
            continue
        min_ops = min(min_ops, len(n_str) - len(new_n_str))
    
    if min_ops == float('inf'):
        return -1
    return min_ops
  
solve()","
def solve():
    from math import sqrt

    n = int(input())
    num_str = str(n)

    if int(sqrt(n))**2 == n:
        return 0

    for i in range(len(num_str)):
        new_num_str = num_str[:i] + num_str[i+1:]
        new_num = int(new_num_str)
        
        if new_num != 0 and int(sqrt(new_num))**2 == new_num:
            return len(num_str) - len(new_num_str)

    return -1

solve()","
def solve():
    n = int(input())
    str_n = str(n)
    
    if int(n**0.5)**2 == n:
        print(0)
    else:
        for i in range(len(str_n)):
            tmp = int(str_n[:i] + str_n[i+1:])
            if int(tmp**0.5)**2 == tmp:
                print(len(str_n) - len(str(tmp)))
                return
        print(-1)
 
solve()","
def solve():
    n = int(input())
    
    def is_square(num):
        if num < 0:
            return False
        sqrt_num = int(num ** 0.5)
        return sqrt_num * sqrt_num == num
    
    for i in range(10):
        for digit in str(i):
            temp_n = str(n).replace(digit, """")
            if temp_n != """" and is_square(int(temp_n)):
                return len(str(n)) - len(temp_n)
    return -1

solve()","
def solve():
    n = int(input())
    
    def check_square(num):
        sqrt_num = int(num ** 0.5)
        return sqrt_num * sqrt_num == num
    
    min_ops = float('inf')
    
    for i in range(len(str(n))):
        possible_num = int(str(n)[:i] + str(n)[i+1:])
        if check_square(possible_num):
            min_ops = min(min_ops, len(str(n)) - len(str(possible_num)))
            
    if min_ops == float('inf'):
        return -1
    else:
        return min_ops

solve()","
def solve():
    n = int(input())
    n_str = str(n)
    
    if int(n_str) ** 0.5 == int(n_str) ** 0.5 // 1:
        print(0)
    else:
        for i in range(len(n_str)):
            modified_n = n_str[:i] + n_str[i+1:]
            if int(modified_n) ** 0.5 == int(modified_n) ** 0.5 // 1:
                print(len(n_str) - len(modified_n))
                return
        print(-1)

solve()","
def solve():
    n = int(input())
    n_str = str(n)
    
    for i in range(len(n_str)):
        temp_str = n_str[:i] + n_str[i+1:]
        temp_int = int(temp_str)
        temp_sqrt = int(pow(temp_int, 0.5))
        if temp_sqrt * temp_sqrt == temp_int:
            return len(n_str) - len(temp_str)
    
    return -1
 
solve()","
def solve():
    n = int(input())

    def is_square(num):
        return int(num**0.5)**2 == num

    for i in range(len(str(n)), -1, -1):
        new_num = int(str(n)[:i] + str(n)[i+1:])
        if is_square(new_num):
            return len(str(n)) - len(str(new_num))
        
    return -1

solve()","
def solve():
    n = input().strip()
    
    def is_square(num):
        return int(num**0.5)**2 == num
    
    if is_square(int(n)):
        print(0)
    else:
        min_ops = float('inf')
        for i in range(len(n)):
            new_n = n[:i] + n[i+1:]
            if new_n != '0' and is_square(int(new_n)):
                min_ops = min(min_ops, len(n) - len(new_n))
        print(min_ops if min_ops != float('inf') else -1)

solve()
","
def solve():
    n = int(input())
    
    def is_square(num):
        sqrt_num = int(num ** 0.5)
        return sqrt_num * sqrt_num == num
    
    if is_square(n):
        print(0)
    else:
        n_str = str(n)
        for i in range(len(n_str)):
            temp_str = n_str[:i] + n_str[i+1:]
            if temp_str != '0' and is_square(int(temp_str)):
                print(len(n_str) - len(temp_str))
                return
        print(-1)

solve()
","
def solve():
    n = int(input())
    
    for i in range(len(str(n))-1, -1, -1):
        new_num = str(n)[:i] + str(n)[i+1:]
        root = int(new_num)**0.5
        if root.is_integer():
            return len(str(n))-len(new_num)
    
    return -1

solve()","
def solve():
    n = int(input())
    num_str = str(n)
    
    def is_square(num):
        return int(num ** 0.5) ** 2 == num
    
    if is_square(n):
        return 0
    
    for i in range(len(num_str)):
        new_num = int(num_str[:i] + num_str[i+1:])
        if is_square(new_num):
            return len(num_str) - len(num_str[:i]) - 1
    
    return -1
  
solve()","40.0","0.0","46.666666666666664","0.0","0.0","0.0","46.666666666666664","0.0","0.0","40.0","0.0","0.0","46.666666666666664","46.666666666666664","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/223","
QUESTION:
Let's define a function $f(p)$ on a permutation $p$ as follows. Let $g_i$ be the greatest common divisor (GCD) of elements $p_1$, $p_2$, ..., $p_i$ (in other words, it is the GCD of the prefix of length $i$). Then $f(p)$ is the number of distinct elements among $g_1$, $g_2$, ..., $g_n$.

Let $f_{max}(n)$ be the maximum value of $f(p)$ among all permutations $p$ of integers $1$, $2$, ..., $n$.

Given an integers $n$, count the number of permutations $p$ of integers $1$, $2$, ..., $n$, such that $f(p)$ is equal to $f_{max}(n)$. Since the answer may be large, print the remainder of its division by $1000\,000\,007 = 10^9 + 7$.


-----Input-----

The only line contains the integer $n$ ($2 \le n \le 10^6$) — the length of the permutations.


-----Output-----

The only line should contain your answer modulo $10^9+7$.


-----Examples-----
Input
2

Output
1
Input
3

Output
4
Input
6

Output
120


-----Note-----

Consider the second example: these are the permutations of length $3$:  $[1,2,3]$, $f(p)=1$.  $[1,3,2]$, $f(p)=1$.  $[2,1,3]$, $f(p)=2$.  $[2,3,1]$, $f(p)=2$.  $[3,1,2]$, $f(p)=2$.  $[3,2,1]$, $f(p)=2$. 

The maximum value $f_{max}(3) = 2$, and there are $4$ permutations $p$ such that $f(p)=2$.
Use user-input-Based format and function signature solve()","
from math import gcd

def solve():
    n = int(input())
    MOD = 10**9 + 7

    def factorial(n):
        result = 1
        for i in range(1, n+1):
            result = (result * i) % MOD
        return result

    def count_permutations(n):
        result = 1
        for i in range(2, n+1):
            result = (result * i) % MOD
        return result

    def f_max(n):
        result = 1
        for i in range(2, n+1):
            result = (result * i) % MOD
        return result

    print((count_permutations(n) - f_max(n)) % MOD)

solve()
","
from math import gcd

def solve():
    n = int(input())
    MOD = 1000000007

    def calc_power(base, exp):
        result = 1
        while exp:
            if exp % 2:
                result = (result * base) % MOD
            base = (base * base) % MOD
            exp //= 2
        return result

    answer = 1
    for i in range(2, n + 1):
        answer = (answer * i) % MOD

    for i in range(2, n):
        answer = (answer * calc_power(i, MOD - 2)) % MOD

    print(answer)

solve()
  ","
from math import gcd

def solve():
    MOD = 1000000007

    n = int(input())

    fact = [1]
    for i in range(1, n + 1):
        fact.append((fact[-1] * i) % MOD)

    ans = 0
    for k in range(1, n + 1):
        cnt = 0
        for i in range(1, int(n / k) + 1):
            cnt += pow(i, n // k, MOD)
            cnt %= MOD
        cnt *= fact[k]
        cnt %= MOD
        if k % 2 == 1:
            ans += cnt
        else:
            ans -= cnt
        ans %= MOD

    print(ans)

solve()
","
from math import gcd

def solve():
    mod = 1000000007
    
    def factorial(n):
        result = 1
        for i in range(1, n + 1):
            result = (result * i) % mod
        return result
    
    n = int(input())
    result = 1
    for i in range(2, n + 1):
        result = (result * i) % mod
    
    print(result)

solve()","
from math import gcd

def solve(n):
    MOD = 10**9 + 7

    def count_perms(n, m):
        res = 1
        for i in range(2, n+1):
            res = (res * i) % MOD

        for i in range(2, m+1):
            res = (res * pow(i, n, MOD)) % MOD

        return res

    ans = 0
    for d in range(1, n):
        if gcd(d, n) == 1:
            ans += pow(n, n-1, MOD)

    return (count_perms(n, n) - ans) % MOD
  
solve()","
from math import gcd
MOD = 10**9 + 7

def solve(n):
    dp = [0] * (n + 1)
    for i in range(2, n + 1):
        j = 1
        while i * j <= n:
            dp[i * j] += 1
            j += 1
    ans = 1
    for i in range(2, n + 1):
        j = 2
        cnt = 0
        while i * j <= n:
            cnt += dp[i * j]
            j += 1
        ans = (ans * pow(j, cnt, MOD)) % MOD
    return ans

n = int(input())
print(solve(n))

solve()","
from math import factorial

def solve(n):
    MOD = 1000000007

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    def f_max(n):
        res = 0
        for i in range(1, n + 1):
            res += gcd(res, i)
            if res == i:
                return i
        return res

    def count_permutations(n):
        max_f = f_max(n)
        count = factorial(n) % MOD
        for i in range(2, max_f + 1):
            count = (count * i) % MOD
        return count

    return count_permutations(n)
  
solve()","
from math import gcd

def solve(n):
    MOD = 10**9 + 7
    
    def comb(n, k):
        res = 1
        for i in range(n, n - k, -1):
            res = (res * i) % MOD
        for i in range(1, k + 1):
            res = (res * pow(i, MOD - 2, MOD)) % MOD
        return res
    
    ans = 1
    for i in range(2, n + 1):
        ans = (ans * i) % MOD
    
    for i in range(2, n + 1):
        d = 2
        while d * d <= i:
            if i % d == 0:
                break
            d += 1
        if d * d > i:
            ans = (ans + comb(n, i)) % MOD
    
    return ans

# Example usage:
n = int(input())
print(solve(n))

solve()","
from math import gcd

def solve():
    MOD = 10**9 + 7

    n = int(input())

    fact = [1, 1]
    for i in range(2, n + 1):
        fact.append((fact[-1] * i) % MOD)

    ans = 0
    for i in range(1, n + 1):
        ans += (fact[n] * pow(fact[i] * fact[n - i], MOD - 2, MOD) * (i % 2 if i != 1 else 1)) % MOD

    print(ans % MOD)

solve()
","
def solve():
    import math

    n = int(input())
    MOD = 10**9 + 7

    factorial = [1] * (n + 1)
    for i in range(1, n + 1):
        factorial[i] = (factorial[i - 1] * i) % MOD

    ans = 0
    for i in range(1, n + 1):
        ans = (ans + factorial[n] * pow(i, MOD - 2, MOD) % MOD * pow(n - i + 1, n, MOD)) % MOD

    print(ans)

solve()
  ","
from math import gcd

def solve():
    n = int(input())
    
    def count_perms(n):
        mod = 10**9 + 7
        
        def factorial(n):
            res = 1
            for i in range(2, n+1):
                res = (res * i) % mod
            return res
        
        cnt = 0
        for k in range(1, n+1):
            cnt += factorial(n) // factorial(n - k)
            cnt %= mod
        return cnt
    
    print(count_perms(n))

solve()","
def solve(n):
    MOD = 1000000007
    
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a
    
    def solve_case(n):
        ans = 0
        for i in range(1, int(n**0.5) + 1):
            ans = (ans + pow(i, n, MOD) - pow(i - 1, n, MOD)) % MOD
        for i in range(1, n // (n // int(n**0.5)) + 1):
            ans = (ans + (n // i - n // (i + 1)) * pow(i, n, MOD)) % MOD
        return ans
    
    return solve_case(n)

n = int(input())
print(solve(n))
  
solve()","
import math

def solve():
    n = int(input())
    MOD = 10**9 + 7

    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)

    ans = 1
    for i in range(2, n+1):
        ans = (ans * i) % MOD
    for i in range(2, n+1):
        x = (n // i)
        ans = (ans * pow(i, x, MOD)) % MOD

    print(ans)

solve()
","
from math import gcd

def solve():
    MOD = 10**9 + 7

    def factorial(n):
        result = 1
        for i in range(1, n + 1):
            result = (result * i) % MOD
        return result

    n = int(input())
    ans = factorial(n - 1)

    for i in range(n - 1, 1, -1):
        ans = (ans + factorial(n - 1) * pow(i, MOD - 2, MOD)) % MOD

    print(ans)

solve()
","
import math

def solve():
    n = int(input())
    MOD = 10**9 + 7

    def gcd(a, b):
        while b != 0:
            a, b = b, a % b
        return a

    def f_max(n):
        ans = 0
        for i in range(1, n+1):
            ans += n // i * i
        return ans

    def count_permutations_with_f_max(n):
        res = 1
        for i in range(1, n+1):
            res = (res * i) % MOD
        return res

    f_max_val = f_max(n)
    permutations_count = count_permutations_with_f_max(n)

    print(permutations_count % MOD)

solve()
","
from math import gcd

def solve(n):
    MOD = 1000000007

    def factorial(n):
        result = 1
        for i in range(1, n + 1):
            result = (result * i) % MOD
        return result

    result = factorial(n) * (n - 1) % MOD
    for i in range(n - 2, 0, -1):
        result = (result * i) % MOD

    return result

n = int(input())
print(solve(n))

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","12.5","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/224","
QUESTION:
One day, the Grasshopper was jumping on the lawn and found a piece of paper with a string. Grasshopper became interested what is the minimum jump ability he should have in order to be able to reach the far end of the string, jumping only on vowels of the English alphabet. Jump ability is the maximum possible length of his jump. 

Formally, consider that at the begginning the Grasshopper is located directly in front of the leftmost character of the string. His goal is to reach the position right after the rightmost character of the string. In one jump the Grasshopper could jump to the right any distance from 1 to the value of his jump ability. [Image] The picture corresponds to the first example. 

The following letters are vowels: 'A', 'E', 'I', 'O', 'U' and 'Y'.


-----Input-----

The first line contains non-empty string consisting of capital English letters. It is guaranteed that the length of the string does not exceed 100. 


-----Output-----

Print single integer a — the minimum jump ability of the Grasshopper (in the number of symbols) that is needed to overcome the given string, jumping only on vowels.


-----Examples-----
Input
ABABBBACFEYUKOTT

Output
4
Input
AAA

Output
1
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    vowels = set('AEIOUY')
    max_jump = 1
    current_jump = 1
    
    for char in s:
        if char in vowels:
            current_jump = 1
        else:
            current_jump += 1
            max_jump = max(max_jump, current_jump)
    
    print(max_jump)

solve()
","
def solve():
    import math
    
    s = input()
    
    vowels = set(['A', 'E', 'I', 'O', 'U', 'Y'])
    
    max_jump = 0
    current_jump = 0
    
    for char in s:
        if char in vowels:
            current_jump += 1
        else:
            max_jump = max(max_jump, current_jump)
            current_jump = 0
            
    max_jump = max(max_jump, current_jump)
    
    print(max_jump)

solve()
","
def solve():
    vowels = set(['A', 'E', 'I', 'O', 'U', 'Y'])
    word = input().strip()
    max_jump = 0
    curr_jump = 0
    
    for letter in word:
        if letter in vowels:
            curr_jump = 0
        else:
            curr_jump += 1
            max_jump = max(max_jump, curr_jump)
    
    print(max_jump + 1)

# Run the function
solve()
","
def solve():
    s = input().strip()
    vowels = ['A', 'E', 'I', 'O', 'U', 'Y']
    max_jump = 1
    current_jump = 0

    for c in s:
        if c in vowels:
            current_jump += 1
            max_jump = max(max_jump, current_jump)
        else:
            current_jump = 0

    print(max_jump)

solve()
","
def solve():
    vowels = 'AEIOUY'
    s = input().strip()
    min_jump = float('inf')
    
    for i in range(len(s)):
        if s[i] in vowels:
            min_jump = min(min_jump, i+1)
    
    print(min_jump)

solve()
","
python
def solve():
    s = input().strip()
    vowels = ['A', 'E', 'I', 'O', 'U', 'Y']
    
    min_jump = float('inf')
    current_jump = 0
    
    for char in s:
        if char in vowels:
            current_jump = 1
        else:
            current_jump += 1
        
        min_jump = min(min_jump, current_jump)
    
    print(min_jump)

solve()
","
def solve():
    vowels = set(['A', 'E', 'I', 'O', 'U', 'Y'])
    string = input().strip()
    
    max_jump = 0
    current_jump = 0
    
    for char in string:
        if char in vowels:
            current_jump = 1
        else:
            current_jump += 1
            max_jump = max(max_jump, current_jump)
    
    print(max_jump)

# Call the function to execute
solve()
","
def solve():
    vowels = set(['A', 'E', 'I', 'O', 'U', 'Y'])
    string = input().strip()
    max_jump = 1
    current_jump = 1

    for letter in string:
        if letter in vowels:
            current_jump = 1
        else:
            current_jump += 1
            max_jump = max(max_jump, current_jump)

    print(max_jump)

solve()
","
def solve():
    s = input().strip()
    vowels = set('AEIOUY')
    max_jump = 0
    curr_jump = 0
    
    for char in s:
        if char in vowels:
            curr_jump = 1
        else:
            curr_jump += 1
        max_jump = max(max_jump, curr_jump)
    
    print(max_jump)

solve()
","
def solve():
    s = input().strip()
    vowels = set('AEIOUY')
    
    jump = 1
    for i, c in enumerate(s):
        if c in vowels:
            jump = max(jump, i+1)
    
    print(jump)

solve()
","
def solve():
    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}
    
    s = input().strip()
    n = len(s)
    
    jump = 1
    for i in range(1, n+1):
        if s[i-1] in vowels:
            jump = max(jump, i)
    
    return jump

solve()","
def solve():
    vowels = set('AEIOUY')
    s = input().strip()
    
    res = 1
    for i in range(1, len(s)+1):
        if any(c in vowels for c in s[:i]):
            res = i
    
    print(res)

solve()
","
def solve():
    vowels = ""AEIOUY""
    string = input().strip()
    
    max_jump = 0
    current_jump = 0
    
    for char in string:
        if char in vowels:
            current_jump += 1
        else:
            max_jump = max(max_jump, current_jump)
            current_jump = 0
    
    max_jump = max(max_jump, current_jump)
    
    print(max_jump)

solve()
","
def solve():
    import math
    s = input().strip()
    vowels = set(['A', 'E', 'I', 'O', 'U', 'Y'])
    
    max_jump = 1
    current_jump = 1
    
    for i in range(1, len(s)):
        if s[i] in vowels:
            current_jump = 1
        else:
            current_jump += 1
            max_jump = max(max_jump, current_jump)
    
    print(max_jump)

solve()
","
def solve():
    s = input().strip()
    vowels = set(['A', 'E', 'I', 'O', 'U', 'Y'])
    max_jump = 1
    current_jump = 1
    
    for i in range(len(s)):
        if s[i] in vowels:
            max_jump = max(max_jump, current_jump)
            current_jump = 1
        else:
            current_jump += 1
    
    print(max(max_jump, current_jump))

solve()
","
def solve():
    vowels = ""AEIOUY""
    s = input().strip()
    
    max_jump = 0
    current_jump = 0
    
    for char in s:
        if char in vowels:
            current_jump += 1
        else:
            max_jump = max(max_jump, current_jump)
            current_jump = 0
    
    max_jump = max(max_jump, current_jump)
    
    print(max_jump)

solve()
","100.0","6.666666666666667","100.0","6.666666666666667","26.666666666666668","0.0","46.666666666666664","100.0","66.66666666666666","6.666666666666667","0.0","6.666666666666667","6.666666666666667","66.66666666666666","100.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/225","
QUESTION:
Dawid has four bags of candies. The $i$-th of them contains $a_i$ candies. Also, Dawid has two friends. He wants to give each bag to one of his two friends. Is it possible to distribute the bags in such a way that each friend receives the same amount of candies in total?

Note, that you can't keep bags for yourself or throw them away, each bag should be given to one of the friends.


-----Input-----

The only line contains four integers $a_1$, $a_2$, $a_3$ and $a_4$ ($1 \leq a_i \leq 100$) — the numbers of candies in each bag.


-----Output-----

Output YES if it's possible to give the bags to Dawid's friends so that both friends receive the same amount of candies, or NO otherwise. Each character can be printed in any case (either uppercase or lowercase).


-----Examples-----
Input
1 7 11 5

Output
YES

Input
7 3 2 5

Output
NO



-----Note-----

In the first sample test, Dawid can give the first and the third bag to the first friend, and the second and the fourth bag to the second friend. This way, each friend will receive $12$ candies.

In the second sample test, it's impossible to distribute the bags.
Use user-input-Based format and function signature solve()","
def solve():
    from itertools import product

    a = list(map(int, input().split()))

    for p in product([0, 1], repeat=4):
        sum1 = sum(a[i] for i in range(4) if p[i] == 0)
        sum2 = sum(a[i] for i in range(4) if p[i] == 1)
        if sum1 == sum2:
            print(""YES"")
            return

    print(""NO"")

solve()","
def solve():
    # Input
    a = list(map(int, input().split()))
    
    # Check if it's possible to distribute candies equally to both friends
    total_sum = sum(a)
    for i in range(1 << 4):
        friend1_candies = 0
        for j in range(4):
            if i & (1 << j):
                friend1_candies += a[j]
        friend2_candies = total_sum - friend1_candies
        if friend1_candies == friend2_candies:
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    a = list(map(int, input().split()))
    total_sum = sum(a)
    for i in range(1 << 4):
        cur_sum = 0
        for j in range(4):
            if i & (1 << j):
                cur_sum += a[j]
        if cur_sum * 2 == total_sum:
            print(""YES"")
            return
    print(""NO"")

solve()","
def solve():
    from itertools import combinations

    a = list(map(int, input().split()))

    totals = [sum(comb) for comb in combinations(a, 2)]
    if any(total % 2 == 0 and total // 2 in a for total in totals):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    from itertools import product
    
    a = list(map(int, input().split()))
    
    for p in product([0, 1], repeat=4):
        if sum(ai * pi for ai, pi in zip(a, p)) == sum(a) / 2:
            print(""YES"")
            return
    
    print(""NO"")

solve()
","
def solve():
    a1, a2, a3, a4 = map(int, input().split())
    total_candies = sum([a1, a2, a3, a4])
    for i in range(1 << 4):
        sum1 = 0
        for j in range(4):
            if i & (1 << j):
                sum1 += [a1, a2, a3, a4][j]
        sum2 = total_candies - sum1
        if sum1 == sum2:
            print(""YES"")
            return
    print(""NO"")
  
solve()","
def solve():
    a = list(map(int, input().split()))
    total_sum = sum(a)
    for i in range(1 << 4):
        cur_sum = 0
        for j in range(4):
            if i & (1 << j):
                cur_sum += a[j]
        if cur_sum * 2 == total_sum:
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    a = list(map(int, input().split()))
    total_candies = sum(a)
    for i in range(1 << 4):
        sum_first_friend = 0
        for j in range(4):
            if i & (1 << j):
                sum_first_friend += a[j]
        if sum_first_friend * 2 == total_candies:
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    a1, a2, a3, a4 = map(int, input().split())
    if a1 + a2 == a3 + a4 or a1 + a3 == a2 + a4 or a1 + a4 == a2 + a3:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    a = list(map(int, input().split()))
    sums = []
    for i in range(1 << 4):
        total = 0
        for j in range(4):
            if (i >> j) & 1:
                total += a[j]
        sums.append(total)
    return ""YES"" if any(sum1 == sum2 for sum1 in sums for sum2 in sums) else ""NO""

solve()
  ","
def solve():
    from itertools import product

    a = list(map(int, input().split()))

    for p in product([0, 1], repeat=4):
        friend1 = sum(a[i] for i in range(4) if p[i] == 0)
        friend2 = sum(a[i] for i in range(4) if p[i] == 1)
        if friend1 == friend2:
            print(""YES"")
            return

    print(""NO"")

solve()
","
def solve():
    a = list(map(int, input().split()))
    total_sum = sum(a)
    for i in range(1 << 4):
        subset_sum = 0
        for j in range(4):
            if i & (1 << j):
                subset_sum += a[j]
        if subset_sum * 2 == total_sum:
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    a = list(map(int, input().split()))
    total_sum = sum(a)
    for mask in range(1 << 4):
        sum1 = 0
        for i in range(4):
            if (mask >> i) & 1:
                sum1 += a[i]
        sum2 = total_sum - sum1
        if sum1 == sum2:
            print(""YES"")
            return
    print(""NO"")

solve()
","
def solve():
    a1, a2, a3, a4 = map(int, input().split())
    total_candies = a1 + a2 + a3 + a4
    if total_candies % 2 != 0:
        print(""NO"")
    else:
        possible = False
        for mask in range(1, 1 << 4):
            sum1 = 0
            for i in range(4):
                if mask & (1 << i):
                    sum1 += locals()['a{}'.format(i+1)]
            if sum1 * 2 == total_candies:
                possible = True
                break
        if possible:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    a1, a2, a3, a4 = map(int, input().split())
    total_candies = sum([a1, a2, a3, a4])
    
    if total_candies % 2 != 0:
        print(""NO"")
    else:
        for mask in range(1, 1 << 4):
            sum1 = sum2 = 0
            for i in range(4):
                if (1 << i) & mask:
                    sum1 += eval(f""a{i + 1}"")
                else:
                    sum2 += eval(f""a{i + 1}"")
            if sum1 == sum2:
                print(""YES"")
                return
        print(""NO"")
  
solve()","
def solve():
    from itertools import permutations
    
    a = list(map(int, input().split()))
    
    for perm in permutations(a):
        if perm[0] + perm[1] == perm[2] + perm[3] or perm[0] + perm[2] == perm[1] + perm[3] or perm[0] + perm[3] == perm[1] + perm[2]:
            print(""YES"")
            return
    
    print(""NO"")

solve()","100.0","100.0","100.0","26.666666666666668","100.0","100.0","100.0","100.0","66.66666666666666","0.0","100.0","100.0","100.0","100.0","100.0","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/226","
QUESTION:
You may have heard of the pie rule before. It states that if two people wish to fairly share a slice of pie, one person should cut the slice in half, and the other person should choose who gets which slice. Alice and Bob have many slices of pie, and rather than cutting the slices in half, each individual slice will be eaten by just one person.

The way Alice and Bob decide who eats each slice is as follows. First, the order in which the pies are to be handed out is decided. There is a special token called the ""decider"" token, initially held by Bob. Until all the pie is handed out, whoever has the decider token will give the next slice of pie to one of the participants, and the decider token to the other participant. They continue until no slices of pie are left.

All of the slices are of excellent quality, so each participant obviously wants to maximize the total amount of pie they get to eat. Assuming both players make their decisions optimally, how much pie will each participant receive?


-----Input-----

Input will begin with an integer N (1 ≤ N ≤ 50), the number of slices of pie. 

Following this is a line with N integers indicating the sizes of the slices (each between 1 and 100000, inclusive), in the order in which they must be handed out.


-----Output-----

Print two integers. First, the sum of the sizes of slices eaten by Alice, then the sum of the sizes of the slices eaten by Bob, assuming both players make their decisions optimally.


-----Examples-----
Input
3
141 592 653

Output
653 733

Input
5
10 21 10 21 10

Output
31 41



-----Note-----

In the first example, Bob takes the size 141 slice for himself and gives the decider token to Alice. Then Alice gives the size 592 slice to Bob and keeps the decider token for herself, so that she can then give the size 653 slice to herself.
Use user-input-Based format and function signature solve()","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))

    alice_total = 0
    bob_total = 0

    for i in range(N):
        if i % 2 == 0:
            if slices[0] > slices[-1]:
                alice_total += slices[0]
                slices.pop(0)
            else:
                alice_total += slices[-1]
                slices.pop()
        else:
            if slices[0] > slices[-1]:
                bob_total += slices[0]
                slices.pop(0)
            else:
                bob_total += slices[-1]
                slices.pop()

    print(alice_total, bob_total)

solve()
","
def solve():
    from collections import deque

    n = int(input())
    sizes = list(map(int, input().split()))

    alice = 0
    bob = 0
    slices = deque(sorted(sizes, reverse=True))

    for i in range(n):
        if i % 2 == 0:
            alice += slices.popleft()
        else:
            bob += slices.popleft()
    
    print(alice, bob)

solve()","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))

    alice_pie = 0
    bob_pie = 0

    for i in range(N):
        if i % 2 == 0:
            alice_pie += max(slices[0], slices[-1])
        else:
            bob_pie += max(slices[0], slices[-1])

        slices.pop(slices.index(max(slices[0], slices[-1])))

    print(alice_pie, bob_pie)


solve()
","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))

    alice_sum = 0
    bob_sum = 0

    for i in range(N):
        if i % 2 == 0:
            if slices[0] > slices[-1]:
                alice_sum += slices[0]
                del slices[0]
            else:
                alice_sum += slices[-1]
                del slices[-1]
        else:
            if slices[0] > slices[-1]:
                bob_sum += slices[0]
                del slices[0]
            else:
                bob_sum += slices[-1]
                del slices[-1]

    print(alice_sum, bob_sum)

solve()","
def solve():
    n = int(input())
    slices = list(map(int, input().split()))
    
    alice_pie = 0
    bob_pie = 0
    bob_turn = True
    
    for slice_size in sorted(slices, reverse=True):
        if bob_turn:
            bob_pie += slice_size
        else:
            alice_pie += slice_size
        bob_turn = not bob_turn
    
    print(alice_pie, bob_pie)

solve()
","
def solve():
    N = int(input())
    sizes = list(map(int, input().split()))

    dp = [[0] * N for _ in range(N)]
    for l in range(N-1, -1, -1):
        for r in range(l, N):
            if l == r:
                dp[l][r] = sizes[l]
            else:
                dp[l][r] = max(sizes[l] - dp[l+1][r], sizes[r] - dp[l][r-1])

    total = sum(sizes)
    alice = (total + dp[0][N-1]) // 2
    bob = total - alice

    print(alice, bob)

solve()","
def solve():
    N = int(input())
    sizes = list(map(int, input().split()))

    alice_sum = 0
    bob_sum = 0

    for i in range(N):
        if i % 2 == 0:
            if sizes[0] > sizes[-1]:
                alice_sum += sizes[0]
                del sizes[0]
            else:
                alice_sum += sizes[-1]
                del sizes[-1]
        else:
            if sizes[0] > sizes[-1]:
                bob_sum += sizes[0]
                del sizes[0]
            else:
                bob_sum += sizes[-1]
                del sizes[-1]

    return alice_sum, bob_sum

solve()","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))
    
    alice_pie = 0
    bob_pie = 0
    
    for i in range(N):
        if i % 2 == 0:
            if slices[0] > slices[-1]:
                alice_pie += slices[0]
                slices.pop(0)
            else:
                alice_pie += slices[-1]
                slices.pop()
        else:
            if slices[0] > slices[-1]:
                bob_pie += slices[0]
                slices.pop(0)
            else:
                bob_pie += slices[-1]
                slices.pop()
    
    print(alice_pie, bob_pie)

solve()
","
def solve():
    N = int(input())
    sizes = list(map(int, input().split()))
    
    alice_total = 0
    bob_total = 0
    
    for i in range(N // 2):
        if i % 2 == 0:
            alice_total += max(sizes[i], sizes[N - 1 - i])
            bob_total += min(sizes[i], sizes[N - 1 - i])
        else:
            bob_total += max(sizes[i], sizes[N - 1 - i])
            alice_total += min(sizes[i], sizes[N - 1 - i])
    
    print(alice_total, bob_total)

solve()
","
def solve():
    import sys
    input = sys.stdin.readline

    n = int(input())
    sizes = list(map(int, input().split()))

    alice_pie = []
    bob_pie = []

    for i in range(n):
        if i % 2 == 0:
            alice_pie.append(sizes[i])
        else:
            bob_pie.append(sizes[i])

    print(sum(alice_pie), sum(bob_pie))

solve()
","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))

    alice_sum = 0
    bob_sum = 0

    for i in range(N):
        if i % 2 == 0:
            if slices[0] >= slices[-1]:
                alice_sum += slices[0]
                slices.pop(0)
            else:
                alice_sum += slices[-1]
                slices.pop()
        else:
            if slices[0] >= slices[-1]:
                bob_sum += slices[0]
                slices.pop(0)
            else:
                bob_sum += slices[-1]
                slices.pop()

    print(alice_sum, bob_sum)

solve()","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))
    
    alice_total = 0
    bob_total = 0

    for i in range(N):
        if i % 2 == 0:
            if slices[0] >= slices[-1]:
                alice_total += slices[0]
                del slices[0]
            else:
                alice_total += slices[-1]
                del slices[-1]
        else:
            if slices[0] >= slices[-1]:
                bob_total += slices[0]
                del slices[0]
            else:
                bob_total += slices[-1]
                del slices[-1]

    print(alice_total, bob_total)

solve()
  ","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))

    sum_alice = sum(slices[i] for i in range(N) if i % 2 == N % 2)
    sum_bob = sum(slices) - sum_alice

    print(sum_alice, sum_bob)

solve()","
def solve():
    n = int(input())
    slices = list(map(int, input().split()))
    
    alice_sum = 0
    bob_sum = 0
    for i in range(n):
        if i % 2 == 0:
            if slices[0] > slices[-1]:
                alice_sum += slices[0]
                del slices[0]
            else:
                alice_sum += slices[-1]
                del slices[-1]
        else:
            if slices[0] > slices[-1]:
                bob_sum += slices[0]
                del slices[0]
            else:
                bob_sum += slices[-1]
                del slices[-1]
    
    print(alice_sum, bob_sum)

solve()
","
def solve():
    N = int(input())
    slices = list(map(int, input().split()))
    
    alice_total = 0
    bob_total = 0

    for i in range(N):
        if i % 2 == 0:
            turn_winner = max(slices[0], slices[-1])
            if slices[0] == turn_winner:
                slices.pop(0)
            else:
                slices.pop()
            
            bob_total += turn_winner
        else:
            turn_winner = max(slices[0], slices[-1])
            if slices[0] == turn_winner:
                slices.pop(0)
            else:
                slices.pop()
            
            alice_total += turn_winner
    
    print(alice_total, bob_total)

solve()
","
def solve():
    import sys
    input = sys.stdin.readline
    n = int(input())
    slices = list(map(int, input().split()))
    
    alice_sum = 0
    bob_sum = 0
    
    for i, slice_size in enumerate(sorted(slices, reverse=True)):
        if i % 2 == 0:
            alice_sum += slice_size
        else:
            bob_sum += slice_size
    
    print(alice_sum, bob_sum)

solve()
","6.666666666666667","6.666666666666667","6.666666666666667","6.666666666666667","40.0","6.666666666666667","0.0","6.666666666666667","6.666666666666667","20.0","6.666666666666667","6.666666666666667","33.33333333333333","6.666666666666667","33.33333333333333","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/227","
QUESTION:
You've got a positive integer sequence a_1, a_2, ..., a_{n}. All numbers in the sequence are distinct. Let's fix the set of variables b_1, b_2, ..., b_{m}. Initially each variable b_{i} (1 ≤ i ≤ m) contains the value of zero. Consider the following sequence, consisting of n operations.

The first operation is assigning the value of a_1 to some variable b_{x} (1 ≤ x ≤ m). Each of the following n - 1 operations is assigning to some variable b_{y} the value that is equal to the sum of values that are stored in the variables b_{i} and b_{j} (1 ≤ i, j, y ≤ m). At that, the value that is assigned on the t-th operation, must equal a_{t}. For each operation numbers y, i, j are chosen anew.

Your task is to find the minimum number of variables m, such that those variables can help you perform the described sequence of operations.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 23). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 ≤ a_{k} ≤ 10^9).

It is guaranteed that all numbers in the sequence are distinct.


-----Output-----

In a single line print a single number — the minimum number of variables m, such that those variables can help you perform the described sequence of operations.

If you cannot perform the sequence of operations at any m, print -1.


-----Examples-----
Input
5
1 2 3 6 8

Output
2

Input
3
3 6 5

Output
-1

Input
6
2 4 8 6 10 18

Output
3



-----Note-----

In the first sample, you can use two variables b_1 and b_2 to perform the following sequence of operations.  b_1 := 1;  b_2 := b_1 + b_1;  b_1 := b_1 + b_2;  b_1 := b_1 + b_1;  b_1 := b_1 + b_2.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    m = 1
    while True:
        variables = [0] * m
        values = [a[0]]
        for i in range(1, n):
            found = False
            for j in range(m):
                for k in range(j, m):
                    if variables[j] + variables[k] == a[i]:
                        values.append(a[i])
                        found = True
                        break
                if found:
                    break
            if not found:
                break
            variables.append(a[i])
        if len(values) == n:
            print(m)
            return
        m += 1
    print(-1)

solve()
","
def solve():
    n = int(input())
    numbers = list(map(int, input().split()))

    def can_perform_sequence(m):
        variables = [0] * m
        used_values = set()

        for i in range(1, n):
            found = False
            for j in range(m):
                for k in range(j, m):
                    if variables[j] + variables[k] == numbers[i] and variables[j] not in used_values and variables[k] not in used_values:
                        variables.append(numbers[i])
                        used_values.add(variables[j])
                        used_values.add(variables[k])
                        found = True
                        break
                if found:
                    break
            if not found:
                return False

        return True

    for m in range(1, n + 1):
        if can_perform_sequence(m):
            print(m)
            return

    print(-1)
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    def check(m):
        variables = [0] * m
        possible_values = set()
        possible_values.add(a[0])
        
        for t in range(1, n):
            new_possible_values = set()
            for i in range(m):
                for j in range(i, m):
                    if variables[i] + variables[j] in possible_values:
                        new_possible_values.add(a[t])
                        break
            variables.append(a[t])
            variables.pop(0)
            possible_values = new_possible_values
        
        return len(variables)
    
    for m in range(1, n+1):
        if check(m) == n:
            return m
    return -1

solve()","
def solve():
    n = int(input())
    sequence = list(map(int, input().split()))
    previous_values = set()
    
    for i in range(1, n):
        current_values = set()
        for x in previous_values:
            for y in previous_values:
                current_values.add(x + y)
        if sequence[i] not in current_values:
            print(-1)
            return
        previous_values.update(current_values)

    print(len(previous_values))

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    max_val = max(a)
    m = 1
    while 2**m <= max_val:
        m += 1
    for i in range(1, m+1):
        for j in range(1, m+1):
            if len(set(a) & {2**i - 1, 2**j - 1}) == 0:
                return m
    return -1

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    m = 1
    while True:
        exists = True
        b = [0] * m
        for i in range(n-1):
            found = False
            for j in range(m):
                for k in range(j, m):
                    if b[j] + b[k] == a[i+1]:
                        b.append(a[i])
                        found = True
                        break
                if found:
                    break
            if not found:
                exists = False
                break
        if exists:
            print(m)
            break
        m += 1
    else:
        print(-1)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    m = 1
    while True:
        found = set()
        for i in range(1, n):
            for j in range(i):
                found.add(a[i] - a[j])
        if len(found) <= m:
            print(m)
            return
        m += 1
    print(-1)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    found = False
    for m in range(1, 100):
        b = [0] * m
        seq = [a[0]]
        
        for t in range(1, n):
            found_sum = False
            for i in range(m):
                for j in range(i, m):
                    if b[i] + b[j] == a[t]:
                        b.append(a[t])
                        found_sum = True
                        break
                if found_sum:
                    break
                    
            if not found_sum:
                found = False
                break
        
        if found:
            print(m)
            return
    
    print(-1)

solve()","
def solve():
    pass

if __name__ == ""__main__"":
    n = int(input())
    nums = list(map(int, input().split()))
    # Write your solution here
    print(-1)

solve()","
from itertools import permutations

def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    num_vars = -1
    for m in range(1, n + 1):
        for vars_perm in permutations(range(1, m + 1), m):
            vals = [0] * m
            possible = True
            for t in range(1, n):
                vals.append(a[t])
                vals.sort()
                new_vals = []
                for i in range(len(vals)):
                    for j in range(i, len(vals)):
                        new_vals.append(vals[i] + vals[j])
                new_vals = list(set(new_vals))
                if a[t + 1] not in new_vals:
                    possible = False
                    break
                vals = new_vals
                
            if possible:
                num_vars = m
                break
    
    print(num_vars)

solve()
","
def solve():
    pass

if __name__ == ""__main__"":
    n = int(input())
    a = list(map(int, input().split()))
    # Your implementation here

solve()","
def solve():
    pass

# Parse input
n = int(input())
a = list(map(int, input().split()))

# Your code here

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    possible_m = -1
    for m in range(1, n + 1):
        variables = [0] * m
        found = True
        for t in range(1, n):
            found_new_value = False
            for y in range(m):
                for i in range(m):
                    for j in range(m):
                        if variables[i] + variables[j] == a[t]:
                            variables[y] = a[t]
                            found_new_value = True
                            break
                    if found_new_value:
                        break
                if found_new_value:
                    break
            if not found_new_value:
                found = False
                break
        if found:
            possible_m = m
            break
    print(possible_m)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    m = 1
    while m <= n:
        found = False
        b = [0] * m
        for t in range(n-1):
            found_t = False
            for i in range(m):
                for j in range(m):
                    if b[i] + b[j] == a[t]:
                        found_t = True
                        break
                if found_t:
                    break
            if not found_t:
                found = True
                break
            b.append(a[t])
        if not found:
            print(m)
            return
        m += 1
    print(-1)


solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    for m in range(1, 24):
        vals = [0] * m
        found = True
        for i in range(1, n):
            cur_val = a[i]
            found_cur_val = False
            for x in range(m):
                for y in range(x, m):
                    if vals[x] + vals[y] == cur_val:
                        found_cur_val = True
                        break
                if found_cur_val:
                    break
            if not found_cur_val:
                found = False
                break
            vals.append(cur_val)
        if found:
            print(m)
            return
    print(-1)

solve()
","
def solve():
    import itertools

    n = int(input())
    a = list(map(int, input().split()))

    for m in range(1, n+1):
        for vars_combination in itertools.combinations(range(10), m):
            vars_values = [0] * 10
            vars_values[:m] = a[:m]

            for i in range(m, n):
                valid = False
                for x, y in itertools.combinations(vars_combination, 2):
                    if vars_values[i] == vars_values[x] + vars_values[y]:
                        vars_values[i] = vars_values[x] + vars_values[y]
                        valid = True
                        break

                if not valid:
                    break
            else:
                print(m)
                return

    print(-1)

solve()","100.0","13.333333333333334","0.0","6.666666666666667","0.0","100.0","13.333333333333334","6.666666666666667","6.666666666666667","22.22222222222222","0.0","0.0","13.333333333333334","13.333333333333334","13.333333333333334","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/228","
QUESTION:
Alice and Bob are playing a game with $n$ piles of stones. It is guaranteed that $n$ is an even number. The $i$-th pile has $a_i$ stones.

Alice and Bob will play a game alternating turns with Alice going first.

On a player's turn, they must choose exactly $\frac{n}{2}$ nonempty piles and independently remove a positive number of stones from each of the chosen piles. They can remove a different number of stones from the piles in a single turn. The first player unable to make a move loses (when there are less than $\frac{n}{2}$ nonempty piles).

Given the starting configuration, determine who will win the game.


-----Input-----

The first line contains one integer $n$ ($2 \leq n \leq 50$) — the number of piles. It is guaranteed that $n$ is an even number.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 50$) — the number of stones in the piles.


-----Output-----

Print a single string ""Alice"" if Alice wins; otherwise, print ""Bob"" (without double quotes).


-----Examples-----
Input
2
8 8

Output
Bob

Input
4
3 1 4 1

Output
Alice



-----Note-----

In the first example, each player can only remove stones from one pile ($\frac{2}{2}=1$). Alice loses, since Bob can copy whatever Alice does on the other pile, so Alice will run out of moves first.

In the second example, Alice can remove $2$ stones from the first pile and $3$ stones from the third pile on her first move to guarantee a win.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))
    
    total_stones = sum(piles)
    max_stones = max(piles)
    
    if max_stones > total_stones - max_stones:
        print(""Alice"")
    else:
        print(""Bob"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_stones = sum(a)
    if total_stones == min(a) * n:
        print(""Bob"")
    else:
        print(""Alice"")

solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))
    
    total_stones = sum(piles)
    
    if total_stones % 2 == 0:
        print(""Bob"")
    else:
        print(""Alice"")

solve()
","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))

    total_stones = sum(piles)
    max_stones = max(piles)

    if max_stones * 2 > total_stones:
        print(""Alice"")
    else:
        print(""Bob"")

solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))
    
    total_stones = sum(piles)
    max_sum_to_remove = max(piles) * n // 2
    
    if max_sum_to_remove > total_stones - max(piles):
        print(""Alice"")
    else:
        print(""Bob"")

solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))

    total_stones = sum(piles)
    max_stones = max(piles)

    if max_stones > total_stones - max_stones:
        print(""Bob"")
    else:
        print(""Alice"")

solve()
","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))
    
    # Alice wins if the sum of the number of stones in each pile is odd
    if sum(piles) % 2 == 1:
        print(""Alice"")
    else:
        print(""Bob"")

solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))
    
    total_stones = sum(piles)
    max_stones = max(piles)
    
    if max_stones > total_stones // 2:
        print(""Bob"")
    else:
        print(""Alice"")

solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))

    total_stones = sum(piles)
    max_stones = max(piles)

    if max_stones > total_stones - max_stones or total_stones % 2 != 0:
        print(""Alice"")
    else:
        print(""Bob"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_stones = sum(a)
    max_possible_moves = min(a) * n // 2

    if total_stones - max_possible_moves <= max_possible_moves:
        print(""Alice"")
    else:
        print(""Bob"")

solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))

    total_stones = sum(piles)
    max_stones = max(piles)

    if max_stones * 2 > total_stones:
        print(""Alice"")
    else:
        print(""Bob"")

solve()
","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))

    xor_sum = 0
    for num in piles:
        xor_sum ^= num

    if xor_sum == 0 or n % 2 == 0:
        print(""Bob"")
    else:
        print(""Alice"")

solve()
","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))
    
    # Calculate the XOR of all the pile sizes
    xor_sum = 0
    for pile in piles:
        xor_sum ^= pile
    
    # The first player wins if the XOR sum is non-zero
    if xor_sum != 0:
        print(""Alice"")
    else:
        print(""Bob"")

solve()","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))

    total_stones = sum(piles)
    max_stones = max(piles)
    second_max_stones = sorted(piles)[-2]

    if n == 2 and max_stones == second_max_stones:
        print(""Bob"")
    else:
        print(""Alice"")
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    # Determine the winner based on the number of unique stone counts
    unique_counts = len(set(a))
    if unique_counts % 2 == 0:
        print(""Bob"")
    else:
        print(""Alice"")

solve()
  ","
def solve():
    n = int(input())
    piles = list(map(int, input().split()))
    
    total_stones = sum(piles)
    largest_pile = max(piles)
    
    if largest_pile > total_stones - largest_pile:
        print(""Alice"")
    else:
        print(""Bob"")

solve()
","46.666666666666664","60.0","53.333333333333336","46.666666666666664","46.666666666666664","53.333333333333336","53.333333333333336","53.333333333333336","53.333333333333336","40.0","46.666666666666664","46.666666666666664","53.333333333333336","60.0","26.666666666666668","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/229","
QUESTION:
Today, hedgehog Filya went to school for the very first time! Teacher gave him a homework which Filya was unable to complete without your help.

Filya is given an array of non-negative integers a_1, a_2, ..., a_{n}. First, he pick an integer x and then he adds x to some elements of the array (no more than once), subtract x from some other elements (also, no more than once) and do no change other elements. He wants all elements of the array to be equal.

Now he wonders if it's possible to pick such integer x and change some elements of the array using this x in order to make all elements equal.


-----Input-----

The first line of the input contains an integer n (1 ≤ n ≤ 100 000) — the number of integers in the Filya's array. The second line contains n integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 10^9) — elements of the array.


-----Output-----

If it's impossible to make all elements of the array equal using the process given in the problem statement, then print ""NO"" (without quotes) in the only line of the output. Otherwise print ""YES"" (without quotes).


-----Examples-----
Input
5
1 3 3 2 1

Output
YES

Input
5
1 2 3 4 5

Output
NO



-----Note-----

In the first sample Filya should select x = 1, then add it to the first and the last elements of the array and subtract from the second and the third elements.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total_sum = sum(a)
    if total_sum % n == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    total_sum = sum(arr)
    max_num = max(arr)
    min_num = min(arr)

    if (total_sum % n == 0) and (total_sum/n >= min_num) and ((total_sum/n) <= max_num):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    array = list(map(int, input().split()))

    array.sort()
    diff = array[-1] - array[0]
    
    if diff % 2 == 0:
        x = diff // 2
        for num in array:
            if num != array[0] + x and num != array[-1] - x:
                print(""NO"")
                return
    
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    if (sum(arr) % n == 0) and (max(arr) - min(arr) <= 2):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    s = sum(a)
    if s % n == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    target = sum(a) / n
    if target.is_integer():
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_element = min(a)
    max_element = max(a)
    count_min = sum(1 for x in a if x == min_element)
    count_max = sum(1 for x in a if x == max_element)

    if (max_element - min_element) % 2 != 0:
        print(""NO"")
    elif count_min == n or count_max == n:
        print(""YES"")
    elif count_min == 1 or count_max == 1:
        print(""NO"")
    else:
        print(""YES"")

# Run the function
solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    total_sum = sum(a)
    min_val = min(a)
    
    if (total_sum % n == 0) and (total_sum >= n * min_val):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    target_sum = sum(a)
    if target_sum % n == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if (sum(a) % n == 0) and (len(set(a)) > 1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    
    total_sum = sum(arr)
    if total_sum % n == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    total_sum = sum(a)
    max_num = max(a)
    min_num = min(a)
    
    if (total_sum % n == 0) and (total_sum >= n * min_num) and ((total_sum - min_num) % n == 0):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    min_val = min(a)
    max_val = max(a)
    count_min = a.count(min_val)
    count_max = a.count(max_val)

    diff = max_val - min_val

    if diff % 2 == 0 and count_min == n - count_min:
        print(""YES"")
    elif diff % 2 == 1 and count_min + count_max == n:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    if sum(a) % n == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_val = max(a)
    min_val = min(a)
    max_count = a.count(max_val)
    min_count = a.count(min_val)
    
    if max_val == min_val or max_count >= 2 or (max_val - min_val) % 2 != 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    import sys

    n = int(sys.stdin.readline().strip())
    a = list(map(int, sys.stdin.readline().split()))

    total_sum = sum(a)
    if total_sum % n == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","66.66666666666666","66.66666666666666","46.666666666666664","66.66666666666666","66.66666666666666","66.66666666666666","53.333333333333336","66.66666666666666","66.66666666666666","46.666666666666664","66.66666666666666","46.666666666666664","60.0","66.66666666666666","53.333333333333336","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/230","
QUESTION:
Given is a string S of length N.
Find the maximum length of a non-empty string that occurs twice or more in S as contiguous substrings without overlapping.
More formally, find the maximum positive integer len such that there exist integers l_1 and l_2 ( 1 \leq l_1, l_2 \leq N - len + 1 ) that satisfy the following:
 - l_1 + len \leq l_2
 - S[l_1+i] = S[l_2+i] (i = 0, 1, ..., len - 1)
If there is no such integer len, print 0.

-----Constraints-----
 - 2 \leq N \leq 5 \times 10^3
 - |S| = N
 - S consists of lowercase English letters.

-----Input-----
Input is given from Standard Input in the following format:
N
S

-----Output-----
Print the maximum length of a non-empty string that occurs twice or more in S as contiguous substrings without overlapping. If there is no such non-empty string, print 0 instead.

-----Sample Input-----
5
ababa

-----Sample Output-----
2

The strings satisfying the conditions are: a, b, ab, and ba. The maximum length among them is 2, which is the answer.
Note that aba occurs twice in S as contiguous substrings, but there is no pair of integers l_1 and l_2 mentioned in the statement such that l_1 + len \leq l_2.
Use user-input-Based format and function signature solve()","
def solve():
    N = int(input())
    S = input().strip()
    
    max_len = 0
    for i in range(1, N):
        for j in range(i+1, N):
            if S[i:i+(j-i)] == S[j:j+(j-i)]:
                max_len = max(max_len, j-i)
    
    print(max_len)

solve()
","
def solve():
    N = int(input())
    S = input().strip()
    max_len = 0

    for i in range(N):
        for j in range(i+1, N):
            len_str = 0
            while j+len_str < N and S[i+len_str] == S[j+len_str]:
                len_str += 1
            if len_str > max_len and j+len_str < N:
                max_len = len_str

    print(max_len)

solve()
","
def solve():
    N = int(input())
    S = input().strip()
    max_len = 0
    for i in range(1, N):
        for j in range(i + 1, N - i + 1):
            if S[i:i + i] == S[j:j + i]:
                max_len = max(max_len, i)
    print(max_len)

solve()","
def solve():
    N = int(input())
    S = input()
    
    max_len = 0
    
    for i in range(1, N):
        for j in range(i+1, N):
            if S[i:j] in S[j:]:
                max_len = max(max_len, j-i)
    
    print(max_len)

solve()
","
def solve():
    N = int(input())
    S = input().strip()

    answer = 0
    for i in range(1, N):
        for j in range(N - i):
            if S[j:j+i] == S[j+i:j+2*i]:
                answer = max(answer, i)
    
    print(answer)

solve()
","
def solve():
    N = int(input())
    S = input().strip()
    max_len = 0

    for i in range(1, N):
        for j in range(i+N%2, N):
            if S[i:N//2+i] == S[N//2+j:]:
                max_len = max(max_len, N//2)
    
    print(max_len)

solve()
","
def solve():
    # Getting input
    N = int(input())
    S = input().strip()

    # Initializing variables
    ans = 0

    # Looping through potential lengths
    for i in range(1, N):
        for j in range(N - i):
            if S[j:j+i] == S[j+i:j+2*i]:
                ans = max(ans, i)

    # Printing the result
    print(ans)

solve()","
def solve():
    N = int(input())
    S = input()

    maxlen = 0
    for i in range(1, N):
        for j in range(i + 1, N + 1):
            if S[i-1:j-1] == S[j-1:j+i-1]:
                maxlen = max(maxlen, i)

    print(maxlen)

solve()
","
def solve():
    N = int(input())
    S = input().strip()
    ans = 0
    for i in range(1, N):
        for j in range(N - i):
            if S[j:j+i] == S[j+i:j+2*i]:
                ans = max(ans, i)
    print(ans)

solve()
","
def solve():
    N = int(input())
    S = input().strip()
    
    max_len = 0
    
    for i in range(1, N):
        for j in range(i+1, N+1):
            if S[i-1:j-1] == S[j-1:2*j-i-1] and j-i > max_len:
                max_len = j - i
                
    print(max_len)

solve()
","
def solve():
    N = int(input())
    S = input()

    max_len = 0
    for i in range(1, N):
        for j in range(i+1, N+1):
            if j - i <= max_len:
                continue
            if S[i-1:j-1] in S[j-1:]:
                max_len = j - i

    print(max_len)

solve()
","
def solve():
    N = int(input())
    S = input()

    max_len = 0
    for i in range(1, N):
        for j in range(i+1, N-(i-1)+1):
            if S[i-1:i-1+i] == S[j-1:j-1+i]:
                max_len = max(max_len, i)
    
    print(max_len)

solve()","
def solve():
    N = int(input())
    S = input().rstrip()

    res = 0
    for i in range(1, N):
        for j in range(i+1, N):
            found = True
            while j + res <= N and S[j:j + res] == S[i:i + res]:
                res += 1
                found = True
            if not found:
                break

    print(res)

solve()
","
def solve():
    N = int(input())
    S = input().strip()
    
    max_len = 0
    for i in range(1, N):
        for j in range(i+1, N):
            if S[i:i+(j-i)] == S[j:j+(j-i)]:
                max_len = max(max_len, j-i)
    
    print(max_len)

solve()
","
def solve():
    N = int(input())
    S = input()
    max_len = 0

    for len in range(1, N):
        for l1 in range(N - len + 1):
            for l2 in range(l1 + len, N - len + 1):
                match = True
                for i in range(len):
                    if S[l1 + i] != S[l2 + i]:
                        match = False
                        break
                if match:
                    max_len = max(max_len, len)

    print(max_len)

solve()
","
def solve():
    N = int(input())
    S = input().strip()
    
    max_len = 0
    for i in range(1, N):
        for j in range(i+1, N):
            if j - i <= max_len:
                continue
            if S[i:] == S[j:j-i]:
                max_len = j - i
                
    print(max_len)

solve()
  ","20.0","37.5","13.333333333333334","100.0","46.666666666666664","6.666666666666667","46.666666666666664","13.333333333333334","46.666666666666664","46.666666666666664","100.0","26.666666666666668","40.0","20.0","100.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/231","
QUESTION:
The main street of Berland is a straight line with n houses built along it (n is an even number). The houses are located at both sides of the street. The houses with odd numbers are at one side of the street and are numbered from 1 to n - 1 in the order from the beginning of the street to the end (in the picture: from left to right). The houses with even numbers are at the other side of the street and are numbered from 2 to n in the order from the end of the street to its beginning (in the picture: from right to left). The corresponding houses with even and odd numbers are strictly opposite each other, that is, house 1 is opposite house n, house 3 is opposite house n - 2, house 5 is opposite house n - 4 and so on. [Image] 

Vasya needs to get to house number a as quickly as possible. He starts driving from the beginning of the street and drives his car to house a. To get from the beginning of the street to houses number 1 and n, he spends exactly 1 second. He also spends exactly one second to drive the distance between two neighbouring houses. Vasya can park at any side of the road, so the distance between the beginning of the street at the houses that stand opposite one another should be considered the same.

Your task is: find the minimum time Vasya needs to reach house a.


-----Input-----

The first line of the input contains two integers, n and a (1 ≤ a ≤ n ≤ 100 000) — the number of houses on the street and the number of the house that Vasya needs to reach, correspondingly. It is guaranteed that number n is even.


-----Output-----

Print a single integer — the minimum time Vasya needs to get from the beginning of the street to house a.


-----Examples-----
Input
4 2

Output
2

Input
8 5

Output
3



-----Note-----

In the first sample there are only four houses on the street, two houses at each side. House 2 will be the last at Vasya's right.

The second sample corresponds to picture with n = 8. House 5 is the one before last at Vasya's left.
Use user-input-Based format and function signature solve()","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2 * a - 1)
    else:
        print(2 * (n // 2 - a + 1))

solve()","
def solve():
    n, a = map(int, input().split())
    
    if a <= n // 2:
        print(a)
    else:
        print(n // 2 - a % 2 + 1)

solve()
","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2 * a - 1)
    else:
        print(2 * (n - a) if n % 2 == 0 else 2 * (n - a) - 1)

solve()","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(a + 1)
    else:
        print(n - a + 1)

solve()
","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(1 + (a - 1) * 2)
    else:
        print(2 + (n - a) * 2)

solve()
","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(a + (n // 2) - 1)
    else:
        print(n - a + (n // 2) - 1)

solve()
","
def solve():
    n, a = map(int, input().split())
    
    if a <= n // 2:
        print(a + 1)
    else:
        print(n - a + 1)

solve()
","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2 * a - 1)
    else:
        print(2 * (n // 2 - a + 1))

solve()","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2 * a - 1)
    else:
        print(2 * (n // 2 - a + 1))

solve()","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2*a - 1)
    else:
        print(2*(n - a) - 1)

solve()
","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2*a - 1)
    else:
        print(2*(n - a) if n % 2 == 0 else 2*(n - a) - 1)

solve()
","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2 * a - 1)
    else:
        print(2 * (n // 2 - a + 1))

solve()","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(2 * a - 1)
    else:
        print(2 * (n // 2 - a + 1))

solve()","
def solve():
    n, a = map(int, input().split())
    if a <= n / 2:
        print(2 * a - 1)
    else:
        print(2 * (n // 2 - a + 1))

solve()","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(a + 1)
    else:
        print(n - a + 1)

solve()
","
def solve():
    n, a = map(int, input().split())
    if a <= n // 2:
        print(1 + (a - 1) * 2)
    else:
        print(2 + (n - a) * 2)

solve()
","26.666666666666668","40.0","26.666666666666668","26.666666666666668","26.666666666666668","13.333333333333334","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/232","
QUESTION:
There is unrest in the Galactic Senate. Several thousand solar systems have declared their intentions to leave the Republic. Master Heidi needs to select the Jedi Knights who will go on peacekeeping missions throughout the galaxy. It is well-known that the success of any peacekeeping mission depends on the colors of the lightsabers of the Jedi who will go on that mission. 

Heidi has n Jedi Knights standing in front of her, each one with a lightsaber of one of m possible colors. She knows that for the mission to be the most effective, she needs to select some contiguous interval of knights such that there are exactly k_1 knights with lightsabers of the first color, k_2 knights with lightsabers of the second color, ..., k_{m} knights with lightsabers of the m-th color. Help her find out if this is possible.


-----Input-----

The first line of the input contains n (1 ≤ n ≤ 100) and m (1 ≤ m ≤ n). The second line contains n integers in the range {1, 2, ..., m} representing colors of the lightsabers of the subsequent Jedi Knights. The third line contains m integers k_1, k_2, ..., k_{m} (with $1 \leq \sum_{i = 1}^{m} k_{i} \leq n$) – the desired counts of lightsabers of each color from 1 to m.


-----Output-----

Output YES if an interval with prescribed color counts exists, or output NO if there is none.


-----Example-----
Input
5 2
1 1 2 2 1
1 2

Output
YES
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = [0] * (m + 1)
    total_colors = sum(desired_counts)

    start = 0
    for end in range(n):
        color_counts[colors[end]] += 1

        if end - start + 1 == total_colors:
            if color_counts[1:] == desired_counts:
                return ""YES""
            color_counts[colors[start]] -= 1
            start += 1

    return ""NO""

# Example usage
print(solve())

solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))
    
    color_count = {i: 0 for i in range(1, m + 1)}
    left, right = 0, 0
    while right < n:
        color_count[colors[right]] += 1
        while all(color_count[i] >= desired_counts[i-1] for i in range(1, m+1)):
            color_count[colors[left]] -= 1
            left += 1
        if sum(color_count.values()) == sum(desired_counts):
            return ""YES""
        right += 1
    
    return ""NO""

solve()
","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_freq = [0] * (m + 1)
    count = 0
    for color in colors:
        color_freq[color] += 1
        if color_freq[color] <= desired_counts[color - 1]:
            count += 1
        if count == sum(desired_counts):
            return ""YES""

    return ""NO""

solve()
","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = [0] * (m + 1)
    total_colors = sum(desired_counts)

    start = 0
    for end in range(n):
        color_counts[colors[end]] += 1
        if end - start + 1 > total_colors:
            color_counts[colors[start]] -= 1
            start += 1

        if end - start + 1 == total_colors and color_counts[1:] == desired_counts:
            print(""YES"")
            return

    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_freq = [0] * m
    for color in colors:
        color_freq[color-1] += 1

    left = 0
    current_counts = [0] * m
    for right in range(n):
        current_counts[colors[right]-1] += 1
        while all(current_counts[i] >= desired_counts[i] for i in range(m)):
            if all(current_counts[i] == desired_counts[i] for i in range(m)):
                return ""YES""
            current_counts[colors[left]-1] -= 1
            left += 1

    return ""NO""

# Input example
# 5 2
# 1 1 2 2 1
# 1 2
# print(solve())
  
solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = [0] * m
    intervals = {}

    def is_valid():
        for i in range(m):
            if color_counts[i] < desired_counts[i]:
                return False
        return True

    result = ""NO""
    start = 0
    for end in range(n):
        color_counts[colors[end] - 1] += 1

        while is_valid():
            intervals[(start, end)] = True
            color_counts[colors[start] - 1] -= 1
            start += 1

        if (start, end) in intervals:
            result = ""YES""
            break

    return result

solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))
    
    color_counts = [0] * m
    start = 0
    unique_colors = 0
    result = ""NO""
    
    for end in range(n):
        if color_counts[colors[end] - 1] == 0:
            unique_colors += 1
        color_counts[colors[end] - 1] += 1
        
        while unique_colors == m:
            if end - start + 1 == sum(desired_counts):
                result = ""YES""
                break
            color_counts[colors[start] - 1] -= 1
            if color_counts[colors[start] - 1] == 0:
                unique_colors -= 1
            start += 1
    
    return result

solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = [0] * (m + 1)
    color_counts[0] = 1

    needed = sum(desired_counts)
    curr_count = 0
    ans = ""NO""

    for i in range(n):
        color_counts[colors[i]] += 1
        if color_counts[colors[i]] <= desired_counts[colors[i] - 1]:
            curr_count += 1

        while color_counts[colors[curr_count]] > desired_counts[colors[curr_count] - 1] or color_counts[colors[curr_count]] == 0:
            color_counts[colors[curr_count]] -= 1
            curr_count += 1

        if curr_count == needed:
            ans = ""YES""
            break

    print(ans)

solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = [0] * (m + 1)
    for i in range(n):
        color_counts[colors[i]] += 1
        if i >= sum(desired_counts):
            color_counts[colors[i - sum(desired_counts)]] -= 1
        if color_counts == desired_counts:
            print(""YES"")
            return

    print(""NO"")

solve()
","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))
    
    color_counts = [0] * m
    left, right = 0, 0
    total = 0
    
    while right < n:
        color_counts[colors[right] - 1] += 1
        if color_counts[colors[right] - 1] <= desired_counts[colors[right] - 1]:
            total += 1
        
        while color_counts[colors[left] - 1] > desired_counts[colors[left] - 1]:
            color_counts[colors[left] - 1] -= 1
            total -= 1
            left += 1
        
        if total == sum(desired_counts):
            return ""YES""
        
        right += 1
    
    return ""NO""

import sys
if __name__ == ""__main__"":
    sys.setrecursionlimit(10**7)
    result = solve()
    print(result)

solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = [0] * m
    for color in colors:
        color_counts[color-1] += 1

    for i in range(n):
        current_counts = [0] * m
        for j in range(i, n):
            current_counts[colors[j]-1] += 1
            if current_counts == desired_counts:
                return ""YES""
    return ""NO""

# Call the function to see the output
print(solve())

solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = {i: 0 for i in range(1, m+1)}
    left, right = 0, 0
    unique_colors = 0

    while right < n:
        if color_counts[colors[right]] == 0:
            unique_colors += 1
        color_counts[colors[right]] += 1

        if unique_colors == m:
            while color_counts[colors[left]] > desired_counts[colors[left]-1]:
                color_counts[colors[left]] -= 1
                left += 1

            if right - left + 1 == sum(desired_counts):
                return ""YES""

        right += 1

    return ""NO""

solve()","
def solve():
    n, m = map(int, input().split())
    jedi_colors = list(map(int, input().split()))
    desired_counts = list(map(int, input().split()))

    color_counts = [0] * (m + 1)
    current_counts = [0] * (m + 1)
    
    for i in range(1, n + 1):
        color_counts[jedi_colors[i - 1]] += 1
        if all(current_counts[j] >= desired_counts[j] for j in range(1, m + 1)):
            print(""YES"")
            return
        current_counts[jedi_colors[i - 1]] += 1
        while all(current_counts[j] > desired_counts[j] for j in range(1, m + 1)):
            current_counts[jedi_colors[i - 1 - color_counts[jedi_colors[i - 1]] + 1] -= 1
    
    print(""NO"")

solve()
","
def solve(n, m, colors, desired_counts):
    prefix_sums = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            prefix_sums[i][j] = prefix_sums[i - 1][j] + (1 if colors[i - 1] == j else 0)

    count_freq = [0] * (m + 1)
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            for k in range(1, m + 1):
                count_freq[k] = prefix_sums[j][k] - prefix_sums[i - 1][k]

            if count_freq == desired_counts:
                return ""YES""
    return ""NO""

# Example input
n = 5
m = 2
colors = [1, 1, 2, 2, 1]
desired_counts = [1, 2]

print(solve(n, m, colors, desired_counts))
  
solve()","
from collections import Counter

def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    target_counts = list(map(int, input().split()))

    colors_dict = Counter()
    left, right = 0, 0
    valid_count = 0

    while right < n:
        colors_dict[colors[right]] += 1
        
        if colors_dict[colors[right]] == target_counts[colors[right] - 1]:
            valid_count += 1
            
        while valid_count == m:
            if right - left + 1 == sum(target_counts):
                return ""YES""
            
            colors_dict[colors[left]] -= 1
            if colors_dict[colors[left]] < target_counts[colors[left] - 1]:
                valid_count -= 1
            
            left += 1
        
        right += 1
    
    return ""NO""


solve()","
def solve():
    n, m = map(int, input().split())
    colors = list(map(int, input().split()))
    target_counts = list(map(int, input().split()))

    color_counts = {i: 0 for i in range(1, m+1)}
    start = 0
    for end in range(n):
        color_counts[colors[end]] += 1
        while all(color_counts[i] >= target_counts[i-1] for i in range(1, m+1)):
            if end - start + 1 >= sum(target_counts):
                return ""YES""
            color_counts[colors[start]] -= 1
            start += 1

    return ""NO""

solve()
","0.0","0.0","0.0","100.0","0.0","0.0","0.0","26.666666666666668","26.666666666666668","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/233","
QUESTION:
Mishka is a little polar bear. As known, little bears loves spending their free time playing dice for chocolates. Once in a wonderful sunny morning, walking around blocks of ice, Mishka met her friend Chris, and they started playing the game.

Rules of the game are very simple: at first number of rounds n is defined. In every round each of the players throws a cubical dice with distinct numbers from 1 to 6 written on its faces. Player, whose value after throwing the dice is greater, wins the round. In case if player dice values are equal, no one of them is a winner.

In average, player, who won most of the rounds, is the winner of the game. In case if two players won the same number of rounds, the result of the game is draw.

Mishka is still very little and can't count wins and losses, so she asked you to watch their game and determine its result. Please help her!


-----Input-----

The first line of the input contains single integer n n (1 ≤ n ≤ 100) — the number of game rounds.

The next n lines contains rounds description. i-th of them contains pair of integers m_{i} and c_{i} (1 ≤ m_{i},  c_{i} ≤ 6) — values on dice upper face after Mishka's and Chris' throws in i-th round respectively.


-----Output-----

If Mishka is the winner of the game, print ""Mishka"" (without quotes) in the only line.

If Chris is the winner of the game, print ""Chris"" (without quotes) in the only line.

If the result of the game is draw, print ""Friendship is magic!^^"" (without quotes) in the only line.


-----Examples-----
Input
3
3 5
2 1
4 2

Output
Mishka
Input
2
6 1
1 6

Output
Friendship is magic!^^
Input
3
1 5
3 3
2 2

Output
Chris


-----Note-----

In the first sample case Mishka loses the first round, but wins second and third rounds and thus she is the winner of the game.

In the second sample case Mishka wins the first round, Chris wins the second round, and the game ends with draw with score 1:1.

In the third sample case Chris wins the first round, but there is no winner of the next two rounds. The winner of the game is Chris.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
    
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
    
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()
","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
    
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
            
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    m_wins = 0
    c_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            m_wins += 1
        elif c > m:
            c_wins += 1
    
    if m_wins > c_wins:
        print(""Mishka"")
    elif c_wins > m_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

# Example of calling the function
# solve()
","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
    
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()
","
def solve():
    n = int(input())
    
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
    
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif m < c:
            chris_wins += 1

    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif mishka_wins < chris_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")
  
solve()","
def solve():
    rounds = int(input())
    mishka_score = 0
    chris_score = 0

    for _ in range(rounds):
        m, c = map(int, input().split())
        if m > c:
            mishka_score += 1
        elif c > m:
            chris_score += 1

    if mishka_score > chris_score:
        print(""Mishka"")
    elif chris_score > mishka_score:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
            
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1
    
    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()
","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1

    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    m_wins = 0
    c_wins = 0

    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            m_wins += 1
        elif c > m:
            c_wins += 1

    if m_wins > c_wins:
        print(""Mishka"")
    elif c_wins > m_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()
","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0

    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1

    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","
def solve():
    n = int(input())
    m = 0
    c = 0

    for _ in range(n):
        m_i, c_i = map(int, input().split())
        if m_i > c_i:
            m += 1
        elif m_i < c_i:
            c += 1

    if m > c:
        print(""Mishka"")
    elif m < c:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()
","
def solve():
    n = int(input())
    mishka_wins = 0
    chris_wins = 0
    
    for _ in range(n):
        m, c = map(int, input().split())
        if m > c:
            mishka_wins += 1
        elif c > m:
            chris_wins += 1

    if mishka_wins > chris_wins:
        print(""Mishka"")
    elif chris_wins > mishka_wins:
        print(""Chris"")
    else:
        print(""Friendship is magic!^^"")

solve()","100.0","100.0","100.0","100.0","0.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/234","
QUESTION:
One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.

Alex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?

He needs your help to check it.

A Minesweeper field is a rectangle $n \times m$, where each cell is either empty, or contains a digit from $1$ to $8$, or a bomb. The field is valid if for each cell:   if there is a digit $k$ in the cell, then exactly $k$ neighboring cells have bombs.  if the cell is empty, then all neighboring cells have no bombs. 

Two cells are neighbors if they have a common side or a corner (i. e. a cell has at most $8$ neighboring cells).


-----Input-----

The first line contains two integers $n$ and $m$ ($1 \le n, m \le 100$) — the sizes of the field.

The next $n$ lines contain the description of the field. Each line contains $m$ characters, each of them is ""."" (if this cell is empty), ""*"" (if there is bomb in this cell), or a digit from $1$ to $8$, inclusive.


-----Output-----

Print ""YES"", if the field is valid and ""NO"" otherwise.

You can choose the case (lower or upper) for each letter arbitrarily.


-----Examples-----
Input
3 3
111
1*1
111

Output
YES
Input
2 4
*.*.
1211

Output
NO


-----Note-----

In the second example the answer is ""NO"" because, if the positions of the bombs are preserved, the first line of the field should be *2*1.

You can read more about Minesweeper in Wikipedia's article.
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    def is_valid(i, j):
        if field[i][j] == '.':
            for x in range(max(0, i-1), min(n, i+2)):
                for y in range(max(0, j-1), min(m, j+2)):
                    if field[x][y] == '*':
                        return False
        elif field[i][j] != '*':
            bombs = sum(1 for x in range(max(0, i-1), min(n, i+2)) for y in range(max(0, j-1), min(m, j+2)) if field[x][y] == '*')
            if int(field[i][j]) != bombs:
                return False
        return True

    for i in range(n):
        for j in range(m):
            if not is_valid(i, j):
                print(""NO"")
                return
    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] != ""*"":
                bombs_count = sum(field[x][y] == ""*"" for x in range(max(0, i-1), min(n, i+2)) for y in range(max(0, j-1), min(m, j+2))
                if field[i][j] == ""."":
                    if bombs_count != 0:
                        print(""NO"")
                        return
                else:
                    if int(field[i][j]) != bombs_count:
                        print(""NO"")
                        return
    
    print(""YES"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    dr = [-1, -1, -1, 0, 0, 1, 1, 1]
    dc = [-1, 0, 1, -1, 1, -1, 0, 1]
    
    def is_valid(r, c):
        if field[r][c] == '*':
            return True
        bombs = sum(field[r+dr[i]][c+dc[i]] == '*' for i in range(8))
        return field[r][c] == str(bombs)
    
    for i in range(n):
        for j in range(m):
            if field[i][j] != '*' and not is_valid(i, j):
                print(""NO"")
                return
    print(""YES"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    bombs = [(i, j) for i in range(n) for j in range(m) if field[i][j] == '*']
    
    for bomb in bombs:
        i, j = bomb
        for x in range(max(0, i-1), min(n, i+2)):
            for y in range(max(0, j-1), min(m, j+2)):
                if field[x][y] != '*':
                    field[x] = field[x][:y] + str(int(field[x][y])+1) + field[x][y+1:]

    for i in range(n):
        for j in range(m):
            if field[i][j] == '*':
                if any(field[x][y] == '0' for x in range(max(0, i-1), min(n, i+2)) for y in range(max(0, j-1), min(m, j+2))):
                    print(""NO"")
                    return

    print(""YES"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    def get_bombs_count(x, y):
        count = 0
        for i in range(max(0, x - 1), min(n, x + 2)):
            for j in range(max(0, y - 1), min(m, y + 2)):
                if field[i][j] == '*':
                    count += 1
        return count

    for x in range(n):
        for y in range(m):
            if field[x][y] != '.':
                if int(field[x][y]) != get_bombs_count(x, y):
                    print(""NO"")
                    return

    print(""YES"")

solve()
  ","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] != '*':
                bombs = 0
                for dx, dy in dirs:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':
                        bombs += 1
                if field[i][j] != '.' and int(field[i][j]) != bombs:
                    print(""NO"")
                    return
            elif field[i][j] == '*':
                for dx, dy in dirs:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] != '*':
                        field[ni][nj] = str(int(field[ni][nj]) - 1)
    
    print(""YES"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    def is_valid(i, j):
        if field[i][j] == '*':
            return True
        count = 0
        for dx in range(-1, 2):
            for dy in range(-1, 2):
                ni, nj = i + dx, j + dy
                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':
                    count += 1
        return count == 0 if field[i][j] == '.' else count == int(field[i][j])

    for i in range(n):
        for j in range(m):
            if not is_valid(i, j):
                print(""NO"")
                return
    print(""YES"")

solve()
","
def solve():
    import itertools

    n, m = map(int, input().split())
    field = [input() for _ in range(n)]

    for i, j in itertools.product(range(n), range(m)):
        if field[i][j].isdigit():
            count_bombs = 0
            for x, y in itertools.product(range(-1, 2), range(-1, 2)):
                if 0 <= i+x < n and 0 <= j+y < m and field[i+x][j+y] == '*':
                    count_bombs += 1
            if int(field[i][j]) != count_bombs:
                print(""NO"")
                return

    print(""YES"")

solve()
  ","
def solve():
    n, m = map(int, input().split())
    field = [list(input().strip()) for _ in range(n)]

    dx = [1, 1, 1, 0, 0, -1, -1, -1]
    dy = [-1, 0, 1, -1, 1, -1, 0, 1]

    def is_valid(x, y):
        if x < 0 or x >= n or y < 0 or y >= m:
            return False
        return True

    for i in range(n):
        for j in range(m):
            if field[i][j] != '*':
                bombs = 0
                for k in range(8):
                    new_x = i + dx[k]
                    new_y = j + dy[k]
                    if is_valid(new_x, new_y) and field[new_x][new_y] == '*':
                        bombs += 1
                if field[i][j] != '.' and int(field[i][j]) != bombs:
                    print(""NO"")
                    return
    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j].isdigit():
                bombs_count = 0
                for dx, dy in directions:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == ""*"":
                        bombs_count += 1
                if bombs_count != int(field[i][j]):
                    print(""NO"")
                    return
            elif field[i][j] == ""*"":
                print(""NO"")
                return
    
    print(""YES"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    def is_valid(i, j):
        bombs = [(dx, dy) for dx in range(-1, 2) for dy in range(-1, 2)
                 if 0 <= i+dx < n and 0 <= j+dy < m and field[i+dx][j+dy] == ""*""]
        if field[i][j] == ""."":
            return len(bombs) == 0
        elif field[i][j] == ""*"":
            return True
        else:
            return len(bombs) == int(field[i][j])
    
    valid = all(is_valid(i, j) for i in range(n) for j in range(m))
    print(""YES"" if valid else ""NO"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] != ""."":
                bombs = 0
                for dx, dy in directions:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == ""*"":
                        bombs += 1
                if field[i][j] != str(bombs):
                    print(""NO"")
                    return
    
    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] != '*':
                bomb_count = sum(field[x][y] == '*' for x in range(max(0, i-1), min(n, i+2)) for y in range(max(0, j-1), min(m, j+2))
                if bomb_count != int(field[i][j]):
                    print(""NO"")
                    return
    
    print(""YES"")
  
solve()","
def solve():
    n, m = map(int, input().split())
    field = [list(input()) for _ in range(n)]

    for i in range(n):
        for j in range(m):
            if field[i][j] == '.':
                continue

            bomb_count = 0
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':
                        bomb_count += 1

            if field[i][j] != '*' and int(field[i][j]) != bomb_count:
                print(""NO"")
                return

    print(""YES"")

solve()
","
def solve():
    n, m = map(int, input().split())
    field = [input() for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] != '*':
                bombs_count = 0
                for ni in range(max(0, i-1), min(n, i+2)):
                    for nj in range(max(0, j-1), min(m, j+2)):
                        if field[ni][nj] == '*':
                            bombs_count += 1
                if field[i][j] != '.' and int(field[i][j]) != bombs_count:
                    print(""NO"")
                    return
    print(""YES"")

solve()","
def solve():
    n, m = map(int, input().split())
    field = [list(input()) for _ in range(n)]

    dx = [1, 1, 1, 0, 0, -1, -1, -1]
    dy = [1, 0, -1, 1, -1, 1, 0, -1]

    def is_valid(x, y):
        if field[x][y] == ""."":
            for i in range(8):
                nx, ny = x + dx[i], y + dy[i]
                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == ""*"":
                    return False
        elif field[x][y].isdigit():
            bombs = 0
            for i in range(8):
                nx, ny = x + dx[i], y + dy[i]
                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == ""*"":
                    bombs += 1
            if int(field[x][y]) != bombs:
                return False
        return True

    for i in range(n):
        for j in range(m):
            if not is_valid(i, j):
                print(""NO"")
                return
    print(""YES"")


solve()
","100.0","0.0","26.666666666666668","33.33333333333333","20.0","20.0","100.0","93.33333333333333","93.33333333333333","60.0","100.0","60.0","0.0","93.33333333333333","93.33333333333333","100.0","","","","","","","","","","","","","","","",""
"APPS/235","
QUESTION:
After passing a test, Vasya got himself a box of $n$ candies. He decided to eat an equal amount of candies each morning until there are no more candies. However, Petya also noticed the box and decided to get some candies for himself.

This means the process of eating candies is the following: in the beginning Vasya chooses a single integer $k$, same for all days. After that, in the morning he eats $k$ candies from the box (if there are less than $k$ candies in the box, he eats them all), then in the evening Petya eats $10\%$ of the candies remaining in the box. If there are still candies left in the box, the process repeats — next day Vasya eats $k$ candies again, and Petya — $10\%$ of the candies left in a box, and so on.

If the amount of candies in the box is not divisible by $10$, Petya rounds the amount he takes from the box down. For example, if there were $97$ candies in the box, Petya would eat only $9$ of them. In particular, if there are less than $10$ candies in a box, Petya won't eat any at all.

Your task is to find out the minimal amount of $k$ that can be chosen by Vasya so that he would eat at least half of the $n$ candies he initially got. Note that the number $k$ must be integer.


-----Input-----

The first line contains a single integer $n$ ($1 \leq n \leq 10^{18}$) — the initial amount of candies in the box.


-----Output-----

Output a single integer — the minimal amount of $k$ that would allow Vasya to eat at least half of candies he got.


-----Example-----
Input
68

Output
3



-----Note-----

In the sample, the amount of candies, with $k=3$, would change in the following way (Vasya eats first):

$68 \to 65 \to 59 \to 56 \to 51 \to 48 \to 44 \to 41 \\ \to 37 \to 34 \to 31 \to 28 \to 26 \to 23 \to 21 \to 18 \to 17 \to 14 \\ \to 13 \to 10 \to 9 \to 6 \to 6 \to 3 \to 3 \to 0$.

In total, Vasya would eat $39$ candies, while Petya — $29$.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    low, high = 1, n
    while low < high:
        mid = (low + high) // 2
        candies_left = n
        vasya_candies = 0
        petya_candies = 0
        while candies_left > 0:
            vasya_candies += min(mid, candies_left)
            candies_left -= min(mid, candies_left)
            petya_candies += candies_left // 10
            candies_left -= candies_left // 10
        if vasya_candies >= (n + 1) // 2:
            high = mid
        else:
            low = mid + 1
    return low

solve()","
def solve():
    n = int(input())
    candies_eaten = 0
    
    for k in range(1, n):
        candies_left = n
        while candies_left > 0:
            candies_eaten += min(k, candies_left)
            candies_left -= min(k, candies_left)
            candies_left -= candies_left // 10
    
        if candies_eaten >= (n+1)//2:
            return k

solve()","
def solve():
    n = int(input())
    candies_eaten_by_vasya = 0

    for k in range(1, n):
        candies_left = n
        while candies_left > 0:
            candies_eaten_by_vasya += min(k, candies_left)
            candies_left -= min(k, candies_left)
            candies_left -= candies_left // 10

        if candies_eaten_by_vasya * 2 >= n:
            return k

solve()","
def solve():
    n = int(input())
    
    def check(k):
        candies = n
        vasya_candies = 0
        petya_candies = 0
        
        while candies > 0:
            vasya_eats = min(k, candies)
            candies -= vasya_eats
            vasya_candies += vasya_eats
            petya_eats = int(candies * 0.1)
            candies -= petya_eats
            petya_candies += petya_eats
        
        return vasya_candies >= n // 2
    
    left, right = 1, n
    while left < right:
        mid = (left + right) // 2
        if check(mid):
            right = mid
        else:
            left = mid + 1
    
    return left

solve()","
def solve():
    n = int(input())
    candies_eaten = 0
    k = 1
    while candies_eaten < n/2:
        candies_left = n
        while candies_left > 0:
            candies_left -= k
            candies_eaten += k
            if candies_left < 10:
                break
            candies_petia = candies_left // 10
            candies_left -= candies_petia
        k += 1
    return k-1

solve()","
def solve():
    n = int(input())
    
    candies_eaten_by_vasya = 0
    candies_eaten_by_petya = 0
    k = 1
    
    while candies_eaten_by_vasya < n // 2:
        candies_left = n
        while candies_left > 0:
            candies_left -= k
            candies_eaten_by_vasya += k
            if candies_left >= 10:
                eaten_by_petya = candies_left // 10
                candies_left -= eaten_by_petya
                candies_eaten_by_petya += eaten_by_petya
        k += 1
        
    return k - 1
  
solve()","
def solve():
    n = int(input())
    
    def eat_candies(k):
        vasya_candies = 0
        petya_candies = 0
        candies_left = n
        
        while candies_left > 0:
            vasya_candies += min(k, candies_left)
            candies_left -= min(k, candies_left)
            petya_candies += candies_left // 10
            candies_left -= candies_left // 10
        
        return vasya_candies >= n // 2
    
    left, right = 1, n
    while left < right:
        mid = (left + right) // 2
        
        if eat_candies(mid):
            right = mid
        else:
            left = mid + 1
    
    return left

solve()","
def solve():
    n = int(input())
    candies_eaten_by_vasya = 0
    candies_eaten_by_petya = 0
    k = 1
    
    while candies_eaten_by_vasya < n // 2:
        candies_left = n
        while candies_left > 0:
            candies_left -= k
            candies_eaten_by_vasya += k
            if candies_left >= 10:
                candies_petya_eats = candies_left // 10
            else:
                candies_petya_eats = 0
            candies_eaten_by_petya += candies_petya_eats
            candies_left -= candies_petya_eats
    
        k += 1

    return k-1
  
solve()","
def solve():
    n = int(input())
    start = n
    half = n // 2
    k = 1
    total_k = 0
    while n > 0:
        total_k += k
        eaten_by_petya = 0
        while n > 0 and (eaten_by_petya < n // 10):
            eaten_by_petya += n // 10
            n -= n // 10
        n -= k
        k += 1
    return k - 1 if total_k - eaten_by_petya >= half else k

solve()","
def solve():
    n = int(input())
    
    def candy_simulation(k):
        vasya_eaten = 0
        petya_eaten = 0
        remaining = n
        
        while remaining > 0:
            vasya_eaten += k
            remaining -= k
            
            petya_eaten += min(remaining, remaining // 10)
            remaining -= min(remaining, remaining // 10)
        
        return vasya_eaten
    
    low, high = 1, n
    while low < high:
        mid = (low + high) // 2
        if candy_simulation(mid) >= n // 2:
            high = mid
        else:
            low = mid + 1

    return low

solve()
","
def solve():
    n = int(input())
    
    def eat_candies(k):
        vasya_candies = 0
        petya_candies = 0
        candies_left = n
        
        while candies_left > 0:
            vasya_candies += k
            candies_left -= k
            
            petya_candies += candies_left // 10
            candies_left -= candies_left // 10

        return vasya_candies
    
    low = 1
    high = n
    result = n
    
    while low <= high:
        mid = (low + high) // 2
        vasya_candies = eat_candies(mid)
        
        if vasya_candies * 2 >= n:
            result = mid
            high = mid - 1
        else:
            low = mid + 1

    return result

solve()","
def solve():
    n = int(input())
    
    lo, hi = 1, n
    while lo < hi:
        mid = (lo + hi) // 2
        V = n
        P = 0
        while V > 0:
            eat_v = min(V, mid)
            V -= eat_v
            eat_p = V // 10
            P += eat_p
            V -= eat_p
        if P < n/2:
            lo = mid + 1
        else:
            hi = mid
    return lo

solve()","
def solve():
    n = int(input())
    
    low, high = 1, n // 2
    
    while low < high:
        mid = (low + high) // 2
        candies_left = n
        vasya_eaten = 0
        
        while candies_left > 0:
            eaten_vasya = min(candies_left, mid)
            vasya_eaten += eaten_vasya
            candies_left -= eaten_vasya
            eaten_petya = min(candies_left // 10, candies_left)
            candies_left -= eaten_petya
        
        if vasya_eaten * 2 >= n:
            high = mid
        else:
            low = mid + 1
    
    return low

solve()","
def solve():
    n = int(input())
    
    def candies_eaten(k):
        candies_vasya = 0
        candies_petya = 0
        candies_left = n
        
        while candies_left > 0:
            candies_vasya += min(k, candies_left)
            candies_left -= min(k, candies_left)
            candies_petya += candies_left // 10
            candies_left -= candies_left // 10
        
        return candies_vasya >= n // 2
        
    left, right = 1, n
    while left < right:
        mid = (left + right) // 2
        if candies_eaten(mid):
            right = mid
        else:
            left = mid + 1
    
    return left

solve()
","
def solve():
    n = int(input())
    candies_left = n
    vasya_eaten = 0
    petya_eaten = 0
    
    for k in range(1, n+1):
        candies_left = n
        vasya_eaten = 0
        petya_eaten = 0

        while candies_left > 0:
            vasya_eaten += min(k, candies_left)
            candies_left -= min(k, candies_left)

            if candies_left >= 10:
                petya_eaten += candies_left // 10
                candies_left -= candies_left // 10
            else:
                petya_eaten += 0
        
        if vasya_eaten >= n // 2:
            return k

solve()","
def solve():
    n = int(input())
    
    def candies_left(k, candies):
        vasya_eaten = 0
        petya_eaten = 0
        
        while candies > 0:
            vasya_eaten += k
            candies -= k
            petya_eaten += min(candies, candies // 10)
            candies -= min(candies, candies // 10)
        
        return vasya_eaten >= n // 2
    
    left, right = 1, n
    while left < right:
        mid = (left + right) // 2
        if candies_left(mid, n):
            right = mid
        else:
            left = mid + 1
            
    return left

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/236","
QUESTION:
A necklace can be described as a string of links ('-') and pearls ('o'), with the last link or pearl connected to the first one. $0$ 

You can remove a link or a pearl and insert it between two other existing links or pearls (or between a link and a pearl) on the necklace. This process can be repeated as many times as you like, but you can't throw away any parts.

Can you make the number of links between every two adjacent pearls equal? Two pearls are considered to be adjacent if there is no other pearl between them.

Note that the final necklace should remain as one circular part of the same length as the initial necklace.


-----Input-----

The only line of input contains a string $s$ ($3 \leq |s| \leq 100$), representing the necklace, where a dash '-' represents a link and the lowercase English letter 'o' represents a pearl.


-----Output-----

Print ""YES"" if the links and pearls can be rejoined such that the number of links between adjacent pearls is equal. Otherwise print ""NO"".

You can print each letter in any case (upper or lower).


-----Examples-----
Input
-o-o--
Output
YES
Input
-o---

Output
YES
Input
-o---o-

Output
NO
Input
ooo

Output
YES
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    n = len(s)
    pearls = s.count('o')
    links = n - pearls
    if pearls == 0:
        print(""YES"")
    elif links % pearls == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    necklace = input().strip()
    n = len(necklace)
    pearls_count = necklace.count('o')
    links_count = n - pearls_count

    if pearls_count == 0 or links_count % pearls_count == 0:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    s = input().strip()
    n = len(s)
    pearls_count = s.count('o')
    links_count = n - pearls_count
    if pearls_count == 0:
        return ""YES""
    if links_count % pearls_count == 0:
        return ""YES""
    return ""NO""


# Call the function to test it
solve()
","
def solve():
    s = input().strip()

    num_pearls = s.count('o')
    num_links = s.count('-')

    if num_pearls == 0:
        print(""YES"")
    elif num_links % num_pearls == 0:
        print(""YES"")
    else:
        print(""NO"")

import sys

if __name__ == ""__main__"":
    solve()
","
def solve():
    import math

    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)

    def check_necklace(necklace):
        num_links = 0
        num_pearls = 0
        gap_length = 0
        gaps = []
        
        for char in necklace:
            if char == '-':
                num_links += 1
                if num_pearls > 0:
                    gap_length += 1
            else:
                num_pearls += 1
                if gap_length > 0:
                    gaps.append(gap_length)
                    gap_length = 0
        
        if num_pearls == 0:
            return True
        
        gaps.append(gap_length + num_links)  # Last gap
        
        div = gaps[0]
        for gap in gaps[1:]:
            div = gcd(div, gap)
        
        return num_pearls * div == num_links

    necklace = input().strip()
    if check_necklace(necklace):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    s = input()
    links_count = s.count('-')
    pearls_count = s.count('o')
    min_links_count = min(links_count, pearls_count)
    
    if min_links_count == 0:
        print(""YES"")
    elif links_count % min_links_count == 0 and pearls_count % min_links_count == 0:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    s = input().strip()
    n = len(s)
    
    pearl_count = s.count('o')
    link_count = n - pearl_count
    
    if pearl_count == 0:
        return ""YES""
    
    if link_count % pearl_count == 0:
        return ""YES""
    else:
        return ""NO""

solve()
","
def solve():
    s = input()

    pearls_count = s.count('o')
    links_count = len(s) - pearls_count

    if links_count == 0:
        return ""YES""
    
    if pearls_count % links_count == 0:
        return ""YES""
    
    return ""NO""

solve()
","
def solve():
    s = input().strip()
    pearls = s.count('o')
    links = s.count('-')
    
    if pearls == 0:
        print(""YES"")
    elif links % pearls == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    s = input().strip()
    pearls_count = s.count('o')
    links_count = len(s) - pearls_count
    if pearls_count == 0 or links_count % pearls_count == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    s = input().strip()
    pearl_count = s.count('o')
    link_count = len(s) - pearl_count
    if pearl_count == 0 or link_count % pearl_count == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    s = input().strip()
    num_links = s.count('-')
    num_pearls = s.count('o')
    
    if num_pearls == 0:
        print(""YES"")
    elif num_links % num_pearls == 0:
        print(""YES"")
    else:
        print(""NO"")

import sys
solve()
  ","
def solve():
    s = input().strip()
    n = len(s)
    
    pearls = s.count('o')
    links = n - pearls
    
    if pearls == 0:
        print(""YES"")
    elif links % pearls == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    s = input()
    pearls = s.count('o')
    links = s.count('-')
    
    if pearls == 0:
        print(""YES"")
    else:
        if links % pearls == 0:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
def solve():
    s = input().strip()
    pearl_count = s.count('o')
    link_count = s.count('-')
    
    if pearl_count == 0:
        return ""YES""
    
    if link_count % pearl_count == 0:
        return ""YES""
    else:
        return ""NO""

solve()
","
def solve():
    s = input().strip()
    pearls_count = s.count('o')
    links_count = s.count('-')
    
    if pearls_count == 0 or pearls_count == len(s) or links_count % pearls_count == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","100.0","100.0","0.0","100.0","46.666666666666664","93.33333333333333","0.0","0.0","100.0","100.0","100.0","100.0","100.0","100.0","0.0","100.0","","","","","","","","","","","","","","","",""
"APPS/237","
QUESTION:
n hobbits are planning to spend the night at Frodo's house. Frodo has n beds standing in a row and m pillows (n ≤ m). Each hobbit needs a bed and at least one pillow to sleep, however, everyone wants as many pillows as possible. Of course, it's not always possible to share pillows equally, but any hobbit gets hurt if he has at least two pillows less than some of his neighbors have. 

Frodo will sleep on the k-th bed in the row. What is the maximum number of pillows he can have so that every hobbit has at least one pillow, every pillow is given to some hobbit and no one is hurt?


-----Input-----

The only line contain three integers n, m and k (1 ≤ n ≤ m ≤ 10^9, 1 ≤ k ≤ n) — the number of hobbits, the number of pillows and the number of Frodo's bed.


-----Output-----

Print single integer — the maximum number of pillows Frodo can have so that no one is hurt.


-----Examples-----
Input
4 6 2

Output
2

Input
3 10 3

Output
4

Input
3 6 1

Output
3



-----Note-----

In the first example Frodo can have at most two pillows. In this case, he can give two pillows to the hobbit on the first bed, and one pillow to each of the hobbits on the third and the fourth beds.

In the second example Frodo can take at most four pillows, giving three pillows to each of the others.

In the third example Frodo can take three pillows, giving two pillows to the hobbit in the middle and one pillow to the hobbit on the third bed.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k = map(int, input().split())
    if n == 1:
        print(1)
    else:
        min_pillows = min(m // n, m - n)
        remaining_pillows = m - min_pillows
        max_pillows = min(remaining_pillows, n - 1)
        print(max_pillows)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    if n == 1:
        print(1)
    else:
        pillows_per_hobbit = m // n
        if pillows_per_hobbit < 2:
            print(0)
        else:
            if pillows_per_hobbit * (n - 1) >= m:
                print(m - n)
            else:
                extra_pillows = m - (pillows_per_hobbit * (n - 1))
                if extra_pillows >= k - 1:
                    print(pillows_per_hobbit)
                else:
                    print(pillows_per_hobbit - 1)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    remaining_pillows = m - n
    max_pillows = min(remaining_pillows, n - 1)
    
    if k == 1 or k == n:
        print(max_pillows)
    else:
        left_hobbits = k - 1
        right_hobbits = n - k
        each_side_pillows = max_pillows // 2
        
        if each_side_pillows >= left_hobbits and each_side_pillows >= right_hobbits:
            print(each_side_pillows)
        else:
            print(min(left_hobbits, right_hobbits))

solve()","
def solve():
    n, m, k = map(int, input().split())
    if n == 1:
        print(1)
    else:
        left_min = min(m-k+1, k)  # Minimum pillows on the left side
        right_min = min(m-(n-k)+1, n-k+1)  # Minimum pillows on the right side
        print(min(m, left_min + right_min))

solve()","
def solve():
    n, m, k = map(int, input().split())
    if n == 1:
        print(min(m-1, k))
    else:
        print(min(m//n, m - n) - 1)

solve()","
def solve():
    n, m, k = map(int, input().split())
    max_pillows = min(m // n, m - n) + 1
    print(max_pillows)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    left = k - 1
    right = n - k
    pillows_per_hobbit = (m - (n - 1)) // n
    max_pillows = min(pillows_per_hobbit, left, right) + 1
    print(max_pillows)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    if n == 1:
        print(1)
    else:
        min_pillows_needed = 1 + min(n - 1, m - n)
        max_pillows = m - min_pillows_needed
        
        if max_pillows >= k:
            print(max_pillows)
        else:
            remaining_pillows = max(0, max_pillows - abs(max_pillows - k + 1))
            print(remaining_pillows)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    if n == 1:
        print(min(m, 1))
    else:
        print(min(m // n, m - n) * (k != 1) + min(m // n + 1, m - n) * (k == 1))

solve()
","
def solve():
    n, m, k = map(int, input().split())
    max_pillows = min(m // n, (m - 1) // max(k-1, n-k) + 1)
    print(max_pillows)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    min_pillows = 1
    max_pillows = min(m - n + 1, m - k + 1, k)
    
    return max_pillows

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    if n == 1:
        print(1)
    else:
        min_pillows = min(m // n, 1)
        remaining_pillows = m - min_pillows * n
        if k == 1 or k == n:
            print(min_pillows)
        else:
            max_pillows = min(min_pillows + 1, remaining_pillows)
            print(max_pillows)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    if n == 1:
        print(1)
    else:
        print(min((m//n), (m//n)+(m//n-1)*(k-1), m-k+1))

solve()","
def solve():
    n, m, k = map(int, input().split())
    if n == 1:
        print(1)
    else:
        if m >= n * k:
            print(1)
        else:
            remaining_pillows = m - n
            max_pillows = (m-k) // ((n-1) * 2) * 2
            print(min(max_pillows, remaining_pillows))

solve()","
def solve():
    n, m, k = map(int, input().split())
    min_pillows = 1
    max_pillows = min(m - n + 1, n - k, k - 1)
    print(max_pillows)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    
    min_pillows_each = 1
    total_pillows_available = m - n
    
    pillows_left = m - min_pillows_each * (n-1)
    
    if pillows_left >= total_pillows_available:
        print(total_pillows_available)
    else:
        print(m - 1 - total_pillows_available + min(k, n-k))

solve()","6.666666666666667","6.666666666666667","0.0","13.333333333333334","0.0","73.33333333333333","46.666666666666664","13.333333333333334","13.333333333333334","40.0","0.0","33.33333333333333","46.666666666666664","13.333333333333334","20.0","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/238","
QUESTION:
You are given an array $a_1, a_2, \dots , a_n$ and two integers $m$ and $k$.

You can choose some subarray $a_l, a_{l+1}, \dots, a_{r-1}, a_r$. 

The cost of subarray $a_l, a_{l+1}, \dots, a_{r-1}, a_r$ is equal to $\sum\limits_{i=l}^{r} a_i - k \lceil \frac{r - l + 1}{m} \rceil$, where $\lceil x \rceil$ is the least integer greater than or equal to $x$. 

The cost of empty subarray is equal to zero.

For example, if $m = 3$, $k = 10$ and $a = [2, -4, 15, -3, 4, 8, 3]$, then the cost of some subarrays are:  $a_3 \dots a_3: 15 - k \lceil \frac{1}{3} \rceil = 15 - 10 = 5$;  $a_3 \dots a_4: (15 - 3) - k \lceil \frac{2}{3} \rceil = 12 - 10 = 2$;  $a_3 \dots a_5: (15 - 3 + 4) - k \lceil \frac{3}{3} \rceil = 16 - 10 = 6$;  $a_3 \dots a_6: (15 - 3 + 4 + 8) - k \lceil \frac{4}{3} \rceil = 24 - 20 = 4$;  $a_3 \dots a_7: (15 - 3 + 4 + 8 + 3) - k \lceil \frac{5}{3} \rceil = 27 - 20 = 7$. 

Your task is to find the maximum cost of some subarray (possibly empty) of array $a$.


-----Input-----

The first line contains three integers $n$, $m$, and $k$ ($1 \le n \le 3 \cdot 10^5, 1 \le m \le 10, 1 \le k \le 10^9$).

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($-10^9 \le a_i \le 10^9$).


-----Output-----

Print the maximum cost of some subarray of array $a$.


-----Examples-----
Input
7 3 10
2 -4 15 -3 4 8 3

Output
7

Input
5 2 1000
-13 -4 -9 -20 -11

Output
0
Use user-input-Based format and function signature solve()","
from math import ceil

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    max_cost = 0
    prefix_sum = [0]
    for num in a:
        prefix_sum.append(prefix_sum[-1] + num)
    
    for i in range(1, n+1):
        for j in range(i, 0, -m):
            cost = prefix_sum[i] - prefix_sum[j-1] - k * ceil((i - j + 1) / m)
            max_cost = max(max_cost, cost)
    
    print(max_cost)

solve()
","
from math import ceil 

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_sum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]
    
    max_cost = 0
    min_prefix_sum = prefix_sum[0]
    
    for i in range(1, n + 1):
        if i - m >= 0:
            min_prefix_sum = min(min_prefix_sum, prefix_sum[i - m])
        max_cost = max(max_cost, prefix_sum[i] - k * ceil((i - min_prefix_sum) / m))
    
    print(max_cost)

solve()
  ","
import math

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    def calculate_cost(l, r):
        return sum(a[l:r+1]) - k * math.ceil((r - l + 1) / m)
    
    max_cost = 0
    prefix_sum = [0]
    for i in range(n):
        prefix_sum.append(prefix_sum[-1] + a[i])
    
    for l in range(n):
        for r in range(l, n):
            cost = calculate_cost(l, r)
            max_cost = max(max_cost, cost)
    
    print(max_cost)

solve()
","
from math import ceil

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    prefix_sum = [0]
    for num in a:
        prefix_sum.append(prefix_sum[-1] + num)
    
    max_cost = 0
    for i in range(1, n+1):
        for j in range(i % m, i+1, m):
            max_cost = max(max_cost, prefix_sum[i] - prefix_sum[j] - k * ceil((i - j) / m))
    
    print(max_cost)

solve()
","
import math

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    max_cost = 0
    prefix_sum = 0
    max_prefix_sum = float('-inf')
    for i in range(n):
        prefix_sum += a[i]
        max_prefix_sum = max(max_prefix_sum, prefix_sum)
        remaining_elements = n - i - 1
        ceil_div = math.ceil(remaining_elements / m)
        cost = max_prefix_sum - k * ceil_div
        max_cost = max(max_cost, cost, max_prefix_sum)

    print(max_cost)


solve()","
def solve():
    import math

    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    max_cost = 0
    prefix_sum = [0]
    for num in a:
        prefix_sum.append(prefix_sum[-1] + num)

    suffix_max = [0] * (n + 1)
    max_suffix = prefix_sum[-1]
    for i in range(n - 1, -1, -1):
        suffix_max[i] = max(max_suffix, suffix_max[i + 1])
        max_suffix = max(max_suffix, prefix_sum[i])

    for l in range(n + 1):
        r = min(n, l + m)
        cost = prefix_sum[r] - prefix_sum[l] - k * math.ceil((r - l) / m)
        max_cost = max(max_cost, cost + suffix_max[r])

    return max_cost


solve()","
import math

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    max_cost = 0
    current_sum = 0
    current_max_sum = 0
    
    for i in range(n):
        current_sum = max(a[i], a[i] - k * (math.ceil((i + 1) / m)))
        current_max_sum = max(current_sum, current_max_sum + a[i])
        max_cost = max(max_cost, current_max_sum)
    
    print(max_cost)

solve()
","
from math import ceil

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    max_cost = 0
    prefix_sum = 0
    cummulative_max = 0
    
    for i in range(n):
        prefix_sum += a[i]
        cost = prefix_sum - k * ceil((i+1) / m)
        cummulative_max = max(cummulative_max, cost)
        max_cost = max(max_cost, cummulative_max)
    
    print(max_cost)

solve()
","
import sys

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    prefix_sum = [0] * (n + 1)
    max_cost = 0
    min_sum = 0
    for i in range(n):
        prefix_sum[i+1] = prefix_sum[i] + a[i]

    for l in range(n):
        for r in range(l+1, n+1):
            cost = prefix_sum[r] - prefix_sum[l] - k * ((r - l) // m + ((r - l) % m != 0))
            max_cost = max(max_cost, cost)

    print(max_cost)

solve()
","
import math

def solve(n, m, k, a):
    prefix_sum = [0]
    for num in a:
        prefix_sum.append(prefix_sum[-1] + num)
    
    dp = [0] * (n + 1)
    
    for i in range(1, n + 1):
        dp[i] = max(dp[j] + prefix_sum[i] - prefix_sum[j] - k * ((i - j) // m) for j in range(i + 1))

    return max(dp)


# Read input
n, m, k = map(int, input().split())
a = list(map(int, input().split()))

# Call the function with the provided input
print(solve(n, m, k, a))

solve()","
def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    ans = max(0, max([sum(a[i:j]) - k * ((j - i - 1) // m + 1) for i in range(n) for j in range(i+1, n+1)]))
    
    print(ans)

solve()
","
from math import ceil

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    max_cost, curr_cost = 0, 0
    prefix_sum = [0]
    for i in range(n):
        prefix_sum.append(prefix_sum[-1] + a[i])
    
    dp = [[-float('inf')] * m for _ in range(n + 1)]
    for i in range(n + 1):
        for j in range(m):
            if i >= j + 1:
                dp[i][j] = max(dp[i][j], dp[i - (j + 1)][j] + prefix_sum[i] - k * ceil((j + 1) / m))
            max_cost = max(max_cost, dp[i][j])
    
    print(max_cost)

solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    def cost(l, r):
        return sum(a[l:r+1]) - k * ((r - l + 1) // m)
    
    max_cost = 0
    prefix_sum = [0] + [sum(a[:i+1]) for i in range(n)]
    
    for l in range(n):
        for r in range(l, min(n, l + m * (n-l))):
            max_cost = max(max_cost, prefix_sum[r+1] - prefix_sum[l] - k * ((r - l + 1) // m))

    print(max_cost)

solve()
","
from math import ceil

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    max_cost = 0
    prefix_sum = [0] * (n+1)
    for i in range(n):
        prefix_sum[i+1] = prefix_sum[i] + a[i]
    
    for l in range(n):
        for r in range(l, n):
            cost = prefix_sum[r+1] - prefix_sum[l] - k * ceil((r - l + 1) / m)
            max_cost = max(max_cost, cost)

    print(max_cost)

# Input example
solve()
","
import math

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    dp = [0] * n
    max_cost = 0
    running_sum = 0
    running_sum_mod_m = 0
    for i in range(n):
        running_sum += a[i]
        running_sum_mod_m += a[i]
        if i >= m:
            running_sum_mod_m -= a[i - m]
        dp[i] = max(dp[i], running_sum - k * math.ceil((i + 1) / m))
        if i - m >= 0:
            dp[i] = max(dp[i], dp[i - m] + running_sum_mod_m - k * math.ceil((i - m + 1) / m))
        max_cost = max(max_cost, dp[i])

    print(max(max_cost, 0))


solve()","
from math import ceil

def solve():
    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))

    prefix_sum = [0]
    for i in range(n):
        prefix_sum.append(prefix_sum[-1] + a[i])

    max_cost = 0
    min_sum = 0
    for i in range(n):
        max_cost = max(max_cost, prefix_sum[i+1] - min_sum - k*ceil((i+1) / m))
        min_sum = min(min_sum, prefix_sum[i+1] - k*ceil((i+1) / m))

    print(max_cost)

solve()
","33.33333333333333","53.333333333333336","100.0","66.66666666666666","6.666666666666667","0.0","6.666666666666667","53.333333333333336","100.0","0.0","100.0","20.0","13.333333333333334","100.0","80.0","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/239","
QUESTION:
You are given a rectangular grid of lattice points from (0, 0) to (n, m) inclusive. You have to choose exactly 4 different points to build a polyline possibly with self-intersections and self-touching. This polyline should be as long as possible.

A polyline defined by points p_1, p_2, p_3, p_4 consists of the line segments p_1 p_2, p_2 p_3, p_3 p_4, and its length is the sum of the lengths of the individual line segments.


-----Input-----

The only line of the input contains two integers n and m (0 ≤ n, m ≤ 1000). It is guaranteed that grid contains at least 4 different points.


-----Output-----

Print 4 lines with two integers per line separated by space — coordinates of points p_1, p_2, p_3, p_4 in order which represent the longest possible polyline.

Judge program compares your answer and jury's answer with 10^{ - 6} precision.


-----Examples-----
Input
1 1

Output
1 1
0 0
1 0
0 1

Input
0 10

Output
0 1
0 10
0 0
0 9
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    print(f""{n} {m}"")
    print(f""0 0"")
    print(f""{n} 0"")
    print(f""0 {m}"")

solve()
","
def solve():
    n, m = map(int, input().split())
    print(""0 1"")
    print(""0"", m)
    print(""0 0"")
    print(""0"", m-1)

if __name__ == '__main__':
    solve()
  ","
def solve():
    n, m = map(int, input().split())
    print(1, 1)
    print(0, 0)
    print(1, 0)
    print(0, 1)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, m = map(int, input().split())
    if n == 0:
        print(""0 1\n0 {}\n0 0\n0 {}"".format(m, m-1))
    else:
        print(""1 1\n0 0\n1 0\n0 1"")

solve()","
import itertools

def solve():
    n, m = map(int, input().split())
    points = [(0, 0), (n, m), (0, m), (n, 0)]
    
    max_distance = 0
    max_perm = None
    for perm in itertools.permutations(points):
        distance = sum(((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5 for (x1, y1), (x2, y2) in zip(perm, perm[1:]))
        if distance > max_distance:
            max_distance = distance
            max_perm = perm
    
    for x, y in max_perm:
        print(x, y)

solve()
  ","
import sys

def solve():
    n, m = map(int, input().split())
    print(f""{n} {m}"")
    print(""0 0"")
    print(f""{n} 0"")
    print(""0 1"")

solve()
","
from itertools import permutations

def solve():
    n, m = map(int, input().split())
    points = []
    for i in range(n+1):
        points.append((i, 0))
    for i in range(m):
        points.append((0, i+1))
    for i in range(1, n+1):
        points.append((i, m))
    for i in range(1, m):
        points.append((n, i))

    max_dist = 0
    best_points = []
    for perm in permutations(points, 4):
        dist = 0
        for i in range(3):
            dist += abs(perm[i][0] - perm[i+1][0]) + abs(perm[i][1] - perm[i+1][1])
        if dist > max_dist:
            max_dist = dist
            best_points = perm

    for p in best_points:
        print(p[0], p[1])
  
solve()","
import itertools

def solve():
    n, m = map(int, input().split())
    points = [(0, 0), (0, m), (n, 0), (n, m)]
    
    max_dist = 0
    max_polyline = None
    
    for perm in itertools.permutations(points):
        dist = 0
        for i in range(1, 4):
            dist += abs(perm[i][0] - perm[i-1][0]) + abs(perm[i][1] - perm[i-1][1])
        
        if dist > max_dist:
            max_dist = dist
            max_polyline = perm
    
    for p in max_polyline:
        print(p[0], p[1])

solve()
  ","
def solve():
    n, m = map(int, input().split())
    print(""0 1"")
    print(f""{0} {m}"")
    print(f""{0} {0}"")
    print(f""{0} {m-1}"")

solve()","
def solve():
    n, m = map(int, input().split())
    print(0, 1)
    print(0, m)
    print(0, 0)
    print(0, m-1)

solve()","
import itertools

def solve():
    n, m = map(int, input().split())
    points = list(itertools.product(range(n+1), range(m+1))
    dists = lambda a, b: (a[0]-b[0])**2 + (a[1]-b[1])**2
    max_dist = 0
    ans = []
    for p1, p2, p3, p4 in itertools.combinations(points, 4):
        cur_dist = dists(p1, p2) + dists(p2, p3) + dists(p3, p4)
        if cur_dist > max_dist:
            max_dist = cur_dist
            ans = [p1, p2, p3, p4]
    for point in ans:
        print(f""{point[0]} {point[1]}"")

solve()","
from itertools import permutations

def solve():
    n, m = map(int, input().split())
    
    points = [(i, j) for i in range(n+1) for j in range(m+1)]
    
    max_len = 0
    max_points = []
    
    for p1, p2, p3, p4 in permutations(points, 4):
        dist = abs(p1[0]-p2[0]) + abs(p2[0]-p3[0]) + abs(p3[0]-p4[0]) + abs(p1[1]-p2[1]) + abs(p2[1]-p3[1]) + abs(p3[1]-p4[1])
        if dist > max_len:
            max_len = dist
            max_points = [p1, p2, p3, p4]
    
    for point in max_points:
        print(point[0], point[1])

solve()","
def solve():
    n, m = map(int, input().split())
    if n == 0:
        print(""0 1\n0 {}\n0 0\n0 {}"".format(m, m-1))
    else:
        print(""{0} {1}\n0 0\n{0} 0\n0 0"".format(n, m))

solve()
","
from itertools import combinations

def solve(n, m):
    points = [(i, j) for i in range(n+1) for j in range(m+1)]
    max_len = 0
    polyline = []

    for comb in combinations(points, 4):
        len_sum = sum(abs(comb[i][0] - comb[i-1][0]) + abs(comb[i][1] - comb[i-1][1]) for i in range(1, 4))
        if len_sum > max_len:
            max_len = len_sum
            polyline = comb

    for point in polyline:
        print(point[0], point[1])

solve()","
def solve():
    n, m = map(int, input().split())
    
    if n == 0:
        print(""0 1\n0 {}\n0 0\n0 {}"".format(m, m-1))
    else:
        print(""1 1\n0 0\n1 0\n0 1"")

solve()
","
import itertools

def solve():
    n, m = map(int, input().split())
    points = [(x, y) for x in range(n+1) for y in range(m+1)]
    max_length = 0
    polyline = []

    for p1, p2, p3, p4 in itertools.combinations(points, 4):
        length = sum(abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]),
                     abs(p2[0] - p3[0]) + abs(p2[1] - p3[1]),
                     abs(p3[0] - p4[0]) + abs(p3[1] - p4[1]))
        
        if length > max_length:
            max_length = length
            polyline = [p1, p2, p3, p4]

    for point in polyline:
        print(point[0], point[1])

solve()
","20.0","6.666666666666667","6.666666666666667","13.333333333333334","13.333333333333334","6.666666666666667","14.285714285714285","13.333333333333334","6.666666666666667","6.666666666666667","0.0","16.666666666666664","6.666666666666667","0.0","13.333333333333334","0.0","","","","","","","","","","","","","","","",""
"APPS/240","
QUESTION:
Vasya decided to pass a very large integer n to Kate. First, he wrote that number as a string, then he appended to the right integer k — the number of digits in n. 

Magically, all the numbers were shuffled in arbitrary order while this note was passed to Kate. The only thing that Vasya remembers, is a non-empty substring of n (a substring of n is a sequence of consecutive digits of the number n).

Vasya knows that there may be more than one way to restore the number n. Your task is to find the smallest possible initial integer n. Note that decimal representation of number n contained no leading zeroes, except the case the integer n was equal to zero itself (in this case a single digit 0 was used).


-----Input-----

The first line of the input contains the string received by Kate. The number of digits in this string does not exceed 1 000 000.

The second line contains the substring of n which Vasya remembers. This string can contain leading zeroes. 

It is guaranteed that the input data is correct, and the answer always exists.


-----Output-----

Print the smalles integer n which Vasya could pass to Kate.


-----Examples-----
Input
003512
021

Output
30021

Input
199966633300
63

Output
3036366999
Use user-input-Based format and function signature solve()","
def solve():
    import itertools

    s = input().strip()
    remembered = input().strip()

    for perm in itertools.permutations(s, len(s)):
        num = ''.join(perm)
        if remembered in num:
            if num[0] == '0':
                continue
            return int(num)

# Call the function to execute
solve()
","
def solve():
    import itertools

    received_str = input().strip()
    remembered_substr = input().strip()

    n_digits = len(received_str) - len(remembered_substr)
    
    permutations = list(itertools.permutations(remembered_substr))
    sorted_perms = sorted([''.join(p) for p in permutations])

    for perm in sorted_perms:
        potential_n = received_str[:n_digits] + perm
        if potential_n < received_str:
            smallest_n = potential_n

    print(smallest_n)

solve()
","
def solve():
    import sys
    input_string = sys.stdin.readline().rstrip()
    remember_substring = sys.stdin.readline().rstrip()
    
    digits_count = len(input_string) - len(remember_substring)
    count_dict = {}
    for digit in input_string:
        count_dict[digit] = count_dict.get(digit, 0) + 1
    
    for digit in remember_substring:
        count_dict[digit] -= 1
    
    n = """"
    leading_zero = True
    for digit in sorted(count_dict.keys()):
        if count_dict[digit] > 0:
            n += digit * count_dict[digit]
        elif leading_zero and count_dict[digit] == 0:
            n += digit * digits_count
            leading_zero = False
    
    return n


solve()","
def solve():
    from collections import Counter

    # Read input
    s = input().strip()
    remembered = input().strip()

    count_s = Counter(s)
    count_remembered = Counter(remembered)
    
    diff = count_s - count_remembered

    # Find the missing digits
    missing_digits = ''.join([k * v for k, v in diff.items()])

    # Restore the number n
    n = missing_digits + remembered

    if n[0] == '0':
        non_zero = [x for x in n if x != '0']
        zero_count = n.count('0')
        n = '0' * zero_count + ''.join(non_zero)
    
    return int(n)

# Call the function
result = solve()
print(result)

solve()","
def solve():
    from collections import Counter
    
    s = input().strip() 
    sub = input().strip()
    
    counts = Counter(s)
    for c in sub:
        counts[c] -= 1
    
    n = """"
    for c, count in sorted(counts.items()):
        if count > 0:
            n += c * count
    n += sub
    
    if n[0] == ""0"":
        for i, digit in enumerate(n):
            if digit != ""0"":
                n = digit + n[:i] + n[i+1:]
                break
    
    print(n)

solve()
","
def solve():
    import re

    s = input().strip()
    remembered = input().strip()

    digits = sorted(re.findall(r'\d', s))
    missing_digits = [d for d in remembered if d not in digits]

    n = ''.join(missing_digits) + ''.join(digits)
    
    if n[0] == '0':
        non_zero_digits = [d for d in n if d != '0']
        zero_count = n.count('0')
        n = '0' * zero_count + ''.join(non_zero_digits)

    print(n)

solve()
","
def solve():
    import itertools
    s = input().strip()
    remember = input().strip()
    
    digits = [int(d) for d in s]
    remember_digits = [int(d) for d in remember]
    
    remember_count = len(remember_digits)
    
    indices = [i for i, x in enumerate(digits) if x == remember_digits[0]]
    
    min_num = int(s)
    
    for index in indices:
        sub = digits[index:index+remember_count]
        
        if sub == remember_digits:
            num = int(''.join(map(str, digits[:index] + digits[index+remember_count:])))
            min_num = min(min_num, num)
    
    print(min_num)

solve()
","
def solve():
    from collections import Counter

    received = input().strip()
    remember = input().strip()

    received_counter = Counter(received)
    remember_counter = Counter(remember)

    for digit, count in remember_counter.items():
        if received_counter[digit] < count:
            missing_digits = count - received_counter[digit]
            smallest_digit = min(d for d in received_counter if d > digit)
            received_counter[smallest_digit] -= missing_digits
            received = received.replace(smallest_digit, digit, missing_digits)

    return int(''.join(sorted(received, reverse=True)))

# Uncomment the following line if you want to test the function using the provided examples
# print(solve())

solve()","
def solve():
    import sys
    
    received_str = input().strip()
    remembered_substr = input().strip()
    
    counts = [0] * 10
    for c in received_str:
        counts[int(c)] += 1
        
    for c in remembered_substr:
        counts[int(c)] -= 1
        
    min_substr = remembered_substr[0]
    for i in range(1, len(counts)):
        if counts[i] > 0:
            min_substr += str(i) * counts[i]
    
    return min_substr

solve()","
def solve():
    import re

    s = input()
    remembered_substring = input()

    num_counts = [0] * 10
    for char in s:
        num_counts[int(char)] += 1

    for char in remembered_substring:
        num_counts[int(char)] -= 1

    leading_zero = True
    result = ''
    for char in remembered_substring:
        if char != '0':
            leading_zero = False
        if not leading_zero:
            for i in reversed(range(int(char))):
                if num_counts[i] > 0:
                    result += str(i)
                    num_counts[i] -= 1
                    break

    for i in range(1, 10):
        while num_counts[i] > 0:
            result += str(i)
            num_counts[i] -= 1

    return result


solve()","
def solve():
    s = input()
    substring = input()
    s_count = [0] * 10
    for digit in s:
        s_count[int(digit)] += 1
    for digit in substring:
        s_count[int(digit)] -= 1
    n = int(substring)
    s_count[int(substring[0])] += 1
    leading_zero = 0
    for i in range(1, 10):
        if s_count[i] > 0:
            n = int(str(i) + substring)
            leading_zero = s_count[0]
            break
    s_count[int(substring[0])] -= 1
    s_count[0] -= leading_zero
    remaining_digits = []
    for i in range(0, 10):
        while s_count[i] > 0:
            remaining_digits.append(str(i))
            s_count[i] -= 1
    n = int(''.join(remaining_digits))
    if n == 0:
        return '0'
    return n
  
solve()","
def solve():
    from collections import Counter
    
    received_num = input().strip()
    remembered_substring = input().strip()
    
    num_counter = Counter(received_num)
    substr_counter = Counter(remembered_substring)
    
    for digit in remembered_substring:
        if num_counter[digit] < substr_counter[digit]:
            for i in range(10):
                if num_counter[str(i)] >= substr_counter[digit]:
                    num_counter[digit] -= 1
                    num_counter[str(i)] += 1
                    received_num = received_num.replace(digit, str(i), 1)
                    break
                
    if received_num[0] == '0':
        for i in range(1, len(received_num)):
            if received_num[i] != '0':
                received_num = '0' + received_num[i:]
                break
                
    print(int(received_num))

solve()
","
def solve():
    from collections import Counter

    s = input()
    target = input()

    s_counter = Counter(s)
    target_counter = Counter(target)

    result = ''

    for num in sorted(s_counter.keys()):
        if num in target_counter:
            result += num * target_counter[num]

    for num in sorted(s_counter.keys()):
        if num not in target_counter:
            result += num * s_counter[num]

    return result

solve()","
def solve():
    import itertools

    received = input()
    remembered = input()
    
    possible_numbers = []
    for perm in itertools.permutations(received, len(remembered)):
        num = int("""".join(perm))
        str_num = str(num)
        if str_num.startswith(remembered):
            if str_num[0] == ""0"" and len(remembered) > 1:
                continue
            possible_numbers.append(num)
    
    smallest_num = min(possible_numbers)
    print(smallest_num)

solve()
","
def solve():
    from collections import Counter
    
    s = input().strip()
    remembered = input().strip()
    
    count_s = Counter(s)
    count_rem = Counter(remembered)
    
    diff = count_s - count_rem
    
    res = ''
    found = False
    for i in range(1, 10):
        if count_rem[str(i)] > 0:
            res += str(i)
            count_rem[str(i)] -= 1
            found = True
            break
    
    if not found:
        for i in range(1, 10):
            if diff[str(i)] > 0:
                res += str(i)
                diff[str(i)] -= 1
                break
    
    for i in range(10):
        res += str(i) * diff[str(i)]
    
    res += remembered
    
    while diff['0'] > 0:
        res += '0' * diff['0']
    
    return res

solve()","
def solve():
    from collections import Counter
    
    s = input().strip()
    sub = input().strip()
    
    count_s = Counter(s)
    count_sub = Counter(sub)
    
    diff = count_s - count_sub
    
    result = """"
    leading_zero = True
    
    for c in s:
        if count_sub[c] > 0:
            count_sub[c] -= 1
            result += c
            if leading_zero and c != '0':
                leading_zero = False
        elif c in diff and diff[c] > 0:
            diff[c] -= 1
            if leading_zero and c != '0':
                leading_zero = False
            result += c
    
    if leading_zero:
        result = '0' + result
    
    print(result)
        
solve()
  ","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","16.666666666666664","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/241","
QUESTION:
Not so long ago company R2 bought company R1 and consequently, all its developments in the field of multicore processors. Now the R2 laboratory is testing one of the R1 processors.

The testing goes in n steps, at each step the processor gets some instructions, and then its temperature is measured. The head engineer in R2 is keeping a report record on the work of the processor: he writes down the minimum and the maximum measured temperature in his notebook. His assistant had to write down all temperatures into his notebook, but (for unknown reasons) he recorded only m.

The next day, the engineer's assistant filed in a report with all the m temperatures. However, the chief engineer doubts that the assistant wrote down everything correctly (naturally, the chief engineer doesn't doubt his notes). So he asked you to help him. Given numbers n, m, min, max and the list of m temperatures determine whether you can upgrade the set of m temperatures to the set of n temperatures (that is add n - m temperatures), so that the minimum temperature was min and the maximum one was max.


-----Input-----

The first line contains four integers n, m, min, max (1 ≤ m < n ≤ 100; 1 ≤ min < max ≤ 100). The second line contains m space-separated integers t_{i} (1 ≤ t_{i} ≤ 100) — the temperatures reported by the assistant.

Note, that the reported temperatures, and the temperatures you want to add can contain equal temperatures.


-----Output-----

If the data is consistent, print 'Correct' (without the quotes). Otherwise, print 'Incorrect' (without the quotes).


-----Examples-----
Input
2 1 1 2
1

Output
Correct

Input
3 1 1 3
2

Output
Correct

Input
2 1 1 3
2

Output
Incorrect



-----Note-----

In the first test sample one of the possible initial configurations of temperatures is [1, 2].

In the second test sample one of the possible initial configurations of temperatures is [2, 1, 3].

In the third test sample it is impossible to add one temperature to obtain the minimum equal to 1 and the maximum equal to 3.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    reported_temps = list(map(int, input().split()))

    min_reported = min(reported_temps)
    max_reported = max(reported_temps)

    if min_temp >= min_reported and max_temp <= max_reported:
        print('Correct')
    else:
        print('Incorrect')

solve()
","
def solve():
    n, m, mn, mx = map(int, input().split())
    temps = list(map(int, input().split()))
    
    min_temp = min(temps)
    max_temp = max(temps)
    
    if mn >= min_temp and mx <= max_temp:
        print(""Correct"")
    else:
        print(""Incorrect"")

solve()
","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    reported_temps = list(map(int, input().split()))

    if min(reported_temps) < min_temp or max(reported_temps) > max_temp:
        print('Incorrect')
    else:
        print('Correct')

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    temps = list(map(int, input().split()))
    if min(temps) >= min_temp and max(temps) <= max_temp and (min_temp in temps or max_temp in temps or m < n):
        print('Correct')
    else:
        print('Incorrect')

solve()","
def solve():
    n, m, temp_min, temp_max = map(int, input().split())
    reported_temps = list(map(int, input().split()))

    min_reported = min(reported_temps)
    max_reported = max(reported_temps)

    if min_reported < temp_min or max_reported > temp_max:
        print('Incorrect')
    else:
        print('Correct')

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    reported_temperatures = list(map(int, input().split()))

    min_reported = min(reported_temperatures)
    max_reported = max(reported_temperatures)

    if min_temp >= min_reported and max_temp <= max_reported:
        print('Correct')
    else:
        print('Incorrect')

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    reported_temperatures = list(map(int, input().split()))
    
    min_reported_temp = min(reported_temperatures)
    max_reported_temp = max(reported_temperatures)
    
    if min_temp >= min_reported_temp and max_temp <= max_reported_temp:
        print(""Correct"")
    else:
        print(""Incorrect"")

solve()
","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    reported_temps = list(map(int, input().split()))
    
    min_reported = min(reported_temps)
    max_reported = max(reported_temps)
    
    if min_temp >= min_reported and max_temp <= max_reported:
        print('Correct')
    else:
        print('Incorrect')

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    temperatures = list(map(int, input().split()))

    current_min = min(temperatures)
    current_max = max(temperatures)

    if min_temp >= current_min and max_temp <= current_max:
        print('Correct')
    else:
        print('Incorrect')

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    temperatures = list(map(int, input().split()))

    if min(temperatures) <= min_temp and max(temperatures) >= max_temp:
        print('Correct')
    elif min(temperatures) > min_temp and max(temperatures) < max_temp:
        print('Incorrect')
    elif min(temperatures) > min_temp and max(temperatures) >= max_temp:
        if min_temp in temperatures or max_temp in temperatures:
            print('Correct')
        else:
            print('Incorrect')
    elif min(temperatures) <= min_temp and max(temperatures) < max_temp:
        if min_temp in temperatures or max_temp in temperatures:
            print('Correct')
        else:
            print('Incorrect')

solve()
","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    temperatures = list(map(int, input().split()))
    
    min_temp_existing = min(temperatures)
    max_temp_existing = max(temperatures)
    
    if min_temp_existing < min_temp or max_temp_existing > max_temp:
        print(""Incorrect"")
    else:
        if n - m >= 2:
            print(""Correct"")
        elif n - m == 1:
            if (min_temp in temperatures) and (max_temp in temperatures):
                print(""Correct"")
            elif (min_temp in temperatures) and (max_temp not in temperatures):
                if max_temp_existing < max_temp:
                    print(""Correct"")
                else:
                    print(""Incorrect"")
            elif (min_temp not in temperatures) and (max_temp in temperatures):
                if min_temp_existing > min_temp:
                    print(""Correct"")
                else:
                    print(""Incorrect"")
            else:
                if min_temp_existing < min_temp and max_temp_existing < max_temp:
                    print(""Correct"")
                else:
                    print(""Incorrect"")
        else:
            if min_temp in temperatures and max_temp in temperatures:
                print(""Correct"")
            else:
                if min_temp in temperatures:
                    if max_temp_existing < max_temp:
                        print(""Correct"")
                    else:
                        print(""Incorrect"")
                elif max_temp in temperatures:
                    if min_temp_existing > min_temp:
                        print(""Correct"")
                    else:
                        print(""Incorrect"")
                else:
                    if min_temp_existing < min_temp and max_temp_existing < max_temp:
                        print(""Correct"")
                    else:
                        print(""Incorrect"")

solve()
 ","
def solve():
  n, m, min_temp, max_temp = map(int, input().split())
  reported_temps = list(map(int, input().split()))

  min_reported = min(reported_temps)
  max_reported = max(reported_temps)

  if min_temp >= min_reported and max_temp <= max_reported:
    print('Correct')
  else:
    print('Incorrect')

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    assistant_temps = list(map(int, input().split()))
    
    min_assistant = min(assistant_temps)
    max_assistant = max(assistant_temps)
    
    if min_assistant < min_temp or max_assistant > max_temp:
        print('Incorrect')
    else:
        print('Correct')

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    assistant_temps = list(map(int, input().split()))

    min_reported_temp = min(assistant_temps)
    max_reported_temp = max(assistant_temps)

    if min_reported_temp >= min_temp and max_reported_temp <= max_temp:
        print('Correct')
    else:
        print('Incorrect')

solve()
","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    temperatures = list(map(int, input().split()))

    min_temp_reported = min(temperatures)
    max_temp_reported = max(temperatures)

    if min_temp_reported < min_temp or max_temp_reported > max_temp:
        print(""Incorrect"")
    else:
        print(""Correct"")

solve()","
def solve():
    n, m, min_temp, max_temp = map(int, input().split())
    temps_reported = list(map(int, input().split()))

    min_reported = min(temps_reported)
    max_reported = max(temps_reported)

    if min_temp >= min_reported and max_temp <= max_reported:
        print('Correct')
    else:
        print('Incorrect')

solve()
","46.666666666666664","46.666666666666664","86.66666666666667","86.66666666666667","86.66666666666667","46.666666666666664","46.666666666666664","46.666666666666664","46.666666666666664","66.66666666666666","100.0","46.666666666666664","86.66666666666667","86.66666666666667","86.66666666666667","46.666666666666664","","","","","","","","","","","","","","","",""
"APPS/242","
QUESTION:
Mr. Santa asks all the great programmers of the world to solve a trivial problem. He gives them an integer m and asks for the number of positive integers n, such that the factorial of n ends with exactly m zeroes. Are you among those great programmers who can solve this problem?


-----Input-----

The only line of input contains an integer m (1 ≤ m ≤ 100 000) — the required number of trailing zeroes in factorial.


-----Output-----

First print k — the number of values of n such that the factorial of n ends with m zeroes. Then print these k integers in increasing order.


-----Examples-----
Input
1

Output
5
5 6 7 8 9 
Input
5

Output
0


-----Note-----

The factorial of n is equal to the product of all integers from 1 to n inclusive, that is n! = 1·2·3·...·n.

In the first sample, 5! = 120, 6! = 720, 7! = 5040, 8! = 40320 and 9! = 362880.
Use user-input-Based format and function signature solve()","
from math import factorial

def solve():
    m = int(input())
    n = 5
    count = 0
    result = []
    
    while n <= m:
        zeros = 0
        temp = n
        
        while temp > 0:
            temp //= 5
            zeros += temp
        
        if zeros == m:
            count += 1
            result.append(n)
        
        n += 1
    
    print(count)
    print(*result)

solve()","
def solve():
    import math
    m = int(input())
    n = 5
    count = 0
    factors = set()
    
    while n <= m:
        count += m // n
        factors.add(n)
        n *= 5
    
    print(count)
    
    for i in range(5, m+1):
        value = i
        for f in factors:
            while value % f == 0:
                value //= f
        if value == 1:
            print(i, end=' ')

solve()","
from math import factorial

def solve():
    m = int(input())
    n = 5
    k = 0
    result = []
    
    while factorial(n) % (10 ** k) == 0:
        zeros = 0
        temp = factorial(n)
        
        while temp % 10 == 0:
            zeros += 1
            temp //= 10
        
        if zeros == m:
            result.append(n)
        
        n += 1
    
    print(len(result))
    print("" "".join(map(str, result)))

solve()","
def solve():
    import math

    m = int(input())
    n = 0

    while math.factorial(n) % (10 ** m) == 0:
        n += 1

    if n == 0:
        print(0)
    else:
        factors = []
        for i in range(n):
            if math.factorial(i) % (10 ** m) == 0:
                factors.append(i)
        print(len(factors))
        print(*factors)

solve()","
def solve():
    m = int(input())

    def trailing_zeroes(n):
        res = 0
        while n > 0:
            n //= 5
            res += n
        return res

    def find_values():
        low, high = 0, 10**18
        while low != high:
            mid = (low + high) // 2
            if trailing_zeroes(mid) < m:
                low = mid + 1
            else:
                high = mid
        if trailing_zeroes(low) == m:
            return low
        return 0

    n = find_values()
    if n == 0:
        print(0)
    else:
        print(5)
        for i in range(n, n + 5):
            print(i)

solve()
","
def solve():
    m = int(input())
    count = 0
    n = 5

    while n <= m:
        count += m // n
        n *= 5

    print(count)
    if count > 0:
        n = 5
        for i in range(count):
            print(n, end="" "")
            n += 1

solve()
","
# Function to solve Mr. Santa's problem
def solve():
    m = int(input())
    count = 0
    result = []
    x = 5
    while x <= m:
        count += m // x
        x *= 5
    print(count)
    for i in range(5, m+1):
        if i % 5 == 0:
            temp = i
            while temp % 5 == 0:
                temp //= 5
                count -= 1
            if count == 0:
                break
            elif count < 0:
                result = []
        else:
            count += 1
            result.append(i)
    print(*result)

# Call the function
solve()
","
import math

def solve():
    m = int(input())
    n = 5
    count = 0
    factors = []
    
    while n <= m:
        count += m // n
        n *= 5
    
    for i in range(m, m-count, -1):
        factors.append(i)
    
    print(count)
    print("" "".join(map(str, factors)))

solve()
","
import math

def solve():
    m = int(input())
    n = 1
    count_zeroes = 0
    results = []
    
    while True:
        fact = math.factorial(n)
        while fact % 10 == 0:
            count_zeroes += 1
            fact //= 10
        if count_zeroes == m:
            results.append(n)
        elif count_zeroes > m:
            break
        n += 1
        count_zeroes = 0
    
    print(len(results))
    if results:
        print(*results)

solve()
","
def solve():
    m = int(input())
    ans = []
    num = 5
    while num <= m:
        rem = 0
        div = num
        while div >= 5:
            rem += div // 5
            div = div // 5
        if rem == m:
            ans.append(num)
        num += 5
    print(len(ans))
    print(*ans)

solve()
","
from math import factorial

def solve():
    m = int(input())
    
    def count_trailing_zeroes(num):
        count = 0
        while num % 10 == 0:
            count += 1
            num //= 10
        return count
    
    def find_factorial_with_m_zeroes(m):
        count = 0
        result = []
        n = 1
        while True:
            if count_trailing_zeroes(factorial(n)) == m:
                count += 1
                result.append(n)
            n += 1
            if count > 0 and count_trailing_zeroes(factorial(n)) != m:
                break
        return count, result
    
    k, values = find_factorial_with_m_zeroes(m)
    
    print(k)
    if k > 0:
        print("" "".join(map(str, values)))

solve()
","
from math import factorial

def solve():
    m = int(input())
    n = 1
    result = []
    
    while True:
        if factorial(n) % (10 ** m) == 0:
            result.append(n)
        if factorial(n) % (10 ** (m+1)) != 0:
            break
        n += 1
    
    print(len(result))
    print("" "".join(map(str, result)))
  
solve()","
def solve():
    import math
    m = int(input())
    count = 0
    n = 5
    results = []
    while n <= m:
        count += m // n
        n *= 5
    for i in range(count):
        results.append(5 * i + 5)
    print(count)
    print(*results)

solve()
","
from math import factorial

def solve():
    m = int(input(""Enter the required number of trailing zeroes in factorial: ""))
    
    count = 0
    n = 1
    result = []
    
    while(True):
        if str(factorial(n)).count('0') == m:
            count += 1
            result.append(n)
        elif str(factorial(n)).count('0') > m:
            break
        
        n += 1
    
    print(count)
    if count > 0:
        print(*result)

solve()
","
from math import factorial

def solve():
    m = int(input())
    n = 5
    ans = []
    while n * (n - 1) // 2 != m:
        n += 5
    while n:
        if factorial(n) % 10 == 0:
            ans.append(str(n))
        n += 5
        if len(ans) == m:
            break
    print(len(ans))
    print(' '.join(ans))

solve()
","
def solve():
    m = int(input())
    count = 0
    n = 5
    result = []

    while n <= m:
        zeros = 0
        temp = n

        while temp > 0:
            temp //= 5
            zeros += temp

        if zeros == m:
            count += 1
            result.append(n)

        n += 5

    print(count)
    print("" "".join(str(num) for num in result))

solve()
","6.666666666666667","0.0","0","6.666666666666667","6.666666666666667","0.0","0.0","0.0","100.0","6.666666666666667","100.0","6.666666666666667","0.0","0.0","0","6.666666666666667","","","All tests timed out","","","","","","","","","","","","All tests timed out",""
"APPS/243","
QUESTION:
Chouti was tired of the tedious homework, so he opened up an old programming problem he created years ago.

You are given a connected undirected graph with $n$ vertices and $m$ weighted edges. There are $k$ special vertices: $x_1, x_2, \ldots, x_k$.

Let's define the cost of the path as the maximum weight of the edges in it. And the distance between two vertexes as the minimum cost of the paths connecting them.

For each special vertex, find another special vertex which is farthest from it (in terms of the previous paragraph, i.e. the corresponding distance is maximum possible) and output the distance between them.

The original constraints are really small so he thought the problem was boring. Now, he raises the constraints and hopes you can solve it for him.


-----Input-----

The first line contains three integers $n$, $m$ and $k$ ($2 \leq k \leq n \leq 10^5$, $n-1 \leq m \leq 10^5$) — the number of vertices, the number of edges and the number of special vertices.

The second line contains $k$ distinct integers $x_1, x_2, \ldots, x_k$ ($1 \leq x_i \leq n$).

Each of the following $m$ lines contains three integers $u$, $v$ and $w$ ($1 \leq u,v \leq n, 1 \leq w \leq 10^9$), denoting there is an edge between $u$ and $v$ of weight $w$. The given graph is undirected, so an edge $(u, v)$ can be used in the both directions.

The graph may have multiple edges and self-loops.

It is guaranteed, that the graph is connected.


-----Output-----

The first and only line should contain $k$ integers. The $i$-th integer is the distance between $x_i$ and the farthest special vertex from it.


-----Examples-----
Input
2 3 2
2 1
1 2 3
1 2 2
2 2 1

Output
2 2 

Input
4 5 3
1 2 3
1 2 5
4 2 1
2 3 2
1 4 4
1 3 3

Output
3 3 3 



-----Note-----

In the first example, the distance between vertex $1$ and $2$ equals to $2$ because one can walk through the edge of weight $2$ connecting them. So the distance to the farthest node for both $1$ and $2$ equals to $2$.

In the second example, one can find that distance between $1$ and $2$, distance between $1$ and $3$ are both $3$ and the distance between $2$ and $3$ is $2$.

The graph may have multiple edges between and self-loops, as in the first example.
Use user-input-Based format and function signature solve()","
def solve():
    import heapq

    n, m, k = map(int, input().split())
    special_vertices = set(map(int, input().split()))

    graph = {i: [] for i in range(1, n+1)}
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))

    def dijkstra(start):
        distances = {vertex: float('inf') for vertex in graph}
        distances[start] = 0
        pq = [(0, start)]

        while pq:
            current_distance, current_vertex = heapq.heappop(pq)

            if current_distance > distances[current_vertex]:
                continue

            for neighbor, weight in graph[current_vertex]:
                distance = current_distance + weight

                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))

        return distances

    max_distances = []
    for vertex in special_vertices:
        distances = dijkstra(vertex)
        max_distance = max(distances[v] for v in special_vertices)
        max_distances.append(max_distance)

    print(*max_distances)

solve()
","
from collections import defaultdict

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))
    graph = defaultdict(list)
    
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    distances = [-1] * (n + 1)
    
    def dfs(node, parent, distance):
        distances[node] = distance
        for neighbor, weight in graph[node]:
            if neighbor != parent:
                dfs(neighbor, node, max(distance, weight))
    
    for vertex in special_vertices:
        dfs(vertex, parent=0, distance=0)
    
    result = [max(distances[vertex] for vertex in special_vertices) for _ in range(k)]
    print(*result)

solve()
","
from collections import defaultdict

def solve():
    n, m, k = map(int, input().split())
    special_vertices = set(map(int, input().split()))
    
    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    distances = {v: -1 for v in special_vertices}
    
    def dfs(node, parent, max_dist):
        if node in special_vertices:
            distances[node] = max_dist
        
        for neighbor, weight in graph[node]:
            if neighbor != parent:
                new_dist = max(max_dist, weight)
                dfs(neighbor, node, new_dist)
    
    dfs(list(special_vertices)[0], -1, 0)
    
    print(' '.join(str(distances[v]) for v in special_vertices))

solve()
","
from collections import defaultdict

def solve():
    n, m, k = map(int, input().split())
    special_vertices = set(map(int, input().split()))
    graph = defaultdict(list)

    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))

    def dfs(node, parent, max_distance):
        for neighbor, weight in graph[node]:
            if neighbor != parent:
                max_distance = max(max_distance, weight)
                dfs(neighbor, node, max_distance)
        return max_distance

    output = []
    for special_vertex in special_vertices:
        output.append(max(dfs(special_vertex, 0, 0) for _ in range(2)))

    print(*output)

solve()
","
from collections import defaultdict, deque

def solve():
    n, m, k = map(int, input().split())
    special_vertices = set(map(int, input().split()))
    
    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    def bfs(start):
        visited = set()
        max_distance = [-1] * (n + 1)
        max_distance[start] = 0
        q = deque([start])
        
        while q:
            node = q.popleft()
            visited.add(node)
            
            for neighbor, weight in graph[node]:
                if neighbor not in visited:
                    max_distance[neighbor] = max(max_distance[neighbor], max_distance[node], weight)
                    q.append(neighbor)
        
        return max_distance
                
    for vertex in special_vertices:
        max_distance = bfs(vertex)
        farthest_distance = max(max_distance[v] for v in special_vertices)
        print(farthest_distance, end=' ')

solve()
  ","
def solve():
    import sys
    from collections import defaultdict
    from heapq import heappop, heappush

    n, m, k = map(int, input().split())
    special_vertices = set(map(int, input().split()))

    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))

    def dijkstra(start):
        distances = {vertex: float('inf') for vertex in range(1, n+1)}
        distances[start] = 0
        queue = []
        heappush(queue, (0, start))

        while queue:
            cost, current_vertex = heappop(queue)
            if cost > distances[current_vertex]:
                continue
            for neighbor, weight in graph[current_vertex]:
                new_cost = max(cost, weight)
                if new_cost < distances[neighbor]:
                    distances[neighbor] = new_cost
                    heappush(queue, (new_cost, neighbor))

        return distances

    max_distances = dijkstra(1)
    for special_vertex in special_vertices:
        farthest_distance = max(dist for vertex, dist in max_distances.items() if vertex in special_vertices and vertex != special_vertex)
        print(farthest_distance, end=' ')

solve()
","
from collections import defaultdict

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))
    graph = defaultdict(list)
    
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    def dfs(node, parent, maxx):
        distances[node] = maxx
        for neighbor, weight in graph[node]:
            if neighbor != parent:
                dfs(neighbor, node, max(maxx, weight))
    
    distances = [0] * (n + 1)
    dfs(special_vertices[0], 0, 0)
    
    result = [distances[sv] for sv in special_vertices]
    print(*result)

solve()
  ","
import collections

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))
    
    graph = collections.defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    def bfs(start):
        distances = [-1] * (n + 1)
        distances[start] = 0
        queue = collections.deque([start])
        
        while queue:
            current_node = queue.popleft()
            for neighbor, weight in graph[current_node]:
                if distances[neighbor] == -1:
                    distances[neighbor] = distances[current_node] + weight
                    queue.append(neighbor)
        
        return distances
    
    result = []
    for special_vertex in special_vertices:
        distances = bfs(special_vertex)
        farthest_distance = max(distances[x] for x in special_vertices)
        result.append(farthest_distance)
    
    print(' '.join(map(str, result)))

solve()
","
from collections import defaultdict

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))
    
    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    def dfs(v, parent):
        max_dist = 0
        for neighbour, weight in graph[v]:
            if neighbour != parent:
                dist = dfs(neighbour, v) + weight
                max_dist = max(max_dist, dist)
        return max_dist
    
    distances = [0] * (n + 1)
    for special_vertex in special_vertices:
        distances[special_vertex] = dfs(special_vertex, 0)
    
    result = []
    for special_vertex in special_vertices:
        max_distance = 0
        for vertex in special_vertices:
            if vertex != special_vertex:
                max_distance = max(max_distance, distances[vertex])
        result.append(max_distance)
    
    print(*result)

solve()
","
from collections import defaultdict
import heapq

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))
    
    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    def dijkstra(s):
        distances = [float('inf')] * (n+1)
        distances[s] = 0
        pq = [(0, s)]
        
        while pq:
            dist, node = heapq.heappop(pq)
            if dist > distances[node]:
                continue
            
            for neighbor, weight in graph[node]:
                new_dist = max(dist, weight)
                if new_dist < distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(pq, (new_dist, neighbor))
        
        return distances
    
    all_distances = [dijkstra(x) for x in special_vertices]
    
    for i in range(k):
        max_dist = 0
        for j in range(k):
            if i != j:
                max_dist = max(max_dist, all_distances[i][special_vertices[j]])
        print(max_dist, end=' ')
  
solve()","
def solve():
    import sys
    from collections import defaultdict
    from heapq import heappush, heappop
    
    def dijkstra(graph, start):
        distances = {node: float('inf') for node in graph}
        distances[start] = 0
        pq = [(0, start)]
        while pq:
            current_dist, current_node = heappop(pq)
            if current_dist > distances[current_node]:
                continue
            for neighbor, weight in graph[current_node]:
                distance = max(current_dist, weight)
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heappush(pq, (distance, neighbor))
        return distances
    
    n, m, k = map(int, input().split())
    special_vertices = set(map(int, input().split()))
    
    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    distances = {node: dijkstra(graph, node) for node in special_vertices}
    
    result = []
    for node in special_vertices:
        farthest_dist = 0
        for key, dist in distances[node].items():
            if key in special_vertices and key != node:
                farthest_dist = max(farthest_dist, dist)
        result.append(farthest_dist)
    
    print(*result)

solve()
","
from collections import defaultdict
import heapq

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))

    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))

    def dijkstra(start):
        distances = [float('inf')] * (n + 1)
        distances[start] = 0
        max_distance = 0

        pq = [(0, start)]
        while pq:
            dist, node = heapq.heappop(pq)
            if dist > distances[node]:
                continue

            for neighbor, weight in graph[node]:
                new_distance = max(distances[node], weight)
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    max_distance = max(max_distance, new_distance)
                    heapq.heappush(pq, (new_distance, neighbor))

        return max_distance

    distances = [dijkstra(vertex) for vertex in special_vertices]
    print(*distances)

solve()
  ","
from collections import deque

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))

    graph = [[] for _ in range(n + 1)]
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))

    def bfs(source):
        dist = [-1] * (n + 1)
        dist[source] = 0
        queue = deque([source])

        while queue:
            node = queue.popleft()
            for neighbor, weight in graph[node]:
                if dist[neighbor] == -1:
                    dist[neighbor] = dist[node] + weight
                    queue.append(neighbor)

        return dist

    distances = [bfs(vertex) for vertex in special_vertices]

    for i in range(k):
        max_distance = max(distance[special_vertices[i]] for distance in distances)
        print(max_distance, end="" "")

# Example usage
solve()
","
def solve():
    from collections import defaultdict
    import heapq

    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))

    graph = defaultdict(list)

    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))

    def dijkstra(start):
        distance = [float('inf') for _ in range(n + 1)]
        distance[start] = 0
        pq = [(0, start)]

        while pq:
            dist, node = heapq.heappop(pq)

            if dist > distance[node]:
                continue

            for neighbor, weight in graph[node]:
                new_dist = max(dist, weight)
                if new_dist < distance[neighbor]:
                    distance[neighbor] = new_dist
                    heapq.heappush(pq, (new_dist, neighbor))

        return distance

    all_distances = [dijkstra(vertex) for vertex in special_vertices]

    output = []
    for i in range(k):
        max_dist = 0
        for j in range(k):
            if i != j:
                max_dist = max(max_dist, all_distances[i][special_vertices[j]])
        output.append(max_dist)

    print(' '.join(map(str, output)))

solve()
","
from collections import defaultdict
import heapq

def solve():
    n, m, k = map(int, input().split())
    special_vertices = list(map(int, input().split()))
    
    adj_list = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        adj_list[u].append((v, w))
        adj_list[v].append((u, w))
    
    distances = {}
    for special_vertex in special_vertices:
        visited = set()
        pq = [(0, special_vertex)]
        while pq:
            dist, node = heapq.heappop(pq)
            if node in visited:
                continue
            visited.add(node)
            distances[special_vertex, node] = dist
            for neighbor, weight in adj_list[node]:
                if neighbor not in visited:
                    heapq.heappush(pq, (max(dist, weight), neighbor))
    
    result = []
    for special_vertex in special_vertices:
        farthest_distance = -1
        for other_special_vertex in special_vertices:
            if other_special_vertex != special_vertex:
                distance = distances[special_vertex, other_special_vertex]
                farthest_distance = max(farthest_distance, distance)
        result.append(farthest_distance)
    
    print(*result)

  
solve()","
from collections import defaultdict
import heapq

def solve():
    n, m, k = map(int, input().split())
    special_vertices = set(map(int, input().split()))
    
    graph = defaultdict(list)
    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))
        
    def dijkstra(start):
        distances = [float('inf')] * (n + 1)
        distances[start] = 0
        pq = [(0, start)]
        
        while pq:
            dist, node = heapq.heappop(pq)
            if dist > distances[node]:
                continue
                
            for neighbor, weight in graph[node]:
                if dist + weight < distances[neighbor]:
                    distances[neighbor] = dist + weight
                    heapq.heappush(pq, (distances[neighbor], neighbor))
                    
        return distances
    
    max_distances = []
    for vertex in special_vertices:
        distances = dijkstra(vertex)
        max_dist = max(distances[v] for v in special_vertices if v != vertex)
        max_distances.append(max_dist)
    
    print(*max_distances)


solve()","73.33333333333333","73.33333333333333","6.666666666666667","13.333333333333334","80.0","6.666666666666667","0.0","66.66666666666666","6.666666666666667","100.0","100.0","13.333333333333334","66.66666666666666","100.0","100.0","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/244","
QUESTION:
Bomboslav likes to look out of the window in his room and watch lads outside playing famous shell game. The game is played by two persons: operator and player. Operator takes three similar opaque shells and places a ball beneath one of them. Then he shuffles the shells by swapping some pairs and the player has to guess the current position of the ball.

Bomboslav noticed that guys are not very inventive, so the operator always swaps the left shell with the middle one during odd moves (first, third, fifth, etc.) and always swaps the middle shell with the right one during even moves (second, fourth, etc.).

Let's number shells from 0 to 2 from left to right. Thus the left shell is assigned number 0, the middle shell is 1 and the right shell is 2. Bomboslav has missed the moment when the ball was placed beneath the shell, but he knows that exactly n movements were made by the operator and the ball was under shell x at the end. Now he wonders, what was the initial position of the ball?


-----Input-----

The first line of the input contains an integer n (1 ≤ n ≤ 2·10^9) — the number of movements made by the operator.

The second line contains a single integer x (0 ≤ x ≤ 2) — the index of the shell where the ball was found after n movements.


-----Output-----

Print one integer from 0 to 2 — the index of the shell where the ball was initially placed.


-----Examples-----
Input
4
2

Output
1

Input
1
1

Output
0



-----Note-----

In the first sample, the ball was initially placed beneath the middle shell and the operator completed four movements.  During the first move operator swapped the left shell and the middle shell. The ball is now under the left shell.  During the second move operator swapped the middle shell and the right one. The ball is still under the left shell.  During the third move operator swapped the left shell and the middle shell again. The ball is again in the middle.  Finally, the operators swapped the middle shell and the right shell. The ball is now beneath the right shell.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    x = int(input())
    
    if n % 2 == 0:
        print(x)
    else:
        if x == 0:
            print(1)
        elif x == 1:
            print(0)
        else:
            print(2)

solve()
","
def solve():
    n = int(input())
    x = int(input())
    
    if n % 2 == 0:
        return x
    else:
        if x == 0:
            return 1
        elif x == 1:
            return 0
        else:
            return 2

solve()","
def solve():
    n = int(input())
    x = int(input())
    
    if n % 2 == 0:
        return x
    else:
        if x == 0:
            return 1
        elif x == 1:
            return 0
        else:
            return 2

solve()","
def solve():
    n = int(input())
    x = int(input())

    movements = n % 6

    if movements == 0:
        print(x)
    elif movements == 1:
        print((x + 1) % 3)
    elif movements == 2:
        print((x + 2) % 3)
    elif movements == 3:
        print((x + 2) % 3)
    elif movements == 4:
        print((x + 1) % 3)
    elif movements == 5:
        print(x)

solve()","
def solve():
    n = int(input())
    x = int(input())
    
    if n % 2 == 0:
        movements = n // 2
    else:
        movements = n // 2 + 1
    
    result = (x + movements) % 3
    print(result)

solve()
  ","
def solve():
    n = int(input())
    x = int(input())  
    
    n %= 6
    moves = [x, 1, 0, x, x, 2]
    
    return moves[n]

solve()
  ","
def solve():
    n = int(input())
    x = int(input())
    moves = n % 6

    if moves == 0:
        print(x)
    elif moves == 1:
        if x == 0:
            print(1)
        elif x == 1:
            print(0)
        else:
            print(2)
    elif moves == 2:
        if x == 0:
            print(2)
        elif x == 1:
            print(1)
        else:
            print(0)
    elif moves == 3:
        if x == 0:
            print(2)
        elif x == 1:
            print(0)
        else:
            print(1)
    elif moves == 4:
        if x == 0:
            print(1)
        elif x == 1:
            print(2)
        else:
            print(0)
    else:
        if x == 0:
            print(0)
        elif x == 1:
            print(2)
        else:
            print(1)

solve()
","
def solve():
    n = int(input())
    x = int(input())
    
    if n % 2 == 0:
        if n % 4 == 0:
            return x
        else:
            if x == 0:
                return 1
            elif x == 1:
                return 0
            else:
                return 2
    else:
        if n % 4 == 1:
            return x
        else:
            if x == 0:
                return 2
            elif x == 1:
                return 1
            else:
                return 0

solve()","
def solve():
    n = int(input())
    x = int(input())

    if n % 2 == 0:
        return x
    else:
        if x == 0:
            return 1
        elif x == 1:
            return 0
        elif x == 2:
            return 2

solve()","
def solve():
    n = int(input())
    x = int(input())
    
    moves = n % 6
    
    if moves == 1:
        if x == 0:
            return 1
        if x == 1:
            return 0
        if x == 2:
            return 2
    elif moves == 2:
        if x == 0:
            return 0
        if x == 1:
            return 2
        if x == 2:
            return 1
    elif moves == 3:
        if x == 0:
            return 2
        if x == 1:
            return 1
        if x == 2:
            return 0
    elif moves == 4:
        if x == 0:
            return 1
        if x == 1:
            return 0
        if x == 2:
            return 2
    elif moves == 5:
        if x == 0:
            return 2
        if x == 1:
            return 1
        if x == 2:
            return 0
    else:
        return x


solve()","
def solve():
    n = int(input())
    x = int(input())
    
    moves = n % 6
    
    if moves == 1:
        if x == 0:
            return 1
        elif x == 1:
            return 0
        else:
            return 2
    elif moves == 2:
        if x == 0:
            return 0
        elif x == 1:
            return 2
        else:
            return 1
    elif moves == 3:
        if x == 0:
            return 2
        elif x == 1:
            return 1
        else:
            return 0
    elif moves == 4:
        if x == 0:
            return 1
        elif x == 1:
            return 2
        else:
            return 0
    elif moves == 5:
        if x == 0:
            return 2
        elif x == 1:
            return 0
        else:
            return 1
    else:
        return x

solve()","
def solve():
    n = int(input())
    x = int(input())
    
    movements = n % 6
    
    if movements == 1: 
        if x == 0:
            return 1
        elif x == 1:
            return 0
        else:
            return 2
    elif movements == 2:
        if x == 0:
            return 0
        elif x == 1:
            return 2
        else:
            return 1
    elif movements == 3:
        return x
    elif movements == 4:
        if x == 0:
            return 2
        elif x == 1:
            return 0
        else:
            return 1
    elif movements == 5:
        if x == 0:
            return 1
        elif x == 1:
            return 2
        else:
            return 0
    else:
        return x

solve()","
def solve():
    n = int(input())
    x = int(input())
    
    n = n % 6
    
    for i in range(n):
        if x == 0:
            x = 1
        elif x == 1:
            if i % 2 == 0:
                x = 0
            else:
                x = 2
        else:
            x = 1
    
    return x

solve()","
def solve():
    n = int(input())
    x = int(input())

    if n % 2 == 0:
        return x
    else:
        if x == 0:
            return 1
        elif x == 1:
            return 0
        else:
            return 2

solve()","
def solve():
    n = int(input())
    x = int(input())
    
    if n % 2 == 0:
        print(x)
    else:
        if x == 0:
            print(1)
        elif x == 1:
            print(0)
        else:
            print(2)

solve()","
def solve():
    n = int(input())
    x = int(input())
    
    for i in range(n % 6):
        if i % 2 == 0:
            if x == 0:
                x = 1
            elif x == 1:
                x = 0
        else:
            if x == 1:
                x = 2
            elif x == 2:
                x = 1

    print(x)

solve()
","13.333333333333334","0.0","0.0","20.0","66.66666666666666","0.0","46.666666666666664","0.0","0.0","0.0","0.0","0.0","0.0","0.0","13.333333333333334","53.333333333333336","","","","","","","","","","","","","","","",""
"APPS/245","
QUESTION:
You are given n rectangles. The corners of rectangles have integer coordinates and their edges are parallel to the Ox and Oy axes. The rectangles may touch each other, but they do not overlap (that is, there are no points that belong to the interior of more than one rectangle). 

Your task is to determine if the rectangles form a square. In other words, determine if the set of points inside or on the border of at least one rectangle is precisely equal to the set of points inside or on the border of some square.


-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 5). Next n lines contain four integers each, describing a single rectangle: x_1, y_1, x_2, y_2 (0 ≤ x_1 < x_2 ≤ 31400, 0 ≤ y_1 < y_2 ≤ 31400) — x_1 and x_2 are x-coordinates of the left and right edges of the rectangle, and y_1 and y_2 are y-coordinates of the bottom and top edges of the rectangle. 

No two rectangles overlap (that is, there are no points that belong to the interior of more than one rectangle).


-----Output-----

In a single line print ""YES"", if the given rectangles form a square, or ""NO"" otherwise.


-----Examples-----
Input
5
0 0 2 3
0 3 3 5
2 0 5 2
3 2 5 5
2 2 3 3

Output
YES

Input
4
0 0 2 3
0 3 3 5
2 0 5 2
3 2 5 5

Output
NO
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    rectangles = []
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))

    x_coords = set()
    y_coords = set()
    for rect in rectangles:
        x_coords.add(rect[0])
        x_coords.add(rect[2])
        y_coords.add(rect[1])
        y_coords.add(rect[3])

    if len(x_coords) == 2 and len(y_coords) == 2:
        side_length = max(max(x_coords) - min(x_coords), max(y_coords) - min(y_coords))
        if side_length == max(y_coords) - min(y_coords) and side_length == max(x_coords) - min(x_coords):
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    rects = []
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rects.append((x1, y1, x2, y2))

    points = set()
    for rect in rects:
        for x in range(rect[0], rect[2]):
            for y in range(rect[1], rect[3]):
                points.add((x, y))

    min_x = min(p[0] for p in points)
    max_x = max(p[0] for p in points)
    min_y = min(p[1] for p in points)
    max_y = max(p[1] for p in points)

    if (max_x - min_x) == (max_y - min_y) and len(points) == (max_x - min_x + 1) * (max_y - min_y + 1):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    rectangles = []
    for _ in range(n):
        rectangle = list(map(int, input().split()))
        rectangles.append(rectangle)

    x_coords = set()
    y_coords = set()
    for rectangle in rectangles:
        for i in range(rectangle[0], rectangle[2]):
            x_coords.add(i)
        for j in range(rectangle[1], rectangle[3]):
            y_coords.add(j)

    if len(x_coords) == len(y_coords) == int(len(rectangles)**0.5):
        print(""YES"")
    else:
        print(""NO"")

solve()","
from typing import List

def solve() -> None:
    n = int(input())
    rectangles = []
    for _ in range(n):
        rectangle = list(map(int, input().split()))
        rectangles.append(rectangle)
    
    # Extracting coordinates of all distinct points
    x_coords = set()
    y_coords = set()
    for rectangle in rectangles:
        x_coords.add(rectangle[0])
        x_coords.add(rectangle[2])
        y_coords.add(rectangle[1])
        y_coords.add(rectangle[3])
    
    # Check if the points form a square
    if len(x_coords) == len(y_coords) == 2:
        x_length = max(x_coords) - min(x_coords)
        y_length = max(y_coords) - min(y_coords)
        if x_length == y_length:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")

# Example usage:
# solve()
","
def solve():
    n = int(input())
    rectangles = []
    minX = 31400
    minY = 31400
    maxX = 0
    maxY = 0
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
        
        minX = min(minX, x1)
        minY = min(minY, y1)
        maxX = max(maxX, x2)
        maxY = max(maxY, y2)
    
    total_area = 0
    for rect in rectangles:
        x1, y1, x2, y2 = rect
        total_area += (x2 - x1) * (y2 - y1)
        
    square_area = (maxX - minX) * (maxY - minY)
    
    if total_area == square_area and (maxX - minX) == (maxY - minY):
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
from typing import List

def solve():
    n = int(input())
    rectangles = []
    
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
    
    all_points = set()
    
    for rectangle in rectangles:
        for x in range(rectangle[0], rectangle[2] + 1):
            for y in range(rectangle[1], rectangle[3] + 1):
                all_points.add((x, y))
    
    min_x = min([rectangle[0] for rectangle in rectangles])
    max_x = max([rectangle[2] for rectangle in rectangles])
    min_y = min([rectangle[1] for rectangle in rectangles])
    max_y = max([rectangle[3] for rectangle in rectangles])
    
    if len(all_points) == (max_x - min_x + 1) * (max_y - min_y + 1):
        print(""YES"")
    else:
        print(""NO"")


solve()","
def solve():
    n = int(input())
    rectangles = []
    min_x = min_y = 31400
    max_x = max_y = 0
    
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
        min_x = min(min_x, x1)
        min_y = min(min_y, y1)
        max_x = max(max_x, x2)
        max_y = max(max_y, y2)
    
    if (max_x - min_x == max_y - min_y) and all(((x1 == min_x or x2 == max_x) and (y1 == min_y or y2 == max_y)) for x1, y1, x2, y2 in rectangles):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    rectangles = []
    
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
    
    min_x = min(rect[0] for rect in rectangles)
    max_x = max(rect[2] for rect in rectangles)
    min_y = min(rect[1] for rect in rectangles)
    max_y = max(rect[3] for rect in rectangles)
    
    total_area = (max_x - min_x) * (max_y - min_y)
    actual_area = sum((rect[2] - rect[0]) * (rect[3] - rect[1]) for rect in rectangles)
    
    if total_area == actual_area and (max_x - min_x) == (max_y - min_y):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    rectangles = [list(map(int, input().split())) for _ in range(n)]
    
    min_x = min(rect[0] for rect in rectangles)
    max_x = max(rect[2] for rect in rectangles)
    min_y = min(rect[1] for rect in rectangles)
    max_y = max(rect[3] for rect in rectangles)
    
    side_length = max(max_x - min_x, max_y - min_y)
    
    if all((rect[2] - rect[0] == side_length and rect[3] - rect[1] == side_length) for rect in rectangles):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
from typing import List, Tuple

def solve() -> None:
    n = int(input())
    rectangles = []
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
    
    def is_square(rectangles: List[Tuple[int, int, int, int]]) -> str:
        x_min = min(rectangles, key=lambda r: r[0])[0]
        y_min = min(rectangles, key=lambda r: r[1])[1]
        x_max = max(rectangles, key=lambda r: r[2])[2]
        y_max = max(rectangles, key=lambda r: r[3])[3]
        
        side_length = max(x_max - x_min, y_max - y_min)
        
        for rect in rectangles:
            if rect[2] - rect[0] != side_length or rect[3] - rect[1] != side_length:
                return ""NO""
        
        return ""YES""
    
    print(is_square(rectangles))

solve()
  ","
def solve():
    n = int(input())
    rectangles = []
    min_x, min_y, max_x, max_y = 31401, 31401, 0, 0

    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
        min_x = min(min_x, x1)
        min_y = min(min_y, y1)
        max_x = max(max_x, x2)
        max_y = max(max_y, y2)

    total_points = sum((x2 - x1) * (y2 - y1) for x1, y1, x2, y2 in rectangles)

    if total_points == (max_x - min_x) * (max_y - min_y) and max_x - min_x == max_y - min_y:
        print(""YES"")
    else:
        print(""NO"")

# Example usage:
# solve()
  ","
def solve():
    n = int(input())
    rectangles = []
    min_x = float('inf')
    max_x = 0
    min_y = float('inf')
    max_y = 0

    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
        min_x = min(min_x, x1)
        max_x = max(max_x, x2)
        min_y = min(min_y, y1)
        max_y = max(max_y, y2)

    total_area = (max_x - min_x) * (max_y - min_y)
    rectangles_area = sum((x2 - x1) * (y2 - y1) for x1, y1, x2, y2 in rectangles)

    if total_area == rectangles_area and (max_x - min_x) == (max_y - min_y):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    rectangles = []
    min_x = float('inf')
    min_y = float('inf')
    max_x = float('-inf')
    max_y = float('-inf')

    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
        min_x = min(min_x, x1)
        min_y = min(min_y, y1)
        max_x = max(max_x, x2)
        max_y = max(max_y, y2)

    total_area = 0
    for rect in rectangles:
        total_area += (rect[2] - rect[0]) * (rect[3] - rect[1])

    if (max_x - min_x) == (max_y - min_y) and total_area == (max_x - min_x) * (max_y - min_y):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    rectangles = []
    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))

    min_x = min(rectangles, key=lambda x: x[0])[0]
    max_x = max(rectangles, key=lambda x: x[2])[2]
    min_y = min(rectangles, key=lambda x: x[1])[1]
    max_y = max(rectangles, key=lambda x: x[3])[3]

    if (max_x - min_x) == (max_y - min_y) and all([(x, y, x + max_x - min_x, y + max_y - min_y) in rectangles for x in [min_x, max_x - max_x + min_x] for y in [min_y, max_y - max_y + min_y]):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    rectangles = []
    total_area = 0
    leftmost_x, rightmost_x, bottom_y, top_y = float('inf'), 0, float('inf'), 0

    for _ in range(n):
        x1, y1, x2, y2 = map(int, input().split())
        rectangles.append((x1, y1, x2, y2))
        total_area += (x2 - x1) * (y2 - y1)
        leftmost_x = min(leftmost_x, x1)
        rightmost_x = max(rightmost_x, x2)
        bottom_y = min(bottom_y, y1)
        top_y = max(top_y, y2)

    if total_area == (rightmost_x - leftmost_x) * (top_y - bottom_y) and (rightmost_x - leftmost_x) == (top_y - bottom_y):
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    rectangles = []
    for _ in range(n):
        rectangle = list(map(int, input().split()))
        rectangles.append(rectangle)

    min_x = min(rectangle[0] for rectangle in rectangles)
    min_y = min(rectangle[1] for rectangle in rectangles)
    max_x = max(rectangle[2] for rectangle in rectangles)
    max_y = max(rectangle[3] for rectangle in rectangles)

    total_area = (max_x - min_x) * (max_y - min_y)
    combined_area = sum((rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]) for rectangle in rectangles)

    if total_area == combined_area and max_x - min_x == max_y - min_y:
        print(""YES"")
    else:
        print(""NO"")

solve()","46.666666666666664","100.0","33.33333333333333","0.0","100.0","25.0","53.333333333333336","100.0","46.666666666666664","46.666666666666664","0.0","100.0","100.0","0.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/246","
QUESTION:
Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number x is really big if the difference between x and the sum of its digits (in decimal representation) is not less than s. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than n.

Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.


-----Input-----

The first (and the only) line contains two integers n and s (1 ≤ n, s ≤ 10^18).


-----Output-----

Print one integer — the quantity of really big numbers that are not greater than n.


-----Examples-----
Input
12 1

Output
3

Input
25 20

Output
0

Input
10 9

Output
1



-----Note-----

In the first example numbers 10, 11 and 12 are really big.

In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).

In the third example 10 is the only really big number (10 - 1 ≥ 9).
Use user-input-Based format and function signature solve()","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(num):
        return sum(int(digit) for digit in str(num))
    
    count = 0
    for x in range(1, n+1):
        if x - sum_of_digits(x) >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def digit_sum(num):
        return sum(map(int, str(num)))
    
    count = 0
    for i in range(1, n+1):
        sum_digits = digit_sum(i)
        if i - sum_digits >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(num):
        return sum([int(digit) for digit in str(num)])
    
    count = 0
    for x in range(1, n+1):
        if x - sum_of_digits(x) >= s:
            count += 1
    
    print(count)

solve()","
def solve():
    n, s = map(int, input().split())

    def digit_sum(num):
        return sum(int(i) for i in str(num))

    count = 0
    for x in range(1, n+1):
        if x - digit_sum(x) >= s:
            count += 1

    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        if x - sum(int(digit) for digit in str(x)) >= s:
            count += 1
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(num):
        return sum(int(digit) for digit in str(num))
    
    count = 0
    for x in range(1, n + 1):
        if x - sum_of_digits(x) >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    count = 0
    for x in range(1, n+1):
        if x - sum(map(int, str(x))) >= s:
            count += 1
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(num):
        return sum(int(digit) for digit in str(num))
    
    count = 0
    for x in range(1, n+1):
        if x - sum_of_digits(x) >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(num):
        return sum(int(digit) for digit in str(num))
    
    count = 0
    
    for i in range(1, n+1):
        if i - sum_of_digits(i) >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    count = 0
    
    def sum_of_digits(num):
        return sum(int(digit) for digit in str(num))
    
    for x in range(1, n + 1):
        if x - sum_of_digits(x) >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    count = 0
    
    for i in range(1, n+1):
        if i - sum(int(digit) for digit in str(i)) >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(num):
        return sum(map(int, str(num)))
    
    count = 0
    current_num = 1
    
    while current_num <= n:
        sum_digits = sum_of_digits(current_num)
        if current_num - sum_digits >= s:
            count += 1
        current_num += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(num):
        return sum(map(int, str(num)))
    
    count = 0
    for x in range(max(1, n - 1000), n + 1):
        if x - sum_of_digits(x) >= s:
            count += 1
    
    print(count)

solve()
  ","
def solve():
    n, s = map(int, input().split())
    count = 0
    for num in range(1, n + 1):
        temp = num
        total = 0
        while temp > 0:
            total += temp % 10
            temp //= 10
        if num - total >= s:
            count += 1
    print(count)

solve()","
def solve():
    n, s = map(int, input().split())
    
    def digit_sum(num):
        return sum(map(int, str(num)))
    
    count = 0
    for i in range(1, n+1):
        if i - digit_sum(i) >= s:
            count += 1
    
    print(count)

solve()
","
def solve():
    n, s = map(int, input().split())
    
    def sum_of_digits(number):
        return sum(int(digit) for digit in str(number))
    
    count = 0
    for x in range(1, n + 1):
        if x - sum_of_digits(x) >= s:
            count += 1
    
    print(count)

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","60.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/247","
QUESTION:
You are given n points on Cartesian plane. Every point is a lattice point (i. e. both of its coordinates are integers), and all points are distinct.

You may draw two straight lines (not necessarily distinct). Is it possible to do this in such a way that every point lies on at least one of these lines?


-----Input-----

The first line contains one integer n (1 ≤ n ≤ 10^5) — the number of points you are given.

Then n lines follow, each line containing two integers x_{i} and y_{i} (|x_{i}|, |y_{i}| ≤ 10^9)— coordinates of i-th point. All n points are distinct.


-----Output-----

If it is possible to draw two straight lines in such a way that each of given points belongs to at least one of these lines, print YES. Otherwise, print NO.


-----Examples-----
Input
5
0 0
0 1
1 1
1 -1
2 2

Output
YES

Input
5
0 0
1 0
2 1
1 1
2 3

Output
NO



-----Note-----

In the first example it is possible to draw two lines, the one containing the points 1, 3 and 5, and another one containing two remaining points. [Image]
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    
    if n <= 4:
        print(""YES"")
    else:
        x_values = set()
        y_values = set()
        for x, y in points:
            x_values.add(x)
            y_values.add(y)
        
        if len(x_values) <= 2 or len(y_values) <= 2:
            print(""YES"")
        else:
            print(""NO"")

solve()
","
from collections import defaultdict

def solve():
    n = int(input())
    points = []
    for _ in range(n):
        x, y = map(int, input().split())
        points.append((x, y))
    
    lines = defaultdict(set)
    
    for i in range(n):
        for j in range(i+1, n):
            x1, y1 = points[i]
            x2, y2 = points[j]
            a = y2 - y1
            b = x1 - x2
            c = x1*y2 - x2*y1
            count = 0
            for point in points:
                x, y = point
                if a*x + b*y == c:
                    count += 1
            if count == n:
                return ""YES""
    
    return ""NO""
  
solve()","
from collections import defaultdict

def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]

    slopes = defaultdict(set)
    for i in range(n):
        x1, y1 = points[i]
        for j in range(i+1, n):
            x2, y2 = points[j]
            if x1 == x2:
                slope = 'inf'
            else:
                slope = (y2 - y1) / (x2 - x1)
            slopes[slope].add(i)
            slopes[slope].add(j)

    for k in slopes:
        if len(slopes[k]) == n:
            return ""YES""
    return ""NO""


solve()","
from collections import defaultdict

def solve():
    n = int(input())
    points = []
    for _ in range(n):
        x, y = map(int, input().split())
        points.append((x, y))

    lines = defaultdict(int)
    for i in range(n):
        for j in range(i+1, n):
            line = (points[i][0] - points[j][0], points[i][1] - points[j][1])
            lines[line] += 1

    for count in lines.values():
        if count >= n-1:
            print(""YES"")
            return

    print(""NO"")

solve()","
from collections import defaultdict

def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]

    count = defaultdict(int)
    for x, y in points:
        count[x] += 1
        count[y] += 1

    max_count = max(count.values())
    if max_count >= 3 or (max_count == 2 and sum(val == 2 for val in count.values()) >= 3):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]

    unique_xs = set()
    unique_ys = set()
    for x, y in points:
        unique_xs.add(x)
        unique_ys.add(y)

    if len(unique_xs) < 3 or len(unique_ys) < 3:
        print(""YES"")
    else:
        print(""NO"")

solve()","
from collections import defaultdict

def solve():
    n = int(input())
    points = []
    for _ in range(n):
        x, y = map(int, input().split())
        points.append((x, y))
    
    lines = defaultdict(int)
    for i in range(n):
        for j in range(i + 1, n):
            a = points[i][1] - points[j][1]
            b = points[j][0] - points[i][0]
            c = points[i][0]*points[j][1] - points[j][0]*points[i][1]
            count1, count2 = 0, 0
            for k in range(n):
                if a*points[k][0] + b*points[k][1] + c == 0:
                    count1 += 1
                else:
                    count2 += 1
            lines[(a, b, c)] = max(lines[(a, b, c)], count1, count2)
    
    for count in lines.values():
        if count == n:
            print(""YES"")
            return
    print(""NO"")

solve()","
def solve():
    from collections import defaultdict

    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]

    x_counts = defaultdict(int)
    y_counts = defaultdict(int)

    for point in points:
        x, y = point
        x_counts[x] += 1
        y_counts[y] += 1

    x_max_count = max(x_counts.values())
    y_max_count = max(y_counts.values())

    if x_max_count >= 3 or y_max_count >= 3 or (x_max_count == 2 and y_max_count == 2):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
from collections import defaultdict

def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    
    slopes = defaultdict(set)
    
    for i in range(n):
        x1, y1 = points[i]
        for j in range(i+1, n):
            x2, y2 = points[j]
            if x2 - x1 == 0:
                slope = 'Inf'
            else:
                slope = (y2 - y1) / (x2 - x1)
            slopes[slope].add(i)
            slopes[slope].add(j)
    
    for key in slopes:
        if len(slopes[key]) == n:
            print(""YES"")
            return
    
    print(""NO"")

solve()
","
from collections import defaultdict

def solve():
    n = int(input())
    points = [list(map(int, input().split())) for _ in range(n)]

    x_counter = defaultdict(int)
    y_counter = defaultdict(int)

    for x, y in points:
        x_counter[x] += 1
        y_counter[y] += 1

    for x, y in points:
        if x_counter[x] > 1 or y_counter[y] > 1:
            print(""YES"")
            return

    print(""NO"")

solve()","
from collections import defaultdict

def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    
    x_count = defaultdict(int)
    y_count = defaultdict(int)
    
    for point in points:
        x, y = point
        x_count[x] += 1
        y_count[y] += 1
    
    for x in x_count.values():
        if x == n or x == n-1:
            print(""YES"")
            return
    
    for y in y_count.values():
        if y == n or y == n-1:
            print(""YES"")
            return
    
    print(""NO"")

solve()","
from typing import List, Tuple

def solve(n: int, points: List[Tuple[int, int]]) -> str:
    counts = {}
    for x, y in points:
        slope = (1, 0) if x == 0 else (y, x)
        counts[slope] = counts.get(slope, 0) + 1
    
    return ""YES"" if len(counts) <= 2 else ""NO""

solve()","
from collections import defaultdict

def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    
    slopes = defaultdict(set)
    
    for i in range(n):
        for j in range(i + 1, n):
            x1, y1 = points[i]
            x2, y2 = points[j]
            if x1 == x2:
                slope = float('inf')
            else:
                slope = (y2 - y1) / (x2 - x1)
            slopes[slope].add(i)
            slopes[slope].add(j)
    
    for slope_group in slopes.values():
        if len(slope_group) == n:
            print(""YES"")
            return
    
    print(""NO"")


solve()","
def solve():
    from collections import defaultdict
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    
    lines = defaultdict(set)
    for i in range(n):
        for j in range(i + 1, n):
            if points[i][0] == points[j][0] or points[i][1] == points[j][1]:
                lines[(points[i][0], points[i][1])].add((points[j][0], points[j][1]))
    
    for start_point in points:
        for end_point in points:
            if end_point == start_point:
                continue
            if (start_point[0], start_point[1]) in lines and (end_point[0], end_point[1]) in lines[(start_point[0], start_point[1])]:
                continue
            valid = True
            for other_point in points:
                if other_point == start_point or other_point == end_point:
                    continue
                if not (start_point[0] == other_point[0] or start_point[1] == other_point[1] or end_point[0] == other_point[0] or end_point[1] == other_point[1]):
                    valid = False
                    break
            if valid:
                return ""YES""
    return ""NO""

solve()","
from collections import defaultdict

def solve():
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    
    line_counts = defaultdict(int)
    for i in range(n):
        for j in range(i+1, n):
            x1, y1 = points[i]
            x2, y2 = points[j]
            line_counts[(y2-y1, x1-x2, x2*y1-x1*y2)] += 1

    for count in line_counts.values():
        if count >= n-1 or count == 2:
            print(""YES"")
            return

    print(""NO"")

solve()","
def solve():
    from collections import defaultdict

    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]

    if n <= 4:
        print(""YES"")
        return

    count = defaultdict(int)

    for i in range(n):
        for j in range(i + 1, n):
            a, b = points[i]
            c, d = points[j]
            A = c - a
            B = d - b
            count[A, B] += 1

    for val in count.values():
        if val >= n // 2:
            print(""YES"")
            return

    print(""NO"")

solve()","66.66666666666666","0.0","0.0","46.666666666666664","53.333333333333336","66.66666666666666","46.666666666666664","53.333333333333336","53.333333333333336","53.333333333333336","60.0","0.0","53.333333333333336","0.0","60.0","60.0","","","","","","","","","","","","","","","",""
"APPS/248","
QUESTION:
Memory and his friend Lexa are competing to get higher score in one popular computer game. Memory starts with score a and Lexa starts with score b. In a single turn, both Memory and Lexa get some integer in the range [ - k;k] (i.e. one integer among  - k,  - k + 1,  - k + 2, ...,  - 2,  - 1, 0, 1, 2, ..., k - 1, k) and add them to their current scores. The game has exactly t turns. Memory and Lexa, however, are not good at this game, so they both always get a random integer at their turn.

Memory wonders how many possible games exist such that he ends with a strictly higher score than Lexa. Two games are considered to be different if in at least one turn at least one player gets different score. There are (2k + 1)^2t games in total. Since the answer can be very large, you should print it modulo 10^9 + 7. Please solve this problem for Memory.


-----Input-----

The first and only line of input contains the four integers a, b, k, and t (1 ≤ a, b ≤ 100, 1 ≤ k ≤ 1000, 1 ≤ t ≤ 100) — the amount Memory and Lexa start with, the number k, and the number of turns respectively.


-----Output-----

Print the number of possible games satisfying the conditions modulo 1 000 000 007 (10^9 + 7) in one line.


-----Examples-----
Input
1 2 2 1

Output
6

Input
1 1 1 2

Output
31

Input
2 12 3 1

Output
0



-----Note-----

In the first sample test, Memory starts with 1 and Lexa starts with 2. If Lexa picks  - 2, Memory can pick 0, 1, or 2 to win. If Lexa picks  - 1, Memory can pick 1 or 2 to win. If Lexa picks 0, Memory can pick 2 to win. If Lexa picks 1 or 2, Memory cannot win. Thus, there are 3 + 2 + 1 = 6 possible games in which Memory wins.
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 10**9 + 7
    a, b, k, t = map(int, input().split())
    
    dp = [[0] * (2*k*t + 1) for _ in range(t + 1)]
    dp[0][k*t] = 1
    
    for i in range(1, t + 1):
        for j in range(2*k*t + 1):
            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]) % MOD
    
    ans = 0
    for i in range(2*k*t + 1):
        for j in range(i + 1, 2*k*t + 1):
            if abs(i - k*t) + abs(j - k*t) <= t * k:
                ans = (ans + dp[t][i] * dp[t][j]) % MOD
    
    print(ans)

solve()
","
def solve():
  MOD = 10**9 + 7
  a, b, k, t = map(int, input().split())
  
  dp = [[0] * ((2*k+1)*t+1) for _ in range(t+1)]
  dp[0][0] = 1

  for i in range(1, t+1):
      for j in range(1, (2*k+1)*t+1):
          dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] - (dp[i-1][j-(2*k+1)] if j-(2*k+1)>=0 else 0) - (dp[i-1][j+(2*k+1)] if j+(2*k+1)<=(2*k+1)*t else 0)
          dp[i][j] %= MOD

  ans = 0
  for j in range((2*k+1)*t):
      ans += dp[t][j] * max(0, min(a+t*k, j) - max(0, j-b+1))
      ans %= MOD

  print(ans)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    a, b, k, t = map(int, input().split())
    dp = [[0] * (2*k*t+1) for _ in range(t+1)]
    dp[0][k*t+a-b] = 1
    for i in range(1, t+1):
        for j in range(2*k*t+1):
            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % MOD if 0 < j < 2*k*t else dp[i-1][j-1] if j == 0 else dp[i-1][j+1]
    print(sum(dp[t][k*t+1:]) % MOD)

solve()
","
def solve():
    MOD = 1000000007
    a, b, k, t = map(int, input().split())
    dp = [[0] * (2 * t * k + 1) for _ in range(t + 1)]
    dp[0][t * k] = 1

    for i in range(1, t + 1):
        prefix_sum = [0] * (2 * t * k + 2)
        for j in range(1, 2 * t * k + 1):
            prefix_sum[j] = prefix_sum[j - 1] + dp[i - 1][j - 1]
            if j > 2 * k:
                prefix_sum[j] -= dp[i - 1][j - 2 * k - 1]
            prefix_sum[j] %= MOD

        for j in range(2 * t * k + 1):
            dp[i][j] = (prefix_sum[j + k] - prefix_sum[j - k]) % MOD

    result = 0
    for j in range(t * k + 1 - b, t * k + 1 + k - a):
        result = (result + dp[t][j]) % MOD
    
    print(result)
  
solve()","
def solve():
    a, b, k, t = map(int, input().split())
    
    MOD = 10**9 + 7
    dp = [[0] * (2 * t * k + 1) for _ in range(t + 1)]
    dp[0][t * k + a - b] = 1

    for i in range(1, t + 1):
        for j in range(2 * t * k + 1):
            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD
            if j - 1 >= 0:
                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD
            if j + 1 <= 2 * t * k:
                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD

    result = sum(dp[-1][t * k + 1:]) % MOD
    print(result)

solve()
  ","
def solve():
    mod = 10**9 + 7
    a, b, k, t = map(int, input().split())

    dp = [[0] * (k * 2 + 2) for _ in range(t + 1)]
    dp[0][k] = 1

    for i in range(1, t + 1):
        for j in range(1, k * 2 + 1):
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]
    
    prefix = [0] * (k * t + 2)
    for i in range(1, k * t + 2):
        prefix[i] = prefix[i-1] + dp[t][i]

    ans = 0
    for i in range(k + 1):
        turn_a = min(i + t * k, a + t * k)
        turn_b = b - 1 + t * k
        if turn_a <= turn_b:
            continue
        ans += prefix[turn_a - turn_b]
    
    return ans % mod

solve()
","
def solve():
    a, b, k, t = map(int, input().split())

    mod = 10**9 + 7
    dp = [[0] * (2*k*t + 1) for _ in range(t + 1)]
    dp[0][k*t + a - b] = 1

    for i in range(1, t+1):
        for j in range(2*k*t + 1):
            if j - k <= 0:
                dp[i][j] = dp[i-1][j+k]
            elif j + k >= 2*k*t:
                dp[i][j] = dp[i-1][j-k]
            else:
                dp[i][j] = (dp[i-1][j-k] + dp[i-1][j+k]) % mod

    result = sum(dp[t][(k*t) + k:(k*t) + (2*k*t) + 1]) % mod
    print(result)

solve()
","
def solve():
    mod = 10**9 + 7
    a, b, k, t = map(int, input().split())
    dp = [[0] * ((2*k + 1) * t) for _ in range(t + 1)]
    dp[0][k * t] = 1

    for i in range(1, t + 1):
        for j in range(2*k + 1, len(dp[i]) - (2*k + 1)):
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

    prefix_sum = [0] * len(dp[t])
    prefix_sum[k * t] = dp[t][k * t]
    for i in range(k * t + 1, len(dp[t])):
        prefix_sum[i] = (prefix_sum[i-1] + dp[t][i]) % mod

    res = 0
    for i in range(-k * t, b - a + 1):
        res = (res + dp[t][k * t + i] * prefix_sum[k * t + b - a - i]) % mod

    print(res)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    a, b, k, t = map(int, input().split())
    
    dp = [[0] * ((2*k + 1)*t + 1) for _ in range(t + 1)]
    dp[0][k*t + a - b] = 1
    
    for i in range(1, t + 1):
        for j in range(2*i*k + 1):
            dp[i][j] += dp[i-1][j]
            dp[i][j] %= MOD
            if j + 1 < 2*i*k + 1:
                dp[i][j] += dp[i-1][j+1]
                dp[i][j] %= MOD
            if j - 1 >= 0:
                dp[i][j] += dp[i-1][j-1]
                dp[i][j] %= MOD
    
    result = sum(dp[t][(2*i + a - b)*k] % MOD for i in range(t))
    print(result % MOD)

solve()
","
def solve():
    mod = 10**9 + 7
    
    a, b, k, t = map(int, input().split())
    
    dp = [[0] * (2*t*k + 2) for _ in range(t+1)]
    dp[0][t*k] = 1
    
    for i in range(1, t+1):
        for j in range(2*k*i + 1):
            dp[i][j] = dp[i-1][j]
            if j-1 >= 0:
                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % mod
            if j+1 < 2*k*i + 1:
                dp[i][j] = (dp[i][j] + dp[i-1][j+1]) % mod
    
    ans = 0
    for i in range(2*t*k + 1):
        diff = abs(i - t*k)
        profit = min(diff, a + t*k - b)
        profit %= mod
        ans = (ans + dp[t][i] * profit) % mod
    
    print(ans)

solve()
","
def solve():
    a, b, k, t = map(int, input().split())
    MOD = 10**9 + 7
    dp = [[0] * ((2*k+1)*t + 1) for _ in range(t + 1)]
    dp[0][t*k + a - b] = 1

    for i in range(1, t + 1):
        s = sum(dp[i-1][:])
        for j in range((2*k + 1)*t):
            dp[i][j + 1] = s - dp[i-1][j] if j - k >= 0 else s - dp[i-1][0]
        for j in range(1, (2*k + 1)*t + 1):
            dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD

    total = dp[t][t*k + 1:]
    ans = sum(total) % MOD
    print(ans)

solve()
","
def solve():
    a, b, k, t = map(int, input().split())
    MOD = 10**9 + 7

    # Initialize the dp array with zeros
    dp = [[0] * (2*k*t+1) for _ in range(t+1)]
    dp[0][k*t+a-b] = 1

    for i in range(1, t+1):
        for j in range(2*k*t+1):
            dp[i][j] = (dp[i-1][j] + dp[i-1][(j-1)%len(dp[0])] + dp[i-1][(j+1)%len(dp[0])]) % MOD

    result = sum(dp[t][k*t:])

    print(result % MOD)

solve()
","
def solve():
    MOD = 10**9 + 7
    a, b, k, t = map(int, input().split())

    dp = [[0] * (2*k*t+2) for _ in range(t+1)]
    dp[0][k*t+a-b] = 1

    for i in range(1, t+1):
        for j in range(2*k*t+1):
            for d in range(-k, k+1):
                if 0 <= j+d <= 2*k*t:
                    dp[i][j+d] = (dp[i][j+d] + dp[i-1][j]) % MOD

    ans = sum(dp[-1][k*t+1:]) % MOD
    print(ans)

solve()
  ","
def solve():
    MOD = 10**9 + 7

    a, b, k, t = map(int, input().split())

    dp = [[0] * (2*k*t+1) for _ in range(t+1)]
    dp[0][k*t] = 1

    for i in range(1, t+1):
        for j in range(2*k*t+1):
            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % MOD

    prefix_sum = [0] * (2*k*t+2)
    for i in range(2*k*t+1):
        prefix_sum[i+1] = prefix_sum[i] + dp[t][i]
    
    ans = 0
    for i in range(max(0, a-b+k*t), min(2*k*t+1, a-b+(k*t)*2+1)):
        ans = (ans + dp[t][i] * prefix_sum[i+1-a+b]) % MOD

    print(ans)

solve()
  ","
def solve():
    a, b, k, t = map(int, input().split())
    MOD = 10**9 + 7
    dp = [[0] * (2*k*t + 1) for _ in range(t + 1)]
    dp[0][k*t] = 1

    for i in range(1, t + 1):
        for j in range(2*k*t + 1):
            dp[i][j] = (dp[i-1][j-1] if j > 0 else 0) + (dp[i-1][j+1] if j < 2*k*t else 0)

    prefix_sum = [0] * (2*k*t + 2)
    for i in range(1, 2*k*t + 2):
        prefix_sum[i] = (prefix_sum[i-1] + dp[t][i-1]) % MOD

    ans = 0
    for i in range(2*k*t + 1):
        if i + b - a - 1 >= 0:
            ans = (ans + dp[t][i] * prefix_sum[i + b - a]) % MOD

    print(ans)

solve()
","
def solve():
    a, b, k, t = map(int, input().split())

    mod = 10**9 + 7
    dp = [[0] * (2*k*t+1) for _ in range(t+1)]
    dp[0][k*t] = 1

    for i in range(1, t+1):
        for j in range(2*k*t+1):
            dp[i][j] = dp[i-1][j]
            if j - 1 >= 0:
                dp[i][j] += dp[i-1][j-1]
            if j + 1 < 2*k*t+1:
                dp[i][j] += dp[i-1][j+1]

    prefix_sum = [0] * (2*k*t+2)
    for i in range(1, 2*k*t+2):
        prefix_sum[i] = (prefix_sum[i-1] + dp[t][i-1]) % mod

    ans = (prefix_sum[min(2*k*t+1, a+b+k*t+1)] - prefix_sum[max(0, a+b-k*t)]) % mod
    print(ans)


solve()
","0.0","0.0","0.0","0.0","6.666666666666667","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/249","
QUESTION:
Valery is a PE teacher at a school in Berland. Soon the students are going to take a test in long jumps, and Valery has lost his favorite ruler! 

However, there is no reason for disappointment, as Valery has found another ruler, its length is l centimeters. The ruler already has n marks, with which he can make measurements. We assume that the marks are numbered from 1 to n in the order they appear from the beginning of the ruler to its end. The first point coincides with the beginning of the ruler and represents the origin. The last mark coincides with the end of the ruler, at distance l from the origin. This ruler can be repesented by an increasing sequence a_1, a_2, ..., a_{n}, where a_{i} denotes the distance of the i-th mark from the origin (a_1 = 0, a_{n} = l).

Valery believes that with a ruler he can measure the distance of d centimeters, if there is a pair of integers i and j (1 ≤ i ≤ j ≤ n), such that the distance between the i-th and the j-th mark is exactly equal to d (in other words, a_{j} - a_{i} = d). 

Under the rules, the girls should be able to jump at least x centimeters, and the boys should be able to jump at least y (x < y) centimeters. To test the children's abilities, Valery needs a ruler to measure each of the distances x and y. 

Your task is to determine what is the minimum number of additional marks you need to add on the ruler so that they can be used to measure the distances x and y. Valery can add the marks at any integer non-negative distance from the origin not exceeding the length of the ruler.


-----Input-----

The first line contains four positive space-separated integers n, l, x, y (2 ≤ n ≤ 10^5, 2 ≤ l ≤ 10^9, 1 ≤ x < y ≤ l) — the number of marks, the length of the ruler and the jump norms for girls and boys, correspondingly.

The second line contains a sequence of n integers a_1, a_2, ..., a_{n} (0 = a_1 < a_2 < ... < a_{n} = l), where a_{i} shows the distance from the i-th mark to the origin.


-----Output-----

In the first line print a single non-negative integer v — the minimum number of marks that you need to add on the ruler.

In the second line print v space-separated integers p_1, p_2, ..., p_{v} (0 ≤ p_{i} ≤ l). Number p_{i} means that the i-th mark should be at the distance of p_{i} centimeters from the origin. Print the marks in any order. If there are multiple solutions, print any of them.


-----Examples-----
Input
3 250 185 230
0 185 250

Output
1
230

Input
4 250 185 230
0 20 185 250

Output
0

Input
2 300 185 230
0 300

Output
2
185 230



-----Note-----

In the first sample it is impossible to initially measure the distance of 230 centimeters. For that it is enough to add a 20 centimeter mark or a 230 centimeter mark.

In the second sample you already can use the ruler to measure the distances of 185 and 230 centimeters, so you don't have to add new marks.

In the third sample the ruler only contains the initial and the final marks. We will need to add two marks to be able to test the children's skills.
Use user-input-Based format and function signature solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    has_x = False
    has_y = False
    has_x_y = False
    for i in range(n):
        if marks[i] + x in marks:
            has_x = True
        if marks[i] + y in marks:
            has_y = True
        if marks[i] + x + y in marks:
            has_x_y = True
    
    if has_x and has_y:
        print(0)
    elif has_x or has_y:
        print(1)
        if has_x:
            print(y)
        else:
            print(x)
    elif has_x_y:
        print(1)
        print(min(x, y))
    else:
        print(2)
        print(x, y)

solve()
","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))

    possible_sums = [x, y, y-x]
    additional_marks = set()

    for mark in marks:
        for possible_sum in possible_sums:
            if mark + possible_sum in marks:
                return print(0)

            if mark + possible_sum <= l:
                additional_marks.add(mark + possible_sum)

    for i in range(n):
        for j in range(i + 1, n):
            diff = marks[j] - marks[i]

            if diff in possible_sums:
                return print(0)

            for possible_sum in possible_sums:
                if marks[i] + possible_sum < l and marks[i] + possible_sum + diff in marks:
                    return print(1, marks[i] + possible_sum)

    return print(2, possible_sums[0], possible_sums[1])


solve()
","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    distances = set()
    for i in range(n):
        distances.add(marks[i])
        if marks[i] + x <= l:
            distances.add(marks[i] + x)
        if marks[i] - x >= 0:
            distances.add(marks[i] - x)
        if marks[i] + y <= l:
            distances.add(marks[i] + y)
        if marks[i] - y >= 0:
            distances.add(marks[i] - y)
    
    for i in range(n):
        for j in range(i + 1, n):
            d1 = abs(marks[i] - marks[j])
            d2 = abs(x - y)
            if d1 == d2:
                print(0)
                return
    
    for i in range(n):
        for j in range(i + 1, n):
            d1 = abs(marks[i] - marks[j])
            if marks[i] + x in distances and marks[j] + x in distances:
                print(1)
                print(marks[i] + x)
                return
            if marks[i] + y in distances and marks[j] + y in distances:
                print(1)
                print(marks[i] + y)
                return
            if marks[i] + x in distances and marks[j] - x in distances:
                print(1)
                print(marks[j] - x)
                return
            if marks[i] - x in distances and marks[j] + x in distances:
                print(1)
                print(marks[i] - x)
                return
            if marks[i] + y in distances and marks[j] - y in distances:
                print(1)
                print(marks[j] - y)
                return
            if marks[i] - y in distances and marks[j] + y in distances:
                print(1)
                print(marks[i] - y)
                return
    
    print(2)
    print(x, y)

solve()
","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    diffs = set()
    for i in range(n):
        for j in range(i+1, n):
            diffs.add(marks[j] - marks[i])
    
    if x in diffs and y in diffs:
        print(0)
    elif x in diffs or y in diffs:
        print(1)
        missing_mark = x if y in diffs else y
        print(missing_mark)
    else:
        for i in range(n):
            if marks[i]+x in diffs:
                print(1)
                print(marks[i]+y)
                return
            if marks[i]-x in diffs:
                print(1)
                print(marks[i]+y)
                return
            if marks[i]+y in diffs:
                print(1)
                print(marks[i]+x)
                return
            if marks[i]-y in diffs:
                print(1)
                print(marks[i]+x)
                return
        
        print(2)
        print(x, y)

solve()
","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))

    def check(a, b):
        return any((x + a in marks and y + b in marks) or (x - a in marks and y - b in marks)
                   for a in [0, a] for b in [0, b])

    def add_mark(m):
        print(1)
        print(m)

    if check(x, y):
        print(0)
    elif check(x, 0):
        add_mark(y)
    elif check(y, 0):
        add_mark(x)
    else:
        for i in range(n - 1):
            if marks[i] + x in marks:
                add_mark(marks[i] + y)
                break
            if marks[i] - x > 0 and marks[i] - x < l and marks[i] + y < l:
                add_mark(marks[i] - x)
                break
            if marks[i] + x < l and marks[i] + y < l:
                add_mark(marks[i] + x)
                break


solve()","
def solve():
    n, l, x, y = map(int, input().split())
    a = list(map(int, input().split()))
    
    diffs = set()
    for i in range(n):
        for j in range(i + 1, n):
            diffs.add(a[j] - a[i])
            
    if x in diffs and y in diffs:
        print(0)
    elif x in diffs or y in diffs:
        print(1)
        if x in diffs:
            print(y)
        else:
            print(x)
    else:
        for i in range(n):
            if a[i] + x in diffs:
                print(1)
                print(a[i] + y)
                break
            if a[i] - x in diffs:
                print(1)
                print(a[i] - y)
                break
        else:
            print(2)
            print(x, y)

solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    diffs = set()
    has_x = False
    has_y = False
    for i in range(n):
        for j in range(i+1, n):
            diff = marks[j] - marks[i]
            if diff == x:
                has_x = True
            if diff == y:
                has_y = True
            diffs.add(diff)
    
    if has_x and has_y:
        print(0)
    elif has_x or has_y:
        print(1)
        if has_x:
            print(y)
        else:
            print(x)
    else:
        for diff in diffs:
            if diff + x in diffs:
                print(1)
                print(diff + x)
                return
            if diff - x > 0 and diff - x + y in diffs:
                print(1)
                print(diff - x)
                return
        print(2)
        print(x, y)

solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    def check_distances(d):
        for i in range(n):
            for j in range(i+1, n):
                if marks[j] - marks[i] == d:
                    return True
        return False
    
    def check_jump_norms():
        for i in range(n):
            if marks[i] + x in marks or marks[i] - x in marks:
                return 0, []
            if marks[i] + y in marks or marks[i] - y in marks:
                return 0, []
            if marks[i] + x + y in marks or marks[i] - x - y in marks:
                return 0, []
            if marks[i] + y - x in marks or marks[i] - y + x in marks:
                return 0, []
        
        for i in range(n):
            d1 = marks[i] + x
            d2 = marks[i] - x
            if check_distances(d1) or check_distances(d2):
                return 0, []
        
        return 1, [marks[0] + x]
    
    res, marks_to_add = check_jump_norms()
    
    if res == 0:
        print(0)
    else:
        print(res)
        print(*marks_to_add)

solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    res = set()
    need_x = False
    need_y = False
    
    for i in range(n):
        for j in range(i+1, n):
            if marks[j] - marks[i] == x:
                need_y = True
            if marks[j] - marks[i] == y:
                need_x = True
            res.add(marks[j] - marks[i])
    
    if x in res and y in res:
        print(0)
    elif x in res or y in res:
        if x in res:
            print(1)
            print(y)
        else:
            print(1)
            print(x)
    elif abs(y - x) in res:
        print(1)
        if y - x + marks[0] <= l:
            print(y)
        else:
            print(x)
    else:
        print(2)
        print(x, y)

solve()
","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    found_x = False
    found_y = False
    
    for i in range(n):
        if marks[i] + x in marks:
            found_x = True
        if marks[i] + y in marks:
            found_y = True
        if marks[i] - x > 0 and marks[i] - x in marks:
            found_x = True
        if marks[i] - y > 0 and marks[i] - y in marks:
            found_y = True
        if marks[i] + x < l and marks[i] + x + y in marks:
            found_y = True
        if marks[i] + y < l and marks[i] + y - x in marks:
            found_x = True

    if found_x and found_y:
        print(0)
    elif found_x:
        print(1)
        print(y)
    elif found_y:
        print(1)
        print(x)
    else:
        sum_xy = x + y
        found_sum_xy = False
        for i in range(n):
            if marks[i] + sum_xy in marks or marks[i] - sum_xy > 0 and marks[i] - sum_xy in marks:
                found_sum_xy = True
                print(1)
                print(marks[i] if marks[i] + sum_xy in marks else marks[i] - x)
                break

        if not found_sum_xy:
            print(2)
            print(f""{x} {y}"")

solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    diff1 = {y - x, y + x}
    diff2 = {y, x}
    
    for i in range(n):
        if marks[i] + x in marks or marks[i] + y in marks:
            print(0)
            return
        
        if marks[i] + x + y in marks:
            print(1)
            print(marks[i] + x)
            return
        
    for i in range(n):
        for j in range(i + 1, n):
            if marks[j] - marks[i] in diff1:
                print(1)
                print(marks[i] + (marks[j] - marks[i]) - x)
                return
            if marks[j] - marks[i] in diff2:
                print(1)
                print(marks[i] + x)
                return
            
    for i in range(n):
        if marks[i] - x in marks and marks[i] + y in marks:
            print(1)
            print(marks[i])
            return
            
    print(2)
    print(x, y)

solve()
","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    diffs = {y - x, x + y, y - x + l, y + x}
    
    for i in range(n):
        for j in range(i+1, n):
            d = marks[j] - marks[i]
            if d in diffs:
                print(0)
                return

    for i in range(n):
        for j in range(i+1, n):
            d = marks[j] - marks[i]
            if marks[i] + x + d in marks or marks[j] - x - d in marks:
                print(1)
                print(marks[i] + x + d)
                return
                
            if marks[i] + y - d in marks or marks[j] - y + d in marks:
                print(1)
                print(marks[i] + y - d)
                return
                
    for i in range(n):
        if marks[i] + x in marks:
            print(1)
            print(marks[i])
            return
            
        if marks[i] + y in marks:
            print(1)
            print(marks[i])
            return
            
    print(2)
    print(x, y)

solve()
","### Python Function:
python
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))
    
    check_x = any(mark + x in marks or mark - x in marks for mark in marks)
    check_y = any(mark + y in marks or mark - y in marks for mark in marks)
    
    if check_x and check_y:
        print(0)
    elif check_x or check_y:
        print(1)
        if check_x:
            print(y)
        else:
            print(x)
    else:
        for i in range(n):
            if marks[i] + x in marks or marks[i] - x in marks:
                print(1)
                print(marks[i] + y)
                break
            if marks[i] + y in marks or marks[i] - y in marks:
                print(1)
                print(marks[i] + x)
                break
        else:
            for i in range(n):
                if marks[i] + x + y in marks or marks[i] - x - y in marks or (0 < marks[i] + x < l and marks[i] - y < 0) or (0 < marks[i] + y < l and marks[i] - x < 0):
                    print(1)
                    print(marks[i])
                    break
            else:
                print(2)
                print(x, y)

solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))

    diff1 = set(x + mark for mark in marks)
    diff2 = set(y + mark for mark in marks) - set(marks)
    
    for d in diff1:
        if d in diff2:
            print(0)
            return
        
    for d in diff1:
        if 0 < d < l and (d + x) in marks:
            print(1)
            print(d)
            return
        
    for d in diff2:
        if 0 < d < l and (d - x) in marks:
            print(1)
            print(d - x)
            return
        
    for i in range(n):
        if marks[i] + x in diff2:
            print(1)
            print(marks[i] + x)
            return
        
        if marks[i] - x in diff2:
            print(1)
            print(marks[i] - x)
            return
        
    print(2)
    print(x, y)

solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))

    possible_sums = set()
    for i in range(n):
        for j in range(i + 1, n):
            possible_sums.add(marks[j] - marks[i])

    if x in possible_sums and y in possible_sums:
        print(0)
    elif x in possible_sums or y in possible_sums:
        print(1)
        if x in possible_sums:
            print(y)
        else:
            print(x)
    else:
        for i in range(n):
            if marks[i] + x in possible_sums:
                print(1)
                print(marks[i] + y)
                return
            if marks[i] - x in possible_sums:
                print(1)
                print(marks[i] - y)
                return
            if 0 < marks[i] - y < l and marks[i] + y < l:
                print(2)
                print(marks[i] - x, marks[i] + x)
                return

solve()","
def solve():
    n, l, x, y = map(int, input().split())
    marks = list(map(int, input().split()))

    distances = set()
    for i in range(n):
        for j in range(i + 1, n):
            distances.add(marks[j] - marks[i])
    
    if x in distances and y in distances:
        print(0)
    elif x in distances or y in distances:
        print(1)
        if x in distances:
            print(y)
        else:
            print(x)
    else:
        for i in range(n):
            if marks[i] + x in distances:
                print(1)
                print(marks[i] + y)
                break
            if marks[i] - x in distances:
                print(1)
                print(marks[i] - y)
                break
        else:
            for i in range(n):
                for j in range(i + 1, n):
                    if marks[i] + x + y in distances or marks[i] + y - x in distances:
                        print(1)
                        print(marks[i] + x)
                        break
                    if marks[j] - x - y in distances or marks[j] - y + x in distances:
                        print(1)
                        print(marks[j] - x)
                        break
                else:
                    continue
                break
            else:
                print(2)
                print(x, y)

solve()
","73.33333333333333","13.333333333333334","6.666666666666667","40.0","0.0","40.0","46.666666666666664","13.333333333333334","40.0","73.33333333333333","46.666666666666664","13.333333333333334","0.0","13.333333333333334","33.33333333333333","60.0","","","","","","","","","","","","","","","",""
"APPS/250","
QUESTION:
As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party's cake.

Simple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.

However, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j < i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.

Babaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of simple cakes Babaei has.

Each of the following n lines contains two integers r_{i} and h_{i} (1 ≤ r_{i}, h_{i} ≤ 10 000), giving the radius and height of the i-th cake.


-----Output-----

Print the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.

Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\frac{|a - b|}{\operatorname{max}(1, b)} \leq 10^{-6}$.


-----Examples-----
Input
2
100 30
40 10

Output
942477.796077000

Input
4
1 1
9 7
1 4
10 7

Output
3983.539484752



-----Note-----

In first sample, the optimal way is to choose the cake number 1.

In second sample, the way to get the maximum volume is to use cakes with indices 1, 2 and 4.
Use user-input-Based format and function signature solve()","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))

    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = pi * r * r * h
        for j in range(i):
            r_j, h_j = cakes[j]
            if r_j < r:
                dp[i] = max(dp[i], dp[j] + pi * r * r * h)

    print(max(dp))

solve()
","
from math import pi

def solve():
    def dp(n,R,H):
        cake = sorted([(R[i]*R[i]*H[i],R[i]) for i in range(n)])
        dp = [0] * n
        for i in range(n):
            dp[i] = cake[i][0]
            for j in range(i):
                if cake[j][1] < cake[i][1]:
                    dp[i] = max(dp[i], dp[j] + cake[i][0])
        return max(dp)
        
    n = int(input())
    R = [0] * n
    H = [0] * n
    for i in range(n):
        R[i], H[i] = map(int, input().split())
        
    res = dp(n,R,H) * pi
    print('%.9f' % res)

solve()
","
import math

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))

    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = math.pi * r**2 * h

    for i in range(1, n):
        for j in range(i):
            r_i, h_i = cakes[i]
            r_j, h_j = cakes[j]
            if r_i > r_j and h_i > h_j:
                dp[i] = max(dp[i], dp[j] + (math.pi * r_i**2 * h_i))

    return '{:.9f}'.format(max(dp))


solve()","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))
    
    volumes = [pi * r**2 * h for r, h in cakes]
    dp = [0] * n
    for i in range(n):
        dp[i] = volumes[i]
        for j in range(i):
            if cakes[i][0] > cakes[j][0]:
                dp[i] = max(dp[i], dp[j] + volumes[i])
    
    print(max(dp))

solve()
","
import math

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))

    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = math.pi * r * r * h

    for i in range(1, n):
        for j in range(i):
            ri, hi = cakes[i]
            rj, hj = cakes[j]
            if ri > rj and dp[j] + math.pi * ri * ri * hi > dp[i]:
                dp[i] = dp[j] + math.pi * ri * ri * hi

    print(max(dp))

solve()
","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))

    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = pi * r * r * h

    for i in range(1, n):
        for j in range(i):
            r1, h1 = cakes[i]
            r2, h2 = cakes[j]
            if r1 > r2 and h1 > h2:
                dp[i] = max(dp[i], dp[j] + pi * r1 * r1 * h1)

    print(max(dp))

solve()
  ","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))
    
    dp = [(pi * r**2 * h, pi * r * h) for r, h in cakes]
    dp.sort(key=lambda x: x[1])
    
    ans = dp[0][0]
    for i in range(1, n):
        for j in range(i):
            if dp[i][1] > dp[j][1]:
                ans = max(ans, dp[i][0] + dp[j][0])
    
    print('{:.12f}'.format(ans))

solve()
","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))
    
    dp = [0] * n
    for i in range(n):
        r_i, h_i = cakes[i]
        dp[i] = pi * r_i**2 * h_i
        for j in range(i):
            r_j, h_j = cakes[j]
            if r_j < r_i and h_j < h_i:
                dp[i] = max(dp[i], dp[j] + pi * r_i**2 * h_i)
    
    result = max(dp)
    print(f""{result:.9f}"")


solve()","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))
    
    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = pi * (r ** 2) * h
        for j in range(i):
            r_prev, h_prev = cakes[j]
            if r_prev < r:
                dp[i] = max(dp[i], dp[j] + pi * (r ** 2) * h)
    
    print(f'{max(dp):.9f}')
  
solve()","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))

    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = pi * r**2 * h
        for j in range(i):
            if cakes[j][0] < r:
                dp[i] = max(dp[i], dp[j] + pi * r**2 * h)

    print(max(dp))

solve()
","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))

    dp = [0] * n
    for i in range(n):
        dp[i] = pi * (cakes[i][0] ** 2) * cakes[i][1]

    for i in range(1, n):
        for j in range(i):
            if cakes[i][0] > cakes[j][0]:
                dp[i] = max(dp[i], dp[j] + pi * (cakes[i][0] ** 2) * cakes[i][1])

    print(max(dp))

solve()
","
import math

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))
    
    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = math.pi * r**2 * h
        for j in range(i):
            if cakes[j][0] < r and cakes[j][1] < h:
                dp[i] = max(dp[i], dp[j] + math.pi * r**2 * h)
    
    volume = max(dp)
    print(f'{volume:.10f}')
    
solve()
","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))

    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = pi * r * r * h

    for i in range(1, n):
        r, h = cakes[i]
        for j in range(i):
            prev_r, prev_h = cakes[j]
            if r > prev_r and dp[i] < dp[j] + pi * r * r * h:
                dp[i] = dp[j] + pi * r * r * h

    print(max(dp))

solve()
","
import math

def solve():
    n = int(input())
    cakes = [list(map(int, input().split())) for _ in range(n)]
    
    dp = [0] * n
    for i in range(n):
        dp[i] = math.pi * cakes[i][0] ** 2 * cakes[i][1]
    
    for i in range(1, n):
        for j in range(i):
            if cakes[i][0] > cakes[j][0] and cakes[i][1] > cakes[j][1]:
                dp[i] = max(dp[i], dp[j] + math.pi * cakes[i][0] ** 2 * cakes[i][1])
    
    print(""{:.15f}"".format(max(dp)))

solve()
","
from math import pi

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))
    
    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = pi * (r ** 2) * h
        for j in range(i):
            r_prev, h_prev = cakes[j]
            if r_prev < r:
                dp[i] = max(dp[i], dp[j] + pi * (r ** 2) * h)
    
    print(max(dp))

solve()
","
import math

def solve():
    n = int(input())
    cakes = []
    for _ in range(n):
        r, h = map(int, input().split())
        cakes.append((r, h))
    
    dp = [0] * n
    for i in range(n):
        r, h = cakes[i]
        dp[i] = math.pi * r * r * h
        for j in range(i):
            r_j, h_j = cakes[j]
            if r_j < r:
                dp[i] = max(dp[i], dp[j] + math.pi * r * r * h)
    
    max_volume = max(dp)
    print(""{:.9f}"".format(max_volume))

solve()
","0.0","26.666666666666668","0.0","0.0","0.0","0.0","0.0","86.66666666666667","93.33333333333333","0.0","0.0","0.0","0.0","0.0","0.0","93.33333333333333","","","","","","","","","","","","","","","",""
"APPS/251","
QUESTION:
There is a toy building consisting of $n$ towers. Each tower consists of several cubes standing on each other. The $i$-th tower consists of $h_i$ cubes, so it has height $h_i$.

Let's define operation slice on some height $H$ as following: for each tower $i$, if its height is greater than $H$, then remove some top cubes to make tower's height equal to $H$. Cost of one ""slice"" equals to the total number of removed cubes from all towers.

Let's name slice as good one if its cost is lower or equal to $k$ ($k \ge n$).

 [Image] 

Calculate the minimum number of good slices you have to do to make all towers have the same height. Of course, it is always possible to make it so.


-----Input-----

The first line contains two integers $n$ and $k$ ($1 \le n \le 2 \cdot 10^5$, $n \le k \le 10^9$) — the number of towers and the restriction on slices, respectively.

The second line contains $n$ space separated integers $h_1, h_2, \dots, h_n$ ($1 \le h_i \le 2 \cdot 10^5$) — the initial heights of towers.


-----Output-----

Print one integer — the minimum number of good slices you have to do to make all towers have the same heigth.


-----Examples-----
Input
5 5
3 1 2 2 4

Output
2

Input
4 5
2 3 4 5

Output
2



-----Note-----

In the first example it's optimal to make $2$ slices. The first slice is on height $2$ (its cost is $3$), and the second one is on height $1$ (its cost is $4$).
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    min_height = min(heights)
    total_slices = 0
    
    for height in heights:
        diff = min_height - height
        total_slices += diff
    
    if total_slices > k:
        return (total_slices + k - 1) // k
    else:
        return 1

solve()","
def solve():
    from math import ceil
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    max_height = max(heights)
    total_slices = 0
    for height in heights:
        diff = max_height - height
        total_slices += ceil(diff / k)
    
    print(total_slices)

solve()
","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    max_height = max(heights)

    total_slices = 0
    for height in heights:
        total_slices += max_height - height
    
    if total_slices > k:
        remain_slices = total_slices - k
        result = 1 + remain_slices // (n - 1)
        if remain_slices % (n - 1) != 0:
            result += 1
        return result

    return 0


import sys
if __name__ == '__main__':
    sys.setrecursionlimit(10**6)
    solve()
","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    min_slices = 0
    heights.sort(reverse=True)
    
    diff_sum = 0
    for i in range(1, n):  # Calculate the total difference in heights
        diff_sum += (heights[i - 1] - heights[i]) * i
    
    while diff_sum > k:  # Find the optimal number of slices
        diff = min(diff_sum // n, k)
        diff_sum -= diff * n
        min_slices += diff
        k -= diff
    
    print(min_slices)

solve()
  ","
def solve():
    n, k = map(int, input().split())
    h = list(map(int, input().split()))
    
    total_slices = 0
    for height in range(1, max(h) + 1):
        slice_cost = sum(max(0, tower - height) for tower in h)
        if slice_cost <= k:
            total_slices = height

    return total_slices 

solve()
","
from math import ceil

def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    low = 1
    high = max(heights)
    
    while low < high:
        mid = (low + high) // 2
        
        slices = 0
        for height in heights:
            slices += max(0, ceil((height - mid) / mid))
        
        if slices <= k:
            high = mid
        else:
            low = mid + 1
    
    print(low)

solve()
","
from math import ceil

def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    max_height = max(heights)
    total_slices = 0
    
    for height in heights:
        total_slices += max(0, ceil((max_height - height) / (k - 1)))
    
    print(total_slices)

solve()
","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    low, high = 1, max(heights)
    while low < high:
        mid = (low + high) // 2
        total_slices = sum(max(0, tower - mid) for tower in heights)
        
        if total_slices <= k:
            high = mid
        else:
            low = mid + 1
    
    return low

solve()
","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))

    min_slices = 0
    heights.sort(reverse=True)
    for i in range(1, n):
        diff = heights[i-1] - heights[i]
        slices_needed = min(k, diff)
        min_slices += slices_needed
        heights[i] += slices_needed

    print(min_slices)

solve()
","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    max_height = max(heights)
    total_slices = 0
    
    for height in heights:
        if height < max_height:
            diff = max_height - height
            total_slices += diff
    
    if total_slices % k == 0:
        return total_slices // k
    else:
        return total_slices // k + 1

solve()","
def solve():
    import math
    
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))
    
    min_height = min(heights)
    total_slices = 0
    
    for height in heights:
        if height > min_height:
            total_slices += math.ceil((height - min_height) / (k - 1))
    
    print(total_slices)

solve()
","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))

    low = 1
    high = max(heights)
    
    while low < high:
        mid = (low + high) // 2
        slices = sum(max(0, tower - mid) for tower in heights)
        
        if slices <= k:
            high = mid
        else:
            low = mid + 1

    print(low)

solve()
","
def solve():
    from math import ceil
    n, k = map(int, input().split())
    h = list(map(int, input().split()))
    max_h = max(h)
    total_slices = 0
    for height in h:
        total_slices += ceil((max_h - height) / (max_h - 1))
    print(total_slices)

solve()
","
from math import ceil

def solve():
    n, k = map(int, input().split())
    towers = list(map(int, input().split()))
    
    max_height = max(towers)
    
    min_slices = 0
    for height in range(1, max_height+1):
        total_removed = sum(max(0, tower-height) for tower in towers)
        if total_removed <= k:
            min_slices = height
    
    print(min_slices)

solve()
","
def solve():
    import math

    n, k = map(int, input().split())
    towers = list(map(int, input().split()))

    total_slices = 0
    max_height = max(towers)

    for i in towers:
        if max_height - i > k:
            total_slices += i
        else:
            total_slices += max_height - i

    return math.ceil(total_slices / k)

solve()
","
def solve():
    n, k = map(int, input().split())
    heights = list(map(int, input().split()))

    min_slices = 0
    heights.sort()

    median = heights[len(heights) // 2]
    
    for height in heights:
        if height < median:
            min_slices += median - height
        elif height > median:
            min_slices += height - median

    if min_slices <= k:
        return 0
    else:
        return min_slices - k

solve()
","0.0","80.0","0.0","80.0","0.0","13.333333333333334","73.33333333333333","0.0","80.0","0.0","86.66666666666667","6.666666666666667","46.666666666666664","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/252","
QUESTION:
Alice and Bob are playing yet another card game. This time the rules are the following. There are $n$ cards lying in a row in front of them. The $i$-th card has value $a_i$. 

First, Alice chooses a non-empty consecutive segment of cards $[l; r]$ ($l \le r$). After that Bob removes a single card $j$ from that segment $(l \le j \le r)$. The score of the game is the total value of the remaining cards on the segment $(a_l + a_{l + 1} + \dots + a_{j - 1} + a_{j + 1} + \dots + a_{r - 1} + a_r)$. In particular, if Alice chooses a segment with just one element, then the score after Bob removes the only card is $0$.

Alice wants to make the score as big as possible. Bob takes such a card that the score is as small as possible.

What segment should Alice choose so that the score is maximum possible? Output the maximum score.


-----Input-----

The first line contains a single integer $n$ ($1 \le n \le 10^5$) — the number of cards.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($-30 \le a_i \le 30$) — the values on the cards.


-----Output-----

Print a single integer — the final score of the game.


-----Examples-----
Input
5
5 -2 10 -1 4

Output
6

Input
8
5 2 5 3 -30 -30 6 9

Output
10

Input
3
-10 6 -15

Output
0



-----Note-----

In the first example Alice chooses a segment $[1;5]$ — the entire row of cards. Bob removes card $3$ with the value $10$ from the segment. Thus, the final score is $5 + (-2) + (-1) + 4 = 6$.

In the second example Alice chooses a segment $[1;4]$, so that Bob removes either card $1$ or $3$ with the value $5$, making the answer $5 + 2 + 3 = 10$.

In the third example Alice can choose any of the segments of length $1$: $[1;1]$, $[2;2]$ or $[3;3]$. Bob removes the only card, so the score is $0$. If Alice chooses some other segment then the answer will be less than $0$.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    cards = list(map(int, input().split()))
    
    prefix_sum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + cards[i - 1]
    
    max_score = 0
    min_prefix_sum = 0
    for i in range(1, n + 1):
        max_score = max(max_score, prefix_sum[i] - min_prefix_sum)
        min_prefix_sum = min(min_prefix_sum, prefix_sum[i])
    
    print(max_score)

solve()","
def solve():
    n = int(input())
    cards = list(map(int, input().split()))
    
    prefix_sum = [0] * n
    prefix_sum[0] = cards[0]
    for i in range(1, n):
        prefix_sum[i] = prefix_sum[i-1] + cards[i]
    
    min_prefix_sum = [0] * n
    min_prefix_sum[-1] = prefix_sum[-1]
    for i in range(n-2, -1, -1):
        min_prefix_sum[i] = min(min_prefix_sum[i+1], prefix_sum[i])
    
    max_score = max(prefix_sum[i] - min_prefix_sum[i] for i in range(n))
    
    return max_score

solve()","
from typing import List

def solve(n: int, a: List[int]) -> int:
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + a[i]
    
    max_score = 0
    min_prefix_sum = 0
    prefix_max = 0
    for i in range(1, n + 1):
        max_score = max(max_score, prefix_sum[i] - min_prefix_sum)
        prefix_max = max(prefix_max, prefix_sum[i])
        min_prefix_sum = min(min_prefix_sum, prefix_max)
    
    return max_score

# Run the function with example input
print(solve(5, [5, -2, 10, -1, 4]))  # Output: 6

solve()","
from typing import List

def solve(n: int, a: List[int]) -> int:
    prefix_sum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]
        
    max_score = max_segment_sum = float('-inf')
    for i in range(1, n + 1):
        segment_sum = prefix_sum[i - 1] + (prefix_sum[n] - prefix_sum[i])
        max_segment_sum = max(max_segment_sum, segment_sum)
        
    max_score = max(max_score, max_segment_sum)
    
    return max_score

solve()","
def solve():
    n = int(input())
    cards = list(map(int, input().split()))
    
    max_score = 0
    temp_score = 0
    for c in cards:
        temp_score = max(0, temp_score + c)
        max_score = max(max_score, temp_score)
    
    print(max_score)

solve()
 ","
def solve():
    n = int(input())
    cards = list(map(int, input().split()))

    prefix_sum = [0] * (n+1)
    for i in range(n):
        prefix_sum[i+1] = prefix_sum[i] + cards[i]

    max_score = max(prefix_sum[r] - prefix_sum[l] + prefix_sum[n] + prefix_sum[0] - prefix_sum[r] for l in range(n) for r in range(l, n))
    
    return max_score

solve()","
def solve():
    n = int(input())
    cards = list(map(int, input().split()))
    
    max_score = max_segment_score = current_segment_score = 0
    for card in cards:
        current_segment_score = max(card, current_segment_score + card)
        max_segment_score = max(max_segment_score, current_segment_score)
        max_score = max(max_score, max_segment_score)
    
    print(max_score)

solve()
","
def solve():
    n = int(input())
    cards = list(map(int, input().split()))
    
    total_sum = sum(cards)
    
    prefix_sums = [0]
    curr_sum = 0
    min_prefix_sum = 0
    
    for card in cards:
        curr_sum += card
        min_prefix_sum = min(min_prefix_sum, curr_sum)
        prefix_sums.append(curr_sum)
    
    max_score = float('-inf')
    
    for i in range(1, n+1):
        score = total_sum - (prefix_sums[i] - min_prefix_sum)
        max_score = max(max_score, score)
    
    return max_score

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    prefix_sum = [0] + a.copy()
    for i in range(1, n + 1):
        prefix_sum[i] += prefix_sum[i - 1]

    max_score = -float('inf')
    current_sum = 0
    for i in range(1, n + 1):
        max_score = max(max_score, current_sum + prefix_sum[i - 1] + prefix_sum[n] - prefix_sum[i])
        current_sum = max(current_sum + a[i - 1], 0)

    print(max_score)
  
solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_sum = 0
    current_sum = 0
    for i in range(n):
        if current_sum + a[i] < 0:
            current_sum = 0
        else:
            current_sum += a[i]
            max_sum = max(max_sum, current_sum)
    
    print(max_sum)

solve()
","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    prefix_sum = [0] * (n+1)
    max_sum = prev_sum = 0

    for i in range(1, n+1):
        prefix_sum[i] = prefix_sum[i-1] + a[i-1]

    for i in range(1, n+1):
        max_sum = max(max_sum, prefix_sum[i] - prev_sum)
        prev_sum = min(prev_sum, prefix_sum[i])

    return max_sum

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    max_score = 0
    current_sum = 0
    min_sum = 0
    
    for i in range(n):
        current_sum += a[i]
        max_score = max(max_score, current_sum - min_sum)
        min_sum = min(min_sum, current_sum)
    
    print(max_score)

solve()
","
def solve():
    n = int(input())
    cards = list(map(int, input().split()))

    if n == 1:
        print(max(0, cards[0]))
        return

    prefix_sum = [0] * n
    prefix_sum[0] = cards[0]
    for i in range(1, n):
        prefix_sum[i] = prefix_sum[i - 1] + cards[i]

    max_score = max(0, prefix_sum[-1])
    min_prefix_sum = min(0, prefix_sum[0])
    for i in range(1, n):
        max_score = max(max_score, prefix_sum[i] - min_prefix_sum)
        min_prefix_sum = min(min_prefix_sum, prefix_sum[i])

    print(max_score)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))
    
    total = sum(a)
    max_score = total
    current_sum = 0

    for i in range(n):
        current_sum += a[i]
        max_score = max(max_score, current_sum)
        
        if current_sum < 0:
            current_sum = 0

    print(max_score)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    max_score = 0
    prefix_sums = [0]
    for i in range(n):
        prefix_sums.append(prefix_sums[-1] + a[i])

    min_prefix_sum = 0
    for i in range(1, n+1):
        max_score = max(max_score, prefix_sums[i] - min_prefix_sum)
        min_prefix_sum = min(min_prefix_sum, prefix_sums[i])

    print(max_score)

solve()","
def solve():
    n = int(input())
    a = list(map(int, input().split()))

    max_score = 0
    cur_score = 0

    for i in range(n):
        cur_score += a[i]
        max_score = max(max_score, cur_score)
        if cur_score < 0:
            cur_score = 0

    return max_score

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/253","
QUESTION:
Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.

When a garland is switched on, it periodically changes its state — sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x + k_{i}, x + 2k_{i}, x + 3k_{i} and so on.

Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x_1, x_2 and x_3 (not necessarily distinct) so that he will switch on the first garland during x_1-th second, the second one — during x_2-th second, and the third one — during x_3-th second, respectively, and during each second starting from max(x_1, x_2, x_3) at least one garland will be lit.

Help Mishka by telling him if it is possible to do this!


-----Input-----

The first line contains three integers k_1, k_2 and k_3 (1 ≤ k_{i} ≤ 1500) — time intervals of the garlands.


-----Output-----

If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES.

Otherwise, print NO.


-----Examples-----
Input
2 2 3

Output
YES

Input
4 2 3

Output
NO



-----Note-----

In the first example Mishka can choose x_1 = 1, x_2 = 2, x_3 = 1. The first garland will be lit during seconds 1, 3, 5, 7, ..., the second — 2, 4, 6, 8, ..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x_3 is chosen. Our choice will lead third to be lit during seconds 1, 4, 7, 10, ..., though.

In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.
Use user-input-Based format and function signature solve()","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if max(k1, k2, k3) * 2 <= k1 + k2 + k3:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    if (k1 + 1) * (k2 + 1) * (k3 + 1) % 2 == 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    if (k1 + 1) // 2 >= max(k2, k3) and (k2 + 1) // 2 >= k3:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    k1, k2, k3 = map(int, input().split())

    if max(k1, k2, k3) <= (k1 + k2 + k3 - max(k1, k2, k3) + 1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if k1 == 1 or k2 == 1 or k3 == 1 or (k1 % 2 == 0 and k2 % 2 == 0 and k3 % 2 == 0):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if (k1 + k2 - 1) // k1 == (k2 + k3 - 1) // k2 == (k1 + k3 - 1) // k3:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if (max(k1, k2, k3) * 2) <= (k1 + k2 + k3):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    if k1 == 1 or k2 == 1 or k3 == 1 or (k1 % 2 == 0 and k2 % 2 == 0 and k3 % 3 == 0):
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if max(k1, k2, k3) * 2 <= sum([k1, k2, k3]):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if max(k1, k2, k3) > (k1 + k2 + k3 - max(k1, k2, k3) + 1):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if max(k1, k2, k3) * 2 <= k1 + k2 + k3:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    if (k1 + 1) % k2 == 0 and (k1 + 1) // k2 == k3:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if k1 == 1 or k2 == 1 or k3 == 1:
        print(""YES"")
    elif (k1 % 2 == 0 and k2 % 2 == 0 and k3 % 2 == 0) or (k1 % 2 != 0 and k2 % 2 != 0 and k3 % 2 != 0):
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    k1, k2, k3 = map(int, input().split())
    if k1 == 1 or k2 == 1 or k3 == 1:
        print(""YES"")
    elif k1 == 2 and k2 == 2 and k3 == 2:
        print(""YES"")
    elif k1 == 3 and k2 == 3 and k3 == 3:
        print(""YES"")
    elif k1 == 1 and k2 == 2 and k3 == 3:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    
    if k1 % 2 == 0 and k2 % 2 == 0 and k3 % 2 == 0:
        print(""YES"")
    elif k1 % 2 != 0 and k2 % 2 != 0 and k3 % 2 != 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    k1, k2, k3 = map(int, input().split())
    if (k1 % 2 == 0 and k2 % 2 == 0 and k3 % 2 == 0) or (k1 % 2 == 1 and k2 % 2 == 1 and k3 % 2 == 1):
        print(""YES"")
    else:
        print(""NO"")

solve()","40.0","46.666666666666664","66.66666666666666","33.33333333333333","66.66666666666666","53.333333333333336","40.0","60.0","40.0","66.66666666666666","40.0","53.333333333333336","40.0","73.33333333333333","66.66666666666666","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/254","
QUESTION:
You are given a string $s$ of length $n$ consisting of lowercase Latin letters. You may apply some operations to this string: in one operation you can delete some contiguous substring of this string, if all letters in the substring you delete are equal. For example, after deleting substring bbbb from string abbbbaccdd we get the string aaccdd.

Calculate the minimum number of operations to delete the whole string $s$.


-----Input-----

The first line contains one integer $n$ ($1 \le n \le 500$) — the length of string $s$.

The second line contains the string $s$ ($|s| = n$) consisting of lowercase Latin letters.


-----Output-----

Output a single integer — the minimal number of operation to delete string $s$.


-----Examples-----
Input
5
abaca

Output
3
Input
8
abcddcba

Output
4
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    s = input()
    
    dp = [[0] * n for _ in range(n)]
    
    for length in range(1, n+1):
        for i in range(n-length+1):
            j = i + length - 1
            dp[i][j] = length
            if length > 1:
                dp[i][j] = min(dp[i][j], dp[i+1][j] + 1)
                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)
                if s[i] == s[j]:
                    dp[i][j] = min(dp[i][j], dp[i+1][j-1])
                    for k in range(i+1, j):
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
    
    return dp[0][n-1]

solve()
","
def solve():
    n = int(input())
    s = input()

    dp = [[0] * n for _ in range(n)]
    for l in range(1, n):
        for i in range(n-l):
            j = i + l
            dp[i][j] = l + 1
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])

                if s[i] == s[k+1]:
                    dp[i][j] = min(dp[i][j], dp[i][k+1] + dp[k+2][j])

    return dp[0][n-1]

solve()
","
def solve():
    import sys
    
    n = int(input())
    s = input().strip()
    
    dp = [[0] * n for _ in range(n)]
    
    for length in range(1, n+1):
        for i in range(n-length+1):
            j = i + length - 1
            dp[i][j] = length
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if j > i and s[i] == s[j]:
                dp[i][j] = min(dp[i][j], dp[i+1][j-1])
    
    return dp[0][n-1]

solve()
","
def solve():
    n = int(input())
    s = input()
    
    dp = [[0] * n for _ in range(n)]
    
    for length in range(1, n):
        for i in range(n - length):
            j = i + length
            dp[i][j] = length + 1
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            
            if s[i] == s[j]:
                dp[i][j] = min(dp[i][j], dp[i+1][j-1])
    
    return dp[0][n-1]

solve()
","
def solve():
    n = int(input())
    s = input()
    
    operations = 0
    i = 0
    
    while i < n:
        count = 1
        while i+1 < n and s[i] == s[i+1]:
            count += 1
            i += 1
        operations += 1
        i += 1
    
    return operations

solve()","
python
def solve():
    n = int(input())
    s = input()

    dp = [0] * n
    for i in range(n):
        min_ops = i + 1
        for j in range(i, -1, -1):
            if s[j] == s[i]:
                min_ops = min(min_ops, dp[j - 1] if j > 0 else 0)
            else:
                min_ops = min(min_ops, dp[j] + 1)
        dp[i] = min_ops

    return dp[-1]

solve()
","
def solve():
    n = int(input())
    s = input()
    
    dp = [[0] * n for _ in range(n)]
    
    for length in range(2, n+1):
        for i in range(n-length+1):
            j = i + length - 1
            dp[i][j] = length
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
                if s[i] == s[j]:
                    dp[i][j] = min(dp[i][j], dp[i+1][j-1])
    
    return dp[0][n-1]

solve()
","
def solve():
    import sys

    n = int(sys.stdin.readline())
    s = sys.stdin.readline().strip()

    dp = [[0] * n for _ in range(n)]
    for length in range(1, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = 1 + min(dp[i][k] + dp[k+1][j] for k in range(i, j) if s[k] == s[j])

    print(dp[0][n-1])

solve()
","
def solve():
    n = int(input())
    s = input()

    operations = 0
    i = 0
    while i < n:
        j = i + 1
        while j < n and s[j] == s[i]:
            j += 1
        operations += 1
        i = j

    return operations

# Required import for reading input
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline


solve()","
def solve():
    n = int(input())
    s = input()

    operations = 0
    i = 0

    while i < n:
        j = i
        while j < n and s[j] == s[i]:
            j += 1

        operations += 1
        i = j

    return operations

# Example usage
print(solve())

solve()","
def solve():
    n = int(input())
    s = input()

    dp = [[0] * n for _ in range(n)]

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = length

            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            
            if s[i] == s[j]:
                dp[i][j] = min(dp[i][j], dp[i+1][j-1])

    return dp[0][n-1]

solve()
","
def solve():
    n = int(input())
    s = input()
    
    dp = [[0] * n for _ in range(n)]
    
    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            dp[i][j] = float('inf')
            if s[i] == s[j]:
                dp[i][j] = min(dp[i][j], dp[i + 1][j - 1])
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])
    
    return dp[0][n - 1]

solve()","
def solve():
    n = int(input())
    s = input().strip()
    
    operations = 0
    curr_char = ''
    
    for char in s:
        if char != curr_char:
            operations += 1
            curr_char = char
    
    return operations

solve()
","
def solve():
    n = int(input())
    s = input()
    
    dp = [[0]*n for _ in range(n)]
    
    for gap in range(1, n):
        for i in range(n-gap):
            j = i + gap
            dp[i][j] = gap + 1
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
                if s[i] == s[k+1]:
                    dp[i][j] = min(dp[i][j], dp[i][k+1] + dp[k+1][j])
    
    return dp[0][n-1]

solve()
","
def solve():
    n = int(input())
    s = input()
    
    operations = 0
    i = 0
    while i < n:
        j = i
        while j < n and s[j] == s[i]:
            j += 1
        operations += 1
        i = j
    
    return operations

solve()
","
def solve():
    n = int(input())
    s = input()
    
    operations = 0
    i = 0
    
    while i < n:
        j = i
        while j < n and s[j] == s[i]:
            j += 1
        operations += 1
        i = j

    print(operations)

solve()
","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/255","
QUESTION:
The Berland State University is hosting a ballroom dance in celebration of its 100500-th anniversary! n boys and m girls are already busy rehearsing waltz, minuet, polonaise and quadrille moves.

We know that several boy&girl pairs are going to be invited to the ball. However, the partners' dancing skill in each pair must differ by at most one.

For each boy, we know his dancing skills. Similarly, for each girl we know her dancing skills. Write a code that can determine the largest possible number of pairs that can be formed from n boys and m girls.


-----Input-----

The first line contains an integer n (1 ≤ n ≤ 100) — the number of boys. The second line contains sequence a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 100), where a_{i} is the i-th boy's dancing skill.

Similarly, the third line contains an integer m (1 ≤ m ≤ 100) — the number of girls. The fourth line contains sequence b_1, b_2, ..., b_{m} (1 ≤ b_{j} ≤ 100), where b_{j} is the j-th girl's dancing skill.


-----Output-----

Print a single number — the required maximum possible number of pairs.


-----Examples-----
Input
4
1 4 6 2
5
5 1 5 7 9

Output
3

Input
4
1 2 3 4
4
10 11 12 13

Output
0

Input
5
1 1 1 1 1
3
1 2 3

Output
2
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))

    boys_skills.sort()
    girls_skills.sort()

    pairs = 0
    i = 0
    j = 0

    while i < n and j < m:
        if abs(boys_skills[i] - girls_skills[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys_skills[i] < girls_skills[j]:
            i += 1
        else:
            j += 1

    print(pairs)

solve()
","
def solve():
    from collections import Counter

    n = int(input())
    boys = list(map(int, input().split()))
    m = int(input())
    girls = list(map(int, input().split()))

    boys.sort()
    girls.sort()
    pairs = 0
    boy_counter = Counter(boys)
    girl_counter = Counter(girls)

    for skill in set(boys + girls):
        pairs += min(boy_counter[skill], girl_counter[skill]) + min(boy_counter[skill + 1], girl_counter[skill]) + min(boy_counter[skill], girl_counter[skill + 1])

    print(pairs // 3)

solve()
","
def solve():
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))
    
    boys_skills.sort()
    girls_skills.sort()
    
    pairs = 0
    i, j = 0, 0
    
    while i < n and j < m:
        if abs(boys_skills[i] - girls_skills[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys_skills[i] < girls_skills[j]:
            i += 1
        else:
            j += 1
            
    print(pairs)

solve()
","
def solve():
    n = int(input())
    boys = list(map(int, input().split()))
    m = int(input())
    girls = list(map(int, input().split()))

    boys.sort()
    girls.sort()

    pairs = 0
    i = 0
    j = 0

    while i < n and j < m:
        if abs(boys[i] - girls[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys[i] < girls[j]:
            i += 1
        else:
            j += 1

    print(pairs)

solve()
","
def solve():
    from collections import Counter
    
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))
    
    pairs = 0
    
    boys_counter = Counter(boys_skills)
    girls_counter = Counter(girls_skills)
    
    for i in range(min(min(boys_skills), min(girls_skills)), max(max(boys_skills), max(girls_skills)) + 1):
        pairs += min(boys_counter[i], girls_counter[i])
    
    print(pairs)
  
solve()","
def solve():
    import itertools

    n = int(input())
    boys = list(map(int, input().split()))
    m = int(input())
    girls = list(map(int, input().split()))

    pairs = 0
    boys.sort()
    girls.sort()

    for pair in itertools.product(boys, girls):
        if abs(pair[0] - pair[1]) <= 1:
            pairs += 1
            girls.remove(pair[1])

    print(pairs)

solve()
","
def solve():
    n = int(input())
    boys = list(map(int, input().split()))
    m = int(input())
    girls = list(map(int, input().split()))
    
    boys.sort()
    girls.sort()
    
    pairs = 0
    i = 0
    j = 0
    
    while i < n and j < m:
        if abs(boys[i] - girls[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys[i] < girls[j]:
            i += 1
        else:
            j += 1
    
    print(pairs)

solve()
  ","
def solve():
    from collections import Counter

    n = int(input())
    boys_skills = Counter(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))

    pairs = 0
    for girl in girls_skills:
        if girl-1 in boys_skills and boys_skills[girl-1] > 0:
            boys_skills[girl-1] -= 1
            pairs += 1
        elif girl in boys_skills and boys_skills[girl] > 0:
            boys_skills[girl] -= 1
            pairs += 1
        elif girl+1 in boys_skills and boys_skills[girl+1] > 0:
            boys_skills[girl+1] -= 1
            pairs += 1

    print(pairs)

solve()
","
def solve():
    # Input
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))

    # Sort the skills of boys and girls
    boys_skills.sort()
    girls_skills.sort()

    pairs = 0
    i = 0
    j = 0

    # Find the maximum number of pairs that can be formed
    while i < n and j < m:
        if abs(boys_skills[i] - girls_skills[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys_skills[i] < girls_skills[j]:
            i += 1
        else:
            j += 1

    # Output
    print(pairs)

# Run the function
solve()
","
def solve():
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))
    
    boys_skills.sort()
    girls_skills.sort()
    
    boy_idx = 0
    girl_idx = 0
    pairs = 0
    
    while boy_idx < n and girl_idx < m:
        if abs(boys_skills[boy_idx] - girls_skills[girl_idx]) <= 1:
            pairs += 1
            boy_idx += 1
            girl_idx += 1
        elif boys_skills[boy_idx] < girls_skills[girl_idx]:
            boy_idx += 1
        else:
            girl_idx += 1
    
    print(pairs)

solve()
","
def solve():
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))
    
    boys_skills.sort()
    girls_skills.sort()
    
    boy_idx = 0
    girl_idx = 0
    pairs = 0
    
    while boy_idx < n and girl_idx < m:
        if abs(boys_skills[boy_idx] - girls_skills[girl_idx]) <= 1:
            pairs += 1
            boy_idx += 1
            girl_idx += 1
        elif boys_skills[boy_idx] < girls_skills[girl_idx]:
            boy_idx += 1
        else:
            girl_idx += 1
    
    print(pairs)

solve()
","
def solve():
    n = int(input())
    boys = list(map(int, input().split()))
    m = int(input())
    girls = list(map(int, input().split()))

    boys.sort()
    girls.sort()
    pairs = 0
    i, j = 0, 0

    while i < n and j < m:
        if abs(boys[i] - girls[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys[i] < girls[j]:
            i += 1
        else:
            j += 1

    print(pairs)

solve()
","
# Function signature: solve()
def solve():
    # Input
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))
    
    # Sort boys and girls skills
    boys_skills.sort()
    girls_skills.sort()
    
    # Find maximum possible pairs
    pairs = 0
    i = 0
    j = 0
    while i < n and j < m:
        if abs(boys_skills[i] - girls_skills[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys_skills[i] < girls_skills[j]:
            i += 1
        else:
            j += 1
    
    # Output
    print(pairs)

# Call the function to solve the problem
solve()
","
def solve():
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))

    boys_skills.sort()
    girls_skills.sort()

    count = 0
    i = 0
    j = 0

    while i < n and j < m:
        if abs(boys_skills[i] - girls_skills[j]) <= 1:
            count += 1
            i += 1
            j += 1
        elif boys_skills[i] < girls_skills[j]:
            i += 1
        else:
            j += 1

    print(count)

solve()
","
def solve():
    n = int(input())
    boys_skills = list(map(int, input().split()))
    m = int(input())
    girls_skills = list(map(int, input().split()))
    
    boys_skills.sort()
    girls_skills.sort()
    
    pairs = 0
    i = 0
    j = 0
    while i < n and j < m:
        if abs(boys_skills[i] - girls_skills[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        elif boys_skills[i] < girls_skills[j]:
            i += 1
        else:
            j += 1
    
    return pairs

solve()","
def solve():
    from collections import Counter
    
    n = int(input())
    boys_skills = Counter(map(int, input().split()))
    m = int(input())
    girls_skills = Counter(map(int, input().split()))
    
    pairs = 0
    for boy_skill, boy_count in boys_skills.items():
        for girl_skill, girl_count in girls_skills.items():
            if abs(boy_skill - girl_skill) <= 1 and girl_count > 0 and boy_count > 0:
                pairs += 1
                girls_skills[girl_skill] -= 1
                boys_skills[boy_skill] -= 1
                
    print(pairs)

solve()
","100.0","13.333333333333334","100.0","100.0","46.666666666666664","26.666666666666668","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","0.0","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/256","
QUESTION:
Kicker (table football) is a board game based on football, in which players control the footballers' figures mounted on rods by using bars to get the ball into the opponent's goal. When playing two on two, one player of each team controls the goalkeeper and the full-backs (plays defence), the other player controls the half-backs and forwards (plays attack).

Two teams of company Q decided to battle each other. Let's enumerate players from both teams by integers from 1 to 4. The first and second player play in the first team, the third and the fourth one play in the second team. For each of the four players we know their game skills in defence and attack. The defence skill of the i-th player is a_{i}, the attack skill is b_{i}.

Before the game, the teams determine how they will play. First the players of the first team decide who will play in the attack, and who will play in the defence. Then the second team players do the same, based on the choice of their opponents.

We will define a team's defence as the defence skill of player of the team who plays defence. Similarly, a team's attack is the attack skill of the player of the team who plays attack. We assume that one team is guaranteed to beat the other one, if its defence is strictly greater than the opponent's attack and its attack is strictly greater than the opponent's defence.

The teams of company Q know each other's strengths and therefore arrange their teams optimally. Identify the team that is guaranteed to win (if both teams act optimally) or tell that there is no such team.


-----Input-----

The input contain the players' description in four lines. The i-th line contains two space-separated integers a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ 100) — the defence and the attack skill of the i-th player, correspondingly.


-----Output-----

If the first team can win, print phrase ""Team 1"" (without the quotes), if the second team can win, print phrase ""Team 2"" (without the quotes). If no of the teams can definitely win, print ""Draw"" (without the quotes).


-----Examples-----
Input
1 100
100 1
99 99
99 99

Output
Team 1

Input
1 1
2 2
3 3
2 2

Output
Team 2

Input
3 3
2 2
1 1
2 2

Output
Draw



-----Note-----

Let consider the first test sample. The first team can definitely win if it will choose the following arrangement: the first player plays attack, the second player plays defence.

Consider the second sample. The order of the choosing roles for players makes sense in this sample. As the members of the first team choose first, the members of the second team can beat them (because they know the exact defence value and attack value of the first team).
Use user-input-Based format and function signature solve()","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    
    team1_defense = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    
    team2_defense = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defense > team2_attack and team1_attack > team2_defense:
        print(""Team 1"")
    elif team2_defense > team1_attack and team2_attack > team1_defense:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    
    team1_defense = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    
    team2_defense = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defense > team2_attack and team1_attack > team2_defense:
        print(""Team 1"")
    elif team2_defense > team1_attack and team2_attack > team1_defense:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()
","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    team1_def = max(players[0][0], players[1][0])
    team1_att = min(players[0][1], players[1][1])
    team2_def = max(players[2][0], players[3][0])
    team2_att = min(players[2][1], players[3][1])
    
    if team1_def > team2_att and team1_att > team2_def:
        print(""Team 1"")
    elif team2_def > team1_att and team2_att > team1_def:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()
","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    
    team1_defense = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    
    team2_defense = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defense > team2_attack and team1_attack > team2_defense:
        print(""Team 1"")
    elif team2_defense > team1_attack and team2_attack > team1_defense:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()","
def solve():
    players = []
    for _ in range(4):
        d, a = map(int, input().split())
        players.append((d, a))
    
    team1_defence = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    
    team2_defence = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if (team1_defence > team2_attack) and (team1_attack > team2_defence):
        print(""Team 1"")
    elif (team2_defence > team1_attack) and (team2_attack > team1_defence):
        print(""Team 2"")
    else:
        print(""Draw"")

solve()
","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    first_team_defence = max(players[0][0], players[1][0])
    first_team_attack = min(players[0][1], players[1][1])
    second_team_defence = max(players[2][0], players[3][0])
    second_team_attack = min(players[2][1], players[3][1])

    if first_team_defence > second_team_attack and first_team_attack > second_team_defence:
        print(""Team 1"")
    elif second_team_defence > first_team_attack and second_team_attack > first_team_defence:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()","
def solve():
    players = []
    
    for _ in range(4):
        a, b = map(int, input().split())
        players.append((a, b))
    
    team1_defense = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    team2_defense = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defense > team2_attack and team1_attack > team2_defense:
        print(""Team 1"")
    elif team2_defense > team1_attack and team2_attack > team1_defense:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    
    team1_defence = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    
    team2_defence = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defence > team2_attack and team1_attack > team2_defence:
        print(""Team 1"")
    elif team2_defence > team1_attack and team2_attack > team1_defence:
        print(""Team 2"")
    else:
        print(""Draw"")
  
solve()","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    
    team1_defence = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    
    team2_defence = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defence > team2_attack and team1_attack > team2_defence:
        print(""Team 1"")
    elif team2_defence > team1_attack and team2_attack > team1_defence:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()","
def solve():
    players = [list(map(int, input().split())) for _ in range(4)]
    
    team1_defence = max(players[0][0], players[1][0])
    team1_attack = max(players[0][1], players[1][1])
    
    team2_defence = min(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defence > team2_attack and team1_attack > team2_defence:
        print(""Team 1"")
    elif team2_defence > team1_attack and team2_attack > team1_defence:
        print(""Team 2"")
    else:
        print(""Draw"")
  
solve()","
def solve():
    players = []
    for _ in range(4):
        a, b = map(int, input().split())
        players.append((a, b))

    team1_def = max(players[0][0], players[1][0])
    team1_att = min(players[0][1], players[1][1])

    team2_def = max(players[2][0], players[3][0])
    team2_att = min(players[2][1], players[3][1])

    if team1_def > team2_att and team1_att > team2_def:
        print(""Team 1"")
    elif team2_def > team1_att and team2_att > team1_def:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()
","
def solve():
    player_skills = [list(map(int, input().split())) for _ in range(4)]
    
    team1_defence = max(player_skills[0][0], player_skills[1][0])
    team1_attack = min(player_skills[0][1], player_skills[1][1])
    
    team2_defence = max(player_skills[2][0], player_skills[3][0])
    team2_attack = min(player_skills[2][1], player_skills[3][1])
    
    if team1_defence > team2_attack and team1_attack > team2_defence:
        print(""Team 1"")
    elif team2_defence > team1_attack and team2_attack > team1_defence:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()","
def solve():
    # Reading input
    players = [list(map(int, input().split())) for _ in range(4)]
    
    # Determining which team can win
    team1_defense = max(players[0][0], players[1][0])
    team1_attack = min(players[0][1], players[1][1])
    team2_defense = max(players[2][0], players[3][0])
    team2_attack = min(players[2][1], players[3][1])
    
    if team1_defense > team2_attack and team1_attack > team2_defense:
        print(""Team 1"")
    elif team2_defense > team1_attack and team2_attack > team1_defense:
        print(""Team 2"")
    else:
        print(""Draw"")

# Run the function
solve()
","
def solve():
    player_1 = list(map(int, input().split()))
    player_2 = list(map(int, input().split()))
    player_3 = list(map(int, input().split()))
    player_4 = list(map(int, input().split()))
    
    team_1_defence = max(player_1[0], player_2[0])
    team_1_attack = max(player_1[1], player_2[1])
    team_2_defence = max(player_3[0], player_4[0])
    team_2_attack = max(player_3[1], player_4[1])
    
    if (team_1_defence > team_2_attack) and (team_1_attack > team_2_defence):
        print(""Team 1"")
    elif (team_2_defence > team_1_attack) and (team_2_attack > team_1_defence):
        print(""Team 2"")
    else:
        print(""Draw"")
  
solve()","
def solve():
    team1 = []
    team2 = []
    
    for _ in range(4):
        a, b = map(int, input().split())
        team1.append((a, b))
    
    for i in range(1, 5):
        if i not in [1, 2]:
            team2.append(team1[i-1])
    
    team1_attack = max(team1[0][1], team1[1][1])
    team1_defence = min(team1[0][0], team1[1][0])
    team2_attack = max(team2[0][1], team2[1][1])
    team2_defence = min(team2[0][0], team2[1][0])
    
    if team1_attack > team2_defence and team1_defence > team2_attack:
        print(""Team 1"")
    elif team2_attack > team1_defence and team2_defence > team1_attack:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()","
def solve():
    import sys
    input = sys.stdin.readline

    skills = [list(map(int, input().split())) for _ in range(4)]

    team1_defence = max(skills[0][0], skills[1][0])
    team1_attack = min(skills[0][1], skills[1][1])
    team2_defence = max(skills[2][0], skills[3][0])
    team2_attack = min(skills[2][1], skills[3][1])

    if team1_defence > team2_attack and team1_attack > team2_defence:
        print(""Team 1"")
    elif team2_defence > team1_attack and team2_attack > team1_defence:
        print(""Team 2"")
    else:
        print(""Draw"")

solve()
","66.66666666666666","66.66666666666666","66.66666666666666","66.66666666666666","66.66666666666666","66.66666666666666","66.66666666666666","66.66666666666666","66.66666666666666","60.0","66.66666666666666","66.66666666666666","66.66666666666666","86.66666666666667","60.0","66.66666666666666","","","","","","","","","","","","","","","",""
"APPS/257","
QUESTION:
Takahashi wants to grill N pieces of meat on a grilling net, which can be seen as a two-dimensional plane. The coordinates of the i-th piece of meat are \left(x_i, y_i\right), and its hardness is c_i.
Takahashi can use one heat source to grill the meat. If he puts the heat source at coordinates \left(X, Y\right), where X and Y are real numbers, the i-th piece of meat will be ready to eat in c_i \times \sqrt{\left(X - x_i\right)^2 + \left(Y-y_i\right)^2} seconds.
Takahashi wants to eat K pieces of meat. Find the time required to have K or more pieces of meat ready if he put the heat source to minimize this time.

-----Constraints-----
 - All values in input are integers.
 - 1 \leq N \leq 60
 - 1 \leq K \leq N
 - -1000 \leq x_i , y_i \leq 1000
 - \left(x_i, y_i\right) \neq \left(x_j, y_j\right) \left(i \neq j \right)
 - 1 \leq c_i \leq 100

-----Input-----
Input is given from Standard Input in the following format:
N K
x_1 y_1 c_1
\vdots
x_N y_N c_N

-----Output-----
Print the answer.
It will be considered correct if its absolute or relative error from our answer is at most 10^{-6}.

-----Sample Input-----
4 3
-1 0 3
0 0 3
1 0 2
1 1 40

-----Sample Output-----
2.4

If we put the heat source at \left(-0.2, 0\right), the 1-st, 2-nd, and 3-rd pieces of meat will be ready to eat within 2.4 seconds. This is the optimal place to put the heat source.
Use user-input-Based format and function signature solve()","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    def time_to_eat(x, y):
        return sum(sorted([ci * ((xi - x)**2 + (yi - y)**2)**0.5 for xi, yi, ci in meat])[:K])
    
    min_time = float('inf')
    for (x1, y1), (x2, y2) in combinations([(xi, yi) for xi, yi, _ in meat], 2):
        x = (x1 + x2) / 2
        y = (y1 + y2) / 2
        min_time = min(min_time, time_to_eat(x, y))
    
    print(min_time)

solve()
","
import sys
import math

def solve():
    N, K = map(int, input().split())

    meats = [list(map(int, input().split())) for _ in range(N)]
    
    low, high = 0, 1000

    while high - low > 1e-6:
        mid = (low + high) / 2

        times = sorted([((xi-mid)**2 + (yi-mid)**2)**0.5 * ci for xi, yi, ci in meats])
        
        if sum(times[:K]) >= sum(times):
            high = mid
        else:
            low = mid

    print(""{:.6f}"".format(mid))
    
solve()
","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meats = []
    for _ in range(N):
        x, y, c = map(int, input().split())
        meats.append((x, y, c))
    
    result = float('inf')
    for comb in combinations(meats, K):
        for x in range(-1000, 1001):
            for y in range(-1000, 1001):
                time = 0
                for meat in comb:
                    xi, yi, ci = meat
                    dist = ((x - xi) ** 2 + (y - yi) ** 2) ** 0.5
                    time = max(time, ci * dist)
                result = min(result, time)
    
    print('{:.6f}'.format(result))

solve()
","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    def calc_time(X, Y):
        return max(c * ((X - x)**2 + (Y - y)**2)**0.5 for x, y, c in meat)
    
    ans = float('inf')
    for (x1, y1), (x2, y2) in combinations(meat, K):
        left, right = 0, 1
        for _ in range(50):
            m1 = (2*left + right) / 3
            m2 = (left + 2*right) / 3
            if calc_time(m1*x1 + m2*x2, m1*y1 + m2*y2) < calc_time(m2*x1 + m1*x2, m2*y1 + m1*y2):
                right = m2
            else:
                left = m1
        ans = min(ans, calc_time(m1*x1 + m2*x2, m1*y1 + m2*y2))
    
    print(round(ans, 6))

solve()
","
def solve():
    import itertools

    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    ans = float('inf')
    for points in itertools.combinations(range(N), K):
        for x in range(-1000, 1001):
            for y in range(-1000, 1001):
                time = sorted([meat[i][2] * ((x - meat[i][0])**2 + (y - meat[i][1])**2)**0.5 for i in points])
                ans = min(ans, time[-1])
    
    print(format(ans, '.6f'))

solve()
","
from itertools import combinations
import math

def solve():
    N, K = map(int, input().split())
    meats = [list(map(int, input().split())) for _ in range(N)]
    
    min_time = float('inf')
    for comb in combinations(meats, K):
        for X in range(-1000, 1001):
            for Y in range(-1000, 1001):
                time = 0
                for meat in meats:
                    x, y, c = meat
                    dist = math.sqrt((X - x)**2 + (Y - y)**2)
                    time += c * dist
                min_time = min(min_time, time)
                
    print(f'{min_time:.6f}')

solve()
","
import sys
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meats = [list(map(int, input().split())) for _ in range(N)]
    
    def calculate_time(X, Y):
        times = [c * ((X - x)**2 + (Y - y)**2)**0.5 for x, y, c in meats]
        times.sort()
        return sum(times[:K])
    
    result = sys.maxsize
    for (i, j) in combinations(range(N), K):
        x1, y1, _ = meats[i]
        x2, y2, _ = meats[j]
        X = (x1 + x2) / 2
        Y = (y1 + y2) / 2
        result = min(result, calculate_time(X, Y))
    
    print('{:.10f}'.format(result))

solve()
","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meats = [list(map(int, input().split())) for _ in range(N)]

    def calc_time(x, y):
        return max([ci * ((x - xi) ** 2 + (y - yi) ** 2) ** 0.5 for xi, yi, ci in meats])

    min_time = float('inf')
    for comb in combinations(meats, K):
        for x in range(-1000, 1001):
            for y in range(-1000, 1001):
                min_time = min(min_time, calc_time(x, y))

    print(f""{min_time:.6f}"")

solve()","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    best_time = float('inf')
    for comb in combinations(meat, K):
        for x in range(-1000, 1001):
            for y in range(-1000, 1001):
                time = 0
                for i in range(K):
                    time = max(time, comb[i][2] * ((x - comb[i][0])**2 + (y - comb[i][1])**2)**0.5)
                best_time = min(best_time, time)

    print(""{:.6f}"".format(best_time))

solve()","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    def calc_time(X, Y):
        return max(sorted([ci * ((xi - X)**2 + (yi - Y)**2)**0.5 for xi, yi, ci in meat])[:K])
    
    min_time = float('inf')
    for (i, j) in combinations(range(N), 2):
        x1, y1, _ = meat[i]
        x2, y2, _ = meat[j]
        X = (x1 + x2) / 2
        Y = (y1 + y2) / 2
        min_time = min(min_time, calc_time(X, Y))
    
    for i in range(N):
        for j in range(i+1, N):
            for k in range(j+1, N):
                x1, y1, _ = meat[i]
                x2, y2, _ = meat[j]
                x3, y3, _ = meat[k]
                X = (x1 + x2 + x3) / 3
                Y = (y1 + y2 + y3) / 3
                min_time = min(min_time, calc_time(X, Y))
                
    print('{:.7f}'.format(min_time))

  
solve()","
import itertools

def solve():
    N, K = map(int, input().split())
    coords = [list(map(int, input().split())) for _ in range(N)]

    ans = 1e9
    for comb in itertools.combinations(range(N), K):
        for x in range(-1000, 1001):
            for y in range(-1000, 1001):
                time = 0
                for i in comb:
                    x_i, y_i, c_i = coords[i]
                    time = max(time, c_i * ((x - x_i) ** 2 + (y - y_i) ** 2) ** 0.5)
                ans = min(ans, time)

    print(""{:.6f}"".format(ans))


solve()","
def solve():
    import itertools
    import sys

    N, K = map(int, input().split())
    XYC = [list(map(int, input().split())) for _ in range(N)]

    ans = float('inf')
    for comb in itertools.combinations(range(N), K):
        for i in range(N):
            for j in range(i + 1, N):
                x1, y1, c1 = XYC[i]
                x2, y2, c2 = XYC[j]
                x = (c1 ** 2 * x2 + c2 ** 2 * x1) / (c1 ** 2 + c2 ** 2)
                y = (c1 ** 2 * y2 + c2 ** 2 * y1) / (c1 ** 2 + c2 ** 2)
                time = max(c1 * ((x - x1) ** 2 + (y - y1) ** 2) ** 0.5, c2 * ((x - x2) ** 2 + (y - y2) ** 2) ** 0.5)
                for k in comb:
                    time = max(time, XYC[k][2] * ((x - XYC[k][0]) ** 2 + (y - XYC[k][1]) ** 2) ** 0.5)
                ans = min(ans, time)

    print(ans)

solve()","
from itertools import combinations
from math import sqrt

def solve():
    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    best_time = float('inf')
    for comb in combinations(range(N), K):
        for x in range(-1000, 1001):
            for y in range(-1000, 1001):
                time = 0
                for i in comb:
                    xi, yi, ci = meat[i]
                    time = max(time, ci * sqrt((x - xi)**2 + (y - yi)**2))
                best_time = min(best_time, time)
    
    print(""{:.10f}"".format(best_time))

solve()
","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    def time(left):
        return max([meat[i][2] * ((left[0] - meat[i][0])**2 + (left[1] - meat[i][1])**2)**0.5 for i in range(N)])
    
    ans = float('inf')
    for comb in combinations(range(N), K):
        for i in range(N):
            for j in range(N):
                ans = min(ans, time([(meat[comb[k]][0] + meat[comb[k]][0]) / 2, (meat[comb[k]][1] + meat[comb[k]][1]) / 2]) for k in range(K))
                
    print(""{:.6f}"".format(ans))


solve()","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    meat = [list(map(int, input().split())) for _ in range(N)]
    
    def calc_time(X, Y):
        times = sorted([c * ((X - x)**2 + (Y - y)**2)**0.5 for x, y, c in meat])
        return sum(times[:K])
    
    min_time = 1e9
    for (x1, y1), (x2, y2) in combinations(meat, 2):
        X = (x1 + x2) / 2
        Y = (y1 + y2) / 2
        time = calc_time(X, Y)
        min_time = min(min_time, time)
    
    print(min_time)

  
solve()","
from itertools import combinations

def solve():
    N, K = map(int, input().split())
    coordinates = [list(map(int, input().split())) for _ in range(N)]

    min_time = float('inf')
    for comb in combinations(coordinates, K):
        for x in range(-1000, 1001):
            for y in range(-1000, 1001):
                total_time = 0
                for xi, yi, ci in comb:
                    time = ci * ((x - xi) ** 2 + (y - yi) ** 2) ** 0.5
                    total_time += time
                min_time = min(min_time, total_time)
    
    print(min_time)

solve()
","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/258","
QUESTION:
Monocarp and Bicarp live in Berland, where every bus ticket consists of $n$ digits ($n$ is an even number). During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased. The number of digits that have been erased is even.

Monocarp and Bicarp have decided to play a game with this ticket. Monocarp hates happy tickets, while Bicarp collects them. A ticket is considered happy if the sum of the first $\frac{n}{2}$ digits of this ticket is equal to the sum of the last $\frac{n}{2}$ digits.

Monocarp and Bicarp take turns (and Monocarp performs the first of them). During each turn, the current player must replace any erased digit with any digit from $0$ to $9$. The game ends when there are no erased digits in the ticket.

If the ticket is happy after all erased digits are replaced with decimal digits, then Bicarp wins. Otherwise, Monocarp wins. You have to determine who will win if both players play optimally.


-----Input-----

The first line contains one even integer $n$ $(2 \le n \le 2 \cdot 10^{5})$ — the number of digits in the ticket.

The second line contains a string of $n$ digits and ""?"" characters — the ticket which Monocarp and Bicarp have found. If the $i$-th character is ""?"", then the $i$-th digit is erased. Note that there may be leading zeroes. The number of ""?"" characters is even.


-----Output-----

If Monocarp wins, print ""Monocarp"" (without quotes). Otherwise print ""Bicarp"" (without quotes).


-----Examples-----
Input
4
0523

Output
Bicarp

Input
2
??

Output
Bicarp

Input
8
?054??0?

Output
Bicarp

Input
6
???00?

Output
Monocarp



-----Note-----

Since there is no question mark in the ticket in the first example, the winner is determined before the game even starts, and it is Bicarp.

In the second example, Bicarp also wins. After Monocarp chooses an erased digit and replaces it with a new one, Bicap can choose another position with an erased digit and replace it with the same digit, so the ticket is happy.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    ticket = input()

    first_half_sum = 0
    second_half_sum = 0
    first_half_question_marks = 0
    second_half_question_marks = 0

    for i in range(n // 2):
        if ticket[i] == '?':
            first_half_question_marks += 1
        else:
            first_half_sum += int(ticket[i])

    for i in range(n // 2, n):
        if ticket[i] == '?':
            second_half_question_marks += 1
        else:
            second_half_sum += int(ticket[i])

    if first_half_question_marks == second_half_question_marks:
        if first_half_sum == second_half_sum:
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    elif first_half_question_marks < second_half_question_marks:
        diff = second_half_question_marks - first_half_question_marks
        if (second_half_sum - first_half_sum) <= 9 * diff // 2:
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    else:
        diff = first_half_question_marks - second_half_question_marks
        if (first_half_sum - second_half_sum) <= 9 * diff // 2:
            print(""Bicarp"")
        else:
            print(""Monocarp"")

solve()
","
def solve():
    n = int(input())
    ticket = input()

    cnt = [ticket.count(str(i)) for i in range(10)]
    
    for i in range(10):
        for j in range(10):
            a = i
            b = j
            for k in range(10):
                for l in range(10):
                    a += (k-l) * (cnt[k]-cnt[l])
                    b += (k-l) * (cnt[k]-cnt[l])
                    if a >= n//2 and b >= n//2:
                        print(""Bicarp"")
                        return
    print(""Monocarp"")

solve()","
def solve():
    n = int(input())
    ticket = input().strip()
    
    if n % 4 != 0 or ticket[0] == ticket[n-1]:
        print(""Monocarp"")
    else:
        print(""Bicarp"")

solve()","
def solve():
    n = int(input())
    ticket = input()

    first_half_sum = 0
    second_half_sum = 0
    first_half_unknown = 0
    second_half_unknown = 0

    for i in range(n):
        if i < n/2:
            if ticket[i] == '?':
                first_half_unknown += 1
            else:
                first_half_sum += int(ticket[i])
        else:
            if ticket[i] == '?':
                second_half_unknown += 1
            else:
                second_half_sum += int(ticket[i])

    if first_half_sum > second_half_sum:
        first_half_sum, second_half_sum = second_half_sum, first_half_sum
        first_half_unknown, second_half_unknown = second_half_unknown, first_half_unknown

    diff = second_half_sum - first_half_sum

    if diff > 9 * first_half_unknown:
        print(""Monocarp"")
    elif diff % 2 != 0:
        print(""Monocarp"")
    else:
        if diff // 2 <= second_half_unknown:
            print(""Bicarp"")
        else:
            print(""Monocarp"")

solve()
","
def solve():
    n = int(input())
    ticket = input()

    half = n // 2
    left_sum = 0
    right_sum = 0
    question_marks = 0

    for digit in ticket:
        if digit.isdigit():
            if half > 0:
                left_sum += int(digit)
            else:
                right_sum += int(digit)
            half -= 1
        else:
            question_marks += 1

    if question_marks == 0:
        if left_sum == right_sum:
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    elif question_marks % 2 == 0:
        if left_sum == right_sum:
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    else:
        if left_sum == right_sum or abs(left_sum - right_sum) % 9 == 0:
            print(""Monocarp"")
        else:
            print(""Bicarp"")

solve()","
def solve():
    n = int(input().strip())
    ticket = input().strip()
    
    even_pos_sum = 0
    odd_pos_sum = 0

    for i in range(n // 2):
        if ticket[i] != '?':
            even_pos_sum += int(ticket[i])
        if ticket[n // 2 + i] != '?':
            odd_pos_sum += int(ticket[n // 2 + i])

    if even_pos_sum != odd_pos_sum:
        print(""Monocarp"")
    else:
        zeros = ticket.count('?', 0, n // 2)
        ones = ticket.count('?', n // 2, n)

        if zeros % 2 == 0 and ones % 2 == 0:
            print(""Bicarp"")
        else:
            print(""Monocarp"")

solve()
","
def solve():
    n = int(input())
    ticket = input()
    
    first_half_sum = 0
    second_half_sum = 0
    erased_count = ticket.count('?')
    
    for i in range(n // 2):
        if ticket[i] != '?':
            first_half_sum += int(ticket[i])
        if ticket[n // 2 + i] != '?':
            second_half_sum += int(ticket[n // 2 + i])
    
    diff = abs(first_half_sum - second_half_sum)
    
    if (erased_count % 2 == 1) or (diff % 10 * 2):
        print(""Monocarp"")
    else:
        print(""Bicarp"")

solve()
","
def solve():
    n = int(input())
    ticket = input()
    
    first_sum = sum([int(x) for x in ticket[:n//2] if x.isdigit()])
    second_sum = sum([int(x) for x in ticket[n//2:] if x.isdigit()])
    
    if first_sum == second_sum:
        print(""Bicarp"")
    else:
        print(""Monocarp"")

solve()
","
def solve():
    n = int(input())
    ticket = input()

    first_half_sum = sum(int(x) for x in ticket[:n//2] if x.isdigit())
    second_half_sum = sum(int(x) for x in ticket[n//2:] if x.isdigit())

    # Difference in sum between first half and second half
    diff = abs(first_half_sum - second_half_sum)

    if ticket.count('?') == 0:
        if diff == 0:
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    else:
        if diff == 0 or diff % 9 == 0:
            print(""Bicarp"")
        else:
            print(""Monocarp"")

solve()
  ","
def solve():
    n = int(input())
    ticket = input().strip()

    # Calculate the sum of the first half of the ticket
    first_half_sum = 0
    for i in range(n // 2):
        if ticket[i] != '?':
            first_half_sum += int(ticket[i])

    # Calculate the sum of the second half of the ticket
    second_half_sum = 0
    for i in range(n // 2, n):
        if ticket[i] != '?':
            second_half_sum += int(ticket[i])

    # Check if the ticket is already happy
    if first_half_sum == second_half_sum:
        print(""Bicarp"")
    else:
        if first_half_sum > second_half_sum:
            print(""Monocarp"")
        else:
            print(""Bicarp"")

solve()
","
def solve():
    n = int(input())
    ticket = input()
    
    diff = ticket.count('?') // 2
    sum1, sum2 = 0, 0
    s1, s2 = ticket[:n//2].count('?'), ticket[n//2:].count('?')
    
    for i in range(n // 2):
        if ticket[i] == '?':
            s1 -= 1
        else:
            sum1 += int(ticket[i])
        
    for i in range(n // 2, n):
        if ticket[i] == '?':
            s2 -= 1
        else:
            sum2 += int(ticket[i])
    
    if s1 < s2:
        sum1 += (s2 - s1) * 9
    else:
        sum2 += (s1 - s2) * 9
    
    if sum1 == sum2:
        print(""Bicarp"")
    else:
        print(""Monocarp"")
  
solve()","
def solve():
    n = int(input())
    ticket = input()

    first_half_sum = sum(int(digit) for digit in ticket[:n//2] if digit.isdigit())
    second_half_sum = sum(int(digit) for digit in ticket[n//2:] if digit.isdigit())
    
    if ticket.count('?') % 2 == 0:
        if first_half_sum == second_half_sum:
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    else:
        print(""Bicarp"")

solve()
","
def solve():
    n = int(input())
    ticket = input()

    num_erased = ticket.count('?')

    if num_erased == 0:
        if sum(map(int, ticket[:n//2])) == sum(map(int, ticket[n//2:])):
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    else:
        if num_erased % 2 == 0:
            print(""Bicarp"")
        else:
            print(""Monocarp"")

solve()","
def solve():
    n = int(input())
    ticket = input()

    first_half = sum(int(digit) for digit in ticket[:n//2] if digit.isdigit())
    second_half = sum(int(digit) for digit in ticket[n//2:] if digit.isdigit())
    
    if n // 2 % 2 == 0:
        print(""Bicarp"")
    else:
        print(""Monocarp"")

solve()","
def solve():
    n = int(input())
    ticket = input().strip()

    first_half_sum = 0
    second_half_sum = 0
    unknown_digits = 0

    for i in range(n//2):
        if ticket[i] == ""?"":
            unknown_digits += 1
        else:
            first_half_sum += int(ticket[i])

    for i in range(n//2, n):
        if ticket[i] == ""?"":
            unknown_digits += 1
        else:
            second_half_sum += int(ticket[i])

    if unknown_digits % 2 != 0:
        return ""Monocarp""
    
    if first_half_sum == second_half_sum:
        return ""Bicarp""
    else:
        return ""Monocarp""

solve()","
def solve():
    n = int(input())
    ticket = input()
    
    count_question_marks = ticket.count(""?"")
    
    if count_question_marks == 0:
        print(""Bicarp"")
    elif count_question_marks == 2:
        if ticket.count(""??"") == 2 or (ticket[0] == '?' and ticket[-1] == '?'):
            print(""Bicarp"")
        else:
            print(""Monocarp"")
    else:
        if count_question_marks % 4 == 0:
            print(""Bicarp"")
        else:
            print(""Monocarp"")

solve()
","86.66666666666667","86.66666666666667","40.0","53.333333333333336","40.0","33.33333333333333","46.666666666666664","46.666666666666664","86.66666666666667","60.0","46.666666666666664","46.666666666666664","86.66666666666667","73.33333333333333","0.0","60.0","","","","","","","","","","","","","","","",""
"APPS/259","
QUESTION:
It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly.

Serval will go to the bus station at time $t$, and there are $n$ bus routes which stop at this station. For the $i$-th bus route, the first bus arrives at time $s_i$ minutes, and each bus of this route comes $d_i$ minutes later than the previous one.

As Serval's best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them.


-----Input-----

The first line contains two space-separated integers $n$ and $t$ ($1\leq n\leq 100$, $1\leq t\leq 10^5$) — the number of bus routes and the time Serval goes to the station. 

Each of the next $n$ lines contains two space-separated integers $s_i$ and $d_i$ ($1\leq s_i,d_i\leq 10^5$) — the time when the first bus of this route arrives and the interval between two buses of this route.


-----Output-----

Print one number — what bus route Serval will use. If there are several possible answers, you can print any of them.


-----Examples-----
Input
2 2
6 4
9 5

Output
1

Input
5 5
3 3
2 5
5 6
4 9
6 1

Output
3

Input
3 7
2 2
2 3
2 4

Output
1



-----Note-----

In the first example, the first bus of the first route arrives at time $6$, and the first bus of the second route arrives at time $9$, so the first route is the answer.

In the second example, a bus of the third route arrives at time $5$, so it is the answer.

In the third example, buses of the first route come at times $2$, $4$, $6$, $8$, and so fourth, buses of the second route come at times $2$, $5$, $8$, and so fourth and buses of the third route come at times $2$, $6$, $10$, and so on, so $1$ and $2$ are both acceptable answers while $3$ is not.
Use user-input-Based format and function signature solve()","
def solve():
    n, t = map(int, input().split())
    routes = []
    for _ in range(n):
        s, d = map(int, input().split())
        route = (s, d)
        routes.append(route)
    
    min_time = float('inf')
    bus_route = 0
    for i, (s, d) in enumerate(routes, start=1):
        time = s if s >= t else s + ((t - s + d - 1) // d) * d
        if time < min_time:
            min_time = time
            bus_route = i
    
    print(bus_route)

solve()
","
def solve():
    n, t = map(int, input().split())
    routes = []
    for i in range(n):
        s, d = map(int, input().split())
        x = s
        while x < t:
            x += d
        routes.append((i+1, x))
    
    routes.sort(key=lambda x: x[1])
    print(routes[0][0])

solve()
","
def solve():
    n, t = map(int, input().split())
    min_wait_time = float('inf')
    bus_route = 0

    for i in range(n):
        s, d = map(int, input().split())
        wait_time = s if s >= t else s + (t - s + d - 1) // d * d
        if wait_time < min_wait_time:
            min_wait_time = wait_time
            bus_route = i + 1

    return bus_route

solve()","
def solve():
    import random

    n, t = map(int, input().split())
    buses = []
    
    for _ in range(n):
        s, d = map(int, input().split())
        buses.append((s, d))

    min_diff = float('inf')
    bus_route = -1
    
    for i, (s, d) in enumerate(buses):
        if s >= t:
            diff = s - t
        else:
            diff = s + ((t - s + d - 1) // d) * d - t
        
        if diff < min_diff:
            min_diff = diff
            bus_route = i + 1
        elif diff == min_diff:
            if random.randint(0, 1) == 0:
                bus_route = i + 1
    
    return bus_route
  
solve()","
def solve():
    import random

    n, t = map(int, input().split())
    buses = [list(map(int, input().split())) for _ in range(n)]

    min_time = float('inf')
    bus_route = 0

    for i in range(n):
        s_i, d_i = buses[i]
        time = s_i if s_i >= t else s_i + ((t - s_i + d_i - 1) // d_i) * d_i
        if time < min_time:
            min_time = time
            bus_route = i + 1

    print(bus_route)

solve()
","
def solve():
    import sys

    n, t = map(int, input().split())
    buses = []
    
    for _ in range(n):
        s, d = map(int, input().split())
        buses.append((s, d))
    
    min_wait_time = float('inf')
    bus_route = 1
    
    for i, (s, d) in enumerate(buses):
        if s >= t:
            wait_time = s - t
        else:
            wait_time = (t - s) % d
        
        if wait_time < min_wait_time:
            min_wait_time = wait_time
            bus_route = i + 1
    
    print(bus_route)

solve()
  ","
def solve():
    import random

    n, t = map(int, input().split())
    routes = []
    for _ in range(n):
        s, d = map(int, input().split())
        route_time = s if s <= t else s + ((t - s + d - 1) // d) * d
        routes.append(route_time)

    min_time = min(routes)
    possible_routes = [i+1 for i, route_time in enumerate(routes) if route_time == min_time]
    
    print(random.choice(possible_routes))

solve()","
def solve():
    n, t = map(int, input().split())
    arr = []
    for _ in range(n):
        s, d = map(int, input().split())
        arr.append((s, d))
    
    min_time = float('inf')
    route = -1
    for i in range(n):
        s, d = arr[i]
        if s >= t:
            if s < min_time:
                min_time = s
                route = i + 1
        else:
            diff = t - s
            mod = diff % d
            if mod == 0:
                route = i + 1
                break

    print(route)

solve()
  ","
import random

def solve():
    n, t = map(int, input().split())
    min_time = float('inf')
    bus_route = None

    for i in range(n):
        s_i, d_i = map(int, input().split())
        time = s_i if s_i >= t else s_i + ((t - s_i + d_i - 1) // d_i) * d_i
        if time < min_time:
            min_time = time
            bus_route = i + 1
    print(bus_route)


solve()","
def solve():
    n, t = map(int, input().split())
    routes = []
    for _ in range(n):
        s_i, d_i = map(int, input().split())
        routes.append((s_i, d_i))

    min_time = float('inf')
    min_route = -1
    for idx, (s, d) in enumerate(routes):
        if s > t:
            time_diff = s - t
        else:
            time_diff = ((t - s) // d) * d + d - (t - s) % d
        if time_diff < min_time:
            min_time = time_diff
            min_route = idx + 1

    print(min_route)

solve()
  ","
def solve():
    n, t = map(int, input().split())
    best_route = 1
    min_wait_time = float('inf')

    for i in range(n):
        s, d = map(int, input().split())
        wait_time = 0 if t <= s else ((t - s + d - 1) // d) * d
        if wait_time < min_wait_time:
            min_wait_time = wait_time
            best_route = i + 1

    print(best_route)

# Input reading for user-input format
if __name__ == ""__main__"":
    solve()
  ","
def solve():
    n, t = map(int, input().split())
    routes = []
    
    for _ in range(n):
        s, d = map(int, input().split())
        curr_time = s
        
        while curr_time < t:
            curr_time += d
        
        routes.append(curr_time)
    
    min_time = min(routes)
    print(routes.index(min_time) + 1)

solve()","
def solve():
    import random
    
    n, t = map(int, input().split())
    routes = []
    
    for _ in range(n):
        s, d = map(int, input().split())
        routes.append((s, d))
    
    min_time = float('inf')
    bus_route = 1
    
    for idx, (start_time, interval) in enumerate(routes):
        if start_time > t:
            time_diff = start_time - t
        else:
            time_diff = ((t - start_time) % interval) + 1
        
        if time_diff < min_time:
            min_time = time_diff
            bus_route = idx + 1
        elif time_diff == min_time:
            if random.randint(0, 1) == 1:
                bus_route = idx + 1
    
    print(bus_route)

  
solve()","
def solve():
    n, t = map(int, input().split())
    ans, min_time = 1, float('inf')
    
    for i in range(n):
        s, d = map(int, input().split())
        if s >= t:
            time_diff = s - t
        else:
            time_diff = s + ((t - s + d - 1) // d) * d - t
        if time_diff < min_time:
            min_time = time_diff
            ans = i + 1
            
    print(ans)

# Input reading from user
solve()
","
def solve():
    n, t = map(int, input().split())
    route = 0
    min_time = float('inf')
    
    for i in range(n):
        s_i, d_i = map(int, input().split())
        if s_i >= t:
            if s_i < min_time:
                min_time = s_i
                route = i + 1
        else:
            wait_time = t - s_i
            delay = wait_time % d_i
            if delay == 0:
                route = i + 1
                break
    
    print(route)

# Input
n, t = map(int, input().split())
for _ in range(n):
    si, di = map(int, input().split())


solve()","
def solve():
    n, t = map(int, input().split())
    bus_routes = []
    for _ in range(n):
        s, d = map(int, input().split())
        bus_routes.append((s, d))

    min_time = float('inf')
    bus_num = 0
    for i, (s, d) in enumerate(bus_routes):
        time = s if s >= t else s + (t - s + d - 1) // d * d
        if time < min_time:
            min_time = time
            bus_num = i + 1

    return bus_num

solve()","100.0","100.0","0.0","0.0","100.0","53.333333333333336","46.666666666666664","40.0","100.0","80.0","60.0","100.0","40.0","100.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/260","
QUESTION:
One day, after a difficult lecture a diligent student Sasha saw a graffitied desk in the classroom. She came closer and read: ""Find such positive integer n, that among numbers n + 1, n + 2, ..., 2·n there are exactly m numbers which binary representation contains exactly k digits one"".

The girl got interested in the task and she asked you to help her solve it. Sasha knows that you are afraid of large numbers, so she guaranteed that there is an answer that doesn't exceed 10^18.


-----Input-----

The first line contains two space-separated integers, m and k (0 ≤ m ≤ 10^18; 1 ≤ k ≤ 64).


-----Output-----

Print the required number n (1 ≤ n ≤ 10^18). If there are multiple answers, print any of them.


-----Examples-----
Input
1 1

Output
1

Input
3 2

Output
5
Use user-input-Based format and function signature solve()","
def solve():
    m, k = map(int, input().split())
    n = 2 ** k - m
    print(n)

solve()
","
from math import log2

def solve():
    m, k = map(int, input().split())
    n = 1 << k
    while bin(n).count('1') != k:
        n += 1
    print(n)

solve()","
import math

def solve():
    m, k = map(int, input().split())
    n = (2**k - 1) * m
    print(n)

solve()
","
def solve():
    m, k = map(int, input().split())

    n = 1 << k
    n += m - 1

    print(n)

if __name__ == ""__main__"":
    solve()
","
def solve():
    m, k = map(int, input().split())
    n = (2 ** k - 1) * m
    print(n)

solve()
","
def solve():
    m, k = map(int, input().split())
    n = (2**k - 1) * m
    return n

solve()
","
def solve():
    m, k = map(int, input().split())
    
    n = 2**k - 1 + m
    print(n)

# Required imports
import sys

# User input
solve()
","
def solve():
    m, k = map(int, input().split())

    n = 1
    while True:
        count = 0
        for i in range(n+1, 2*n+1):
            if bin(i).count('1') == k:
                count += 1
        if count == m:
            return n
        n += 1

solve()","
def solve():
    m, k = map(int, input().split())
    n = (2**k - 1) * m
    print(n)

solve()
","
from math import log2, ceil

def solve():
    m, k = map(int, input().split())
    
    n = 2 ** (k-1)
    
    while bin(2*n)[2:].count('1') != m:
        n += 1
    
    print(n)

solve()","
def solve():
    m, k = map(int, input().split())
    
    if k == 1:
        n = 2 ** (m - 1)
    else:
        n = (2 ** k - 1) * (m + 1)
    
    return n

solve()
","
def solve():
    m, k = map(int, input().split())
    n = (2 ** k - 1) if m == 1 else (2 ** (k + 1) - 1) * (m - 1)
    print(n)

solve()
","
from math import log2

def solve():
    m, k = map(int, input().split())
    n = 2**k - 1 + m
    return n

solve()
","
def solve():
    m, k = map(int, input().split())

    count = 0
    n = 1
    while True:
        ones_count = bin(n).count('1')
        if ones_count == k:
            count += 1
        if count == m:
            return n
        n += 1

solve()
","
def solve():
    m, k = map(int, input().split())
    
    if m == 0:
        return 1
    
    n = 1 << k
    return (m - 1) * n + 1

solve()
","
def solve():
    m, k = map(int, input().split())
    n = 2 ** (k - 1) * m
    print(n)

solve()","6.666666666666667","11.11111111111111","6.666666666666667","0.0","6.666666666666667","0.0","0.0","0.0","6.666666666666667","71.42857142857143","0.0","6.666666666666667","0.0","0.0","0.0","20.0","","","","","","","","","","","","","","","",""
"APPS/261","
QUESTION:
In this problem you will meet the simplified model of game King of Thieves.

In a new ZeptoLab game called ""King of Thieves"" your aim is to reach a chest with gold by controlling your character, avoiding traps and obstacles on your way. [Image] 

An interesting feature of the game is that you can design your own levels that will be available to other players. Let's consider the following simple design of a level.

A dungeon consists of n segments located at a same vertical level, each segment is either a platform that character can stand on, or a pit with a trap that makes player lose if he falls into it. All segments have the same length, platforms on the scheme of the level are represented as '*' and pits are represented as '.'. 

One of things that affects speedrun characteristics of the level is a possibility to perform a series of consecutive jumps of the same length. More formally, when the character is on the platform number i_1, he can make a sequence of jumps through the platforms i_1 < i_2 < ... < i_{k}, if i_2 - i_1 = i_3 - i_2 = ... = i_{k} - i_{k} - 1. Of course, all segments i_1, i_2, ... i_{k} should be exactly the platforms, not pits. 

Let's call a level to be good if you can perform a sequence of four jumps of the same length or in the other words there must be a sequence i_1, i_2, ..., i_5, consisting of five platforms so that the intervals between consecutive platforms are of the same length. Given the scheme of the level, check if it is good.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 100) — the number of segments on the level.

Next line contains the scheme of the level represented as a string of n characters '*' and '.'.


-----Output-----

If the level is good, print the word ""yes"" (without the quotes), otherwise print the word ""no"" (without the quotes).


-----Examples-----
Input
16
.**.*..*.***.**.

Output
yes
Input
11
.*.*...*.*.

Output
no


-----Note-----

In the first sample test you may perform a sequence of jumps through platforms 2, 5, 8, 11, 14.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    level = input().strip()
    
    platforms = [i for i in range(n) if level[i] == '*']
    
    for i in range(len(platforms) - 4):
        if platforms[i+1] - platforms[i] == platforms[i+2] - platforms[i+1] == platforms[i+3] - platforms[i+2] == platforms[i+4] - platforms[i+3]:
            print(""yes"")
            return
    
    print(""no"")

solve()","
def solve():
    n = int(input())
    level = input().strip()
    
    for i in range(n-4):
        if level[i] == '*' and level[i+1] == '*' and level[i+2] == '*' and level[i+3] == '*' and level[i+4] == '*':
            print('yes')
            return
    print('no')

solve()
","
def solve():
    n = int(input())
    scheme = input()
    
    platform_indices = [i for i in range(n) if scheme[i] == '*']
    
    for i in range(len(platform_indices) - 4):
        if platform_indices[i+4] - platform_indices[i] == platform_indices[i+3] - platform_indices[i+1] == platform_indices[i+2] - platform_indices[i+1]:
            print(""yes"")
            return
    
    print(""no"")

solve()
","
def solve():
    n = int(input())
    segments = input().strip()
    
    platform_indices = [i for i in range(n) if segments[i] == '*']
    
    for i in range(len(platform_indices) - 4):
        if platform_indices[i + 1] - platform_indices[i] == platform_indices[i + 2] - platform_indices[i + 1] == platform_indices[i + 3] - platform_indices[i + 2] == platform_indices[i + 4] - platform_indices[i + 3]:
            print(""yes"")
            return
    
    print(""no"")
  
solve()","
def solve():
    n = int(input())
    level = input()

    for i in range(n - 4):
        if level[i] == '*' and level[i+1] == '*' and level[i+2] == '*' and level[i+3] == '*' and level[i+4] == '*':
            print(""yes"")
            return

    print(""no"")

solve()","
def solve():
    n = int(input())
    level = input()
    
    platforms = [i for i in range(n) if level[i] == '*']
    
    for i in range(len(platforms)):
        for j in range(i+1, len(platforms)):
            diff = platforms[j] - platforms[i]
            count = 2
            
            while platforms[j] + diff in platforms:
                count += 1
                platforms[j] += diff
            
            if count >= 5:
                print(""yes"")
                return
    
    print(""no"")

solve()
","
def solve():
    n = int(input())
    scheme = input().strip()
    
    platforms = [i for i in range(n) if scheme[i] == '*']
    
    for i in range(len(platforms)):
        for j in range(i + 1, len(platforms)):
            diff = platforms[j] - platforms[i]
            if (platforms[j] + diff in platforms) and (platforms[j] + 2*diff in platforms) and (platforms[j] + 3*diff in platforms):
                print(""yes"")
                return
    print(""no"")

solve()","
def solve():
    n = int(input())
    scheme = input()

    platforms = [i for i in range(n) if scheme[i] == '*']

    for i in range(len(platforms)):
        for j in range(i+1, len(platforms)):
            diff = platforms[j] - platforms[i]
            if platforms[j] + diff in platforms and platforms[j] + 2*diff in platforms and platforms[j] + 3*diff in platforms and platforms[j] + 4*diff in platforms:
                print(""yes"")
                return

    print(""no"")

solve()
","
def solve():
    n = int(input())
    level = input().strip()

    platforms = [i for i in range(n) if level[i] == '*']

    for i in range(len(platforms) - 4):
        diff = platforms[i+1] - platforms[i]
        if all(platforms[j+1] - platforms[j] == diff for j in range(i+1, i+4)):
            print(""yes"")
            return

    print(""no"")

solve()","
def solve():
    n = int(input())
    scheme = input()

    platforms = [i for i in range(n) if scheme[i] == '*']

    for i in range(len(platforms)-4):
        if platforms[i+4] - platforms[i] == platforms[i+3] - platforms[i+1] == platforms[i+2] - platforms[i+1] == platforms[i+1] - platforms[i]:
            print(""yes"")
            return
    
    print(""no"")

solve()
","
def solve():
    n = int(input())
    scheme = input()
    
    platforms = [idx for idx, char in enumerate(scheme) if char == '*']
    
    for i in range(len(platforms) - 4):
        if platforms[i+1] - platforms[i] == platforms[i+2] - platforms[i+1] == platforms[i+3] - platforms[i+2] == platforms[i+4] - platforms[i+3]:
            print(""yes"")
            return
    
    print(""no"")
  
solve()","
def solve():
    n = int(input())
    level = input()

    platforms = [i for i in range(n) if level[i] == '*']

    for i in range(len(platforms) - 3):
        for j in range(i + 3, len(platforms)):
            interval = platforms[j] - platforms[i]
            if all(platforms[k] - platforms[k - 1] == interval for k in range(i + 1, j)):
                print(""yes"")
                return
    
    print(""no"")

# Run the function
solve()
","
def solve():
    n = int(input())
    scheme = input()
    
    platforms = [i for i, val in enumerate(scheme) if val == '*']
    
    for i in range(len(platforms)):
        for j in range(i+1, len(platforms)):
            distance = platforms[j] - platforms[i]
            if platforms[j] + distance in platforms and platforms[j] + 2*distance in platforms and platforms[j] + 3*distance in platforms and platforms[j] + 4*distance in platforms:
                print(""yes"")
                return
    
    print(""no"")

solve()","
def solve():
    n = int(input())
    scheme = input()
    
    indices = [i for i in range(n) if scheme[i] == '*']

    if len(indices) < 5:
        print('no')
    else:
        diffs = [indices[i+1] - indices[i] for i in range(len(indices)-1)]
        
        for i in range(len(diffs)-3):
            if all(diff == diffs[i] for diff in diffs[i:i+4]):
                print('yes')
                return
        
        print('no')
  
solve()","
def solve():
    n = int(input())
    level_scheme = input().strip()
    
    for i in range(n):
        for j in range(i+1, n):
            if level_scheme[i] == '*' and level_scheme[j] == '*':
                diff = j - i
                if i + 4*diff < n and level_scheme[i+2*diff] == '*' and level_scheme[i+3*diff] == '*' and level_scheme[i+4*diff] == '*':
                    print(""yes"")
                    return
    print(""no"")

solve()","
def solve():
    n = int(input())
    level = input()

    platforms = [i for i, segment in enumerate(level) if segment == '*']

    for i in range(len(platforms)):
        for j in range(i+1, len(platforms)):
            diff = platforms[j] - platforms[i]
            if all(platforms[i] + diff*x == platforms[i+x] for x in range(1, 4)):
                print(""yes"")
                return

    print(""no"")

solve()
","80.0","60.0","13.333333333333334","80.0","60.0","100.0","100.0","73.33333333333333","80.0","13.333333333333334","80.0","13.333333333333334","73.33333333333333","80.0","100.0","86.66666666666667","","","","","","","","","","","","","","","",""
"APPS/262","
QUESTION:
ZS the Coder and Chris the Baboon arrived at the entrance of Udayland. There is a n × n magic grid on the entrance which is filled with integers. Chris noticed that exactly one of the cells in the grid is empty, and to enter Udayland, they need to fill a positive integer into the empty cell.

Chris tried filling in random numbers but it didn't work. ZS the Coder realizes that they need to fill in a positive integer such that the numbers in the grid form a magic square. This means that he has to fill in a positive integer so that the sum of the numbers in each row of the grid ($\sum a_{r, i}$), each column of the grid ($\sum a_{i, c}$), and the two long diagonals of the grid (the main diagonal — $\sum a_{i, i}$ and the secondary diagonal — $\sum a_{i, n - i + 1}$) are equal. 

Chris doesn't know what number to fill in. Can you help Chris find the correct positive integer to fill in or determine that it is impossible?


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 500) — the number of rows and columns of the magic grid.

n lines follow, each of them contains n integers. The j-th number in the i-th of them denotes a_{i}, j (1 ≤ a_{i}, j ≤ 10^9 or a_{i}, j = 0), the number in the i-th row and j-th column of the magic grid. If the corresponding cell is empty, a_{i}, j will be equal to 0. Otherwise, a_{i}, j is positive.

It is guaranteed that there is exactly one pair of integers i, j (1 ≤ i, j ≤ n) such that a_{i}, j = 0.


-----Output-----

Output a single integer, the positive integer x (1 ≤ x ≤ 10^18) that should be filled in the empty cell so that the whole grid becomes a magic square. If such positive integer x does not exist, output  - 1 instead.

If there are multiple solutions, you may print any of them.


-----Examples-----
Input
3
4 0 2
3 5 7
8 1 6

Output
9

Input
4
1 1 1 1
1 1 0 1
1 1 1 1
1 1 1 1

Output
1

Input
4
1 1 1 1
1 1 0 1
1 1 2 1
1 1 1 1

Output
-1



-----Note-----

In the first sample case, we can fill in 9 into the empty cell to make the resulting grid a magic square. Indeed, 

The sum of numbers in each row is:

4 + 9 + 2 = 3 + 5 + 7 = 8 + 1 + 6 = 15.

The sum of numbers in each column is:

4 + 3 + 8 = 9 + 5 + 1 = 2 + 7 + 6 = 15.

The sum of numbers in the two diagonals is:

4 + 5 + 6 = 2 + 5 + 8 = 15.

In the third sample case, it is impossible to fill a number in the empty square such that the resulting grid is a magic square.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    empty_row, empty_col = -1, -1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row, empty_col = i, j
                break
    
    if n == 1:
        print(1)
        return
    
    if empty_row == 0:
        row_sum = sum(grid[1])
    else:
        row_sum = sum(grid[0])
    
    col_sum = 0
    for i in range(n):
        col_sum += grid[i][empty_col]
    
    if empty_row == empty_col:
        diag1_sum = 0
        for i in range(n):
            diag1_sum += grid[i][i]
    else:
        diag1_sum = sum(grid[i][i] for i in range(n))
    
    if empty_row + empty_col == n - 1:
        diag2_sum = 0
        for i in range(n):
            diag2_sum += grid[i][n - i - 1]
    else:
        diag2_sum = sum(grid[i][n - i - 1] for i in range(n))
    
    x = row_sum - sum(grid[empty_row])
    
    if x <= 0:
        print(-1)
    else:
        grid[empty_row][empty_col] = x
        if sum(grid[empty_row]) == row_sum and col_sum == row_sum and diag1_sum == row_sum and diag2_sum == row_sum:
            print(x)
        else:
            print(-1)

solve()
","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]

    empty_row, empty_col = -1, -1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row, empty_col = i, j

    row_sum = sum(grid[empty_row])
    col_sum = sum([grid[i][empty_col] for i in range(n)])

    if empty_row == empty_col:
        diagonal_sum1 = sum([grid[i][i] for i in range(n)])
        diagonal_sum2 = sum([grid[i][n - i - 1] for i in range(n)])
        x = row_sum - diagonal_sum1
    elif empty_row + empty_col == n - 1:
        diagonal_sum1 = sum([grid[i][i] for i in range(n)])
        diagonal_sum2 = sum([grid[i][n - i - 1] for i in range(n)])
        x = row_sum - diagonal_sum2
    else:
        x = -1

    return x

solve()","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    def check_magic_square(num):
        row_sums = [sum(row) if num == 0 else sum(row) + num for row in grid]
        col_sums = [sum(col) if num == 0 else sum(col) + num for col in zip(*grid)]
        diagonal_sum = sum(grid[i][i] for i in range(n)) if num == 0 else sum(grid[i][i] for i in range(n)) + num
        reverse_diagonal_sum = sum(grid[i][n - i - 1] for i in range(n)) if num == 0 else sum(grid[i][n - i - 1] for i in range(n)) + num
        
        if len(set(row_sums)) == 1 and len(set(col_sums)) == 1 and diagonal_sum == row_sums[0] and reverse_diagonal_sum == row_sums[0]:
            return row_sums[0]
        else:
            return -1
    
    filled_number = check_magic_square(0)
    print(filled_number)

solve()
","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    empty_row, empty_col = None, None

    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row, empty_col = i, j
                break

    total = sum(grid[empty_row]) if empty_row != empty_col else sum(grid[i][empty_col] for i in range(n))
    filled_sum = sum(row for i, row in enumerate(grid) if i != empty_row)

    x = max(1, total - filled_sum)
    
    if sum(row[empty_col] for row in grid) == total - filled_sum:
        print(x)
    else:
        print(-1)

solve()
","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    empty_row, empty_col = -1, -1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row, empty_col = i, j
    
    row_sum = sum(grid[empty_row])
    col_sum = sum(row[empty_col] for row in grid)
    
    if empty_row == empty_col:
        diag1_sum = sum(grid[i][i] for i in range(n))
        if row_sum != col_sum != diag1_sum:
            print(-1)
            return
    
    if empty_row + empty_col == n - 1:
        diag2_sum = sum(grid[i][n - i - 1] for i in range(n))
        if row_sum != col_sum != diag2_sum:
            print(-1)
            return
    
    candidate_sum = max(row_sum, col_sum)
    if empty_row == empty_col:
        candidate_sum = max(candidate_sum, diag1_sum)
    if empty_row + empty_col == n - 1:
        candidate_sum = max(candidate_sum, diag2_sum)
    
    x = candidate_sum - sum(grid[empty_row])
    print(x)

solve()
","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    empty_row, empty_col = -1, -1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row, empty_col = i, j
    
    row_sum = sum(grid[empty_row][col] for col in range(n) if col != empty_col)
    col_sum = sum(grid[row][empty_col] for row in range(n) if row != empty_row)
    
    if empty_row == empty_col:
        diag1_sum = sum(grid[i][i] for i in range(n) if i != empty_row)
    else:
        diag1_sum = 0
    
    if empty_row == n - empty_col - 1:
        diag2_sum = sum(grid[i][n - i - 1] for i in range(n) if i != empty_row)
    else:
        diag2_sum = 0
    
    x_candidate = max(row_sum, col_sum, diag1_sum, diag2_sum) - sum(grid[empty_row])
    
    if x_candidate <= 0:
        print(-1)
    else:
        print(x_candidate)
  
solve()","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    empty_row, empty_col = -1, -1
    target_sum = -1
    
    for i in range(n):
        row_sum = sum(grid[i])
        if 0 in grid[i]:
            empty_row = i
            target_sum = row_sum
            col_sum = sum([grid[j][empty_row] for j in range(n)])
            break
    
    row_sum = 0
    
    for j in range(n):
        row_sum += grid[j][empty_col]
    
    missing_num = target_sum - row_sum
    
    if missing_num <= 0:
        print(-1)
        return
    
    grid[empty_row][empty_col] = missing_num
    
    for i in range(n):
        if sum(grid[i]) != target_sum:
            print(-1)
            return
    
    for j in range(n):
        col_sum = sum([grid[i][j] for i in range(n)])
        if col_sum != target_sum:
            print(-1)
            return
    
    diag1_sum = sum([grid[i][i] for i in range(n)])
    diag2_sum = sum([grid[i][n - i - 1] for i in range(n)])
    
    if diag1_sum != target_sum or diag2_sum != target_sum:
        print(-1)
        return
    
    print(missing_num)

solve()
","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]

    empty_i, empty_j = None, None
    row_sums = [sum(row) for row in grid]
    col_sums = [sum(col) for col in zip(*grid)]
    diag1_sum = sum(grid[i][i] for i in range(n))
    diag2_sum = sum(grid[i][n-i-1] for i in range(n))

    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_i, empty_j = i, j
                break

    possible_values = set()
    if empty_i is not None and empty_j is not None:
        possible_values.add(max(1, row_sums[empty_i] - col_sums[empty_j]))
        possible_values.add(max(1, col_sums[empty_j] - row_sums[empty_i]))
        possible_values.add(max(1, diag1_sum - row_sums[empty_i]))
        possible_values.add(max(1, diag2_sum - row_sums[empty_i]))

        if len(possible_values) == 1:
            print(possible_values.pop())
        else:
            print(-1)

solve()","
def solve():
    pass

solve()","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    empty_row, empty_col = -1, -1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row, empty_col = i, j
    
    target_sum = sum(grid[empty_row]) if empty_col == 0 else sum(grid[empty_row][:empty_col] + grid[empty_row][empty_col+1:])
    
    diag_sum = sum(grid[i][i] for i in range(n))
    anti_diag_sum = sum(grid[i][n-i-1] for i in range(n))
    
    if empty_row == empty_col:
        grid[empty_row][empty_col] = target_sum - diag_sum
    elif empty_row + empty_col == n - 1:
        grid[empty_row][empty_col] = target_sum - anti_diag_sum
    else:
        grid[empty_row][empty_col] = 1
    
    for row in grid:
        if sum(row) != target_sum:
            print(-1)
            return
    
    for col in range(n):
        if sum(grid[i][col] for i in range(n)) != target_sum:
            print(-1)
            return
    
    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n-i-1] for i in range(n)) != target_sum:
        print(-1)
        return
    
    print(grid[empty_row][empty_col])

solve()
","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    
    empty_row, empty_col = None, None
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row, empty_col = i, j
                break
    
    row_sum = sum(grid[empty_row])
    col_sum = sum(grid[i][empty_col] for i in range(n))
    
    if empty_row == empty_col:
        diag1_sum = sum(grid[i][i] for i in range(n))
    if empty_row + empty_col == n - 1:
        diag2_sum = sum(grid[i][n-i-1] for i in range(n))
    
    x = max(row_sum, col_sum)
    if empty_row == empty_col:
        x = max(x, diag1_sum)
    if empty_row + empty_col == n - 1:
        x = max(x, diag2_sum)

    print(x - sum(row_sum - grid[empty_row][empty_col]))
  
solve()","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]

    empty_row = None
    empty_col = None
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_row = i
                empty_col = j
                break

    sum_row = sum(grid[empty_row])
    sum_col = sum(row[empty_col] for row in grid)

    if empty_row == empty_col:
        sum_diag1 = sum(grid[i][i] for i in range(n))
        if sum_row == sum_col == sum_diag1:
            print(sum_diag1 - sum_row)
        else:
            print(-1)
    elif empty_row + empty_col == n - 1:
        sum_diag2 = sum(grid[i][n - i - 1] for i in range(n))
        if sum_row == sum_col == sum_diag2:
            print(sum_diag2 - sum_row)
        else:
            print(-1)
    else:
        print(-1)

solve()
","
def solve():
    n = int(input())
    magic_grid = []
    for _ in range(n):
        row = list(map(int, input().split()))
        magic_grid.append(row)

    empty_row = 0
    empty_col = 0
    for i in range(n):
        for j in range(n):
            if magic_grid[i][j] == 0:
                empty_row = i
                empty_col = j
    
    if n == 1:
        return 1
    
    if empty_row == 0:
        row_sum = sum(magic_grid[1])
    else:
        row_sum = sum(magic_grid[0])
    
    placeholder = row_sum - sum(magic_grid[empty_row])
    
    diag_sum = 0
    sec_diag_sum = 0
    for i in range(n):
        diag_sum += magic_grid[i][i]
        sec_diag_sum += magic_grid[i][n-i-1]
    
    if empty_row == empty_col:
        diag_sum += placeholder
    if empty_row + empty_col == n - 1:
        sec_diag_sum += placeholder
    
    if row_sum == sec_diag_sum == diag_sum:
        return placeholder
    else:
        return -1
  
solve()","
def solve():
    n = int(input())
    grid = [list(map(int, input().split())) for _ in range(n)]
    empty_i, empty_j = -1, -1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 0:
                empty_i, empty_j = i, j

    target_sum = sum(grid[empty_i])
    row_sum = sum(grid[empty_i][:empty_j] + grid[empty_i][empty_j + 1:])
    target_num = target_sum - row_sum

    if target_sum == sum(grid[(empty_i - 1) % n]) and target_sum == sum(grid[(empty_i + 1) % n]) and \
            target_sum == sum(row[empty_j] for row in grid) and target_sum == sum(row[empty_j] for row in grid):
        print(target_num)
    else:
        print(-1)

solve()","
def solve():
    n = int(input())
    magic_grid = [list(map(int, input().split())) for _ in range(n)]
    
    empty_row, empty_col = -1, -1
    for i in range(n):
        for j in range(n):
            if magic_grid[i][j] == 0:
                empty_row, empty_col = i, j
    
    if n == 1:
        print(1)
    else:
        row_sum = sum(magic_grid[empty_row]) - magic_grid[empty_row][empty_col]
        col_sum = sum(row[empty_col] for row in magic_grid) - magic_grid[empty_row][empty_col]
        
        main_diag_sum = sum(magic_grid[i][i] for i in range(n)) if empty_row != empty_col else 0
        sec_diag_sum = sum(magic_grid[i][n - i - 1] for i in range(n)) if empty_row + empty_col != n - 1 else 0
        
        x = max(row_sum, col_sum, main_diag_sum, sec_diag_sum)
        
        for i in range(n):
            if i != empty_row:
                if x != sum(magic_grid[i]):
                    x = -1
                    break
                if x != sum(row[i] for row in magic_grid):
                    x = -1
                    break
        
        if x == 0:
            x = 1
        print(x)

solve()
","
def solve():
    pass

# Input
n = int(input())
magic_grid = [list(map(int, input().split())) for _ in range(n)]

# Function Implementation
def is_magic_square(grid):
    n = len(grid)
    row_sums = [sum(row) for row in grid]
    col_sums = [sum(col) for col in zip(*grid)]
    diagonal_sum_1 = sum(grid[i][i] for i in range(n))
    diagonal_sum_2 = sum(grid[i][n - i - 1] for i in range(n))

    if len(set(row_sums + col_sums + [diagonal_sum_1, diagonal_sum_2])) == 1:
        return True
    return False

empty_cell = [(i, j) for i in range(n) for j in range(n) if magic_grid[i][j] == 0][0]

def find_magic_number(empty_cell, grid):
    temp_grid = [row[:] for row in grid]
    magic_number = 1

    while True:
        temp_grid[empty_cell[0]][empty_cell[1]] = magic_number
        if is_magic_square(temp_grid):
            return magic_number
        magic_number += 1

        if magic_number > 10**18:
            break

    return -1

output = find_magic_number(empty_cell, magic_grid)
print(output)

solve()","53.333333333333336","0.0","40.0","6.666666666666667","6.666666666666667","20.0","46.666666666666664","53.333333333333336","0.0","46.666666666666664","0.0","33.33333333333333","0.0","40.0","40.0","100.0","","","","","","","","","","","","","","","",""
"APPS/263","
QUESTION:
There are $n$ benches in the Berland Central park. It is known that $a_i$ people are currently sitting on the $i$-th bench. Another $m$ people are coming to the park and each of them is going to have a seat on some bench out of $n$ available.

Let $k$ be the maximum number of people sitting on one bench after additional $m$ people came to the park. Calculate the minimum possible $k$ and the maximum possible $k$.

Nobody leaves the taken seat during the whole process.


-----Input-----

The first line contains a single integer $n$ $(1 \le n \le 100)$ — the number of benches in the park.

The second line contains a single integer $m$ $(1 \le m \le 10\,000)$ — the number of people additionally coming to the park.

Each of the next $n$ lines contains a single integer $a_i$ $(1 \le a_i \le 100)$ — the initial number of people on the $i$-th bench.


-----Output-----

Print the minimum possible $k$ and the maximum possible $k$, where $k$ is the maximum number of people sitting on one bench after additional $m$ people came to the park.


-----Examples-----
Input
4
6
1
1
1
1

Output
3 7

Input
1
10
5

Output
15 15

Input
3
6
1
6
5

Output
6 12

Input
3
7
1
6
5

Output
7 13



-----Note-----

In the first example, each of four benches is occupied by a single person. The minimum $k$ is $3$. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining — the fourth bench. The maximum $k$ is $7$. That requires all six new people to occupy the same bench.

The second example has its minimum $k$ equal to $15$ and maximum $k$ equal to $15$, as there is just a single bench in the park and all $10$ people will occupy it.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    m = int(input())
    a = [int(input()) for _ in range(n)]
    
    min_k = max(max(a), (sum(a) + m + n - 1) // n)
    max_k = max(a) + m
    
    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    
    bench_list = [int(input()) for _ in range(n)]
    min_k = max(max(bench_list), (sum(bench_list) + m + n - 1) // n)
    max_k = max(bench_list) + m

    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    a = [int(input()) for _ in range(n)]

    min_k = max(max(a), (sum(a) + m + n - 1) // n)
    max_k = max(a) + m

    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    
    initial_people = [int(input()) for _ in range(n)]
    
    min_k = max(max(initial_people), (sum(initial_people) + m + n - 1) // n)
    max_k = max(initial_people) + m
    
    print(min_k, max_k)

solve()
","
from typing import List

def solve() -> None:
    n = int(input())
    m = int(input())
    a = [int(input()) for _ in range(n)]

    min_k = max(max(a), (sum(a) + m + n - 1) // n)
    max_k = max(max(a) + m, max(a) + m)

    print(min_k, max_k)


solve()","
def solve():
    n = int(input())
    m = int(input())
    bench_people = [int(input()) for _ in range(n)]
    
    min_k = max(max(bench_people), (sum(bench_people) + m + n - 1) // n)
    max_k = max(bench_people) + m
    
    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    initial_people = [int(input()) for _ in range(n)]
    
    min_possible_k = max(max(initial_people), (sum(initial_people) + m + n - 1) // n)
    max_possible_k = max(initial_people) + m
    
    print(min_possible_k, max_possible_k)

solve()
  ","
def solve():
    n = int(input())
    m = int(input())
    a = [int(input()) for _ in range(n)]

    min_k = max(max(a), (sum(a) + m + n - 1) // n)
    max_k = max(a) + m

    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    
    bench_people = []
    for _ in range(n):
        bench_people.append(int(input()))
    
    min_k = max(max(bench_people), (sum(bench_people) + m + n - 1) // n)
    max_k = max(bench_people) + m
    
    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    people_on_benches = [int(input()) for _ in range(n)]
    
    min_k = max(max(people_on_benches), (sum(people_on_benches) + m + n - 1) // n)
    max_k = max(max(people_on_benches) + m, max(people_on_benches) + m)
    
    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    
    initial_people = [int(input()) for _ in range(n)]
    
    min_k = max(max(initial_people), (sum(initial_people) + m + n - 1) // n)
    max_k = max(initial_people) + m
    
    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    benches = [int(input()) for _ in range(n)]

    min_k = max(max(benches), (sum(benches) + m + n - 1) // n)
    max_k = max(max(benches) + m, max(benches) + m)

    print(min_k, max_k)

solve()","
def solve():
    n = int(input())
    m = int(input())
    initial_people = [int(input()) for _ in range(n)]
    
    min_k = max(max(initial_people), (sum(initial_people) + m + n - 1) // n)
    max_k = max(initial_people) + m
    
    print(min_k, max_k)

solve()","
def solve():
    n = int(input())
    m = int(input())
    bench_list = []
    for i in range(n):
        bench_list.append(int(input()))
    
    min_k = max(max(bench_list), (sum(bench_list) + m + n - 1) // n)
    max_k = max(bench_list) + m
    
    print(min_k, max_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    initial_people = [int(input()) for _ in range(n)]

    max_possible_k = max(initial_people) + m
    min_possible_k = max((sum(initial_people) + m + n - 1) // n, max(initial_people))

    print(min_possible_k, max_possible_k)

solve()
","
def solve():
    n = int(input())
    m = int(input())
    benches = [int(input()) for _ in range(n)]
    
    min_k = max(max(benches), (sum(benches) + m + n - 1) // n)
    max_k = max(benches) + m
    
    print(min_k, max_k)

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/264","
QUESTION:
There is an airplane which has n rows from front to back. There will be m people boarding this airplane.

This airplane has an entrance at the very front and very back of the plane.

Each person has some assigned seat. It is possible for multiple people to have the same assigned seat. The people will then board the plane one by one starting with person 1. Each person can independently choose either the front entrance or back entrance to enter the plane.

When a person walks into the plane, they walk directly to their assigned seat and will try to sit in it. If it is occupied, they will continue walking in the direction they walked in until they are at empty seat - they will take the earliest empty seat that they can find. If they get to the end of the row without finding a seat, they will be angry.

Find the number of ways to assign tickets to the passengers and board the plane without anyone getting angry. Two ways are different if there exists a passenger who chose a different entrance in both ways, or the assigned seat is different. Print this count modulo 10^9 + 7.


-----Input-----

The first line of input will contain two integers n, m (1 ≤ m ≤ n ≤ 1 000 000), the number of seats, and the number of passengers, respectively.


-----Output-----

Print a single number, the number of ways, modulo 10^9 + 7.


-----Example-----
Input
3 3

Output
128



-----Note-----

Here, we will denote a passenger by which seat they were assigned, and which side they came from (either ""F"" or ""B"" for front or back, respectively).

For example, one valid way is 3B, 3B, 3B (i.e. all passengers were assigned seat 3 and came from the back entrance). Another valid way would be 2F, 1B, 3F.

One invalid way would be 2B, 2B, 2B, since the third passenger would get to the front without finding a seat.
Use user-input-Based format and function signature solve()","
def solve():
    MOD = 10**9 + 7

    n, m = map(int, input().split())

    fact = [1] * (n + m + 1)
    for i in range(2, n + m + 1):
        fact[i] = (fact[i - 1] * i) % MOD

    inv_fact = [1] * (n + m + 1)
    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)
    for i in range(n + m - 1, 1, -1):
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

    def nCr(n, r):
        return (fact[n] * inv_fact[r] * inv_fact[n - r]) % MOD

    ans = 0
    for i in range(1, n + 1):
        ans = (ans + nCr(n + m - i, m - 1) * nCr(i - 1, 1)) % MOD

    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, m = map(int, input().split())
    
    dp = [0] * (n + 1)
    dp[0] = 1
    
    for i in range(1, n + 1):
        dp[i] = (dp[i - 1] * 2) % MOD
    
    for _ in range(m):
        p, s = map(str, input().split())
        p = int(p)
        if s == 'F':
            dp[p] = dp[p - 1]
        else:
            dp[p] = (dp[n] - dp[p - 1] + MOD) % MOD
    
    print(dp[n])

solve()
  ","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    ans = 1
    for i in range(m):
        ans = (ans * 2) % MOD
    for i in range(2, n):
        ans = (ans * i) % MOD
    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, m = map(int, input().split())
    
    fact = [1] * (m+1)
    for i in range(1, m+1):
        fact[i] = fact[i-1] * i % MOD
    
    def power(x, y):
        res = 1
        while y:
            if y % 2 == 1:
                res = res * x % MOD
            x = x * x % MOD
            y //= 2
        return res
    
    def C(n, r):
        return fact[n] * power(fact[r] * fact[n-r] % MOD, MOD-2) % MOD
    
    ans = 0
    for i in range(m+1):
        coeff = C(m, i) * power(2, m-i) % MOD
        if i % 2 == 0:
            ans += coeff * power(n-1, m-i) % MOD
        else:
            ans -= coeff * power(n-1, m-i) % MOD
    ans = (ans % MOD + MOD) % MOD

    print(ans)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, m = map(int, input().split())
    
    fact = [1] * (m+1)
    for i in range(1, m+1):
        fact[i] = (fact[i-1] * i) % MOD
    
    inv_fact = [1] * (m+1)
    inv_fact[m] = pow(fact[m], MOD-2, MOD)
    for i in range(m-1, 0, -1):
        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD
    
    def nCr(n, r):
        return (fact[n] * inv_fact[r] * inv_fact[n-r]) % MOD
    
    ans = 0
    for i in range(1, n+1):
        ans += nCr(m-1+i, i-1) * nCr(n-1, i-1)
        ans %= MOD
    
    print(ans)

solve()
","
MOD = 10**9 + 7

def solve():
    n, m = map(int, input().split())
    
    # Calculate the number of ways to assign tickets to passengers without anyone getting angry
    result = 1
    for i in range(m):
        result = (result * (n - i) * 2) % MOD
    
    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, m = map(int, input().split())
    
    def power(x, y):
        res = 1
        while y:
            if y % 2:
                res = (res * x) % MOD
            x = (x * x) % MOD
            y //= 2
        return res
    
    def comb(n, k):
        n_fact = 1
        for i in range(1, n + 1):
            n_fact = (n_fact * i) % MOD
        k_fact = 1
        for i in range(1, k + 1):
            k_fact = (k_fact * i) % MOD
        n_k_fact = 1
        for i in range(1, n - k + 1):
            n_k_fact = (n_k_fact * i) % MOD
        return (n_fact * power(k_fact, MOD - 2) * power(n_k_fact, MOD - 2)) % MOD
    
    result = comb(n, n - m) * power(2, m) % MOD
    print(result)

solve()
","
def solve():
    MOD = 10 ** 9 + 7

    n, m = map(int, input().split())

    def power(a, b):
        if b == 0:
            return 1
        if b % 2 == 0:
            return power(a, b // 2) ** 2 % MOD
        else:
            return a * power(a, b - 1) % MOD

    fact = [1]
    for i in range(1, m + 1):
        fact.append(fact[-1] * i % MOD)

    result = 0
    for i in range(min(n, m) + 1):
        coeff = fact[m] * power(fact[i] * fact[m - i], MOD - 2) % MOD
        add = coeff * power(2, m - i) % MOD * power(2, max(0, n - m) + i) % MOD
        if i % 2 == 0:
            result += add
        else:
            result -= add
        result %= MOD

    result *= fact[n] * power(fact[n - min(n, m)], MOD - 2) * power(fact[m], MOD - 2)
    result %= MOD

    print(result)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    
    def power(x, y):
        result = 1
        while y > 0:
            if y % 2 == 1:
                result = (result * x) % MOD
            x = (x * x) % MOD
            y //= 2
        return result
    
    result = power(2, m) - 1
    result = power(result, n)
    
    print(result)

solve()","
def solve():
    MOD = 10**9 + 7

    n, m = map(int, input().split())

    dp = [1] * (n + 1)

    for i in range(2, n + 1):
        dp[i] = (dp[i-1] + dp[i-2]) % MOD

    result = dp[n]
    result = (result * 2) % MOD

    for i in range(2, m):
        result = (result * i) % MOD

    print(result)

solve()
","
def solve():
    MOD = 10**9 + 7
    n, m = map(int, input().split())
    
    def power(x, y):
        res = 1
        while y > 0:
            if y % 2 == 1:
                res = (res * x) % MOD
            x = (x * x) % MOD
            y //= 2
        return res
    
    def nCr(n, r):
        if r == 0 or r == n:
            return 1
        if r > n - r:
            return nCr(n, n - r)
        numerator = denominator = 1
        for i in range(r):
            numerator = (numerator * (n - i)) % MOD
            denominator = (denominator * (i + 1)) % MOD
        return (numerator * power(denominator, MOD - 2)) % MOD
    
    ans = 1
    for i in range(m):
        ans = (ans * nCr(n-1+i, i)) % MOD
    ans = (ans * power(2, m) - 1) % MOD
    
    print(ans)

solve()
","
def solve():
    mod = 10**9 + 7
    n, m = map(int, input().split())
    fact = [1] * (m + 1)
    for i in range(1, m + 1):
        fact[i] = (fact[i - 1] * i) % mod
    
    inv = [1] * (m + 1)
    for i in range(2, m + 1):
        inv[i] = (mod - (mod // i) * inv[mod % i] % mod) % mod
    
    inv_fact = [1] * (m + 1)
    for i in range(1, m + 1):
        inv_fact[i] = (inv_fact[i - 1] * inv[i]) % mod
    
    def power(x, y):
        res = 1
        while y:
            if y & 1:
                res = (res * x) % mod
            x = (x * x) % mod
            y >>= 1
        return res
    
    ans = 0
    for i in range(m + 1):
        cur = 0
        cur = (cur + fact[m] * inv_fact[i] % mod * inv_fact[m - i] % mod) % mod
        cur = (cur * power(2, n - 1)) % mod
        if i % 2 == 0:
            ans = (ans + cur) % mod
        else:
            ans = (ans - cur + mod) % mod
    print(ans)

solve()
  ","
def solve():
    MOD = 10**9 + 7

    n, m = map(int, input().split())
    
    ans = 1
    for i in range(m):
        ans = (ans * (n - 1 + i) % MOD) % MOD
    print(ans)

solve()
","
MOD = 10**9 + 7

def solve():
    n, m = map(int, input().split())

    def mod_pow(base, exp):
        result = 1
        base %= MOD

        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % MOD

            exp //= 2
            base = (base * base) % MOD

        return result

    def nCr(n, r):
        numerator = 1
        denominator = 1

        for i in range(r):
            numerator = (numerator * (n - i)) % MOD
            denominator = (denominator * (i + 1)) % MOD

        return (numerator * mod_pow(denominator, MOD - 2)) % MOD

    ways = nCr(n, m) * mod_pow(2, m) % MOD
    print(ways)

solve()
  ","
def solve():
    MOD = 10**9 + 7
    
    n, m = map(int, input().split())

    def power(x, y):
        result = 1
        while y > 0:
            if y % 2 == 1:
                result = (result * x) % MOD
            y //= 2
            x = (x * x) % MOD
        return result

    def mul(a, b):
        return (a * b) % MOD

    if m < n:
        print(power(2, m) * 2 % MOD)
    elif m == n:
        print(power(2, m))
    else:
        print(0)

solve()
","
def solve():
    MOD = 10**9 + 7
    
    n, m = map(int, input().split())
    
    fact = [1] * (n + m + 1)
    for i in range(1, n + m + 1):
        fact[i] = fact[i - 1] * i % MOD
    
    def inv(x):
        return pow(x, MOD - 2, MOD)
    
    def choose(n, r):
        return fact[n] * inv(fact[r]) * inv(fact[n - r]) % MOD
    
    ans = 0
    for i in range(m + 1):
        ans = (ans + choose(n + m - i - 1, m - i) * choose(m, i)) % MOD
    
    print(ans)

solve()
  ","0.0","0.0","6.666666666666667","0.0","0.0","13.333333333333334","13.333333333333334","0.0","0.0","6.666666666666667","0.0","0.0","0.0","13.333333333333334","6.666666666666667","7.142857142857142","","","","","","","","","","","","","","","",""
"APPS/265","
QUESTION:
A company of $n$ friends wants to order exactly two pizzas. It is known that in total there are $9$ pizza ingredients in nature, which are denoted by integers from $1$ to $9$.

Each of the $n$ friends has one or more favorite ingredients: the $i$-th of friends has the number of favorite ingredients equal to $f_i$ ($1 \le f_i \le 9$) and your favorite ingredients form the sequence $b_{i1}, b_{i2}, \dots, b_{if_i}$ ($1 \le b_{it} \le 9$).

The website of CodePizza restaurant has exactly $m$ ($m \ge 2$) pizzas. Each pizza is characterized by a set of $r_j$ ingredients $a_{j1}, a_{j2}, \dots, a_{jr_j}$ ($1 \le r_j \le 9$, $1 \le a_{jt} \le 9$) , which are included in it, and its price is $c_j$.

Help your friends choose exactly two pizzas in such a way as to please the maximum number of people in the company. It is known that a person is pleased with the choice if each of his/her favorite ingredients is in at least one ordered pizza. If there are several ways to choose two pizzas so as to please the maximum number of friends, then choose the one that minimizes the total price of two pizzas.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($1 \le n \le 10^5, 2 \le m \le 10^5$) — the number of friends in the company and the number of pizzas, respectively.

Next, the $n$ lines contain descriptions of favorite ingredients of the friends: the $i$-th of them contains the number of favorite ingredients $f_i$ ($1 \le f_i \le 9$) and a sequence of distinct integers $b_{i1}, b_{i2}, \dots, b_{if_i}$ ($1 \le b_{it} \le 9$).

Next, the $m$ lines contain pizza descriptions: the $j$-th of them contains the integer price of the pizza $c_j$ ($1 \le c_j \le 10^9$), the number of ingredients $r_j$ ($1 \le r_j \le 9$) and the ingredients themselves as a sequence of distinct integers $a_{j1}, a_{j2}, \dots, a_{jr_j}$ ($1 \le a_{jt} \le 9$).


-----Output-----

Output two integers $j_1$ and $j_2$ ($1 \le j_1,j_2 \le m$, $j_1 \ne j_2$) denoting the indices of two pizzas in the required set. If there are several solutions, output any of them. Pizza indices can be printed in any order.


-----Examples-----
Input
3 4
2 6 7
4 2 3 9 5
3 2 3 9
100 1 7
400 3 3 2 5
100 2 9 2
500 3 2 9 5

Output
2 3

Input
4 3
1 1
1 2
1 3
1 4
10 4 1 2 3 4
20 4 1 2 3 4
30 4 1 2 3 4

Output
1 2

Input
1 5
9 9 8 7 6 5 4 3 2 1
3 4 1 2 3 4
1 4 5 6 7 8
4 4 1 3 5 7
1 4 2 4 6 8
5 4 1 9 2 8

Output
2 4
Use user-input-Based format and function signature solve()","
def solve():
    n, m = map(int, input().split())
    friends = [list(map(int, input().split()))[1:] for _ in range(n)]
    pizzas = [list(map(int, input().split()))[1:] for _ in range(m)]
    
    ingredients_map = {i: set() for i in range(1, 10)}
    for idx, ingredients in enumerate(pizzas, start=1):
        for ingredient in ingredients[1:]:
            ingredients_map[ingredient].add(idx)
    
    friends_count = {i: 0 for i in range(1, m+1)}
    for idx, fav_ingredients in enumerate(friends, start=1):
        for ingredient in fav_ingredients:
            for pizza_idx in ingredients_map[ingredient]:
                friends_count[pizza_idx] += 1
    
    best_pizzas = sorted(friends_count.items(), key=lambda x: (-x[1], pizzas[x[0]-1][0]))
    
    print(best_pizzas[0][0], best_pizzas[1][0])

solve()
","
def solve():
    n, m = map(int, input().split())
    friends = []
    for _ in range(n):
        f, *fav = map(int, input().split())
        friends.append(set(fav))

    pizzas = []
    for i in range(m):
        c, r, *ing = map(int, input().split())
        pizzas.append((c, set(ing), i+1))

    pizzas.sort()

    ans = []
    max_friends = 0
    for i in range(m-1):
        for j in range(i+1, m):
            combined_ing = pizzas[i][1].union(pizzas[j][1])
            total_friends = sum(1 for friend in friends if any(fav in combined_ing for fav in friend))
            if total_friends > max_friends:
                ans = [pizzas[i][2], pizzas[j][2]]
                max_friends = total_friends
            elif total_friends == max_friends and sum(map(lambda x: x[0], [pizzas[i], pizzas[j]])) < sum(map(lambda x: x[0], [pizzas[ans[0]-1], pizzas[ans[1]-1])):
                ans = [pizzas[i][2], pizzas[j][2]]

    print(*ans)

import sys

lines = sys.stdin.read().strip().split('\n')
input = iter(lines).__next__

solve()
","
def solve():
    import sys

    n, m = map(int, sys.stdin.readline().strip().split())
    friends = [list(map(int, sys.stdin.readline().strip().split()))[1:] for _ in range(n)]
    pizzas = [list(map(int, sys.stdin.readline().strip().split()))[1:] for _ in range(m)]
    
    favorite_ingredients = set()
    for friend in friends:
        favorite_ingredients.update(friend)
    
    min_price = float('inf')
    solution = (0, 0)
    
    for i in range(m-1):
        for j in range(i+1, m):
            ingredients_union = set(pizzas[i][1:]) | set(pizzas[j][1:])
            if len(favorite_ingredients.intersection(ingredients_union)) == len(favorite_ingredients):
                total_price = pizzas[i][0] + pizzas[j][0]
                if total_price < min_price:
                    min_price = total_price
                    solution = (i+1, j+1)
    
    print(solution[0], solution[1])

solve()
","
def solve():
    n, m = map(int, input().split())
    favorite_ingredients = [set(map(int, input().split()[1:])) for _ in range(n)]
    pizzas = [list(map(int, input().split())) for _ in range(m)]

    friends_counts = [0] * m
    for friend in favorite_ingredients:
        for i, pizza in enumerate(pizzas):
            if any(ingredient in friend for ingredient in pizza[2:]):
                friends_counts[i] += 1

    best_pizzas = sorted(range(m), key=lambda x: (-friends_counts[x], pizzas[x][0]))

    print(best_pizzas[0] + 1, best_pizzas[1] + 1)

solve()
","
def solve():
    import heapq

    n, m = map(int, input().split())
    favorites = [list(map(int, input().split()))[1:] for _ in range(n)]
    pizzas = [list(map(int, input().split()))[1:] for _ in range(m)]

    ing_dict = {}
    for i in range(m):
        for ing in pizzas[i][1:]:
            if ing not in ing_dict:
                ing_dict[ing] = set()
            ing_dict[ing].add(i)

    heap = []
    for i in range(m):
        score = 0
        for favs in favorites:
            for f in favs:
                if f in ing_dict and i in ing_dict[f]:
                    score += 1
                    break
        if score > 0:
            heapq.heappush(heap, (score, i))

    ans = []
    while len(ans) < 2:
        ans.append(heapq.heappop(heap)[1])

    print(ans[0] + 1, ans[1] + 1)

solve()","
def solve():
    n, m = map(int, input().split())
    favorite_ingredients = [set(map(int, input().split()[1:])) for _ in range(n)]
    pizzas = [list(map(int, input().split())) for _ in range(m)]
    
    people_pleased = [0] * m
    
    for i, ingredients in enumerate(pizzas):
        for idx, friend in enumerate(favorite_ingredients):
            if any(ingredient in friend for ingredient in ingredients[2:]):
                people_pleased[i] += 1
    
    best_pair = max([(i, j) for i in range(m) for j in range(m) if i != j], key=lambda x: (people_pleased[x[0]] + people_pleased[x[1], sum(pizzas[i][0] + pizzas[j][0]]))
    
    print(best_pair[0] + 1, best_pair[1] + 1)
  
solve()","
def solve():
    n, m = map(int, input().split())
    friends = [list(map(int, input().split()[1:])) for _ in range(n)]
    pizzas = [list(map(int, input().split())) for _ in range(m)]

    ingredients_set = set()
    for friend in friends:
        ingredients_set |= set(friend)

    best_pizzas = None
    max_friends_satisfied = 0
    min_total_price = float('inf')

    for i in range(m):
        for j in range(i+1, m):
            ingredients_union = set(pizzas[i][2:]) | set(pizzas[j][2:])
            friends_satisfied = sum(all(ingredient in ingredients_union for ingredient in friend) for friend in friends)
            if friends_satisfied > max_friends_satisfied or (friends_satisfied == max_friends_satisfied and pizzas[i][0] + pizzas[j][0] < min_total_price):
                max_friends_satisfied = friends_satisfied
                min_total_price = pizzas[i][0] + pizzas[j][0]
                best_pizzas = (i+1, j+1)

    return best_pizzas

# Main code
print(*solve())

solve()","
python
from collections import defaultdict

def solve():
    n, m = map(int, input().split())

    friends_ingredients = [list(map(int, input().split()))[1:] for _ in range(n)]
    pizzas = [list(map(int, input().split()))[1:] for _ in range(m)]

    fav_ingredients = defaultdict(set)
    for idx, favs in enumerate(friends_ingredients):
        for fav in favs:
            fav_ingredients[fav].add(idx)

    best_combo = None
    min_price = float('inf')

    for i in range(m):
        for j in range(i + 1, m):
            current_ingredients = set(pizzas[i][1:]).union(set(pizzas[j][1:]))
            satisfied_people = set()
            for ing in current_ingredients:
                satisfied_people.update(fav_ingredients.get(ing, set()))
            
            if len(satisfied_people) == n and pizzas[i][0] + pizzas[j][0] < min_price:
                min_price = pizzas[i][0] + pizzas[j][0]
                best_combo = (i + 1, j + 1)

    return best_combo

print(*solve())


solve()","
def solve():
    n, m = map(int, input().split())
    friends = [list(map(int, input().split()))[1:] for _ in range(n)]
    pizzas = [list(map(int, input().split()))[1:] for _ in range(m)]
    
    fav_pizza_count = [0] * m
    fav_pizza_indices = [[] for _ in range(10)]
    
    for i, fav_ingredients in enumerate(friends, start=1):
        for fav_ingredient in fav_ingredients:
            for j, (price, _, *ingredients) in enumerate(pizzas, start=1):
                if fav_ingredient in set(ingredients):
                    fav_pizza_count[j - 1] += 1
                    fav_pizza_indices[i].append(j)
    
    max_friends = max(fav_pizza_count)
    
    for i, indices in enumerate(fav_pizza_indices, start=1):
        if fav_pizza_count[indices[0] - 1] == max_friends:
            print(""{} {}"".format(indices[0], indices[1]))

# Input reading
solve()
","
def solve():
    n, m = map(int, input().split())
    favorite_ingredients = [set(map(int, input().split()[1:])) for _ in range(n)]
    pizzas = [list(map(int, input().split())) for _ in range(m)]
    friends_count = [0] * m

    for i in range(n):
        for j, pizza in enumerate(pizzas):
            if any(ingredient in pizza[2:] for ingredient in favorite_ingredients[i]):
                friends_count[j] += 1

    max_friend_count = max(friends_count)
    best_pizzas = [i for i, count in enumerate(friends_count) if count == max_friend_count]

    min_price = float('inf')
    selected_pizzas = None
    for i in range(len(best_pizzas)):
        for j in range(i + 1, len(best_pizzas)):
            price_sum = pizzas[best_pizzas[i]][0] + pizzas[best_pizzas[j]][0]
            if price_sum < min_price:
                min_price = price_sum
                selected_pizzas = (best_pizzas[i], best_pizzas[j])

    print(selected_pizzas[0] + 1, selected_pizzas[1] + 1)

solve()
","
def solve():
    import heapq
    
    n, m = map(int, input().split())
    fav_ingredients = [set(map(int, input().split()[1:])) for _ in range(n)]
    pizzas = [list(map(int, input().split())) for _ in range(m)]
    
    possible_pizzas = []
    
    for i in range(m):
        pizza_ingredients = set(pizzas[i][2:])
        satisfies = []
        for j in range(n):
            if fav_ingredients[j].issubset(pizza_ingredients):
                satisfies.append(j)
        heapq.heappush(possible_pizzas, (-len(satisfies), pizzas[i][0], i+1))
    
    selected_pizzas = []
    
    while len(selected_pizzas) < 2:
        _, price, index = heapq.heappop(possible_pizzas)
        selected_pizzas.append(index)
    
    print(selected_pizzas[0], selected_pizzas[1])

solve()
  ","
def solve():
    import sys
    n, m = map(int, sys.stdin.readline().split())
    favorite_ingredients = [set(map(int, sys.stdin.readline().split()[1:])) for _ in range(n)]
    pizzas = [list(map(int, sys.stdin.readline().split()[1:])) for _ in range(m)]
    
    friends_count = [0] * m
    for i in range(n):
        for idx, pizza in enumerate(pizzas):
            if any(ingredient not in pizza for ingredient in favorite_ingredients[i]):
                continue
            friends_count[idx] += 1

    first_pizza_idx = friends_count.index(max(friends_count))
    friends_count[first_pizza_idx] = 0
    second_pizza_idx = friends_count.index(max(friends_count))
    
    print(first_pizza_idx + 1, second_pizza_idx + 1)

solve()","
def solve():
    pass

solve()","
def solve():
    n, m = map(int, input().split())
    friends = []
    for _ in range(n):
        f, *fav_ingredients = map(int, input().split())
        friends.append(set(fav_ingredients))
    
    pizzas = []
    for i in range(m):
        price, r, *ingredients = map(int, input().split())
        pizzas.append((i+1, price, set(ingredients)))
    
    possible_combinations = []
    for i in range(m):
        for j in range(i+1, m):
            combined_ingredients = pizzas[i][2] | pizzas[j][2]
            num_friends_happy = sum(1 for favs in friends if favs.issubset(combined_ingredients))
            possible_combinations.append((num_friends_happy, pizzas[i][0], pizzas[j][0]))
    
    max_friends_happy = max(possible_combinations, key=lambda x: (x[0], sum(p[1] for p in filter(lambda y: y[0] == x[0], possible_combinations))))
    print(max_friends_happy[1], max_friends_happy[2])

solve()","
def solve():
    # Input parsing
    n, m = map(int, input().split())

    friends = []
    for _ in range(n):
        fav_ing = list(map(int, input().split()[1:]))
        friends.append(set(fav_ing))

    pizzas = []
    for j in range(m):
        price, _, *ings = map(int, input().split())
        pizzas.append((price, set(ings)))
    
    # Logic to find the best pair of pizzas
    best_pair = None
    max_friends_served = 0
    min_total_price = float('inf')

    for i in range(m):
        for k in range(i+1, m):
            served = friends.copy()
            served_count = 0

            for s in served:
                for p in [i, k]:
                    if not s.isdisjoint(pizzas[p][1]):
                        served_count += 1
                        served.remove(s)
                        break

            if served_count > max_friends_served or (served_count == max_friends_served and sum(pizzas[i][0], pizzas[k][0]) < min_total_price):
                max_friends_served = served_count
                min_total_price = sum(pizzas[i][0], pizzas[k][0])
                best_pair = (i+1, k+1)
    
    print(best_pair[0], best_pair[1])

# Input processing
if __name__ == ""__main__"":
    solve()
","
python
def solve():
    n, m = map(int, input().split())
    friends = [list(map(int, input().split()[1:])) for _ in range(n)]
    pizzas = [list(map(int, input().split()[1:])) for _ in range(m)]
    
    ingredients_count = [0] * 10
    for friend in friends:
        for ingredient in friend:
            ingredients_count[ingredient] += 1
    
    best_pizzas = []
    best_friends_satisfied = 0
    min_price = float('inf')
    
    for i in range(m):
        for j in range(i + 1, m):
            combined_ingredients = set(pizzas[i][1:]) | set(pizzas[j][1:])
            friends_satisfied = sum(ingredients_count[ingredient] > 0 for ingredient in combined_ingredients)
            if friends_satisfied > best_friends_satisfied or (friends_satisfied == best_friends_satisfied and sum(pizzas[i][0:1]) + sum(pizzas[j][0:1]) < min_price):
                best_pizzas = [i + 1, j + 1]
                best_friends_satisfied = friends_satisfied
                min_price = sum(pizzas[i][0:1]) + sum(pizzas[j][0:1])
    
    print(best_pizzas[0], best_pizzas[1])

solve()

","33.33333333333333","0.0","33.33333333333333","60.0","46.666666666666664","0.0","0.0","0.0","0.0","80.0","66.66666666666666","6.666666666666667","0.0","80.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/266","
QUESTION:
You have a positive integer m and a non-negative integer s. Your task is to find the smallest and the largest of the numbers that have length m and sum of digits s. The required numbers should be non-negative integers written in the decimal base without leading zeroes.


-----Input-----

The single line of the input contains a pair of integers m, s (1 ≤ m ≤ 100, 0 ≤ s ≤ 900) — the length and the sum of the digits of the required numbers.


-----Output-----

In the output print the pair of the required non-negative integer numbers — first the minimum possible number, then — the maximum possible number. If no numbers satisfying conditions required exist, print the pair of numbers ""-1 -1"" (without the quotes).


-----Examples-----
Input
2 15

Output
69 96

Input
3 0

Output
-1 -1
Use user-input-Based format and function signature solve()","
def solve():
    m, s = map(int, input().split())
    
    if s == 0 and m == 1:
        print(""0 0"")
        return
    
    if s == 0 or s > 9*m:
        print(""-1 -1"")
        return
    
    min_num = """"
    remaining_sum = s
    for i in range(m):
        digit = max(0, remaining_sum - 9*(m-i-1))
        if digit == 0 and i == 0:
            digit = 1
        min_num += str(digit)
        remaining_sum -= digit
    
    max_num = """"
    remaining_sum = s
    for i in range(m):
        digit = min(9, remaining_sum)
        max_num += str(digit)
        remaining_sum -= digit
    
    print(min_num, max_num)

solve()
","
def solve():
    m, s = map(int, input().split())
    if s == 0 and m == 1:
        print(""0 0"")
    elif s == 0 or s > 9*m:
        print(""-1 -1"")
    else:
        min_num = ""1"" + ""0""*(m-2) + ""1""
        max_num = """".join(str(min(9, s)) + ""0"" for _ in range(m))[:-1]
        print(min_num, max_num)

solve()
","
def solve():
    m, s = map(int, input().split())
    
    if s == 0 and m == 1:
        print(""0 0"")
        return
    
    if s == 0 or s > 9*m:
        print(""-1 -1"")
        return
    
    min_num = ''
    remaining_sum = s
    for i in range(m):
        d = max(0, remaining_sum - 9*(m - i - 1))
        min_num += str(d)
        remaining_sum -= d

    max_num = ''
    remaining_sum = s
    for i in range(m):
        d = min(9, remaining_sum)
        max_num += str(d)
        remaining_sum -= d
        
    print(min_num, max_num)

if __name__ == ""__main__"":
    solve()
","
python
def solve():
    m, s = map(int, input().split())
    
    if s == 0:
        if m == 1:
            print(""0 0"")
        else:
            print(""-1 -1"")
    else:
        if s > 9*m:
            print(""-1 -1"")
        else:
            min_num = int('1' + '0'*(m-1))
            max_num = 0
            remaining_sum = s
            for i in range(m):
                for d in range(9, -1, -1):
                    if (i > 0 or d > 0 or (m == 1 and d == 0)) and remaining_sum - d >= 0 and (m-i-1)*9 >= remaining_sum-d:
                        max_num = max_num*10 + d
                        remaining_sum -= d
                        break
            print(min_num, max_num)

solve()
","
def solve():
    m, s = map(int, input().split())
    if s == 0:
        if m == 1:
            print(""0 0"")
        else:
            print(""-1 -1"")
    elif s > 9*m:
        print(""-1 -1"")
    else:
        min_num = int(""1"" + ""0""*(m-1))
        max_num = int(""9""*m)
        if s < m:
            min_num += s - 1
            max_num -= (m - s)
        print(min_num, max_num)

if __name__ == ""__main__"":
    solve()
  ","
from itertools import product

def solve():
    m, s = map(int, input().split())
    
    if s == 0 and m > 1:
        print(""-1 -1"")
        return

    min_num = int(''.join(map(str, next(filter(lambda x: sum(x) == s and x[0] != 0, product(range(10), repeat=m)))))
    max_num = int(''.join(map(str, next(filter(lambda x: sum(x) == s and x[0] != 0, product(range(9, -1, -1), repeat=m)))))
    
    print(min_num, max_num)


solve()","
def solve():
    m, s = map(int, input().split())
    
    if s == 0 and m == 1:
        print(""0 0"")
        return
    
    if s == 0 or s > 9*m:
        print(""-1 -1"")
        return
    
    min_num = """"
    remaining_sum = s
    for i in range(m):
        digit = max(0 if i == 0 else 1, remaining_sum - 9*(m-i-1))
        min_num += str(digit)
        remaining_sum -= digit
    
    max_num = """"
    remaining_sum = s
    for i in range(m):
        digit = min(9, remaining_sum)
        max_num += str(digit)
        remaining_sum -= digit
    
    print(min_num, max_num)

solve()
  ","
def solve():
    m, s = map(int, input().split())
    
    if s == 0 and m == 1:
        print(""0 0"")
        return
    if s == 0 or s > 9*m:
        print(""-1 -1"")
        return
    
    min_num = """"
    max_num = """"
    
    for i in range(m):
        d = min(9, s)
        max_num += str(d)
        s -= d
        
    if len(max_num) < m:
        print(""-1 -1"")
        return

    min_num = max_num[::-1]
    if min_num[0] == '0':
        min_num = min_num[1] + '0' + min_num[2:]

    print(min_num, max_num)

import sys
solve()
","
def solve():
    m, s = map(int, input().split())
    if s == 0 and m > 1:
        print(""-1 -1"")
    elif s == 0 and m == 1:
        print(""0 0"")
    elif s > 9 * m:
        print(""-1 -1"")
    else:
        min_num = """"
        remaining = s
        for i in range(m):
            digit = max(0, remaining - 9 * (m - i - 1))
            min_num += str(digit)
            remaining -= digit
        
        max_num = """"
        remaining = s
        for i in range(m):
            digit = min(9, remaining)
            max_num += str(digit)
            remaining -= digit
        
        print(min_num, max_num)

solve()
","
def solve():
    m, s = map(int, input().split())
    if s == 0 and m == 1:
        print(""0 0"")
        return
    if s == 0 or s > 9*m:
        print(""-1 -1"")
        return
    min_num = ""1"" + ""0""*(m-1)
    max_num = ""9"" + ""0""*(m-1)
    target_sum = s
    curr_min = list(min_num)
    curr_max = list(max_num)
    curr_sum = sum(int(d) for d in curr_min)

    for i in range(m-1, -1, -1):
        while curr_sum < target_sum and curr_min[i] != ""9"":
            curr_min[i] = str(int(curr_min[i]) + 1)
            curr_sum += 1
        while curr_sum > target_sum and curr_max[i] != ""0"":
            curr_max[i] = str(int(curr_max[i]) - 1)
            curr_sum -= 1

    print("""".join(curr_min), """".join(curr_max))
  
solve()","
def solve():
    m, s = map(int, input().split())
    
    if s == 0 and m == 1:
        print(""0 0"")
        return
    
    if s == 0 or s > 9*m:
        print(""-1 -1"")
        return
    
    min_num = """"
    max_num = """"
    
    remaining_sum = s
    for i in range(m):
        digit = min(9, remaining_sum)
        min_num += str(digit)
        remaining_sum -= digit
    
    remaining_sum = s
    for i in range(m):
        digit = min(9, remaining_sum)
        max_num = str(digit) + max_num
        remaining_sum -= digit
    
    print(min_num, max_num)

solve()
  ","
def solve():
    m, s = map(int, input().split())
    if s == 0 and m == 1:
        print(""0 0"")
    elif s == 0 or s > 9*m:
        print(""-1 -1"")
    else:
        min_num = int(""1"" + ""0""*(m-1))
        max_num = int(""9""*m)
        if sum(map(int, str(min_num))) < s:
            min_num += 1
        if sum(map(int, str(max_num))) > s:
            max_num -= 1
        print(min_num, max_num)

import sys
solve()
  ","
def solve():
    m, s = map(int, input().split())

    if s == 0 and m == 1:
        print(""0 0"")
    elif s == 0 or s > 9*m:
        print(""-1 -1"")
    else:
        min_num = int('1' + '0'*(m-1))
        max_num = int('9'*m)

        min_sum = 1
        max_sum = 9*m
        
        min_result = []
        max_result = []
        
        for i in range(m):
            for j in range(10):
                if min_sum + j <= s:
                    min_result.append(str(j))
                    min_sum += j
                    break

        for i in range(m):
            for j in range(9, -1, -1):
                if max_sum - j >= s:
                    max_result.append(str(j))
                    max_sum -= j
                    break

        print(''.join(min_result), ''.join(max_result))

solve()","
def solve():
    m, s = map(int, input().split())

    if s == 0 and m == 1:
        print(""0 0"")
    elif s == 0 or s > 9*m:
        print(""-1 -1"")
    else:
        min_num = int(""1"" + ""0""*(m-1)) if m > 1 else 0
        max_num = """"

        remaining = s
        for i in range(m):
            digit = min(9, remaining)
            max_num = str(digit) + max_num
            remaining -= digit

        print(min_num, max_num)

solve()
","
def solve():
      m, s = map(int,input().split())
      if s == 0 and m == 1:
          print(""0 0"")
      elif s == 0 or s > 9*m:
          print(""-1 -1"")
      else:
          min_num = int('1' + '0'*(m-1))
          if s >= 9*(m-1):
              max_num = int('9'*((s-1)//9) + str(s%9+1) + '0'*(m-(s+8)//9))
          else:
              max_num = int('9'*(s//9) + str(s%9) + '0'*(m-s//9-1))
          print(min_num, max_num)

solve()
  ","
python
def solve():
    m, s = map(int, input().split())
    
    if s == 0 and m == 1:
        return 0, 0
    if s == 0 or s > 9 * m:
        return -1, -1
        
    min_num = ['0'] * m
    max_num = ['0'] * m
    
    s1, s2 = s, s
    for i in range(m):
        d = max(0 if i > 0 else 1, s1 - 9 * (m - i - 1))
        min_num[i] = str(d)
        s1 -= d
        
    for i in range(m):
        d = min(9, s2)
        max_num[i] = str(d)
        s2 -= d
    
    return int(''.join(min_num)), int(''.join(max_num))

# Do not include any lines below this comment

solve()","100.0","40.0","73.33333333333333","0.0","40.0","0.0","73.33333333333333","93.33333333333333","73.33333333333333","46.666666666666664","66.66666666666666","40.0","40.0","40.0","53.333333333333336","0.0","","","","","","","","","","","","","","","",""
"APPS/267","
QUESTION:
You are given two integers $l$ and $r$ ($l \le r$). Your task is to calculate the sum of numbers from $l$ to $r$ (including $l$ and $r$) such that each number contains at most $k$ different digits, and print this sum modulo $998244353$.

For example, if $k = 1$ then you have to calculate all numbers from $l$ to $r$ such that each number is formed using only one digit. For $l = 10, r = 50$ the answer is $11 + 22 + 33 + 44 = 110$.


-----Input-----

The only line of the input contains three integers $l$, $r$ and $k$ ($1 \le l \le r < 10^{18}, 1 \le k \le 10$) — the borders of the segment and the maximum number of different digits.


-----Output-----

Print one integer — the sum of numbers from $l$ to $r$ such that each number contains at most $k$ different digits, modulo $998244353$.


-----Examples-----
Input
10 50 2

Output
1230

Input
1 2345 10

Output
2750685

Input
101 154 2

Output
2189



-----Note-----

For the first example the answer is just the sum of numbers from $l$ to $r$ which equals to $\frac{50 \cdot 51}{2} - \frac{9 \cdot 10}{2} = 1230$. This example also explained in the problem statement but for $k = 1$.

For the second example the answer is just the sum of numbers from $l$ to $r$ which equals to $\frac{2345 \cdot 2346}{2} = 2750685$.

For the third example the answer is $101 + 110 + 111 + 112 + 113 + 114 + 115 + 116 + 117 + 118 + 119 + 121 + 122 + 131 + 133 + 141 + 144 + 151 = 2189$.
Use user-input-Based format and function signature solve()","
def solve():
    l, r, k = map(int, input().split())
    MOD = 998244353

    def count_digits(num):
        return len(set(str(num)))

    def calculate_sum(n):
        return n * (n + 1) // 2

    def calculate_sum_with_max_digits(l, r, k):
        total_sum = 0
        for i in range(l, r + 1):
            if count_digits(i) <= k:
                total_sum += i
        return total_sum % MOD

    result = calculate_sum_with_max_digits(l, r, k)
    print(result)

solve()
","
def solve():
    MOD = 998244353

    l, r, k = map(int, input().split())

    def get_sum(n):
        return n * (n + 1) // 2

    def count_digits(num):
        return len(set(str(num)))

    def calculate_sum(l, r, k):
        total_sum = 0
        for i in range(l, r + 1):
            if count_digits(i) <= k:
                total_sum += i
        return total_sum % MOD

    result = calculate_sum(l, r, k)
    print(result)

solve()
","
def solve():
    l, r, k = map(int, input().split())
    
    mod = 998244353
    s = 0
    
    for i in range(l, r+1):
        s += i
        if len(set(str(i))) > k:
            s -= i
    
    print(s % mod)

solve()
","
def solve():
    l, r, k = map(int, input().split())
    MOD = 998244353
    def calc_sum(n):
        return (n * (n + 1) // 2) % MOD
    def count_nums(x):
        res = 0
        digits = str(x)
        unique = set(digits)
        if len(unique) <= k:
            res += x
        return res
    answer = 0
    for i in range(l, r+1):
        answer += count_nums(i)
    return answer % MOD

solve()","
def solve():
    MOD = 998244353
    
    l, r, k = map(int, input().split())
    
    ans = 0
    for i in range(l, r+1):
        num_str = str(i)
        if len(set(num_str)) <= k:
            ans += i    
    
    print(ans % MOD)

solve()
","
def solve():
    MOD = 998244353
    
    l, r, k = map(int, input().split())
    
    def countDigits(x):
        digits = set()
        while x > 0:
            digits.add(x % 10)
            x //= 10
        return len(digits)
    
    def calcSum(x):
        return (x * (x + 1) // 2) % MOD

    result = 0
    for num in range(l, r+1):
        if countDigits(num) <= k:
            result = (result + num) % MOD
    
    return result


solve()","
def solve():
    l, r, k = map(int, input().split())
    MOD = 998244353
    
    def count_digits(x):
        return len(set(str(x)))
    
    def calc_sum(x):
        return x * (x + 1) // 2
    
    def compute(l, r, k):
        ans = 0
        for i in range(l, r + 1):
            if count_digits(i) <= k:
                ans += i
        return ans % MOD
    
    return compute(l, r, k)

solve()","
def solve():
    MOD = 998244353

    l, r, k = map(int, input().split())

    def get_sum(n):
        return n * (n + 1) // 2

    def count_digits(x):
        return len(set(str(x)))

    def sum_subset(l, r, k):
        total_sum = 0
        for i in range(l, r + 1):
            if count_digits(i) <= k:
                total_sum += i
        return total_sum % MOD

    result = sum_subset(l, r, k)
    print(result)

solve()
  ","
def solve():
    MOD = 998244353

    l, r, k = map(int, input().split())

    def count_same_digits(x):
        same_digits = 0
        while x > 0:
            same_digits |= 1 << (x % 10)
            x //= 10
        return bin(same_digits).count('1')

    def calc(x):
        return (x * (x + 1) // 2) % MOD

    ans = 0
    for i in range(l, r+1):
        if count_same_digits(i) <= k:
            ans = (ans + i) % MOD

    print(ans)

solve()
","
def solve():
    l, r, k = map(int, input().split())
    MOD = 998244353

    def count_digits(num):
        return len(set(str(num)))

    def calculate_sum(n):
        return (n * (n + 1) // 2) % MOD

    total_sum = 0
    for i in range(l, r + 1):
        if count_digits(i) <= k:
            total_sum += i

    return total_sum % MOD

solve()","
def solve():
    MOD = 998244353
    
    l, r, k = map(int, input().split())
    
    def count_digits(num):
        return len(set(str(num)))
    
    def calculate_sum(num):
        return num * (num + 1) // 2
    
    total_sum = 0
    for i in range(l, r+1):
        if count_digits(i) <= k:
            total_sum = (total_sum + i) % MOD
    
    return total_sum

# Call the function
solve()
","
def solve():
    MOD = 998244353
    l, r, k = map(int, input().split())

    def count_digits(x):
        return len(set(str(x)))

    def calculate_sum(num):
        return num * (num + 1) // 2

    def get_valid_numbers(l, r, k):
        total_sum = 0
        for i in range(l, r+1):
            if count_digits(i) <= k:
                total_sum += i
        return total_sum

    def final_sum(l, r, k):
        return get_valid_numbers(l, r, k) % MOD

    print(final_sum(l, r, k))

solve()
","
def solve():
    MOD = 998244353
    l, r, k = map(int, input().split())

    def compute_sum(num):
        return (num * (num + 1) // 2) % MOD

    def count_good(num, k):
        s = str(num)
        if k < len(set(s)):
            return 0
        return 1

    ans = 0
    for i in range(l, r + 1):
        ans = (ans + count_good(i, k)) % MOD

    return ans

solve()
  ","
def solve():
    l, r, k = map(int, input().split())
    mod = 998244353
    ans = 0
    for i in range(l, r + 1):
        num_str = str(i)
        distinct_digits = set(num_str)
        if len(distinct_digits) <= k:
            ans += i
            ans %= mod
    print(ans)

solve()
","
def solve():
    MOD = 998244353
    
    l, r, k = map(int, input().split())

    ans = 0
    cnt = 0
    for d in range(1, 10):
        res = k - 1
        coef = 1
        for i in range(l, r+1):
            if d > i:
                coef = 0
            elif i // 10 % 10 == d:
                coef = 0
            else:
                res += 1
                coef *= (i - cnt)
                cnt += 1
            
            if res < 0:
                break
                
            ans += coef
            ans %= MOD

    return ans

solve()
","
def solve():
    l, r, k = map(int, input().split())
    MOD = 998244353

    def get_sum(n):
        return n * (n + 1) // 2

    def get_num_diff_digits(num, k):
        digits = set(str(num))
        return len(digits) <= k

    def calculate_sum(l, r, k):
        total_sum = 0
        for i in range(l, r + 1):
            if get_num_diff_digits(i, k):
                total_sum += i
        return total_sum % MOD

    print(calculate_sum(l, r, k))

solve()
","100.0","100.0","100.0","0.0","100.0","0.0","0.0","100.0","100.0","0.0","0.0","100.0","0.0","100.0","0.0","100.0","","","","","","","","","","","","","","","",""
"APPS/268","
QUESTION:
Mishka received a gift of multicolored pencils for his birthday! Unfortunately he lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence a_1, a_2, ..., a_{n} of n integer numbers — saturation of the color of each pencil. Now Mishka wants to put all the mess in the pack in order. He has an infinite number of empty boxes to do this. He would like to fill some boxes in such a way that:

  Each pencil belongs to exactly one box;  Each non-empty box has at least k pencils in it;  If pencils i and j belong to the same box, then |a_{i} - a_{j}| ≤ d, where |x| means absolute value of x. Note that the opposite is optional, there can be pencils i and j such that |a_{i} - a_{j}| ≤ d and they belong to different boxes. 

Help Mishka to determine if it's possible to distribute all the pencils into boxes. Print ""YES"" if there exists such a distribution. Otherwise print ""NO"".


-----Input-----

The first line contains three integer numbers n, k and d (1 ≤ k ≤ n ≤ 5·10^5, 0 ≤ d ≤ 10^9) — the number of pencils, minimal size of any non-empty box and maximal difference in saturation between any pair of pencils in the same box, respectively.

The second line contains n integer numbers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — saturation of color of each pencil.


-----Output-----

Print ""YES"" if it's possible to distribute all the pencils into boxes and satisfy all the conditions. Otherwise print ""NO"".


-----Examples-----
Input
6 3 10
7 2 7 7 4 2

Output
YES

Input
6 2 3
4 5 3 13 4 10

Output
YES

Input
3 2 5
10 16 22

Output
NO



-----Note-----

In the first example it is possible to distribute pencils into 2 boxes with 3 pencils in each with any distribution. And you also can put all the pencils into the same box, difference of any pair in it won't exceed 10.

In the second example you can split pencils of saturations [4, 5, 3, 4] into 2 boxes of size 2 and put the remaining ones into another box.
Use user-input-Based format and function signature solve()","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    
    dp = [False] * n
    dp[0] = True
    
    for i in range(1, n):
        for j in range(i-1, max(i-k, -1), -1):
            if abs(pencils[i] - pencils[j]) <= d:
                dp[i] = dp[i] or dp[j]
    
    if any(dp[i] for i in range(n-k, n)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    
    dp = [False] * (n + 1)
    dp[0] = True
    
    for i in range(1, n + 1):
        for j in range(1, k):
            if i - j < 0:
                break
            if pencils[i - 1] - pencils[i - j] <= d:
                dp[i] |= dp[i - j]
    
    if dp[n]:
        print(""YES"")
    else:
        print(""NO"")

solve()
    ","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    
    dp = [False] * n
    dp[0] = True
    
    for i in range(1, n):
        for j in range(i-1, max(i-k, -1), -1):
            if abs(pencils[i] - pencils[j]) <= d:
                dp[i] = dp[i] or dp[j]
    
    if any(dp[i] and i >= k-1 for i in range(n)):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    
    dp = [False] * (n + 1)
    dp[0] = True
    
    for i in range(1, n + 1):
        for j in range(1, min(i, k) + 1):
            if pencils[i - 1] - pencils[i - j] <= d:
                dp[i] |= dp[i - j]
    
    if dp[n]:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    
    dp = [0] * n
    dp[0] = 1
    
    for i in range(1, n):
        for j in range(i-1, max(-1, i-k-1), -1):
            if abs(pencils[i] - pencils[j]) <= d:
                dp[i] = max(dp[i], dp[j])
        if dp[i] == 0:
            return ""NO""
    
    return ""YES""
  
solve()","
def solve():
    import sys
    
    n, k, d = map(int, input().split())
    a = list(map(int, input().split()))
    
    a.sort()
    
    dp = [False] * (n + 1)
    dp[0] = True
    
    for i in range(1, n + 1):
        for j in range(1, min(i, k) + 1):
            if a[i-1] - a[i-j] <= d:
                dp[i] = dp[i] or dp[i - j]
    
    if dp[n]:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    dp = [False] * (n + 1)
    dp[0] = True
    
    for i in range(1, n + 1):
        for j in range(1, k + 1):
            if i - j >= 0 and pencils[i - 1] - pencils[i - j] <= d:
                dp[i] |= dp[i - j]
    
    if dp[n]:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    from collections import deque
    
    n, k, d = map(int, input().split())
    saturation = list(map(int, input().split()))
    
    saturation.sort()
    dp = [False] * (n+1)
    dp[0] = True
    
    for i in range(1, n+1):
        for j in range(1, min(i, k)+1):
            if i-j < 0:
                break
            if abs(saturation[i-1] - saturation[i-j-1]) <= d:
                dp[i] = dp[i] or dp[i-j]
    
    if dp[n]:
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    dp = [False] * n
    dp[0] = True
    
    for i in range(1, n):
        for j in range(1, k+1):
            if i - j >= 0 and abs(pencils[i] - pencils[i-j]) <= d:
                dp[i] = dp[i] or dp[i-j]
                
    if dp[n-1]:
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
from sortedcontainers import SortedList

def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    dp = [False] * n
    sorted_pencils = SortedList()
    
    for i in range(n):
        sorted_pencils.add(i)
        if i >= k:
            sorted_pencils.remove(i - k)
        if i >= k - 1 and (i < n - 1 and pencils[i + 1] - pencils[i - k + 1] <= d or 
                           i == n - 1):
            dp[i] = True
        if dp[i]:
            for j in sorted_pencils.irange(i - k + 1, i):
                dp[j] = True
    
    if dp[n - 1]:
        print(""YES"")
    else:
        print(""NO"")


solve()","
def solve():
    # Input
    n, k, d = map(int, input().split())
    saturations = list(map(int, input().split()))

    saturations.sort()

    dp = [False] * (n+1)
    dp[0] = True

    for i in range(1, n+1):
        for j in range(1, k+1):
            if i - j >= 0 and dp[i-j] and saturations[i-1] - saturations[i-j] <= d:
                dp[i] = True
                break

    # Output
    if dp[n]:
        print(""YES"")
    else:
        print(""NO"")

# Call the function to run it
solve()
  ","
def solve():
    n, k, d = map(int, input().split())
    a = list(map(int, input().split()))

    a.sort()

    dp = [0] * n
    dp[0] = 1

    for i in range(1, n):
        for j in range(i-1, -1, -1):
            if a[i] - a[j] <= d:
                dp[i] |= dp[j]
            if j < i - k and dp[j]:
                break

    if any(dp[n-k:]):
        print(""YES"")
    else:
        print(""NO"")

import sys
if __name__ == ""__main__"":
    sys.setrecursionlimit(10**6)
    solve()
","
def solve():
    import sys
    
    # Read input
    n, k, d = map(int, sys.stdin.readline().strip().split())
    a = list(map(int, sys.stdin.readline().strip().split()))
    
    # Sort the pencils by saturation
    a.sort()
    
    # Initialize a dp array to store if it's possible to distribute pencils
    dp = [False] * (n + 1)
    dp[0] = True
    
    for i in range(1, n + 1):
        for j in range(1, min(i, k) + 1):
            if a[i - 1] - a[i - j] <= d:
                dp[i] |= dp[i - j]
    
    # Output result
    if dp[n]:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    import sys
    n, k, d = map(int, sys.stdin.readline().split())
    pencils = list(map(int, sys.stdin.readline().split()))
    
    pencils.sort()
    
    dp = [False] * n
    dp[0] = True
    
    for i in range(1, n):
        for j in range(i-1, max(i-k, -1)-1, -1):
            if abs(pencils[i] - pencils[j]) <= d:
                dp[i] |= dp[j]
            if dp[i]:
                break
    
    if dp[n-1]:
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    from collections import deque

    n, k, d = map(int, input().split())
    a = list(map(int, input().split()))

    a.sort()
    dp = [False] * n
    dp[0] = True

    for i in range(n):
        for j in range(i):
            if a[i] - a[j] <= d:
                dp[i] |= dp[j]

    if any(dp[n-k:]):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k, d = map(int, input().split())
    pencils = list(map(int, input().split()))
    
    pencils.sort()
    
    dp = [False] * n
    dp[0] = True
    
    for i in range(1, n):
        for j in range(max(0, i - k + 1), i):
            if dp[j] and pencils[i] - pencils[j] <= d:
                dp[i] = True
                break
    
    if dp[n-1]:
        print(""YES"")
    else:
        print(""NO"")

solve()
","73.33333333333333","66.66666666666666","93.33333333333333","66.66666666666666","0.0","66.66666666666666","66.66666666666666","33.33333333333333","73.33333333333333","0.0","66.66666666666666","73.33333333333333","66.66666666666666","73.33333333333333","73.33333333333333","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/269","
QUESTION:
Nothing is eternal in the world, Kostya understood it on the 7-th of January when he saw partially dead four-color garland.

Now he has a goal to replace dead light bulbs, however he doesn't know how many light bulbs for each color are required. It is guaranteed that for each of four colors at least one light is working.

It is known that the garland contains light bulbs of four colors: red, blue, yellow and green. The garland is made as follows: if you take any four consecutive light bulbs then there will not be light bulbs with the same color among them. For example, the garland can look like ""RYBGRYBGRY"", ""YBGRYBGRYBG"", ""BGRYB"", but can not look like ""BGRYG"", ""YBGRYBYGR"" or ""BGYBGY"". Letters denote colors: 'R' — red, 'B' — blue, 'Y' — yellow, 'G' — green.

Using the information that for each color at least one light bulb still works count the number of dead light bulbs of each four colors.


-----Input-----

The first and the only line contains the string s (4 ≤ |s| ≤ 100), which describes the garland, the i-th symbol of which describes the color of the i-th light bulb in the order from the beginning of garland:   'R' — the light bulb is red,  'B' — the light bulb is blue,  'Y' — the light bulb is yellow,  'G' — the light bulb is green,  '!' — the light bulb is dead. 

The string s can not contain other symbols except those five which were described. 

It is guaranteed that in the given string at least once there is each of four letters 'R', 'B', 'Y' and 'G'. 

It is guaranteed that the string s is correct garland with some blown light bulbs, it means that for example the line ""GRBY!!!B"" can not be in the input data. 


-----Output-----

In the only line print four integers k_{r}, k_{b}, k_{y}, k_{g} — the number of dead light bulbs of red, blue, yellow and green colors accordingly.


-----Examples-----
Input
RYBGRYBGR

Output
0 0 0 0
Input
!RGYB

Output
0 1 0 0
Input
!!!!YGRB

Output
1 1 1 1
Input
!GB!RG!Y!

Output
2 1 1 0


-----Note-----

In the first example there are no dead light bulbs.

In the second example it is obvious that one blue bulb is blown, because it could not be light bulbs of other colors on its place according to the statements.
Use user-input-Based format and function signature solve()","
def solve():
    s = input()
    k_r = s.count('R') - (s.count('!') if 'R' in s else 0)
    k_b = s.count('B') - (s.count('!') if 'B' in s else 0)
    k_y = s.count('Y') - (s.count('!') if 'Y' in s else 0)
    k_g = s.count('G') - (s.count('!') if 'G' in s else 0)
    print(k_r, k_b, k_y, k_g)

solve()
","
def solve():
    s = input()
    k_r, k_b, k_y, k_g = 0, 0, 0, 0
    for i in range(4, len(s)):
        if '!' in s[i-4:i]:
            if s[i] == 'R':
                k_r += 1
            elif s[i] == 'B':
                k_b += 1
            elif s[i] == 'Y':
                k_y += 1
            else:
                k_g += 1
    print(k_r, k_b, k_y, k_g)

solve()
","
def solve():
    s = input().strip()
    rb, bb, yb, gb = 0, 0, 0, 0
    
    for i in range(len(s)):
        if s[i] == '!':
            if i % 4 == 0:
                rb += 1
            elif i % 4 == 1:
                bb += 1
            elif i % 4 == 2:
                yb += 1
            else:
                gb += 1
    
    print(rb, bb, yb, gb)

solve()
","
def solve():
    s = input()
    k_r = s.count('R') - (s.count('!') if 'R' in s else 0)
    k_b = s.count('B') - (s.count('!') if 'B' in s else 0)
    k_y = s.count('Y') - (s.count('!') if 'Y' in s else 0)
    k_g = s.count('G') - (s.count('!') if 'G' in s else 0)
    print(k_r, k_b, k_y, k_g)

solve()
  ","
def solve():
    import sys

    s = input().strip()
    k_r, k_b, k_y, k_g = 0, 0, 0, 0

    for i in range(len(s)):
        if s[i] == 'R' and (i % 4 == 0 or i % 4 == 3):
            k_r += 1
        elif s[i] == 'B' and i % 4 == 1:
            k_b += 1
        elif s[i] == 'Y' and i % 4 == 2:
            k_y += 1
        elif s[i] == 'G' and i % 4 == 3:
            k_g += 1

    print(k_r, k_b, k_y, k_g)


solve()
","
def solve():
    s = input().strip()
    
    count_r = s.count('R') - (s.count('!') if 'R' in s else 0)
    count_b = s.count('B') - (s.count('!') if 'B' in s else 0)
    count_y = s.count('Y') - (s.count('!') if 'Y' in s else 0)
    count_g = s.count('G') - (s.count('!') if 'G' in s else 0)
    
    print(count_r, count_b, count_y, count_g)

solve()
  ","
def solve():
    s = input()
    k_r = s.count('R') - (s.find('R') != -1)
    k_b = s.count('B') - (s.find('B') != -1)
    k_y = s.count('Y') - (s.find('Y') != -1)
    k_g = s.count('G') - (s.find('G') != -1)
    
    print(k_r, k_b, k_y, k_g)
    
solve()
","
def solve():
    s = input().strip()
    k_r = s.count('R') - (s.count('!') if '!' in s else 0)
    k_b = s.count('B') - (s.count('!') if '!' in s else 0)
    k_y = s.count('Y') - (s.count('!') if '!' in s else 0)
    k_g = s.count('G') - (s.count('!') if '!' in s else 0)
    print(k_r, k_b, k_y, k_g)

solve()
  ","
def solve():
    s = input()
    colors = ['R', 'B', 'Y', 'G', '!']
    dead_bulbs = [0, 0, 0, 0]
    
    for i in range(4, len(s)):
        if s[i] == '!':
            for j in range(4):
                if s[i-4:i].count(colors[j]) == 0:
                    dead_bulbs[j] += 1
    
    print(dead_bulbs[0], dead_bulbs[1], dead_bulbs[2], dead_bulbs[3])

solve()
","
def solve():
    s = input().strip()
    k_r = s.count('R') - (s.count('!') if 'R' in s else 0)
    k_b = s.count('B') - (s.count('!') if 'B' in s else 0)
    k_y = s.count('Y') - (s.count('!') if 'Y' in s else 0)
    k_g = s.count('G') - (s.count('!') if 'G' in s else 0)
    
    print(k_r, k_b, k_y, k_g)

solve()
","
def solve():
    s = input().strip()
    
    k_r = s.count('R') - s.count('!R')
    k_b = s.count('B') - s.count('!B')
    k_y = s.count('Y') - s.count('!Y')
    k_g = s.count('G') - s.count('!G')
    
    print(k_r, k_b, k_y, k_g)

solve()
","
def solve():
    s = input().strip()
    k_r = s.count('!') if 'R' not in s else 0
    k_b = s.count('!') if 'B' not in s else 0
    k_y = s.count('!') if 'Y' not in s else 0
    k_g = s.count('!') if 'G' not in s else 0

    print(k_r, k_b, k_y, k_g)

solve()
","
def solve():
    s = input().strip()
    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}
    
    for i in range(len(s)):
        if s[i] == '!':
            colors = set()
            if i-1 >= 0:
                colors.add(s[i-1])
            if i+1 < len(s):
                colors.add(s[i+1])
            for color in ['R', 'B', 'Y', 'G']:
                if color not in colors:
                    dead_counts[color] += 1
                    
    print(dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G'])

solve()
","
def solve():
    s = input()
    k_r, k_b, k_y, k_g = 0, 0, 0, 0
    for i in range(len(s)):
        if s[i] == '!':
            if s[(i+1)%len(s)] == 'R':
                k_r += 1
            elif s[(i+1)%len(s)] == 'B':
                k_b += 1
            elif s[(i+1)%len(s)] == 'Y':
                k_y += 1
            elif s[(i+1)%len(s)] == 'G':
                k_g += 1
    print(k_r, k_b, k_y, k_g)

solve()
","
def solve():
    from collections import Counter

    s = input()

    colors = {'R': 0, 'B': 1, 'Y': 2, 'G': 3}
    dead_count = [0, 0, 0, 0]

    for i in range(4, len(s)):
        if s[i] == '!':
            valid_colors = [0, 0, 0, 0]
            for j in range(4):
                valid_colors[colors[s[i-4+j]]] = 1
            for k in range(4):
                if valid_colors[k] == 0:
                    dead_count[k] += 1

    print(*dead_count)

solve()","
def solve():
    s = input().strip()
    k_r = s.count('R') - (s.count('!') if 'R' in s else 0)
    k_b = s.count('B') - (s.count('!') if 'B' in s else 0)
    k_y = s.count('Y') - (s.count('!') if 'Y' in s else 0)
    k_g = s.count('G') - (s.count('!') if 'G' in s else 0)
    print(k_r, k_b, k_y, k_g)

solve()
  ","0.0","60.0","66.66666666666666","0.0","6.666666666666667","0.0","6.666666666666667","0.0","46.666666666666664","0.0","6.666666666666667","46.666666666666664","46.666666666666664","53.333333333333336","46.666666666666664","0.0","","","","","","","","","","","","","","","",""
"APPS/270","
QUESTION:
There is a cave consisting of N rooms and M one-directional passages. The rooms are numbered 1 through N.
Takahashi is now in Room 1, and Room N has the exit. The i-th passage connects Room s_i and Room t_i (s_i < t_i) and can only be traversed in the direction from Room s_i to Room t_i. It is known that, for each room except Room N, there is at least one passage going from that room.
Takahashi will escape from the cave. Each time he reaches a room (assume that he has reached Room 1 at the beginning), he will choose a passage uniformly at random from the ones going from that room and take that passage.
Aoki, a friend of Takahashi's, can block one of the passages (or do nothing) before Takahashi leaves Room 1. However, it is not allowed to block a passage so that Takahashi is potentially unable to reach Room N.
Let E be the expected number of passages Takahashi takes before he reaches Room N. Find the value of E when Aoki makes a choice that minimizes E.

-----Constraints-----
 - 2 \leq N \leq 600
 - N-1 \leq M \leq \frac{N(N-1)}{2}
 - s_i < t_i
 - If i != j, (s_i, t_i) \neq (s_j, t_j). (Added 21:23 JST)
 - For every v = 1, 2, ..., N-1, there exists i such that v = s_i.

-----Input-----
Input is given from Standard Input in the following format:
N M
s_1 t_1
:
s_M t_M

-----Output-----
Print the value of E when Aoki makes a choice that minimizes E.
Your output will be judged as correct when the absolute or relative error from the judge's output is at most 10^{-6}.

-----Sample Input-----
4 6
1 4
2 3
1 3
1 2
3 4
2 4

-----Sample Output-----
1.5000000000

If Aoki blocks the passage from Room 1 to Room 2, Takahashi will go along the path 1 → 3 → 4 with probability \frac{1}{2} and 1 → 4 with probability \frac{1}{2}. E = 1.5 here, and this is the minimum possible value of E.
Use user-input-Based format and function signature solve()","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    passages = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        passages[s].append(t)
    
    dp = [0] * (N + 1)
    for i in range(N - 1, 0, -1):
        min_val = float('inf')
        for j in passages[i]:
            min_val = min(min_val, dp[j])
        dp[i] = 1 + min_val
    
    print('{:.10f}'.format(dp[1]))

solve()","
def solve():
    # Function body for solving the task
    pass

solve()","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    passages = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        passages[s].append(t)
    
    dp = [0] * (N+1)
    for i in range(N-1, 0, -1):
        min_exp = float('inf')
        for j in passages[i]:
            min_exp = min(min_exp, dp[j])
        dp[i] = 1 + min_exp
    
    print(""{:.10f}"".format(dp[1]))

solve()
","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    adj_list = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        adj_list[s].append(t)

    dp = [0] * (N + 1)
    dp[1] = 1

    for i in range(1, N):
        total = 0
        for neigh in adj_list[i]:
            total += dp[i] / len(adj_list[i])
            dp[neigh] += dp[i] / len(adj_list[i])
        dp[i] = total

    print(f'{dp[N]:.10f}')

solve()
  ","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    passages = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        passages[s].append(t)
    
    expected_passages = [0] * (N + 1)
    for i in range(N - 1, 0, -1):
        probabilities = [1 + expected_passages[j] for j in passages[i]]
        expected_passages[i] = sum(probabilities) / len(probabilities)
    
    print(f""{expected_passages[1]:.10f}"")

solve()
","
def solve():
    # Input
    N, M = map(int, input().split())
    passages = [tuple(map(int, input().split())) for _ in range(M)]
    
    # Initialize expected number of passages
    E = 0
    
    # Calculate the probability of each passage being blocked
    prob_blocked = [0] * M
    prob_blocked[0] = 1
    
    for i in range(M):
        s_i, t_i = passages[i]
        prob_blocked[i] = 1 / (t_i - s_i + 1)
    
    # Calculate expected number of passages when each passage is blocked
    for i in range(M):
        prob_passage_blocked = prob_blocked[i]
        prob_reach_N = 1
        
        for j in range(M):
            if j != i:
                s_j, t_j = passages[j]
                prob_reach_N *= (t_j - s_j + 1) / (t_j - s_j)
        
        prob_reach_N *= prob_blocked[i]
        E += prob_reach_N / (1 - prob_passage_blocked)
    
    return E

solve()
  ","
def solve():
    import sys
    from collections import defaultdict
    from queue import Queue
    
    n, m = map(int, input().split())
    graph = defaultdict(list)
    for _ in range(m):
        s, t = map(int, input().split())
        graph[s].append(t)
    
    dist = [-1] * (n+1)
    dist[1] = 0
    q = Queue()
    q.put(1)
    while not q.empty():
        v = q.get()
        for u in graph[v]:
            if dist[u] == -1:
                dist[u] = dist[v] + 1
                q.put(u)
    
    blocking = False
    for u in graph[1]:
        if dist[u] == dist[n]:
            blocking = True
    
    if blocking:
        print(sum(dist) / len(graph[1]))
    else:
        print(""1.0000000000"")

solve()
","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    edges = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        edges[s].append(t)
    
    dp = [0] * (N + 1)
    for i in range(10**6):
        new_dp = [0] * (N + 1)
        for v in range(1, N):
            for u in edges[v]:
                new_dp[u] += dp[v] / len(edges[v])
        dp = new_dp
    
    print('{:.10f}'.format(dp[N]))

solve()
","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    graph = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        graph[s].append(t)

    dp = [0] * (N + 1)
    for i in range(N-1, 0, -1):
        dp[i] = sum(dp[j] + 1 for j in graph[i]) / len(graph[i])

    print(""{:.10f}"".format(dp[1]))

solve()
","
from fractions import Fraction

def solve():
    N, M = map(int, input().split())
    passages = []
    for _ in range(M):
        s, t = map(int, input().split())
        passages.append((s, t))

    blocked_passages = [(1, N)]
    for s, t in passages:
        if s == 1:
            blocked_passages.append((s, t))
    
    total_paths = sum(1 for _ in range(2, N+1) if (1, _) not in blocked_passages)
    E = Fraction(N - 1, total_paths)
    print(float(E))

solve()
","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    graph = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        graph[s].append(t)
    
    dp = [0.0] * (N + 1)
    for i in range(N-2, 0, -1):
        prob = 1.0 / len(graph[i])
        for j in graph[i]:
            dp[i] += (dp[j] + 1) * prob
    
    print(""{:.10f}"".format(dp[1]))
  
solve()","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    edges = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        edges[s].append(t)
    
    dp = [0] * (N + 1)
    for v in range(N-1, 0, -1):
        for u in edges[v]:
            dp[v] += (1 + dp[u]) / len(edges[v])
    
    print(""{:.10f}"".format(dp[1]))

solve()","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    edges = defaultdict(list)
    
    for _ in range(M):
        s, t = map(int, input().split())
        edges[s].append(t)  
    
    dp = [0.0] * (N + 1)
    dp[1] = 1.0
    
    for i in range(1, N):
        next_dp = [0.0] * (N + 1)
        
        for u in range(1, N):
            prob = 1 / len(edges[u]) if edges[u] else 0.0
            
            for v in edges[u]:
                next_dp[v] += dp[u] * prob
                next_dp[u] += dp[u] * (1 - prob)
        
        dp = next_dp

    print(""{:.10f}"".format(dp[N]))

solve()
  ","
from collections import defaultdict

def solve():
    N, M = map(int, input().split())
    edges = defaultdict(list)
    for _ in range(M):
        s, t = map(int, input().split())
        edges[s].append(t)
    
    dp = [0] * (N+1)
    for i in range(N-1, 0, -1):
        sum_prob = 0
        for j in edges[i]:
            sum_prob += dp[j] + 1
        dp[i] = sum_prob / len(edges[i]) if len(edges[i]) > 0 else 0
    
    print(""{:.10f}"".format(dp[1]))

solve()
","
from fractions import Fraction

def solve():
    N, M = map(int, input().split())
    passages = [tuple(map(int, input().split())) for _ in range(M)]

    connected_rooms = [[] for _ in range(N)]
    for s, t in passages:
        connected_rooms[s-1].append(t)

    dp = [0] * N
    for i in range(N-2, -1, -1):
        dp[i] = sum(dp[j-1] + 1 for j in connected_rooms[i]) / len(connected_rooms[i])

    return '{:.10f}'.format(dp[0])

print(solve())
  
solve()","
import sys

def solve():
    N, M = map(int, sys.stdin.readline().split())
    passages = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]

    min_expected_passages = float('inf')
    blocked_passage = None

    for i in range(M):
        blocked = passages[i][1]
        probability = 0
        for j in range(M):
            if passages[j][0] == 1 and passages[j][1] != blocked:
                probability += 1
        expected_passages = (N - 1) / probability
        if expected_passages < min_expected_passages:
            min_expected_passages = expected_passages

    print(""{:.10f}"".format(min_expected_passages))

solve()
","20.0","0.0","20.0","6.666666666666667","20.0","0.0","0.0","0.0","20.0","0.0","6.666666666666667","20.0","8.333333333333332","20.0","0.0","18.181818181818183","","","","","","","","","","","","","","","",""
"APPS/271","
QUESTION:
Vasya has a non-negative integer n. He wants to round it to nearest integer, which ends up with 0. If n already ends up with 0, Vasya considers it already rounded.

For example, if n = 4722 answer is 4720. If n = 5 Vasya can round it to 0 or to 10. Both ways are correct.

For given n find out to which integer will Vasya round it.


-----Input-----

The first line contains single integer n (0 ≤ n ≤ 10^9) — number that Vasya has.


-----Output-----

Print result of rounding n. Pay attention that in some cases answer isn't unique. In that case print any correct answer.


-----Examples-----
Input
5

Output
0

Input
113

Output
110

Input
1000000000

Output
1000000000

Input
5432359

Output
5432360



-----Note-----

In the first example n = 5. Nearest integers, that ends up with zero are 0 and 10. Any of these answers is correct, so you can print 0 or 10.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + (10 - n % 10))

solve()
","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + 10 - n % 10)

solve()
","
def solve():
    n = int(input())
    
    if n % 10 <= 5:
        return n - n % 10
    else:
        return n + 10 - n % 10
  
solve()","
def solve():
    n = int(input().strip())
    
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + (10 - n % 10))
  
solve()","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + 10 - n % 10)

solve()
","
def solve():
    n = int(input().strip())
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + 10 - n % 10)

solve()","
def solve():
    n = int(input())
    if n % 10 <= 4:
        print(n - n % 10)
    else:
        print(n + (10 - n % 10))

solve()","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + (10 - n % 10))

solve()","
def solve():
    n = int(input())
    
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + (10 - n % 10))

solve()
","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n // 10 * 10)
    else:
        print((n // 10 + 1) * 10)

solve()","
def solve():
    n = int(input())
    if n % 10 < 5:
        print(n // 10 * 10)
    else:
        print(n // 10 * 10 + 10)

solve()","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + 10 - (n % 10))

solve()","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n // 10 * 10)
    else:
        print((n // 10 + 1) * 10)

solve()","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n - (n % 10))
    else:
        print(n + (10 - (n % 10)))

solve()","
def solve():
    n = int(input())
    if n % 10 <= 5:
        print(n - n % 10)
    else:
        print(n + (10 - n % 10))

solve()
","
def solve():
    n = int(input())
    
    if n % 10 <= 5:
        ans = n // 10 * 10
    else:
        ans = (n // 10 + 1) * 10
    
    print(ans)

solve()
","100.0","100.0","0.0","100.0","100.0","100.0","93.33333333333333","100.0","100.0","100.0","93.33333333333333","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/272","
QUESTION:
Santa Claus decided to disassemble his keyboard to clean it. After he returned all the keys back, he suddenly realized that some pairs of keys took each other's place! That is, Santa suspects that each key is either on its place, or on the place of another key, which is located exactly where the first key should be. 

In order to make sure that he's right and restore the correct order of keys, Santa typed his favorite patter looking only to his keyboard.

You are given the Santa's favorite patter and the string he actually typed. Determine which pairs of keys could be mixed. Each key must occur in pairs at most once.


-----Input-----

The input consists of only two strings s and t denoting the favorite Santa's patter and the resulting string. s and t are not empty and have the same length, which is at most 1000. Both strings consist only of lowercase English letters.


-----Output-----

If Santa is wrong, and there is no way to divide some of keys into pairs and swap keys in each pair so that the keyboard will be fixed, print «-1» (without quotes).

Otherwise, the first line of output should contain the only integer k (k ≥ 0) — the number of pairs of keys that should be swapped. The following k lines should contain two space-separated letters each, denoting the keys which should be swapped. All printed letters must be distinct.

If there are several possible answers, print any of them. You are free to choose the order of the pairs and the order of keys in a pair.

Each letter must occur at most once. Santa considers the keyboard to be fixed if he can print his favorite patter without mistakes.


-----Examples-----
Input
helloworld
ehoolwlroz

Output
3
h e
l o
d z

Input
hastalavistababy
hastalavistababy

Output
0

Input
merrychristmas
christmasmerry

Output
-1
Use user-input-Based format and function signature solve()","
def solve(s: str, t: str) -> None:
    from collections import defaultdict
    
    mapping = {}
    for i in range(len(s)):
        if s[i] in mapping and mapping[s[i]] != t[i]:
            print(-1)
            return
        mapping[s[i]] = t[i]
    
    swaps = defaultdict(list)
    for key, value in mapping.items():
        if key != value:
            swaps[key].append(value)
            swaps[value].append(key)
    
    print(len(swaps))
    for key, values in swaps.items():
        for value in values:
            print(key, value)

solve()","
def solve():
    s = input()
    t = input()
    
    diff = [(s[i], t[i]) for i in range(len(s)) if s[i] != t[i]]
    
    if len(diff) % 2 != 0:
        print(-1)
    else:
        pairs = set()
        for i in range(len(diff)):
            for j in range(i+1, len(diff)):
                if diff[i][0] == diff[j][1] and diff[i][1] == diff[j][0]:
                    pairs.add((diff[i][0], diff[i][1]))
        
        print(len(pairs))
        for pair in pairs:
            print(pair[0], pair[1])

solve()
","
def solve(s: str, t: str) -> str:
    mapping = {}
    swaps = []
    
    for i in range(len(s)):
        if s[i] in mapping:
            if mapping[s[i]] != t[i]:
                return ""-1""
        else:
            mapping[s[i]] = t[i]
            if t[i] != s[i]:
                mapping[t[i]] = s[i]
                swaps.append((s[i], t[i]))
    
    ans = [str(len(swaps))]
    for swap in swaps:
        ans.append(f""{swap[0]} {swap[1]}"")
    
    return ""\n"".join(ans)

solve()","
def solve(s, t):
    from collections import defaultdict

    def fix_keyboard(s, t):
        if len(s) != len(t):
            return -1

        swap_pairs = []
        mapping = defaultdict()

        for char_s, char_t in zip(s, t):
            if char_s in mapping:
                if mapping[char_s] != char_t:
                    return -1
            else:
                mapping[char_s] = char_t

        for char_s, char_t in zip(s, t):
            if char_t != char_s:
                if mapping[char_t] != char_s:
                    return -1
                swap_pairs.append((char_s, char_t))
                mapping.pop(char_s)

        return swap_pairs

    swap_pairs = fix_keyboard(s, t)

    if swap_pairs == -1:
        return -1
    else:
        print(len(swap_pairs))
        for pair in swap_pairs:
            print(pair[0], pair[1])

solve()","
def solve():
    s = input()
    t = input()
    n = len(s)
    
    count = 0
    swapped_pairs = []
    mapping = {}
    
    for i in range(n):
        if s[i] != t[i]:
            if t[i] in mapping and mapping[t[i]] != s[i]:
                print(-1)
                return
            
            if s[i] in mapping and mapping[s[i]] != t[i]:
                print(-1)
                return
            
            count += 1
            swapped_pairs.append((s[i], t[i]))
            mapping[s[i]] = t[i]
            mapping[t[i]] = s[i]
    
    print(count)
    for pair in swapped_pairs:
        print(pair[0], pair[1])

solve()","
def solve(s: str, t: str) -> None:
    if sorted(s) != sorted(t):
        print(-1)
    else:
        swaps = []
        for i in range(len(s)):
            if s[i] != t[i]:
                for j in range(i + 1, len(t)):
                    if t[j] == s[i]:
                        swaps.append((s[i], t[i]))
                        t = t[:i] + t[j] + t[i+1:j] + t[i] + t[j+1:]
                        break
        print(len(swaps))
        for pair in swaps:
            print(pair[0], pair[1])
   
solve()","
def solve():
    s = input()
    t = input()

    if sorted(s) != sorted(t):
        print(-1)
    else:
        pairs = []
        for i in range(len(s)):
            if s[i] != t[i]:
                for j in range(i + 1, len(t)):
                    if t[j] == s[i]:
                        t = list(t)
                        t[i], t[j] = t[j], t[i]
                        t = """".join(t)
                        pairs.append((s[i], t[i]))
                        break
        print(len(pairs))
        for pair in pairs:
            print(pair[0], pair[1])

solve()
","
def solve():
    import sys
    s, t = input().strip(), input().strip()
    
    char_map = {s[i]: t[i] for i in range(len(s))}
    swapped_keys = set()
    
    for i in range(len(s)):
        if char_map[t[i]] != s[i] or char_map[s[i]] != t[i]:
            if (char_map[t[i]], char_map[s[i]]) in swapped_keys:
                continue
            swapped_keys.add((s[i], t[i]))
    
    if len(swapped_keys) * 2 > len(set(s)):
        print(-1)
    else:
        print(len(swapped_keys))
        for pair in swapped_keys:
            print(pair[0], pair[1])

solve()
","
def solve(s, t):
    n = len(s)
    diff = [(s[i], t[i]) for i in range(n) if s[i] != t[i]]
    seen = set()
    ans = []
    
    for char1, char2 in diff:
        if (char2, char1) in seen:
            ans.append((char1, char2))
            seen.remove((char2, char1))
        else:
            seen.add((char1, char2))
    
    if len(seen) == 0:
        print(len(ans))
        for pair in ans:
            print(pair[0], pair[1])
    else:
        print(-1)

# Example usage
solve(""helloworld"", ""ehoolwlroz"")

solve()","
def solve(s: str, t: str) -> None:
    if sorted(s) != sorted(t):
        print(-1)
        return
    
    swaps = []
    for i in range(len(s)):
        if s[i] != t[i]:
            for j in range(i+1, len(s)):
                if s[j] == s[i]:
                    swaps.append((t[i], t[j))
                    t = t[:i] + t[j] + t[i+1:j] + t[i] + t[j+1:]
                    break
            else:
                print(-1)
                return
    
    print(len(swaps))
    for pair in swaps:
        print(f""{pair[0]} {pair[1]}"")

solve()","
def solve(s: str, t: str) -> None:
    mismatched_pairs = []

    for i in range(len(s)):
        if s[i] != t[i]:
            for j in range(i + 1, len(t)):
                if t[j] == s[i] and s[j] == t[i]:
                    mismatched_pairs.append((s[i], t[i]))
                    s = s[:i] + t[j] + s[i + 1:]
                    t = t[:j] + s[j] + t[j + 1:]
                    break

    if len(mismatched_pairs) == 0:
        print(0)
    else:
        print(len(mismatched_pairs))
        for pair in mismatched_pairs:
            print(pair[0], pair[1])

solve()","
def solve(s: str, t: str) -> str:
    from collections import defaultdict
    
    mapping = defaultdict(str)
    swapped_keys = set()
    
    for i in range(len(s)):
        if mapping[s[i]]:
            if mapping[s[i]] != t[i]:
                return ""-1""
            swapped_keys.add((mapping[s[i]], s[i]))
            mapping[t[i]] = s[i]
        else:
            mapping[t[i]] = s[i]

    ans = []
    for key in swapped_keys:
        ans.append(key[0] + "" "" + key[1])
    
    return str(len(ans)) + ""\n"" + ""\n"".join(ans)

solve()","
def solve(s: str, t: str) -> None:
    from collections import defaultdict
    from itertools import combinations

    def helper(s, t):
        char_map = defaultdict(set)
        for i in range(len(s)):
            char_map[s[i]].add(t[i])
        
        swaps = []
        for k, v in char_map.items():
            if len(v) != 1:
                return -1
            if k in v and len(v) == 1:
                continue
            swaps.append((k, next(iter(v))))
        
        return swaps

    pairs = helper(s, t)
    if pairs == -1:
        print(-1)
    else:
        print(len(pairs))
        for pair in pairs:
            print(pair[0], pair[1])
  
solve()","
from collections import defaultdict

def solve(s: str, t: str) -> str:
    if len(s) != len(t):
        return ""-1""

    swaps = defaultdict(list)
    for char_s, char_t in zip(s, t):
        if char_s != char_t:
            swaps[char_s].append(char_t)

    for key, values in swaps.items():
        if len(values) != 2 or values[0] != values[1]:
            return ""-1""

    pair_count = len(swaps) // 2
    swapped_pairs = []
    for key, values in swaps.items():
        if key < values[0]:
            swapped_pairs.append(f""{key} {values[0]}"")

    return f""{pair_count}\n"" + ""\n"".join(swapped_pairs)

solve()","
def solve(s: str, t: str):
    from collections import defaultdict
    
    pairs_mapping = defaultdict(lambda: None)
    for char_s, char_t in zip(s, t):
        if char_s != char_t:
            # Check if the two keys are already mapped to each other
            if pairs_mapping[char_s] != char_t and pairs_mapping[char_t] != char_s:
                pairs_mapping[char_s] = char_t
        
    swapped_pairs = []
    used_chars = set()
    for char_s, char_t in pairs_mapping.items():
        if char_t not in used_chars:
            swapped_pairs.append((char_s, char_t))
            used_chars.add(char_s)
            used_chars.add(char_t)
    
    if len(swapped_pairs) * 2 != len(used_chars):
        print(""-1"")
    else:
        print(len(swapped_pairs))
        for pair in swapped_pairs:
            print(pair[0], pair[1])

# Example usage
solve(""helloworld"", ""ehoolwlroz"")

solve()","
def solve(s: str, t: str) -> str:
    mismatched_pairs = []
    mapping = {}

    for char_s, char_t in zip(s, t):
        if char_s != char_t:
            if char_s in mapping:
                if mapping[char_s] != char_t:
                    return ""-1""
            mapping[char_s] = char_t
            mismatched_pairs.append((char_s, char_t))
    
    return str(len(mismatched_pairs)) + '\n' + '\n'.join([' '.join(pair) for pair in mismatched_pairs])

solve()","0.0","60.0","0.0","0.0","60.0","0.0","46.666666666666664","40.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/273","
QUESTION:
The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.

You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).

As a reminder, a prefix of a string s is its substring which occurs at the beginning of s: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".


-----Input-----

The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. 


-----Output-----

Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.


-----Examples-----
Input
harry potter

Output
hap

Input
tom riddle

Output
tomr
Use user-input-Based format and function signature solve()","
def solve():
    first_name, last_name = input().split()
    login = """"
    
    for i in range(1, min(len(first_name), len(last_name)) + 1):
        prefix = first_name[:i] + last_name[:i]
        if prefix < login or not login:
            login = prefix
    
    if not login:
        login = first_name if first_name < last_name else last_name
    
    print(login.lower())

solve()
","
def solve():
    first_name, last_name = input().split()
    login = ''
    i, j = 0, 0
    while i < len(first_name) and j < len(last_name):
        if first_name[i] <= last_name[j]:
            login += first_name[i]
            i += 1
        else:
            login += last_name[j]
            j += 1

    if i < len(first_name):
        login += first_name[i:]
    if j < len(last_name):
        login += last_name[j:]

    print(login.lower())

if __name__ == ""__main__"":
    solve()
","
def solve():
    import sys

    first_name, last_name = input().split()

    if first_name < last_name:
        login = first_name[0]
        if len(last_name) > 1:
            login += last_name[0]
        print(login.lower())
    else:
        login = last_name[0]
        if len(first_name) > 1:
            login += first_name[0]
        print(login.lower())

solve()
","
def solve():
    first_name, last_name = input().split()
    login = first_name[0]
    for i in range(1, min(len(first_name), len(last_name))):
        if first_name[:i] <= last_name[:i]:
            login += first_name[i]
        else:
            login += last_name[:i]
            break
    print(login.lower())

solve()
","
def solve():
    first_name, last_name = input().split()
    
    prefix_first = first_name[0]
    prefix_last = last_name[0]
    
    login = prefix_first
    
    if prefix_last < prefix_first:
        login = prefix_last
    elif prefix_last == prefix_first:
        login += min(first_name, last_name)[1:]
    else:
        login += prefix_last
    
    print(login)
    
solve()
","
def solve():
    # Input
    first_name, last_name = input().split()
    
    # Concatenating prefixes to generate login
    login = """"
    for i in range(1, min(len(first_name), len(last_name))+1):
        if first_name[:i] + last_name[:i] < login:
            login = first_name[:i] + last_name[:i]
        elif login == """" or first_name[:i] + last_name[:i] < login:
            login = first_name[:i] + last_name[:i]
    
    # Output the alphabetically earliest login
    print(login.lower())

solve()","
def solve():
    first_name, last_name = input().split()
    
    login = """"
    i = 0
    j = 0
    
    while i < len(first_name) and j < len(last_name):
        if first_name[i] <= last_name[j]:
            login += first_name[i]
            i += 1
        else:
            login += last_name[j]
            j += 1
    
    if i < len(first_name):
        login += first_name[i:]
    elif j < len(last_name):
        login += last_name[j:]
    
    print(login)

solve()
","
def solve():
    first_name, last_name = input().split()
    
    min_length = min(len(first_name), len(last_name))
    login = first_name[0:min_length] + last_name[0:min_length]
    
    if first_name < last_name and first_name[:min_length] != last_name[:min_length]:
        login = first_name[:min_length + 1]
    elif last_name < first_name and first_name[:min_length] != last_name[:min_length]:
        login = last_name[:min_length + 1]
    
    print(login.lower())

solve()
","
def solve():
    first_name, last_name = input().split()
    
    min_len = min(len(first_name), len(last_name))
    login = """"
    
    for i in range(min_len):
        if first_name[:i+1] < last_name[:i+1]:
            login = first_name[:i+1] + last_name[:i+1]
            break
        elif first_name[:i+1] > last_name[:i+1]:
            login = last_name[:i+1] + first_name[:i+1]
            break
    
    if login == """":
        login = first_name[:min_len] + last_name[:min_len]
    
    print(login.lower())

solve()","
def solve():
    # Import necessary module
    import sys
    
    # Read input from user
    input_data = sys.stdin.readline().strip().split()
    
    # Extract first and last names
    first_name = input_data[0]
    last_name = input_data[1]
    
    # Get the alphabetically earliest login
    login = first_name[0] + last_name[:2] if first_name[:2] < last_name[:2] else last_name[0] + first_name[:2]
    
    # Output the result
    print(login)

# Call the function to execute
solve()
","
def solve():
    first, last = input().split()
    login = first[0] + last[:min(2, len(last))]
    print(login.lower())

solve()
","
def solve():
    import itertools

    def generate_logins(first_name, last_name):
        logins = set()
        
        for i in range(1, min(len(first_name) + 1, len(last_name) + 1)):
            prefixes_first = [first_name[:i] if i <= len(first_name) else first_name]
            prefixes_last = [last_name[:i] if i <= len(last_name) else last_name]
            
            for pair in itertools.product(prefixes_first, prefixes_last):
                logins.add(''.join(pair))

        return sorted(logins)[0]

    names = input().split()
    first_name, last_name = names[0], names[1]

    return generate_logins(first_name, last_name)


solve()","
def solve():
    first_name, last_name = input().split()
    
    prefix = """"
    for i in range(min(len(first_name), len(last_name))):
        if first_name[:i+1] != last_name[:i+1]:
            prefix = min(first_name[:i+1], last_name[:i+1])
            break
    if prefix == """":
        prefix = min(first_name, last_name)
        
    return prefix

solve()
","
def solve():
    first_name, last_name = input().split()
    prefix_len = min(len(first_name), len(last_name))
    login = first_name[:prefix_len] + last_name[:prefix_len]
    if login == (first_name + last_name):  # If login is the full name
        login = first_name if first_name <= last_name else last_name
    print(login.lower())

solve()
","
def solve():
    first_name, last_name = input().split()
    
    def generate_login(name1, name2):
        for i in range(1, min(len(name1), len(name2)) + 1):
            login = name1[:i] + name2[:i]
            if login[0] != login[1]:  # Checking if the login generated so far is alphabetical
                return login
        return name1 if name1 < name2 else name2
    
    login = generate_login(first_name, last_name)
    
    print(login)

solve()
","
def solve():
    first_name, last_name = input().split()
    login = first_name[0]
    if first_name < last_name:
        login += first_name[1]
    else:
        login += last_name[0]
    print(login.lower())

solve()
","40.0","6.666666666666667","20.0","6.666666666666667","13.333333333333334","40.0","6.666666666666667","6.666666666666667","20.0","6.666666666666667","13.333333333333334","0.0","0.0","13.333333333333334","26.666666666666668","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/274","
QUESTION:
A sequence of square brackets is regular if by inserting symbols ""+"" and ""1"" into it, you can get a regular mathematical expression from it. For example, sequences ""[[]][]"", ""[]"" and ""[[][[]]]"" — are regular, at the same time ""]["", ""[[]"" and ""[[]]]["" — are irregular. 

Draw the given sequence using a minimalistic pseudographics in the strip of the lowest possible height — use symbols '+', '-' and '|'. For example, the sequence ""[[][]][]"" should be represented as: 

+-        -++- -+    

|+- -++- -+||   |

||   ||   |||   |

|+- -++- -+||   |

+-        -++- -+



Each bracket should be represented with the hepl of one or more symbols '|' (the vertical part) and symbols '+' and '-' as on the example which is given above.

Brackets should be drawn without spaces one by one, only dividing pairs of consecutive pairwise brackets with a single-space bar (so that the two brackets do not visually merge into one symbol). The image should have the minimum possible height. 

The enclosed bracket is always smaller than the surrounding bracket, but each bracket separately strives to maximize the height of the image. So the pair of final brackets in the example above occupies the entire height of the image.

Study carefully the examples below, they adequately explain the condition of the problem. Pay attention that in this problem the answer (the image) is unique. 


-----Input-----

The first line contains an even integer n (2 ≤ n ≤ 100) — the length of the sequence of brackets.

The second line contains the sequence of brackets — these are n symbols ""["" and ""]"". It is guaranteed that the given sequence of brackets is regular. 


-----Output-----

Print the drawn bracket sequence in the format which is given in the condition. Don't print extra (unnecessary) spaces. 


-----Examples-----
Input
8
[[][]][]

Output
+-        -++- -+
|+- -++- -+||   |
||   ||   |||   |
|+- -++- -+||   |
+-        -++- -+

Input
6
[[[]]]

Output
+-     -+
|+-   -+|
||+- -+||
|||   |||
||+- -+||
|+-   -+|
+-     -+

Input
6
[[][]]

Output
+-        -+
|+- -++- -+|
||   ||   ||
|+- -++- -+|
+-        -+

Input
2
[]

Output
+- -+
|   |
+- -+

Input
4
[][]

Output
+- -++- -+
|   ||   |
+- -++- -+
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    brackets = input()

    stack = []
    height = 0
    for bracket in brackets:
        if bracket == '[':
            stack.append(height)
            height += 1
        else:
            height = stack.pop()

    max_height = max(stack) + 1

    for i in range(max_height):
        line = ''
        for bracket in brackets:
            if bracket == '[':
                if i == 0:
                    line += '+-'
                else:
                    line += '| '
            else:
                if i == stack[brackets.index(bracket)]:
                    line += '-+'
                else:
                    line += '  '
        print(line)

solve()
","
def solve():
    n = int(input())
    brackets = input()

    stack = []
    level = 0
    for bracket in brackets:
        if bracket == '[':
            stack.append(level)
            level += 1
        else:
            level = stack.pop()

    height = max(stack) + 1

    for i in range(height):
        line = ''
        for bracket in brackets:
            if bracket == '[':
                line += '+'
            else:
                line += '-'
            line += '-' * 2 * max(0, (level - 1 - i))
            if bracket == ']':
                line += '+'
            else:
                line += '-'
        print(line)

    for i in range(1, height):
        line = ''
        for bracket in brackets:
            if bracket == '[':
                line += '|'
            else:
                line += ' '
            line += ' ' * 2 * max(0, (level - 1 - i))
            if bracket == ']':
                line += '|'
            else:
                line += ' '
        print(line)

    line = ''
    for bracket in brackets:
        if bracket == '[':
            line += '+'
        else:
            line += '-'
        line += '-' * 2 * max(0, (level - 1))
        if bracket == ']':
            line += '+'
        else:
            line += '-'
    print(line)

solve()
  ","
def solve():
    n = int(input())
    brackets = input().strip()
    
    layers = [1] * n
    for i in range(1, n):
        if brackets[i] == brackets[i - 1]:
            layers[i] = layers[i - 1]
        else:
            layers[i] = layers[i - 1] + 2
    
    for i in range(max(layers), 0, -1):
        for j in range(n):
            if j < len(layers) and layers[j] >= i:
                print('+', end='')
            else:
                print(' ', end='')
                
            if j < len(layers) and layers[j] == i:
                if j + 1 < n and brackets[j] == brackets[j + 1]:
                    print('-', end='')
                else:
                    print('+', end='')
            else:
                print(' ', end='')
        print()
        
        for j in range(n):
            if j < len(layers) and layers[j] >= i:
                print('|', end='')
            else:
                print(' ', end='')
                
            if j < len(layers) and layers[j] == i:
                if j + 1 < n and brackets[j] == brackets[j + 1]:
                    print(' ', end='')
                else:
                    print('-', end='')
            else:
                print(' ', end='')
        print()

solve()
  ","
def solve():
    n = int(input())
    brackets = input()

    levels = [0] * n
    height = 1

    result = []
    for bracket in brackets:
        if bracket == '[':
            levels[height - 1] += 1
            height = max(levels) + 1
        else:
            height -= 1
            levels[height] -= 1

        current_level = ['|' if i <= level else ' ' for i, level in enumerate(levels)]
        result.append(''.join(current_level))

    for i in range(max(levels)):
        line = ['+' if level > i else '-' for level in levels]
        result.insert(0, ''.join(line) + '\n')

    for line in result:
        print(line)

solve()","
def solve():
    n = int(input())
    brackets = input()

    level = 0
    result = []

    for bracket in brackets:
        if bracket == '[':
            result.append('+' + '-' * level + '+')
            level += 1
        else:
            level -= 1
            result.append('+' + '-' * level + '+')
    
    for line in zip(*result):
        print(''.join(line))

solve()","
def solve():
    n = int(input())
    brackets = input().strip()
    stack = []
    current_level = 0
    result = """"
    for bracket in brackets:
        if bracket == ""["":
            stack.append(current_level)
            current_level += 1
        else:
            current_level = stack.pop()
        if len(stack) > 0:
            for i in range(max(stack) + 1):
                result += ""|""
            result += ""+""
        else:
            result += ""+""
        for i in range(max(stack)):
            result += ""-+""
        result += "" ""
    print(result)


solve()","
def solve():
    n = int(input())
    s = input()
    
    brackets = []
    for bracket in s:
        if bracket == '[':
            brackets.append(1)
        else:
            brackets.append(-1)
    
    height = max(1, max(abs(sum(brackets[:i])) for i in range(1, len(brackets)+1))
    
    matrix = [[' '] * len(brackets * 2) for _ in range(height * 2)]
    
    offset = 0
    for bracket in brackets:
        if bracket == 1:
            for i in range(height):
                matrix[i][offset] = '+'
                matrix[height * 2 - 1 - i][offset] = '+'
                matrix[i][offset + 1] = '|'
                matrix[height * 2 - 1 - i][offset + 1] = '|'
            offset += 2
        else:
            for i in range(height):
                matrix[i][offset] = '-'
                matrix[height * 2 - 1 - i][offset] = '-'
            offset += 1

    for row in matrix:
        print(''.join(row))

solve()","
def solve():
    n = int(input())
    brackets = list(input())

    heights = [1] * len(brackets)
    level = 0

    for i in range(len(brackets)):
        if brackets[i] == '[':
            level += 1
            heights[i] = level
        else:
            heights[i] = level
            level -= 1

    max_height = max(heights)

    for h in range(max_height):
        line = """"
        for i in range(len(brackets)):
            if heights[i] >= max_height - h:
                if brackets[i] == '[':
                    line += ""+-""
                else:
                    line += ""-+""
            else:
                line += ""  ""
            if i < len(brackets) - 1 and heights[i] != heights[i + 1]:
                line += "" ""
        print(line)


solve()
","
def solve():
    n = int(input())
    brackets = input()
    
    stack = []
    top_height = 0
    level = 0
    for i in range(n):
        if brackets[i] == '[':
            stack.append(level)
            level += 1
            top_height = level if level > top_height else top_height
        else:
            level = stack.pop()
    
    for i in range(top_height):
        for j in range(n):
            if j < n - 1 and brackets[j] == '[' and brackets[j+1] == ']':
                print('+', end='')
            elif brackets[j] == '[':
                if i >= top_height - stack[j]:
                    print('|', end='')
                else:
                    print(' ', end='')
            elif brackets[j] == ']':
                if i >= top_height - stack[j]:
                    print(' ', end='')
                else:
                    print('|', end='')
        
            if j == n - 1:
                print('')
        
solve()
","
def solve():
    n = int(input())
    brackets = input().strip()

    level = 0
    height = 1

    for bracket in brackets:
        if bracket == ""["":
            print(""|"" + ""-"" * (level * 2) + ""+"", end='')
            level += 1
            height = max(height, level)
        else:
            level -= 1
            print(""|"" + ""-"" * (level * 2) + ""+"", end='')

    print()

    for h in range(1, height):
        for i in range(2 * n):
            if i % 2 == 0:
                print(""+"", end='')
            else:
                print(""-"", end='')
        print()

solve()
","
def solve():
    n = int(input())
    brackets = input()
    
    depth = 0
    result = """"
    
    for bracket in brackets:
        if bracket == '[':
            result += '|' + ('-'*depth) + '+'
            depth += 1
        else:
            depth -= 1
            result += '|' + ('-'*depth) + '+'
    
    print(result)

solve()","
def solve():
    n = int(input())
    brackets = input()

    stack = []
    height = 1
    for i in range(n):
        if brackets[i] == '[':
            if brackets[i+1] == ']':
                print('|' + '+-'*(len(stack)+1) + ' |')
                height += 1
            else:
                print('|' + '+-'*len(stack) + '-+|')
            stack.append(i)
        else:
            if stack[-1] == i-1:
                print('|' + '+-'*len(stack) + ' |')
            else:
                print('|' + '+-'*(len(stack)-1) + '-+|')
            stack.pop()

    print('+' + '- '*(len(stack)+1) + '+')

solve()","
def solve():
    n = int(input())
    brackets = input()

    stack = []
    output = []

    for i in range(n):
        if brackets[i] == '[':
            stack.append(i)
        else:
            start = stack.pop()
            if len(stack) == 0:
                output.append([start, i])

    height = (max(len(output), 1) * 2) - 1

    result = [[' ' for _ in range(n*2)] for _ in range(height)]
    
    for i in range(len(output)):
        start, end = output[i]
        mid = (end - start) // 2
        
        level = i * 2
        result[level][start*2] = '+'
        result[level][end*2] = '+'

        for j in range(start*2 + 1, end*2):
            result[level][j] = '-'
        
        for k in range(level + 1, level + 5):
            result[k][start*2] = '|'
            result[k][end*2] = '|'
        
        if i < len(output) - 1:
            next_start, next_end = output[i+1]
            mid_next = (next_end - next_start) // 2

            for j in range(mid*2 + 1, mid_next*2, 2):
                for k in range(level + 2, level + 4):
                    result[k][j] = ' '
    
    for line in result:
        print("""".join(line))

solve()
","
def solve():
    n = int(input())
    brackets = input()
    
    level = 1
    for i in range(len(brackets)):
        if brackets[i] == '[':
            print('|' * level + '+', end='')
            level += 1
        else:
            level -= 1
            print('|' * level + '-', end='')
            if i < len(brackets) - 1 and brackets[i + 1] == ']':
                print('+', end='')
            else:
                print('|', end='')
    print('|' * level)

solve()","
def solve():
    n = int(input())
    brackets = input()

    output = ''
    stack = []
    for b in brackets:
        if b == '[':
            if stack:
                output += '|'
            stack.append(b)
        else:
            stack.pop()
            if stack:
                output += '|-'
            else:
                output += '-'
    print('+' + output + '+')

    row_length = len(output) + 2
    for _ in range(n-2):
        print('|' + ' '*(row_length-2) + '|')

    print('+' + output + '+')
 
solve()","
def solve():
    n = int(input())
    s = input().strip()
    m = 2 * n + 2
    res = [[' ' for _ in range(m)] for _ in range(m)]

    res[0][0] = '+'
    res[0][1] = '-'

    for i in range(1, n):
        res[0][2*i] = '+'
        res[0][2*i+1] = '-'
        res[m-1][2*i-1] = '+'
        res[m-1][2*i] = '-'
        res[i][2*i] = '+'
        res[i][2*i+1] = '-'
        res[i-1][2*i-1] = '|'
        res[m-i][2*i-1] = '|'

    res[n][0] = '+'
    res[n][1] = '-'
    res[m-1][m-1] = '+'
    res[m-1][m-2] = '-'

    for i in range(2, m-2):
        res[n][i] = '-'
        res[m-1][i] = '-'

    for i in range(m):
        print(''.join(res[i]))

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/275","
QUESTION:
Piegirl got bored with binary, decimal and other integer based counting systems. Recently she discovered some interesting properties about number $q = \frac{\sqrt{5} + 1}{2}$, in particular that q^2 = q + 1, and she thinks it would make a good base for her new unique system. She called it ""golden system"". In golden system the number is a non-empty string containing 0's and 1's as digits. The decimal value of expression a_0a_1...a_{n} equals to $\sum_{i = 0}^{n} a_{i} \cdot q^{n - i}$.

Soon Piegirl found out that this system doesn't have same properties that integer base systems do and some operations can not be performed on it. She wasn't able to come up with a fast way of comparing two numbers. She is asking for your help.

Given two numbers written in golden system notation, determine which of them has larger decimal value.


-----Input-----

Input consists of two lines — one for each number. Each line contains non-empty string consisting of '0' and '1' characters. The length of each string does not exceed 100000.


-----Output-----

Print "">"" if the first number is larger, ""<"" if it is smaller and ""="" if they are equal.


-----Examples-----
Input
1000
111

Output
<

Input
00100
11

Output
=

Input
110
101

Output
>



-----Note-----

In the first example first number equals to $((\sqrt{5} + 1) / 2)^{3} \approx 1.618033988^{3} \approx 4.236$, while second number is approximately 1.618033988^2 + 1.618033988 + 1 ≈ 5.236, which is clearly a bigger number.

In the second example numbers are equal. Each of them is  ≈ 2.618.
Use user-input-Based format and function signature solve()","
from math import sqrt

def solve():
    q = (sqrt(5) + 1) / 2

    num1 = input().strip()
    num2 = input().strip()

    val1 = sum(int(num1[i]) * q**(len(num1) - i - 1) for i in range(len(num1)))
    val2 = sum(int(num2[i]) * q**(len(num2) - i - 1) for i in range(len(num2))

    if val1 > val2:
        print("">"")
    elif val1 < val2:
        print(""<"")
    else:
        print(""="")

solve()","
from decimal import Decimal

def solve():
    num1 = input()
    num2 = input()

    def convert_to_decimal(num):
        decimal_value = 0
        q = (Decimal(5).sqrt() + 1) / 2

        for i in range(len(num)):
            decimal_value += int(num[i]) * q ** (len(num) - 1 - i)

        return decimal_value

    decimal_num1 = convert_to_decimal(num1)
    decimal_num2 = convert_to_decimal(num2)

    if decimal_num1 > decimal_num2:
        print("">"")
    elif decimal_num1 < decimal_num2:
        print(""<"")
    else:
        print(""="")

solve()
","
from decimal import Decimal

def solve():
    num1 = input().strip()
    num2 = input().strip()

    def get_decimal_value(number):
        decimal_value = Decimal(0)
        q = (Decimal(5).sqrt() + 1) / 2

        for i, digit in enumerate(number[::-1]):
            decimal_value += int(digit) * q**(i)

        return decimal_value

    decimal_value_num1 = get_decimal_value(num1)
    decimal_value_num2 = get_decimal_value(num2)

    if decimal_value_num1 > decimal_value_num2:
        print("">"")
    elif decimal_value_num1 < decimal_value_num2:
        print(""<"")
    else:
        print(""="")

solve()
","
import math

def solve():
    num1 = input().strip()
    num2 = input().strip()

    def to_decimal(num):
        decimal_val = 0
        length = len(num)
        
        for i in range(length):
            power = length - i - 1
            decimal_val += int(num[i]) * (math.pow((math.sqrt(5) + 1) / 2, power))

        return decimal_val

    decimal_num1 = to_decimal(num1)
    decimal_num2 = to_decimal(num2)

    if decimal_num1 > decimal_num2:
        print("">"")
    elif decimal_num1 < decimal_num2:
        print(""<"")
    else:
        print(""="")

solve()
","
from sympy import Rational

def solve():
    q = Rational((5 ** 0.5) + 1, 2)
    
    num1 = input().strip()
    num2 = input().strip()
    
    val1 = sum(int(num1[i]) * q ** (len(num1) - i - 1) for i in range(len(num1)))
    val2 = sum(int(num2[i]) * q ** (len(num2) - i - 1) for i in range(len(num2))
    
    if val1 > val2:
        print("">"")
    elif val1 < val2:
        print(""<"")
    else:
        print(""="")

solve()","
from sympy import symbols

def solve():
    phi = (5 ** 0.5 + 1) / 2
    a = input().strip()
    b = input().strip()
    
    a_decimal = 0
    b_decimal = 0
    
    for i in range(len(a)):
        a_decimal += int(a[i]) * phi ** (len(a) - i - 1)
    
    for i in range(len(b)):
        b_decimal += int(b[i]) * phi ** (len(b) - i - 1)
    
    if a_decimal > b_decimal:
        print("">"")
    elif a_decimal < b_decimal:
        print(""<"")
    else:
        print(""="")

solve()","
from decimal import Decimal

def solve():
    def calculate_decimal(num):
        decimal_val = Decimal(0)
        num_len = len(num)
        
        for i in range(num_len):
            decimal_val += int(num[i]) * (Decimal(1 + 5 ** 0.5) / 2) ** Decimal(num_len - i - 1)
        
        return decimal_val
    
    num1 = input().strip()
    num2 = input().strip()
    
    decimal_num1 = calculate_decimal(num1)
    decimal_num2 = calculate_decimal(num2)
    
    if decimal_num1 < decimal_num2:
        print(""<"")
    elif decimal_num1 > decimal_num2:
        print("">"")
    else:
        print(""="")

solve()
  ","
from sympy import Rational

def solve():
    q = Rational((5**0.5 + 1) / 2)
    
    num1 = input().strip()
    num2 = input().strip()
    
    val1 = sum(int(num1[i]) * q**(len(num1) - i - 1) for i in range(len(num1)))
    val2 = sum(int(num2[i]) * q**(len(num2) - i - 1) for i in range(len(num2))
    
    if val1 > val2:
        print("">"")
    elif val1 < val2:
        print(""<"")
    else:
        print(""="")


solve()","
import math

def solve():
    num1 = input().strip()
    num2 = input().strip()

    def to_decimal(num):
        total = 0
        power = len(num) - 1
        for digit in num:
            if digit == '1':
                total += (math.sqrt(5) + 1) / 2 ** power
            power -= 1
        return total

    decimal_num1 = to_decimal(num1)
    decimal_num2 = to_decimal(num2)

    if decimal_num1 < decimal_num2:
        print(""<"")
    elif decimal_num1 > decimal_num2:
        print("">"")
    else:
        print(""="")

solve()
  ","
from math import sqrt

def solve():
    q = (sqrt(5) + 1) / 2

    num1 = input().strip()
    num2 = input().strip()

    def convert_to_decimal(num_str):
        decimal_val = 0
        n = len(num_str)
        for i in range(n):
            decimal_val += int(num_str[i]) * (q ** (n - i - 1))
        return decimal_val

    decimal_val1 = convert_to_decimal(num1)
    decimal_val2 = convert_to_decimal(num2)

    if decimal_val1 > decimal_val2:
        print("">"")
    elif decimal_val1 < decimal_val2:
        print(""<"")
    else:
        print(""="")

solve()
","
import math

def solve():
    num1 = input()
    num2 = input()
    
    def convert_to_decimal(num):
        decimal_val = 0
        n = len(num)
        for i in range(n):
            decimal_val += int(num[i]) * math.pow((math.sqrt(5) + 1) / 2, n - i - 1)
        return decimal_val

    decimal_num1 = convert_to_decimal(num1)
    decimal_num2 = convert_to_decimal(num2)
    
    if decimal_num1 > decimal_num2:
        print("">"")
    elif decimal_num1 < decimal_num2:
        print(""<"")
    else:
        print(""="")

solve()
","
from sympy import sqrt

def solve():
    q = (sqrt(5) + 1) / 2

    num1 = input().strip()
    num2 = input().strip()

    val1 = sum(int(num1[i]) * q ** (len(num1) - 1 - i) for i in range(len(num1)))
    val2 = sum(int(num2[i]) * q ** (len(num2) - 1 - i) for i in range(len(num2))

    if val1 > val2:
        print("">"")
    elif val1 < val2:
        print(""<"")
    else:
        print(""="")

solve()
","
from decimal import Decimal

def solve():
    q = (Decimal(5).sqrt() + 1) / 2

    num1 = input().strip()
    num2 = input().strip()

    val1 = Decimal(0)
    val2 = Decimal(0)

    for i in range(len(num1)):
        val1 += int(num1[i]) * q**(len(num1) - i - 1)

    for i in range(len(num2)):
        val2 += int(num2[i]) * q**(len(num2) - i - 1)

    if val1 < val2:
        print(""<"")
    elif val1 > val2:
        print("">"")
    else:
        print(""="")

solve()","
import math

def solve():
    num1 = input().strip()
    num2 = input().strip()

    def golden_decimal(num):
        value = 0
        for i in range(len(num)):
            value += int(num[i]) * ((math.sqrt(5) + 1) / 2) ** (len(num) - i - 1)
        return value

    decimal_num1 = golden_decimal(num1)
    decimal_num2 = golden_decimal(num2)

    if decimal_num1 > decimal_num2:
        print("">"")
    elif decimal_num1 < decimal_num2:
        print(""<"")
    else:
        print(""="")

solve()
","
from sympy import N, sqrt

def solve():
    num1 = input().strip()
    num2 = input().strip()
    
    q = (sqrt(5) + 1) / 2
    
    def decimal_value(num):
        value = 0
        for i in range(len(num)):
            value += int(num[i]) * q**(len(num) - i - 1)
        return N(value, 10)
    
    val1 = decimal_value(num1)
    val2 = decimal_value(num2)
    
    if val1 > val2:
        print("">"")
    elif val1 < val2:
        print(""<"")
    else:
        print(""="")

solve()
  ","
from sympy import Rational

def solve():
    num1 = input()
    num2 = input()
    
    q = Rational(1, 2) * (5**0.5 + 1)
    
    val1 = sum(int(num1[i]) * q**(len(num1) - 1 - i) for i in range(len(num1)))
    val2 = sum(int(num2[i]) * q**(len(num2) - 1 - i) for i in range(len(num2))
    
    if val1 > val2:
        print("">"")
    elif val1 < val2:
        print(""<"")
    else:
        print(""="")
  
solve()","0.0","93.33333333333333","93.33333333333333","100.0","0.0","0.0","93.33333333333333","0.0","46.666666666666664","100.0","100.0","0.0","93.33333333333333","100.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/276","
QUESTION:
You took a peek on Thanos wearing Infinity Gauntlet. In the Gauntlet there is a place for six Infinity Gems:  the Power Gem of purple color,  the Time Gem of green color,  the Space Gem of blue color,  the Soul Gem of orange color,  the Reality Gem of red color,  the Mind Gem of yellow color. 

Using colors of Gems you saw in the Gauntlet determine the names of absent Gems.


-----Input-----

In the first line of input there is one integer $n$ ($0 \le n \le 6$) — the number of Gems in Infinity Gauntlet.

In next $n$ lines there are colors of Gems you saw. Words used for colors are: purple, green, blue, orange, red, yellow. It is guaranteed that all the colors are distinct. All colors are given in lowercase English letters.


-----Output-----

In the first line output one integer $m$ ($0 \le m \le 6$) — the number of absent Gems.

Then in $m$ lines print the names of absent Gems, each on its own line. Words used for names are: Power, Time, Space, Soul, Reality, Mind. Names can be printed in any order. Keep the first letter uppercase, others lowercase.


-----Examples-----
Input
4
red
purple
yellow
orange

Output
2
Space
Time

Input
0

Output
6
Time
Mind
Soul
Power
Reality
Space



-----Note-----

In the first sample Thanos already has Reality, Power, Mind and Soul Gems, so he needs two more: Time and Space.

In the second sample Thanos doesn't have any Gems, so he needs all six.
Use user-input-Based format and function signature solve()","
def solve():
    gems = {
        'purple': 'Power',
        'green': 'Time',
        'blue': 'Space',
        'orange': 'Soul',
        'red': 'Reality',
        'yellow': 'Mind'
    }

    n = int(input())
    seen_gems = set()
    for _ in range(n):
        color = input().strip()
        seen_gems.add(gems[color])

    all_gems = set(gems.values())
    missing_gems = all_gems - seen_gems

    print(len(missing_gems))
    for gem in missing_gems:
        print(gem)

solve()","
from typing import List

def solve():
    gems = ['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind']
    colors_to_gems = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}

    n = int(input())
    colors = []
    for _ in range(n):
        colors.append(input())

    present_gems = [colors_to_gems[color] for color in colors]
    absent_gems = list(set(gems) - set(present_gems))

    print(len(absent_gems))
    for gem in absent_gems:
        print(gem)
  
solve()","
def solve():
    gems_colors = [""purple"", ""green"", ""blue"", ""orange"", ""red"", ""yellow""]
    gems_names = [""Power"", ""Time"", ""Space"", ""Soul"", ""Reality"", ""Mind""]
    
    n = int(input())
    seen_gems = set()

    for _ in range(n):
        seen_gems.add(input())

    absent_gems = set(gems_names) - set([gems_names[gems_colors.index(color)] for color in seen_gems])

    print(len(absent_gems))
    for gem in absent_gems:
        print(gem)

solve()","
from typing import List

def solve():
    gems = {'power': 'Power', 'time': 'Time', 'space': 'Space', 'soul': 'Soul', 'reality': 'Reality', 'mind': 'Mind'}
    
    n = int(input())
    present_gems = set()
    for _ in range(n):
        color = input().strip()
        for key, value in gems.items():
            if color == key:
                present_gems.add(value)
    
    absent_gems = set(gems.values()) - present_gems
    
    print(len(absent_gems))
    for gem in absent_gems:
        print(gem)
  
solve()","
def solve():
    gems_colors = ['purple', 'green', 'blue', 'orange', 'red', 'yellow']
    gems_names = ['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind']
    
    n = int(input())
    present_gems = set()
    
    for _ in range(n):
        present_gems.add(input())
    
    absent_gems = set(gems_names) - set([gems_names[gems_colors.index(color)] for color in present_gems])
    
    m = len(absent_gems)
    print(m)
    
    for gem in absent_gems:
        print(gem)
   
solve()","
def solve():
    from collections import Counter

    gems_colors = {
        'purple': 'Power',
        'green': 'Time',
        'blue': 'Space',
        'orange': 'Soul',
        'red': 'Reality',
        'yellow': 'Mind'
    }
    
    n = int(input())
    seen_colors = [input() for _ in range(n)]

    missing_gems = set(gems_colors.values()) - set(gems_colors[color] for color in seen_colors)
    print(len(missing_gems))
    for gem in missing_gems:
        print(gem)

solve()","
def solve():
    colors = set([""purple"", ""green"", ""blue"", ""orange"", ""red"", ""yellow""])
    gems = {""purple"": ""Power"", ""green"": ""Time"", ""blue"": ""Space"", ""orange"": ""Soul"", ""red"": ""Reality"", ""yellow"": ""Mind""}
    
    n = int(input())
    seen_colors = set()
    for _ in range(n):
        color = input().strip()
        seen_colors.add(color)
    
    absent_colors = colors - seen_colors
    m = len(absent_colors)
    
    for color in absent_colors:
        print(gems[color])
    
    return

solve()
","
def solve():
    gems = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}
    
    n = int(input())
    present_gems = set(input() for _ in range(n))
    
    absent_gems = set(gems[color] for color in gems if color not in present_gems)
    
    print(len(absent_gems))
    for gem in absent_gems:
        print(gem)

solve()
","
def solve():
    gems = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}
    color_to_gem = {v: k for k, v in gems.items()}

    n = int(input())
    colors_seen = [input() for _ in range(n)]

    absent_colors = set(color_to_gem.keys()) - set(colors_seen)
    m = len(absent_colors)

    print(m)
    for color in absent_colors:
        print(color_to_gem[color])

solve()","
def solve():
    colors = set(['purple', 'green', 'blue', 'orange', 'red', 'yellow'])
    gems = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}

    n = int(input())
    present_gems = set()
    for _ in range(n):
        color = input().strip()
        present_gems.add(color)

    absent_gems = colors.difference(present_gems)
    m = len(absent_gems)
    
    print(m)
    for color in absent_gems:
        print(gems[color])

solve()
","
def solve():
    gems = {
        'purple': 'Power',
        'green': 'Time',
        'blue': 'Space',
        'orange': 'Soul',
        'red': 'Reality',
        'yellow': 'Mind'
    }

    n = int(input())
    present_gems = set(input() for _ in range(n))
    absent_gems = set(gems.values()) - set([gems[color] for color in present_gems])

    m = len(absent_gems)
    print(m)
    for gem in absent_gems:
        print(gem)

# Required import for user input
import sys
sys.stdin = open(0)

solve()
","
from typing import List

def solve() -> None:
    gems = {
        'purple': 'Power',
        'green': 'Time',
        'blue': 'Space',
        'orange': 'Soul',
        'red': 'Reality',
        'yellow': 'Mind'
    }

    n = int(input())
    existing_gems = set(input() for _ in range(n))

    all_gems = set(gems.keys())
    absent_gems = all_gems - existing_gems

    print(len(absent_gems))
    for gem_color in absent_gems:
        print(gems[gem_color])
  
solve()","
from typing import List

def solve():
    gems = {
        'purple': 'Power',
        'green': 'Time',
        'blue': 'Space',
        'orange': 'Soul',
        'red': 'Reality',
        'yellow': 'Mind'
    }
    
    n = int(input())
    
    colors_found = set()
    for _ in range(n):
        colors_found.add(input())
    
    missing_gems = set(gems.values()) - set([gem for color, gem in gems.items() if color in colors_found])
    
    print(len(missing_gems))
    for missing_gem in missing_gems:
        print(missing_gem)

solve()","
def solve():
    gems_dict = {""purple"": ""Power"", ""green"": ""Time"", ""blue"": ""Space"", ""orange"": ""Soul"", ""red"": ""Reality"", ""yellow"": ""Mind""}
    colors_seen = set()
    
    n = int(input())
    for _ in range(n):
        color = input()
        colors_seen.add(color)
    
    absent_gems = [gem_name for color, gem_name in gems_dict.items() if color not in colors_seen]
    
    m = len(absent_gems)
    print(m)
    for gem in absent_gems:
        print(gem)
  
solve()","
def solve():
    gems = {
        ""purple"": ""Power"",
        ""green"": ""Time"",
        ""blue"": ""Space"",
        ""orange"": ""Soul"",
        ""red"": ""Reality"",
        ""yellow"": ""Mind""
    }

    n = int(input())
    existing_gems = set()

    for _ in range(n):
        color = input().strip()
        existing_gems.add(gems[color])

    missing_gems = set(gems.values()) - existing_gems
    print(len(missing_gems))
    for gem in missing_gems:
        print(gem)

solve()","
def solve():
    gems_colors = set(['purple', 'green', 'blue', 'orange', 'red', 'yellow'])
    gems_names = ['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind']

    n = int(input())
    seen_gems = set(input() for _ in range(n))

    absent_gems = gems_colors - seen_gems
    m = len(absent_gems)

    print(m)
    for gem_color in absent_gems:
        gem_index = ['purple', 'green', 'blue', 'orange', 'red', 'yellow'].index(gem_color)
        print(gems_names[gem_index])


solve()","13.333333333333334","6.666666666666667","6.666666666666667","0.0","26.666666666666668","13.333333333333334","0.0","6.666666666666667","0.0","13.333333333333334","13.333333333333334","13.333333333333334","6.666666666666667","26.666666666666668","20.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/277","
QUESTION:
The last stage of Football World Cup is played using the play-off system.

There are n teams left in this stage, they are enumerated from 1 to n. Several rounds are held, in each round the remaining teams are sorted in the order of their ids, then the first in this order plays with the second, the third — with the fourth, the fifth — with the sixth, and so on. It is guaranteed that in each round there is even number of teams. The winner of each game advances to the next round, the loser is eliminated from the tournament, there are no draws. In the last round there is the only game with two remaining teams: the round is called the Final, the winner is called the champion, and the tournament is over.

Arkady wants his two favorite teams to play in the Final. Unfortunately, the team ids are already determined, and it may happen that it is impossible for teams to meet in the Final, because they are to meet in some earlier stage, if they are strong enough. Determine, in which round the teams with ids a and b can meet.


-----Input-----

The only line contains three integers n, a and b (2 ≤ n ≤ 256, 1 ≤ a, b ≤ n) — the total number of teams, and the ids of the teams that Arkady is interested in. 

It is guaranteed that n is such that in each round an even number of team advance, and that a and b are not equal.


-----Output-----

In the only line print ""Final!"" (without quotes), if teams a and b can meet in the Final.

Otherwise, print a single integer — the number of the round in which teams a and b can meet. The round are enumerated from 1.


-----Examples-----
Input
4 1 2

Output
1

Input
8 2 6

Output
Final!

Input
8 7 5

Output
2



-----Note-----

In the first example teams 1 and 2 meet in the first round.

In the second example teams 2 and 6 can only meet in the third round, which is the Final, if they win all their opponents in earlier rounds.

In the third example the teams with ids 7 and 5 can meet in the second round, if they win their opponents in the first round.
Use user-input-Based format and function signature solve()","
def solve():
    n, a, b = map(int, input().split())
    
    round_num = 1
    while n > 1:
        n = n // 2
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 1:
                print(""Final!"")
            else:
                print(round_num)
            return
        round_num += 1

solve()
","
def solve():
    n, a, b = map(int, input().split())
    
    round_num = 1
    while n > 1:
        n = n // 2
        if (a <= n and b > n) or (a > n and b <= n):
            break
        round_num += 1
    
    if n == 1:
        print(""Final!"")
    else:
        print(round_num)

solve()","
def solve():
    n, a, b = map(int, input().split())
    
    round = 1
    while n > 1:
        n = n // 2
        if a <= n < b or b <= n < a:
            break
        round += 1
    
    if n == 1:
        print(""Final!"")
    else:
        print(round)

solve()","
def solve():
    n, a, b = map(int, input().split())
    
    round_num = 1
    while n > 1:
        n = n // 2
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 1:
                print(""Final!"")
            else:
                print(round_num)
            break
        round_num += 1

solve()","
def solve():
    n, a, b = map(int, input().split())
    if (a + 1) // 2 == (b + 1) // 2:
        print(""Final!"")
    else:
        round_count = 1
        while n > 1:
            n = (n + 1) // 2
            round_count += 1
            if (a + 1) // 2 == (b + 1) // 2:
                print(round_count)
                break

solve()
","
def solve():
    n, a, b = map(int, input().split())
    
    round_count = 1
    while n > 1:
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 2:
                print(""Final!"")
            else:
                print(round_count)
            return
        round_count += 1
        n = (n + 1) // 2

solve()
","
def solve():
    n, a, b = map(int, input().split())
    
    round_num = 1
    while n > 2:
        if (a + 1) // 2 == (b + 1) // 2:
            break
        a = (a + 1) // 2
        b = (b + 1) // 2
        n = (n + 1) // 2
        round_num += 1

    if n == 2:
        print(""Final!"")
    else:
        print(round_num)

solve()","
def solve():
    n, a, b = map(int, input().split())
    if abs(a-b) == 1 and (a+b)%4 == 3:
        print(""Final!"")
    else:
        round = 1
        while n > 1:
            a = (a+1)//2
            b = (b+1)//2
            n = (n+1)//2
            if a == b:
                break
            round += 1
        print(round)

solve()","
def solve():
    n, a, b = map(int, input().split())
    
    round = 1
    while n > 1:
        n = n // 2
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 1:
                print(""Final!"")
            else:
                print(round)
            return
        round += 1

solve()
","
def solve():
    n, a, b = map(int, input().split())
    round = 1
    
    while n > 1:
        a = (a + 1) // 2
        b = (b + 1) // 2
        n = (n + 1) // 2
        if a == b:
            break
        round += 1
    
    if n == 1:
        print(""Final!"")
    else:
        print(round)

solve()","
def solve():
    n, a, b = map(int, input().split())
    
    round_num = 1
    while n > 1:
        if a <= n // 2 < b or b <= n // 2 < a:
            break
        n = (n + 1) // 2
        round_num += 1
    
    if n == 2:
        print(""Final!"")
    else:
        print(round_num)
  
solve()","
def solve():
    n, a, b = map(int, input().split())

    round = 1
    while n > 1:
        n = n // 2
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 1:
                print(""Final!"")
            else:
                print(round)
            break
        round += 1

solve()
","
def solve():
    n, a, b = map(int, input().split())
    
    round_num = 1
    while n > 1:
        n = n // 2
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 1:
                print(""Final!"")
            else:
                print(round_num)
            return
        round_num += 1

solve()
","
def solve():
    n, a, b = map(int, input().split())
    round_count = 1

    while n > 1:
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 2:
                print(""Final!"")
            else:
                print(round_count)
            return
        n = (n + 1) // 2
        round_count += 1

solve()
","
def solve():
    n, a, b = map(int, input().split())
    
    round_count = 1
    while n > 1:
        n = n // 2
        if (a + 1) // 2 == (b + 1) // 2:
            break
        round_count += 1
    
    if n == 1:
        print(""Final!"")
    else:
        print(round_count)

solve()","
def solve():
    n, a, b = map(int, input().split())
    
    round_num = 1
    while n > 1:
        n = n // 2
        if (a + 1) // 2 == (b + 1) // 2:
            if n == 1:
                print(""Final!"")
            else:
                print(round_num)
                break
        round_num += 1

solve()
","26.666666666666668","13.333333333333334","13.333333333333334","26.666666666666668","13.333333333333334","26.666666666666668","100.0","26.666666666666668","26.666666666666668","100.0","13.333333333333334","26.666666666666668","26.666666666666668","26.666666666666668","86.66666666666667","26.666666666666668","","","","","","","","","","","","","","","",""
"APPS/278","
QUESTION:
Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.

Pavel has a plan: a permutation p and a sequence b_1, b_2, ..., b_{n}, consisting of zeros and ones. Each second Pavel move skewer on position i to position p_{i}, and if b_{i} equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.

Unfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.

There is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k ≥ 2n), so that after k seconds each skewer visits each of the 2n placements.

It can be shown that some suitable pair of permutation p and sequence b exists for any n.


-----Input-----

The first line contain the integer n (1 ≤ n ≤ 2·10^5) — the number of skewers.

The second line contains a sequence of integers p_1, p_2, ..., p_{n} (1 ≤ p_{i} ≤ n) — the permutation, according to which Pavel wants to move the skewers.

The third line contains a sequence b_1, b_2, ..., b_{n} consisting of zeros and ones, according to which Pavel wants to reverse the skewers.


-----Output-----

Print single integer — the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements.


-----Examples-----
Input
4
4 3 2 1
0 1 1 1

Output
2

Input
3
2 3 1
0 0 0

Output
1



-----Note-----

In the first example Pavel can change the permutation to 4, 3, 1, 2.

In the second example Pavel can change any element of b to 1.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    changes = 0
    for i in range(n):
        if p[i] != i + 1:
            changes += 1
        if b[i] == 1:
            changes += 1

    print(changes)

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    count = 0
    for i in range(n):
        if p[i] != i + 1:
            count += 1
        if b[i] != 0:
            count += 1
    
    print(count)

# Run the function
solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    changes = 0
    for i in range(n):
        if p[i] != i + 1:
            changes += 1
        if b[i] == 1:
            changes += 1
    
    print(changes)

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    elements_to_change = 0
    for i in range(n):
        if p[i] != i+1:
            elements_to_change += 1
    b_changes = sum(b) if sum(b) != 0 else 1
    print(max(elements_to_change, b_changes))

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    count_changes = 0
    for i in range(n):
        if p[i] != i + 1:
            count_changes += 1
        if b[i] == 1:
            count_changes += 1

    print(count_changes)

# Call the function to run
solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    changes = 0
    for i in range(n):
        if p[i] == i + 1:
            changes += 1
        else:
            if b[i] == 0:
                changes += 1
    
    print(changes)

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    changes = sum(1 for i, (pi, bi) in enumerate(zip(p, b), start=1) if pi != i or bi == 1)
    
    print(changes)

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    changes = 0
    for i in range(n):
        if p[i] != i+1:
            changes += 1
        if i > 0 and b[i] == 1 and b[i-1] == 1:
            changes += 1

    print(changes)

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    changes_needed = 0
    
    for i in range(n-1):
        if p[i] > p[i+1] and b[i] == 0:
            changes_needed += 1
        elif p[i] < p[i+1] and b[i] == 1:
            changes_needed += 1
    
    print(changes_needed)

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    changes = 0
    for i in range(n):
        if p[i] != i+1:
            changes += 1
        if (b[i] == 1 and p[i] == i+1) or (b[i] == 0 and p[i] != i+1):
            changes += 1
            
    print(changes)

solve()","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    changes_p = 0
    changes_b = b.count(1)

    for i in range(n):
        if p[i] != i + 1:
            changes_p += 1

    print(max(changes_p, changes_b))

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    changes = 0
    for i in range(n):
        if p[i] == i + 1:
            changes += 1
        if i < n - 1 and b[i] == 1 and b[i+1] == 1:
            b[i] = 0
            b[i+1] = 0
            changes += 2

    print(changes)

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    changes_p = 0
    changes_b = sum(b)

    for i in range(n):
        if p[i] != i+1:
            changes_p += 1

    print(max(changes_p, changes_b))

solve()
","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    changes = 0
    for i in range(n):
        if p[i] != i+1:
            changes += 1
        if b[i] == 1:
            changes += 1
    
    print(changes)

solve()
","
from typing import List

def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))
    
    changes = 0
    for i in range(n):
        if p[i] != i+1:
            changes += 1
        if b[i] == 1:
            changes += 1
    
    print(changes)

solve()","
def solve():
    n = int(input())
    p = list(map(int, input().split()))
    b = list(map(int, input().split()))

    pos_count = [0] * n
    rev_count = [0] * n

    for i in range(n):
        if p[i] == i + 1:
            pos_count[i] += 1
        if b[i] == 1:
            rev_count[i] += 1

    need_change = n
    for i in range(n):
        need_change = min(need_change, n - pos_count[p[i]-1] + rev_count[p[i]-1])

    print(need_change)

# Call the function to run it
solve()
","0.0","0.0","0.0","6.666666666666667","0.0","20.0","0.0","6.666666666666667","26.666666666666668","0.0","0.0","33.33333333333333","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/279","
QUESTION:
The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals v_1 meters per second, and in the end it is v_2 meters per second. We know that this section of the route took exactly t seconds to pass.

Assuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters.


-----Input-----

The first line contains two integers v_1 and v_2 (1 ≤ v_1, v_2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.

The second line contains two integers t (2 ≤ t ≤ 100) — the time when the car moves along the segment in seconds, d (0 ≤ d ≤ 10) — the maximum value of the speed change between adjacent seconds.

It is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v_1,  the speed in the last second equals v_2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d. 


-----Output-----

Print the maximum possible length of the path segment in meters. 


-----Examples-----
Input
5 6
4 2

Output
26
Input
10 10
10 0

Output
100


-----Note-----

In the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.

In the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.
Use user-input-Based format and function signature solve()","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())
    
    total_distance = v1
    current_speed = v1
    
    for i in range(1, t):
        next_speed = min(v2, current_speed + d)
        total_distance += next_speed
        current_speed = next_speed
    
    print(total_distance)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())

    path_length = 0
    speed = v1

    for _ in range(t-1):
        if speed + d <= v2:
            speed += d
        else:
            speed = v2
        path_length += speed

    path_length += v2
    print(path_length)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())
    
    ans = v1
    cur = v1
    for i in range(1, t):
        cur = min(v2, cur + d)
        ans += cur
        
    print(ans)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())
    
    speeds = [v1]
    for i in range(1, t):
        prev_speed = speeds[i-1]
        max_speed = min(v2, prev_speed + d)
        speeds.append(max_speed)
    
    total_length = sum(speeds)
    
    print(total_length)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())
    
    total_path = v1
    current_speed = v1

    for i in range(1, t):
        next_speed = min(v2, current_speed + d)
        total_path += next_speed
        current_speed = next_speed

    print(total_path)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())

    total_distance = 0
    current_speed = v1

    for _ in range(t):
        total_distance += current_speed
        max_speed = min(v2, current_speed + d)
        current_speed = max(current_speed, max_speed - d)

    print(total_distance)

if __name__ == ""__main__"":
    solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())

    max_length = v1
    current_speed = v1

    for i in range(1, t):
        current_speed = min(v2, current_speed + d)
        max_length += current_speed

    print(max_length)

solve()
","
def solve():
    v_1, v_2 = map(int, input().split())
    t, d = map(int, input().split())
    
    path_length = v_1
    speed = v_1
    
    for _ in range(t - 1):
        speed = min(speed + d, v_2 - (t - 1 - _)*d)
        path_length += speed
        
    print(path_length)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())
    
    speeds = [v1]
    for i in range(1, t):
        max_speed = min(v2, speeds[-1] + d)
        speeds.append(max_speed)
        
    total_distance = sum(speeds)
    print(total_distance)


solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())

    max_len = v1
    curr_speed = v1

    for i in range(1, t):
        curr_speed = min(v2, curr_speed + d)
        max_len += curr_speed

    print(max_len)

solve()
","
from typing import Tuple

def solve() -> None:
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())
    
    path_length = v1
    current_speed = v1
    speed_diff = min(d, v2 - v1)
    
    for i in range(1, t):
        current_speed = min(v2, current_speed + speed_diff)
        path_length += current_speed
    
    print(path_length)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())

    total_length = v1
    current_speed = v1
    for _ in range(1, t):
        current_speed = min(v2, current_speed + d)
        total_length += current_speed

    return total_length

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())

    total_distance = v1
    current_speed = v1

    for _ in range(t-1):
        max_speed = max(v2, current_speed-d)
        current_speed = min(current_speed+d, max_speed)
        total_distance += current_speed

    print(total_distance)

solve()
","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())

    speed = v1
    total_length = v1

    for i in range(1, t):
        speed = min(v2, speed + d)
        total_length += speed

    print(total_length)

solve()
  ","
def solve():
    v1, v2 = map(int, input().split())
    t, d = map(int, input().split())
    
    ans = v1
    speed = v1
    for i in range(1, t):
        speed = min(speed + d, v2 - ((t-1) - i) * d)   
        ans += speed
    
    print(ans)

solve()
","
def solve():
    v1, v2 = map(int, input().strip().split())
    t, d = map(int, input().strip().split())
    
    total_distance = 0
    current_speed = v1
    for i in range(t):
        total_distance += current_speed
        current_speed = min(v2, current_speed + d)
    
    print(total_distance)

solve()
","40.0","20.0","40.0","40.0","40.0","20.0","40.0","13.333333333333334","40.0","40.0","40.0","0.0","53.333333333333336","40.0","40.0","40.0","","","","","","","","","","","","","","","",""
"APPS/280","
QUESTION:
There are N camels numbered 1 through N.
The weight of Camel i is w_i.
You will arrange the camels in a line and make them cross a bridge consisting of M parts.
Before they cross the bridge, you can choose their order in the line - it does not have to be Camel 1, 2, \ldots, N from front to back - and specify the distance between each adjacent pair of camels to be any non-negative real number.
The camels will keep the specified distances between them while crossing the bridge.
The i-th part of the bridge has length l_i and weight capacity v_i.
If the sum of the weights of camels inside a part (excluding the endpoints) exceeds v_i, the bridge will collapse.
Determine whether it is possible to make the camels cross the bridge without it collapsing. If it is possible, find the minimum possible distance between the first and last camels in the line in such a case.
It can be proved that the answer is always an integer, so print an integer.

-----Constraints-----
 - All values in input are integers.
 - 2 \leq N \leq 8
 - 1 \leq M \leq 10^5
 - 1 \leq w_i,l_i,v_i \leq 10^8

-----Input-----
Input is given from Standard Input in the following format:
N M
w_1 w_2 \cdots w_N
l_1 v_1
\vdots
l_M v_M

-----Output-----
If the bridge will unavoidably collapse when the camels cross the bridge, print -1.
Otherwise, print the minimum possible distance between the first and last camels in the line when the camels cross the bridge without it collapsing.

-----Sample Input-----
3 2
1 4 2
10 4
2 6

-----Sample Output-----
10

 - It is possible to make the camels cross the bridge without it collapsing by, for example, arranging them in the order 1, 3, 2 from front to back, and setting the distances between them to be 0, 10.
 - For Part 1 of the bridge, there are moments when only Camel 1 and 3 are inside the part and moments when only Camel 2 is inside the part. In both cases, the sum of the weights of camels does not exceed 4 - the weight capacity of Part 1 - so there is no collapse.
 - For Part 2 of the bridge, there are moments when only Camel 1 and 3 are inside the part and moments when only Camel 2 is inside the part. In both cases, the sum of the weights of camels does not exceed 6 - the weight capacity of Part 2 - so there is no collapse.
 - Note that the distance between two camels may be 0 and that camels on endpoints of a part are not considered to be inside the part.
Use user-input-Based format and function signature solve()","
def solve():
    import itertools

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    min_distance = float('inf')
    for perm in itertools.permutations(range(N)):
        for dists in itertools.product(range(11), repeat=N-1):
            distances = [0] + [sum(dists[:i]) for i in range(1, N-1)] + [sum(dists)]
            valid = True
            for l, v in parts:
                for i in range(N):
                    total_weight = sum(weights[perm[j]] for j in range(N) if distances[j] <= i < distances[j+1])
                    if total_weight > v:
                        valid = False
                        break
                if not valid:
                    break
            if valid:
                min_distance = min(min_distance, distances[-1])

    if min_distance == float('inf'):
        print(-1)
    else:
        print(int(min_distance))

solve()
","
from itertools import permutations

def solve():
    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    bridge_parts = [list(map(int, input().split())) for _ in range(M)]
    
    min_distance = -1
    
    for order in permutations(range(1, N+1)):
        for i in range(N-1):
            min_dist = 10**9
            for j in range(M):
                total_weight = sum(weights[order[k]-1] for k in range(i, i+2))
                if total_weight > bridge_parts[j][1]:
                    min_dist = -1
                    break
                else:
                    min_dist = min(min_dist, bridge_parts[j][0] / total_weight)
            if min_dist == -1:
                break
            min_distance = max(min_distance, min_dist) if min_distance != -1 else min_dist
    
    print(int(min_distance))


solve()","
def solve():
    import itertools

    N, M = map(int, input().split())
    w = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    perms = itertools.permutations(range(N))

    min_distance = float('inf')

    for perm in perms:
        for i in range(N - 1):
            distance = 0
            for j in range(M):
                part_sum = sum(w[perm[k]] for k in range(i, i + parts[j][0]))
                if part_sum > parts[j][1]:
                    distance = float('inf')
                    break
                distance += parts[j][0]
            min_distance = min(min_distance, distance)

    if min_distance == float('inf'):
        print(-1)
    else:
        print(int(min_distance))


solve()","
def solve():
    import itertools

    N, M = map(int, input().split())
    w = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    result = -1

    for perm in itertools.permutations(range(N)):
        for dis in itertools.combinations_with_replacement(range(11), N-1):
            dis = [(0, d, N-1) for d in dis]
            perm_dis = list(zip(perm, dis))
            valid = True

            for l, v in parts:
                part_weights = [0] * N
                for i, (p, (start, end, d)) in enumerate(perm_dis):
                    if start <= l < end:
                        part_weights[l] += w[p]

                    if part_weights[l] > v:
                        valid = False
                        break

                if not valid:
                    break

            if valid:
                dist = sum(d for _, (_, _, d) in perm_dis)
                if result == -1 or dist < result:
                    result = dist

    print(result)

solve()
","
def solve(N, M, w, bridges):
    from itertools import permutations
    
    def check_distance(distances):
        for bridge in bridges:
            for p in permutations(range(N), N):
                total_weight = 0
                for i in range(M):
                    total_weight += sum(w[j] for j in p if distances[j] <= bridge[i][0] <= distances[j+1])
                    if total_weight > bridge[i][1]:
                        break
                else:
                    return True
        return False
    
    distances = [0] * N
    for i in range(1, N-1):
        distances[i] = float('inf')
    
    def update_distances(l, r):
        while l < r:
            distances[l] = min(distances[l], r - l)
            l += 1
    
    best_distance = float('inf')
    left, mid, right = 1, 1, 2
    while check_distance(distances):
        if mid == N - 1:
            best_distance = min(best_distance, distances[N-1])
            right += 1
            mid = right
        else:
            mid += 1
        while mid < N - 1 and check_distance(distances):
            mid += 1
        update_distances(left, mid)
    
    return int(best_distance)

# Sample Input
N = 3
M = 2
w = [1, 4, 2]
bridges = [(10, 4), (2, 6)]

print(solve(N, M, w, bridges))
  
solve()","
def solve():
    import itertools

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    perms = itertools.permutations(range(N))
    min_distance = float('inf')

    for perm in perms:
        for d in range(101):
            distances = [d] * (N - 1)
            collapse = False

            for part in parts:
                start = 0
                end = part[0]
                total_weight = 0

                for c in range(N):
                    total_weight += weights[perm[c]]
                    if c != 0:
                        total_weight += weights[perm[c - 1]]
                    
                    if end <= c < N - 1 or c > 0:
                        collapse |= total_weight > part[1]
                    
                    if c == end - 1:
                        if collapse:
                            break
                        start = end
                        end += part[0]
                        total_weight = 0

                if collapse:
                    break

            if not collapse:
                min_distance = min(min_distance, sum(distances))

    print(min_distance if min_distance != float('inf') else -1)


solve()
","
def solve():
    import itertools

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    min_distance = float('inf')

    for perm in itertools.permutations(range(N)):
        for dist in itertools.combinations_with_replacement(range(11), N-1):
            positions = [0] + list(itertools.accumulate(dist))

            for part in parts:
                for i in range(N):
                    total_weight = sum(weights[p] for p in range(N) if positions[p] >= part[0] and positions[p] < part[1] and p != i)
                    if total_weight > part[2]:
                        break
                else:
                    min_distance = min(min_distance, positions[-1])
                    break

    if min_distance == float('inf'):
        print(-1)
    else:
        print(min_distance)
  
solve()","
def solve():
    import itertools

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    min_distance = float('inf')
    for perm in itertools.permutations(range(N)):
        for distances in itertools.product(range(11), repeat=N-1):
            valid = True
            for l, v in parts:
                weight_sum = 0
                for i in range(N-1):
                    weight_sum += weights[perm[i]]
                    if weight_sum > v:
                        valid = False
                        break
                    weight_sum += weights[perm[i+1]]
                    if weight_sum > v:
                        valid = False
                        break
                if not valid:
                    break
            if valid:
                min_distance = min(min_distance, sum(distances))

    if min_distance == float('inf'):
        print(-1)
    else:
        print(min_distance)
  
solve()","
from itertools import permutations

def solve():
    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    bridges = [tuple(map(int, input().split())) for _ in range(M)]

    min_distance = float('inf')

    for perm in permutations(range(N)):
        for i in range(M):
            current_total_weight = 0
            for j in range(N):
                if j == 0:
                    current_total_weight += weights[perm[j]]
                else:
                    current_total_weight += weights[perm[j]]
                    distance_between = current_total_weight / (j + 1)
                    if distance_between < min_distance:
                        min_distance = distance_between
                    if current_total_weight > bridges[i][1]:
                        min_distance = -1
                        break

            if min_distance == -1:
                break

    print(int(min_distance))

solve()","
def solve():
    from itertools import permutations

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    bridge_parts = [list(map(int, input().split())) for _ in range(M)]

    min_distance = float('inf')
    for perm in permutations(range(N)):
        for part in bridge_parts:
            for i in range(N-1):
                total_weight = sum(weights[perm[j]] for j in range(i, i+2))
                if total_weight > part[1]:
                    break
            else:
                min_distance = min(min_distance, part[0])

    if min_distance == float('inf'):
        print(-1)
    else:
        print(min_distance)

solve()
","
def solve():
    import itertools

    N, M = map(int, input().split())
    w = list(map(int, input().split()))
    bridges = [list(map(int, input().split())) for _ in range(M)]

    perms = itertools.permutations(range(N))

    min_distance = float('inf')
    for perm in perms:
        for dist in range(11):
            max_weight = [0] * M
            for i, camel in enumerate(perm):
                pos = 0
                for j, (l, v) in enumerate(bridges):
                    if pos + l <= dist:
                        pos += l
                    else:
                        break
                    if w[camel] + max_weight[j] > v:
                        break
                    max_weight[j] += w[camel]
                else:
                    if pos < dist:
                        break
                    min_distance = min(min_distance, dist)
                    break

    if min_distance == float('inf'):
        print(-1)
    else:
        print(min_distance)

solve()","
def solve():
    import itertools

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    bridges = [list(map(int, input().split())) for _ in range(M)]
    
    perms = itertools.permutations(weights)
    min_distance = float('inf')
    for perm in perms:
        distance = sum(max(0, l - abs(perm[i] - perm[i+1])) for i, l in enumerate(map(lambda x: x[0], bridges)))
        if distance < min_distance:
            min_distance = distance
    
    if min_distance == float('inf'):
        print(-1)
    else:
        print(int(min_distance))

solve()
","
def solve():
    import itertools

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    perms = itertools.permutations(range(N), N)
    min_distance = float('inf')

    for perm in perms:
        for part in parts:
            curr_sum = 0
            max_weight = 0
            for i in range(1, len(perm)):
                curr_sum += weights[perm[i]]
                max_weight = max(max_weight, weights[perm[i]])
                dist = abs(part[0] - part[1])
                if max_weight + curr_sum > part[1] and dist < min_distance:
                    min_distance = dist

    if min_distance == float('inf'):
        print(-1)
    else:
        print(min_distance)

solve()","
def solve():
    from itertools import permutations

    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    min_distance = float('inf')
    for perm in permutations(range(N)):
        for intervals in permutations((parts[i][0], parts[i][0] + parts[i][1]) for i in range(M)):
            max_dist = max(intervals[i][0] - intervals[i-1][1] for i in range(M)) if M > 1 else 0
            if max_dist >= min_distance:
                continue

            can_cross = True
            for i in range(M):
                total_weight = sum(weights[j] for j in perm if intervals[i][0] < j < intervals[i][1])
                if total_weight > parts[i][1]:
                    can_cross = False
                    break

            if can_cross:
                min_distance = max_dist

    return min_distance if min_distance < float('inf') else -1

solve()","
from itertools import permutations

def solve():
    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]
    
    min_distance = float('inf')
    for perm in permutations(range(N)):
        distances = [0] + [float('inf')] * (N - 1)
        for i in range(N - 1):
            for j in range(i + 1, N):
                distances[perm[j]] = min(distances[perm[j]], distances[perm[i]] + abs(sum(weights[perm[i] : perm[j + 1]])))
        
        valid = True
        for l, v in parts:
            total_weight = 0
            for i in range(N - 1):
                total_weight += weights[perm[i]]
                if total_weight > v:
                    valid = False
                    break
                total_weight += distances[perm[i]]
                
            if valid and total_weight + weights[perm[-1]] <= v:
                min_distance = min(min_distance, distances[perm[-1]])

    if min_distance == float('inf'):
        print(-1)
    else:
        print(int(min_distance))


solve()","
from itertools import permutations

def solve():
    N, M = map(int, input().split())
    weights = list(map(int, input().split()))
    parts = [list(map(int, input().split())) for _ in range(M)]

    min_distance = float('inf')
    for perm in permutations(range(N)):
        for dists in permutations(range(N - 1)):
            prev = -1
            for part in parts:
                current_weight = 0
                for i in range(len(part)):
                    if prev != -1:
                        current_weight += weights[perm[prev]] + weights[perm[prev + 1]]
                    prev += 1
                    current_weight += sum(weights[perm[p]] for p in dists[:i])
                    if current_weight > part[1]:
                        break
                else:
                    min_distance = min(min_distance, sum(parts[j][0] for j in dists))
    print(min_distance if min_distance != float('inf') else -1)

solve()
","0.0","78.57142857142857","6.666666666666667","0.0","0.0","33.33333333333333","0.0","50.0","73.33333333333333","25.0","66.66666666666666","0.0","0.0","0.0","0.0","7.142857142857142","","","","","","","","","","","","","","","",""
"APPS/281","
QUESTION:
Even if the world is full of counterfeits, I still regard it as wonderful.

Pile up herbs and incense, and arise again from the flames and ashes of its predecessor — as is known to many, the phoenix does it like this.

The phoenix has a rather long lifespan, and reincarnates itself once every a! years. Here a! denotes the factorial of integer a, that is, a! = 1 × 2 × ... × a. Specifically, 0! = 1.

Koyomi doesn't care much about this, but before he gets into another mess with oddities, he is interested in the number of times the phoenix will reincarnate in a timespan of b! years, that is, [Image]. Note that when b ≥ a this value is always integer.

As the answer can be quite large, it would be enough for Koyomi just to know the last digit of the answer in decimal representation. And you're here to provide Koyomi with this knowledge.


-----Input-----

The first and only line of input contains two space-separated integers a and b (0 ≤ a ≤ b ≤ 10^18).


-----Output-----

Output one line containing a single decimal digit — the last digit of the value that interests Koyomi.


-----Examples-----
Input
2 4

Output
2

Input
0 10

Output
0

Input
107 109

Output
2



-----Note-----

In the first example, the last digit of $\frac{4 !}{2 !} = 12$ is 2;

In the second example, the last digit of $\frac{10 !}{0 !} = 3628800$ is 0;

In the third example, the last digit of $\frac{109 !}{107 !} = 11772$ is 2.
Use user-input-Based format and function signature solve()","
def solve():
    import math

    a, b = map(int, input().split())
    
    def factorial(n):
        if n == 0:
            return 1
        return n * factorial(n-1)
    
    result = factorial(b) // factorial(a)
    last_digit = result % 10
    
    print(last_digit)

solve()","
from math import factorial

def solve():
    a, b = map(int, input().split())
    
    def last_digit_factorial(n):
        if n == 0:
            return 1
        else:
            return factorial(n) % 10
    
    result = last_digit_factorial(b) // last_digit_factorial(a)
    print(result % 10)

solve()
","
def solve():
    import math
    a, b = map(int, input().split())
    fact_a = math.factorial(a)
    fact_b = math.factorial(b)
    result = (fact_b // fact_a) % 10
    print(result)

solve()
","
from math import factorial

def solve():
    a, b = map(int, input().split())
    if b - a >= 5:
        print(0)
    else:
        result = 1
        for i in range(a + 1, b + 1):
            result *= i % 10
        print(result % 10)

solve()
","
from math import factorial

def solve():
    a, b = map(int, input().split())
    
    def last_digit_of_factorial(n):
        if n == 0:
            return 1
        else:
            return factorial(n) % 10

    result = last_digit_of_factorial(b) // last_digit_of_factorial(a)
    print(result % 10)

solve()
","
def solve():
    import math
    
    a, b = map(int, input().split())
    
    def factorial_digit(n):
        res = 1
        for i in range(1, n+1):
            res *= i
            while res % 10 == 0:
                res //= 10
            res %= 100000
        return res % 10
    
    result = factorial_digit(b) // factorial_digit(a)
    
    print(result % 10)

solve()","
def solve():
    import math
    
    a, b = map(int, input().split())
    
    def factorial(n):
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result
    
    last_digit = str(factorial(b) // factorial(a))[-1]
    print(last_digit)

solve()","
from math import factorial

def solve():
    a, b = map(int, input().split())
    a_factorial = 1 if a == 0 else factorial(a) % 10
    b_factorial = factorial(b) % 10
    result = (b_factorial // a_factorial) % 10
    print(result)

solve()
","
def solve():
    import math
    a, b = map(int, input().split())
    result = 1
    for i in range(a+1, b+1):
        result *= i
        while result % 10 == 0:
            result //= 10
        result %= 10
    print(result)

solve()
","
def solve():
    import math

    a, b = map(int, input().split())
    
    if b == a:
        print(0)
    else:
        print(math.factorial(b) // math.factorial(a) % 10)

solve()","
def solve():
    import math

    a, b = map(int, input().split())
    result = 1
    for i in range(a + 1, b + 1):
        result *= i
        result %= 10

    print(result)

solve()
","
import math

def solve():
    a, b = map(int, input().split())
    
    def factorial_last_digit(n):
        if n == 0:
            return 1
        else:
            return math.factorial(n) % 10

    result = factorial_last_digit(b) // factorial_last_digit(a)
    
    print(result % 10)
  
solve()","
def solve():
    import math

    a, b = map(int, input().split())
    
    def factorial(n):
        if n == 0:
            return 1
        return n * factorial(n - 1)
    
    result = factorial(b) // factorial(a)
    last_digit = result % 10
    
    print(last_digit)

solve()","
def solve():
    import math
    
    a, b = map(int, input().split())
    
    a_fact = 1 if a == 0 else math.factorial(a)
    b_fact = math.factorial(b)
    
    result = b_fact // a_fact
    
    last_digit = result % 10
    
    print(last_digit)

solve()
","
def solve():
    import math

    a, b = map(int, input().split())
    result = 1
    for i in range(a + 1, b + 1):
        result *= i
        while result % 10 == 0:
            result //= 10
        result %= 10
    print(result)

solve()
","
def solve():
    import math

    a, b = map(int, input().split())

    def factorial(n):
        if n == 0:
            return 1
        else:
            return n * factorial(n - 1)

    last_digit = str(math.factorial(b) // math.factorial(a))[-1]
    print(last_digit)

solve()
  ","66.66666666666666","33.33333333333333","100.0","100.0","33.33333333333333","41.66666666666667","100.0","33.33333333333333","57.14285714285714","100.0","100.0","33.33333333333333","66.66666666666666","100.0","57.14285714285714","100.0","","","","","","","","","","","","","","","",""
"APPS/282","
QUESTION:
A frog lives on the axis Ox and needs to reach home which is in the point n. She starts from the point 1. The frog can jump to the right at a distance not more than d. So, after she jumped from the point x she can reach the point x + a, where a is an integer from 1 to d.

For each point from 1 to n is known if there is a lily flower in it. The frog can jump only in points with a lilies. Guaranteed that there are lilies in the points 1 and n.

Determine the minimal number of jumps that the frog needs to reach home which is in the point n from the point 1. Consider that initially the frog is in the point 1. If the frog can not reach home, print -1.


-----Input-----

The first line contains two integers n and d (2 ≤ n ≤ 100, 1 ≤ d ≤ n - 1) — the point, which the frog wants to reach, and the maximal length of the frog jump.

The second line contains a string s of length n, consisting of zeros and ones. If a character of the string s equals to zero, then in the corresponding point there is no lily flower. In the other case, in the corresponding point there is a lily flower. Guaranteed that the first and the last characters of the string s equal to one.


-----Output-----

If the frog can not reach the home, print -1.

In the other case, print the minimal number of jumps that the frog needs to reach the home which is in the point n from the point 1.


-----Examples-----
Input
8 4
10010101

Output
2

Input
4 2
1001

Output
-1

Input
8 4
11100101

Output
3

Input
12 3
101111100101

Output
4



-----Note-----

In the first example the from can reach home in two jumps: the first jump from the point 1 to the point 4 (the length of the jump is three), and the second jump from the point 4 to the point 8 (the length of the jump is four).

In the second example the frog can not reach home, because to make it she need to jump on a distance three, but the maximum length of her jump equals to two.
Use user-input-Based format and function signature solve()","
def solve():
    n, d = map(int, input().split())
    s = input().strip()

    jumps = 0
    current_pos = 1

    while current_pos < n:
        next_pos = min(current_pos + d, n)
        if s[next_pos - 1] == '1':
            current_pos = next_pos
            jumps += 1
        else:
            found = False
            for i in range(next_pos - 1, current_pos, -1):
                if s[i] == '1':
                    current_pos = i
                    jumps += 1
                    found = True
                    break
            if not found:
                print(-1)
                return

    print(jumps)

solve()
","
def solve():
    n, d = map(int, input().split())
    s = input().strip()
    
    jumps = 0
    pos = 1
    
    while pos < n:
        next_pos = -1
        for i in range(d, 0, -1):
            if pos + i <= n and s[pos + i - 1] == '1':
                next_pos = pos + i
                break
        
        if next_pos == -1:
            print(-1)
            return
        
        jumps += 1
        pos = next_pos
    
    print(jumps)

solve()
","
def solve():
    n, d = map(int, input().split())
    s = input()
    jumps = 0
    current = 1

    while current < n:
        next_jump = current + d
        if next_jump >= n:
            current = n
        else:
            while s[next_jump] == '0':
                next_jump -= 1
            if next_jump == current:
                print(-1)
                return
            current = next_jump
            jumps += 1

    print(jumps)

solve()","
def solve():
    n, d = map(int, input().split())
    s = input().strip()

    jumps = 0
    curr_position = 1

    while curr_position < n:
        next_position = curr_position + d
        if next_position >= n:
            next_position = n
        
        if s[next_position - 1] == '0':
            can_jump = False
            for i in range(next_position - 1, curr_position, -1):
                if s[i] == '1':
                    can_jump = True
                    jumps += 1
                    curr_position = i
                    break
            if not can_jump:
                print(-1)
                return

        else:
            jumps += 1
            curr_position = next_position

    print(jumps)

solve()
","
def solve():
    n, d = map(int, input().split())
    points = input()

    jumps = 0
    current_pos = 1
    while current_pos < n:
        next_pos = current_pos + d
        if next_pos >= n:
            return jumps + 1
        while points[next_pos] != '1' and next_pos > current_pos:
            next_pos -= 1
        
        if next_pos == current_pos:
            return -1
        jumps += 1
        current_pos = next_pos
    
    return jumps

solve()
","
def solve():
    n, d = map(int, input().split())
    flowers = input().strip()

    jumps = 0
    current_pos = 1
    while current_pos < n:
        next_pos = min(current_pos + d, n)
        if flowers[next_pos - 1] == '1':
            if next_pos == current_pos:
                return -1
            jumps += 1
            current_pos = next_pos
        else:
            for jump_distance in range(d, 0, -1):
                next_pos_candidate = current_pos + jump_distance
                if next_pos_candidate <= n and flowers[next_pos_candidate - 1] == '1':
                    jumps += 1
                    current_pos = next_pos_candidate
                    break
            else:
                return -1

    return jumps

solve()","
def solve():
    n, d = map(int, input().split())
    s = input()

    jumps = 0
    curr_position = 1

    while curr_position < n:
        found = False
        for next_position in range(min(curr_position + d, n), curr_position, -1):
            if s[next_position - 1] == '1':
                curr_position = next_position
                jumps += 1
                found = True
                break
        if not found:
            jumps = -1
            break

    print(jumps)


solve()
","
def solve():
    n, d = map(int, input().split())
    s = input()
    
    jumps = 0
    pos = 1
    
    while pos < n:
        next_pos = pos + d
        if next_pos >= n:
            jumps += 1
            break
        
        found_lily = False
        for i in range(next_pos, pos, -1):
            if s[i] == '1':
                found_lily = True
                pos = i
                jumps += 1
                break
        
        if not found_lily:
            print(-1)
            return -1
    
    print(jumps)


solve()","
def solve():
    n, d = map(int, input().split())
    s = input().strip()
    
    jumps = 0
    cur_pos = 1

    while cur_pos < n:
        next_pos = -1
        for i in range(min(n - cur_pos, d), 0, -1):
            if s[cur_pos + i] == '1':
                next_pos = cur_pos + i
                break
        if next_pos == -1:
            print(-1)
            return
        jumps += 1
        cur_pos = next_pos

    print(jumps)

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, d = map(int, input().split())
    s = input()

    jumps = 0
    current_pos = 1

    while current_pos < n:
        next_pos = min(current_pos + d, n)
        if s[next_pos - 1] == '1':
            jumps += 1
            current_pos = next_pos
        else:
            found_lily = False
            for i in range(next_pos - 1, current_pos, -1):
                if s[i] == '1':
                    found_lily = True
                    jumps += 1
                    current_pos = i
                    break
            if not found_lily:
                print(-1)
                return -1

    print(jumps)
    return jumps

solve()","
def solve():
    n, d = map(int, input().split())
    s = input()
    jumps = [float('inf')] * n
    jumps[0] = 0

    for i in range(1, n):
        if s[i] == '1':
            for j in range(max(0, i - d), i):
                if s[j] == '1':
                    jumps[i] = min(jumps[i], jumps[j] + 1)

    if jumps[n - 1] == float('inf'):
        print(-1)
    else:
        print(jumps[n - 1])


solve()","
def solve():
    n, d = map(int, input().split())
    s = input().strip()

    jumps = [float('inf')] * n
    jumps[0] = 0

    for i in range(1, n):
        if s[i] == '1':
            for j in range(max(0, i-d), i):
                if jumps[j] != float('inf'):
                    jumps[i] = min(jumps[j] + 1, jumps[i])

    if jumps[-1] == float('inf'):
        print(-1)
    else:
        print(jumps[-1])

solve()","
def solve():
    n, d = map(int, input().split())
    s = input().strip()

    jumps = 0
    cur_pos = 1

    while cur_pos < n:
        next_pos = min(cur_pos + d, n)
        if s[next_pos - 1] == '1':
            jumps += 1
            cur_pos = next_pos
        else:
            found = False
            for i in range(next_pos-1, cur_pos, -1):
                if s[i] == '1':
                    jumps += 1
                    cur_pos = i
                    found = True
                    break
            if not found:
                print(-1)
                return

    print(jumps)

# Example
solve()
","
def solve():
    n, d = map(int, input().split())
    s = input()

    jumps = 0
    current_position = 1

    while current_position < n:
        next_position = min(current_position + d, n)
        
        if s[next_position - 1] == '1':
            current_position = next_position
            jumps += 1
        else:
            for i in range(next_position - 1, current_position, -1):
                if s[i] == '1':
                    current_position = i
                    jumps += 1
                    break
            else:
                print(-1)
                return -1

    print(jumps)
    return jumps

solve()
","
def solve():
    n, d = map(int, input().split())
    lilies = input()

    jumps = 0
    current_pos = 1

    while current_pos < n:
        next_pos = current_pos + d
        if next_pos >= n:
            next_pos = n

        if '1' not in lilies[current_pos:next_pos]:
            print(-1)
            return

        jumps += 1
        current_pos = next_pos

    print(jumps)

solve()
","
def solve():
    n, d = map(int, input().split())
    s = input().strip()
    jumps = 0
    current_pos = 1

    while current_pos < n:
        next_jump = min(d, n - current_pos)  # Calculate the next jump distance
        next_pos = current_pos + next_jump

        if s[next_pos - 1] == '1':  # Check if there is a lily flower at the next position
            jumps += 1
            current_pos = next_pos
        else:
            for i in range(next_pos - 1, current_pos, -1):
                if s[i] == '1':
                    jumps += 1
                    current_pos = i
                    break
            else:
                print(-1)
                return

    print(jumps)

solve()
","80.0","100.0","0.0","80.0","0.0","0.0","100.0","80.0","0.0","80.0","100.0","100.0","80.0","80.0","80.0","80.0","","","","","","","","","","","","","","","",""
"APPS/283","
QUESTION:
PolandBall is a young, clever Ball. He is interested in prime numbers. He has stated a following hypothesis: ""There exists such a positive integer n that for each positive integer m number n·m + 1 is a prime number"".

Unfortunately, PolandBall is not experienced yet and doesn't know that his hypothesis is incorrect. Could you prove it wrong? Write a program that finds a counterexample for any n.


-----Input-----

The only number in the input is n (1 ≤ n ≤ 1000) — number from the PolandBall's hypothesis. 


-----Output-----

Output such m that n·m + 1 is not a prime number. Your answer will be considered correct if you output any suitable m such that 1 ≤ m ≤ 10^3. It is guaranteed the the answer exists.


-----Examples-----
Input
3

Output
1
Input
4

Output
2


-----Note-----

A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.

For the first sample testcase, 3·1 + 1 = 4. We can output 1.

In the second sample testcase, 4·1 + 1 = 5. We cannot output 1 because 5 is prime. However, m = 2 is okay since 4·2 + 1 = 9, which is not a prime number.
Use user-input-Based format and function signature solve()","
import sympy

def solve():
    n = int(input())
    m = 1
    while sympy.isprime(n*m + 1):
        m += 1
    print(m)

solve()","
import sympy

def solve():
    n = int(input())
    m = 1
    
    while sympy.isprime(n * m + 1):
        m += 1
    
    print(m)

solve()
","
def solve():
    import sympy

    n = int(input())

    m = 1
    while sympy.isprime(n*m + 1):
        m += 1

    print(m)

solve()","
def solve():
    n = int(input())
    m = 1
    while True:
        num = n * m + 1
        is_prime = True
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                is_prime = False
                break
        if not is_prime:
            print(m)
            break
        m += 1

solve()
","
def solve():
    n = int(input())
    
    for m in range(1, 1001):
        if not is_prime(n * m + 1):
            print(m)
            break

def is_prime(x):
    if x < 2:
        return False
    
    for i in range(2, int(x ** 0.5) + 1):
        if x % i == 0:
            return False
    
    return True

solve()","
def solve():
    n = int(input())
    for m in range(1, 1001):
        if not is_prime(n*m + 1):
            print(m)
            break

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

solve()","
import sympy

def solve():
    n = int(input())
    m = 1
    while sympy.isprime(n*m + 1):  
        m += 1
    print(m)

solve()","
def solve():
    n = int(input())
    m = 1
    while True:
        if pow(n * m + 1, 0.5) % 1 == 0:
            m += 1
        else:
            break
    print(m)

solve()
","
def solve():
    n = int(input())
    for m in range(1, 1001):
        if is_prime(n*m + 1) == False:
            print(m)
            break

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

solve()","
def solve():
    n = int(input())
    
    for m in range(1, 1001):
        if (n * m + 1) % 2 == 0:
            print(m)
            break

solve()","
import sympy

def solve():
    n = int(input())
    m = 1
    while sympy.isprime(n*m + 1):
        m += 1
    print(m)
  
solve()","
import sympy

def solve():
    n = int(input())
    
    m = 1
    while True:
        if not sympy.isprime(n * m + 1):
            print(m)
            break
        m += 1

solve()
","
def solve():
    n = int(input())
    m = 1
    while True:
        if not is_prime(n * m + 1):
            print(m)
            break
        m += 1

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

solve()
","
def solve():
    n = int(input())
    
    for m in range(1, 1001):
        if (n * m + 1) % 2 == 0:
            print(m)
            break

solve()","
def solve():
    n = int(input())
    
    for m in range(1, 1001):
        if not is_prime(n*m + 1):
            print(m)
            return

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

solve()","
import sympy

def solve():
    n = int(input())
    for m in range(1, 1001):
        if not sympy.isprime(n * m + 1):
            return m

solve()","0.0","0.0","0.0","100.0","100.0","100.0","0.0","46.666666666666664","100.0","40.0","0.0","0.0","100.0","40.0","100.0","0.0","","","","","","","","","","","","","","","",""
"APPS/284","
QUESTION:
Kolya is developing an economy simulator game. His most favourite part of the development process is in-game testing. Once he was entertained by the testing so much, that he found out his game-coin score become equal to 0.

Kolya remembers that at the beginning of the game his game-coin score was equal to n and that he have bought only some houses (for 1 234 567 game-coins each), cars (for 123 456 game-coins each) and computers (for 1 234 game-coins each).

Kolya is now interested, whether he could have spent all of his initial n game-coins buying only houses, cars and computers or there is a bug in the game. Formally, is there a triple of non-negative integers a, b and c such that a × 1 234 567 + b × 123 456 + c × 1 234 = n?

Please help Kolya answer this question.


-----Input-----

The first line of the input contains a single integer n (1 ≤ n ≤ 10^9) — Kolya's initial game-coin score.


-----Output-----

Print ""YES"" (without quotes) if it's possible that Kolya spent all of his initial n coins buying only houses, cars and computers. Otherwise print ""NO"" (without quotes).


-----Examples-----
Input
1359257

Output
YES
Input
17851817

Output
NO


-----Note-----

In the first sample, one of the possible solutions is to buy one house, one car and one computer, spending 1 234 567 + 123 456 + 1234 = 1 359 257 game-coins in total.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return

    print(""NO"")

solve()
","
def solve():
    n = int(input())
    
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range((n - a * 1234567) // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    
    for a in range(n // 1234567 + 1):
        for b in range((n - a * 1234567) // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    
    for a in range(n // 1234567 + 1):
        for b in range((n - a * 1234567) // 123456 + 1):
            c = (n - a * 1234567 - b * 123456) // 1234
            if a * 1234567 + b * 123456 + c * 1234 == n:
                print(""YES"")
                return
    
    print(""NO"")

solve()","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0 and (n - a * 1234567 - b * 123456) >= 0:
                print(""YES"")
                return
    print(""NO"")

solve()","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    
    print(""NO"")
  
solve()","
def solve():
    n = int(input())
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    
    for a in range(n // 1234567 + 1):
        for b in range(n // 123456 + 1):
            if (n - a * 1234567 - b * 123456) % 1234 == 0:
                print(""YES"")
                return
    
    print(""NO"")

solve()
","60.0","60.0","60.0","100.0","60.0","100.0","100.0","60.0","60.0","60.0","100.0","60.0","60.0","60.0","60.0","60.0","","","","","","","","","","","","","","","",""
"APPS/285","
QUESTION:
The teacher gave Anton a large geometry homework, but he didn't do it (as usual) as he participated in a regular round on Codeforces. In the task he was given a set of n lines defined by the equations y = k_{i}·x + b_{i}. It was necessary to determine whether there is at least one point of intersection of two of these lines, that lays strictly inside the strip between x_1 < x_2. In other words, is it true that there are 1 ≤ i < j ≤ n and x', y', such that:   y' = k_{i} * x' + b_{i}, that is, point (x', y') belongs to the line number i;  y' = k_{j} * x' + b_{j}, that is, point (x', y') belongs to the line number j;  x_1 < x' < x_2, that is, point (x', y') lies inside the strip bounded by x_1 < x_2. 

You can't leave Anton in trouble, can you? Write a program that solves the given task.


-----Input-----

The first line of the input contains an integer n (2 ≤ n ≤ 100 000) — the number of lines in the task given to Anton. The second line contains integers x_1 and x_2 ( - 1 000 000 ≤ x_1 < x_2 ≤ 1 000 000) defining the strip inside which you need to find a point of intersection of at least two lines.

The following n lines contain integers k_{i}, b_{i} ( - 1 000 000 ≤ k_{i}, b_{i} ≤ 1 000 000) — the descriptions of the lines. It is guaranteed that all lines are pairwise distinct, that is, for any two i ≠ j it is true that either k_{i} ≠ k_{j}, or b_{i} ≠ b_{j}.


-----Output-----

Print ""Yes"" (without quotes), if there is at least one intersection of two distinct lines, located strictly inside the strip. Otherwise print ""No"" (without quotes).


-----Examples-----
Input
4
1 2
1 2
1 0
0 1
0 2

Output
NO
Input
2
1 3
1 0
-1 3

Output
YES
Input
2
1 3
1 0
0 2

Output
YES
Input
2
1 3
1 0
0 3

Output
NO


-----Note-----

In the first sample there are intersections located on the border of the strip, but there are no intersections located strictly inside it. [Image]
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    lines = []
    
    for _ in range(n):
        k, b = map(int, input().split())
        lines.append((k, b))
    
    for i in range(n):
        for j in range(i+1, n):
            k1, b1 = lines[i]
            k2, b2 = lines[j]
            if k1 != k2:
                x_intersect = (b2 - b1) / (k1 - k2)
                if x1 < x_intersect < x2:
                    print(""YES"")
                    return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    lines = [tuple(map(int, input().split())) for _ in range(n)]
    
    has_intersection = False
    for i in range(n):
        for j in range(i+1, n):
            k1, b1 = lines[i]
            k2, b2 = lines[j]
            if k1 != k2:
                x_intersect = (b2 - b1) / (k1 - k2)
                if x1 < x_intersect < x2:
                    has_intersection = True
                    break
        if has_intersection:
            break
    
    print(""YES"" if has_intersection else ""NO"")

# Example usage
solve()
","
from itertools import combinations

def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    lines = []
    
    for _ in range(n):
        k, b = map(int, input().split())
        lines.append((k, b))
    
    for line1, line2 in combinations(lines, 2):
        k1, b1 = line1
        k2, b2 = line2
        
        if k1 != k2:
            x_intersect = (b2 - b1) / (k1 - k2)
            if x1 < x_intersect < x2:
                print(""YES"")
                return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    lines = []
    for _ in range(n):
        k, b = map(int, input().split())
        lines.append((k, b))
    
    for i in range(n):
        for j in range(i+1, n):
            k1, b1 = lines[i]
            k2, b2 = lines[j]
            if k1 != k2:
                x_int = (b2 - b1) / (k1 - k2)
                if x1 < x_int < x2:
                    print(""YES"")
                    return
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    
    for _ in range(n):
        k, b = map(int, input().split())
        if (k * x1 + b) * (k * x2 + b) < 0:
            print(""YES"")
            return
    
    print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    
    for _ in range(n):
        k, b = map(int, input().split())
        
    for i in range(n):
        for j in range(i+1, n):
            if (lines[i][1] < lines[j][1] and lines[j][1] < lines[i][2]) or (lines[j][1] < lines[i][1] and lines[i][1] < lines[j][2]):
                print(""YES"")
                return
    
    print(""NO"")
    
solve()
  ","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())

    lines = []
    for _ in range(n):
        k, b = map(int, input().split())
        lines.append((k, b))

    for i in range(n):
        for j in range(i+1, n):
            k1, b1 = lines[i]
            k2, b2 = lines[j]
            if k1 != k2:
                x_intersect = (b2 - b1) / (k1 - k2)
                if x1 < x_intersect < x2:
                    print(""YES"")
                    return

    print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    
    for _ in range(n):
        k, b = map(int, input().split())
        if (k * x1 + b) * (k * x2 + b) < 0:
            print('YES')
            return
    
    print('NO')

solve()
","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    lines = [list(map(int, input().split())) for _ in range(n)]
    
    for i in range(n):
        for j in range(i+1, n):
            x_intersect = (lines[j][1] - lines[i][1]) / (lines[i][0] - lines[j][0])
            y_intersect = lines[i][0] * x_intersect + lines[i][1]
            
            if x1 < x_intersect < x2 and min(lines[i][0], lines[j][0]) != max(lines[i][0], lines[j][0]):
                print(""YES"")
                return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    
    lines = []
    for _ in range(n):
        k, b = map(int, input().split())
        lines.append((k, b))
    
    for i in range(n):
        for j in range(i+1, n):
            k1, b1 = lines[i]
            k2, b2 = lines[j]
            
            if k1 != k2:
                x = (b2 - b1) / (k1 - k2)
                if x1 < x < x2:
                    print(""YES"")
                    return
    print(""NO"")
  
solve()","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())

    intersection_inside = False
    for _ in range(n):
        k, b = map(int, input().split())
        for _ in range(n):
            k2, b2 = map(int, input().split())
            if k != k2:
                x_intersect = (b2 - b) / (k - k2)
                if x1 < x_intersect < x2:
                    intersection_inside = True
                    break
        if intersection_inside:
            break

    if intersection_inside:
        print(""YES"")
    else:
        print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    
    no_intersection = True
    
    for _ in range(n):
        k, b = map(int, input().split())
        
        if no_intersection:
            if (_ > 0):
                if ((b_prev - b) * (k_prev - k) > 0):
                    print(""YES"")
                    return
                if ((b_prev - b) * (k_prev - k) < 0):
                    no_intersection = False
                
        b_prev, k_prev = b, k
        
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    lines = [list(map(int, input().split())) for _ in range(n)]
    
    for i in range(n):
        for j in range(i+1, n):
            if (lines[i][1] != lines[j][1]) and ((x1 - lines[j][1])*(lines[i][0] - lines[j][0]) > (x2 - lines[j][1])*(lines[i][0] - lines[j][0])):
                print(""YES"")
                return
    print(""NO"")

solve()","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())

    for _ in range(n):
        k, b = map(int, input().split())

    for i in range(n):
        for j in range(i+1, n):
            if (b[j] - b[i]) * (k[i] - k[j]) != (b[i] - x1 * k[i]) * (k[j] - x1 * k[j]):
                return ""YES""

    return ""NO""

solve()","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())

    for _ in range(n):
        k, b = map(int, input().split())

    for i in range(n - 1):
        for j in range(i + 1, n):
            if (k[i] > k[j] and b[i] < b[j]) or (k[i] < k[j] and b[i] > b[j]):
                x_intersection = (b[j] - b[i]) / (k[i] - k[j])
                if x_intersection > x1 and x_intersection < x2:
                    print(""YES"")
                    return

    print(""NO"")


solve()
  ","
def solve():
    n = int(input())
    x1, x2 = map(int, input().split())
    lines = []
    
    for _ in range(n):
        k, b = map(int, input().split())
        lines.append((k, b))
    
    for i in range(n):
        for j in range(i+1, n):
            if (lines[i][1] != lines[j][1]):
                x_intersection = (lines[j][1] - lines[i][1]) / (lines[i][0] - lines[j][0])
                if x1 < x_intersection < x2:
                    print(""YES"")
                    return
    print(""NO"")

solve()
","100.0","100.0","100.0","100.0","80.0","0.0","100.0","80.0","73.33333333333333","100.0","33.33333333333333","60.0","46.666666666666664","0.0","0.0","73.33333333333333","","","","","","","","","","","","","","","",""
"APPS/286","
QUESTION:
Let's define a split of $n$ as a nonincreasing sequence of positive integers, the sum of which is $n$. 

For example, the following sequences are splits of $8$: $[4, 4]$, $[3, 3, 2]$, $[2, 2, 1, 1, 1, 1]$, $[5, 2, 1]$.

The following sequences aren't splits of $8$: $[1, 7]$, $[5, 4]$, $[11, -3]$, $[1, 1, 4, 1, 1]$.

The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $[1, 1, 1, 1, 1]$ is $5$, the weight of the split $[5, 5, 3, 3, 3]$ is $2$ and the weight of the split $[9]$ equals $1$.

For a given $n$, find out the number of different weights of its splits.


-----Input-----

The first line contains one integer $n$ ($1 \leq n \leq 10^9$).


-----Output-----

Output one integer — the answer to the problem.


-----Examples-----
Input
7

Output
4

Input
8

Output
5

Input
9

Output
5



-----Note-----

In the first sample, there are following possible weights of splits of $7$:

Weight 1: [$\textbf 7$] 

Weight 2: [$\textbf 3$, $\textbf 3$, 1] 

Weight 3: [$\textbf 2$, $\textbf 2$, $\textbf 2$, 1] 

Weight 7: [$\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$]
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    weights = set()
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            weights.add(i)
            weights.add(n // i)
    print(len(weights))

solve()
","
from math import sqrt

def solve(n):
    def num_divisors(x):
        divs = 1
        for i in range(2, int(sqrt(x)) + 1):
            count = 0
            while x % i == 0:
                count += 1
                x //= i
            divs *= (count + 1)
        if x > 1:
            divs *= 2
        return divs
    
    return num_divisors(n)

solve()","
def solve():
    n = int(input())
    weights = set()
    
    for i in range(1, n+1):
        remainder = n
        j = 1
        
        while remainder >= j:
            weights.add(j)
            remainder -= j
            j += 1
    
    print(len(weights))

solve()
","
def solve():
    n = int(input())
    
    if n == 1:
        print(1)
    else:
        res = 0
        for i in range(1, int(n**0.5) + 1):
            res += min(n // i - i + 1, i)
        
        print(res)

if __name__ == '__main__':
    solve()
","
from math import sqrt

def solve(n):
    def get_divisors(num):
        divisors = set()
        for i in range(1, int(sqrt(num)) + 1):
            if num % i == 0:
                divisors.add(i)
                divisors.add(num // i)
        return divisors

    divisors = get_divisors(2*n)
    result = 0

    for d in divisors:
        if (2*n // d - d + 1) % 2 == 0:
            result += 1

    return result

solve()","
def solve():
    n = int(input())
    weights = set()
    
    for i in range(1, int(n ** 0.5) + 1):
        remainder = n % i
        if remainder == 0:
            weights.add(i)
            weights.add(n // i)
        else:
            j = n // i
            weights.add(i)
            weights.add(j)
    
    print(len(weights))

solve()
","
from math import sqrt
from collections import Counter

def solve(n):
    def count_squares(num):
        count = 0
        for i in range(1, int(sqrt(num)) + 1):
            if num % i == 0:
                count += 1
                if num // i != i:
                    count += 1
        return count

    def get_factors_counts(n):
        factors = []
        i = 1
        while i * i <= n:
            if n % i == 0:
                factors.append(i)
                if n // i != i:
                    factors.append(n // i)
            i += 1
        return dict(Counter(factors))

    if n == 1:
        return 1

    factors_counts = get_factors_counts(n)
    total_weights = 1  # Counting weight 1
    for key in factors_counts:
        total_weights += count_squares(factors_counts[key])

    return total_weights

# Input reading
n = int(input())
# Call the solve function
print(solve(n))
  
solve()","
def solve():
    n = int(input())
    answer = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            while n % i == 0:
                n //= i
            answer += 1
    if n > 1:
        answer += 1
    print(answer)

solve()
","
from collections import Counter

def solve(n):
    def splits(n):
        if n == 0:
            yield []
            return
        for x in range(n, 0, -1):
            for y in splits(n - x):
                yield [x] + y
    
    def weight(split):
        return Counter(split).most_common(1)[0][1]
    
    unique_weights = set()
    for split in splits(n):
        unique_weights.add(weight(split))
    
    return len(unique_weights)

solve()","
def solve():
    n = int(input())
    ans = 0
    i = 1
    while i * (i + 1) // 2 <= n:
        ans += min(n - i * (i + 1) // 2, i)
        i += 1
    print(ans + 1)

solve()
","
def solve():
    n = int(input())
    
    weights = set()
    for i in range(1, n + 1):
        seq_sum = i
        cnt = 1
        while seq_sum <= n:
            weights.add(cnt)
            cnt += 1
            seq_sum += i
            
    print(len(weights))
  
solve()","
def solve():
    n = int(input())
    weights = set()
    for i in range(1, int(n**0.5) + 1):
        j = n
        while j >= i:
            weights.add(j)
            j -= i
    weights.add(n)
    print(len(weights))

solve()
","
from math import sqrt

def solve(n):
    def divisors_count(x):
        count = 0
        for i in range(1, int(sqrt(x)) + 1):
            if x % i == 0:
                count += 1
                if x // i != i:
                    count += 1
        return count

    return divisors_count(n)

solve()","
def solve(n):
    if n == 1:
        return 1
    max_weight = 1
    for i in range(1, n + 1):
        if n % i == 0 and n//i >= i:
            max_weight = i
    return max_weight

n = int(input())
print(solve(n))

solve()","
def solve(n):
    factors = []
    m = n
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            if m % i == 0:
                factors.append(i)
    if n > 1:
        factors.append(n)
    result = 1
    for factor in set(factors):
        cnt = factors.count(factor)
        i = 1
        while cnt >= i:
            cnt -= i
            i += 1
            result += 1
    return result

# Input
n = int(input())

# Output
print(solve(n))

solve()","
def solve(n: int) -> int:
    counts = set()
    for i in range(1, int(n**0.5) + 1):
        remainder = n % i
        if remainder == 0:
            counts.add(i)
            counts.add(n // i)
        else:
            start = n // i
            total = i * start + i * (i - 1) // 2
            if total == n:
                counts.add(i)
    return len(counts)

solve()","6.666666666666667","0.0","6.666666666666667","6.666666666666667","0.0","20.0","0.0","6.666666666666667","0.0","6.666666666666667","6.666666666666667","6.666666666666667","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/287","
QUESTION:
Maxim wants to buy an apartment in a new house at Line Avenue of Metropolis. The house has n apartments that are numbered from 1 to n and are arranged in a row. Two apartments are adjacent if their indices differ by 1. Some of the apartments can already be inhabited, others are available for sale.

Maxim often visits his neighbors, so apartment is good for him if it is available for sale and there is at least one already inhabited apartment adjacent to it. Maxim knows that there are exactly k already inhabited apartments, but he doesn't know their indices yet.

Find out what could be the minimum possible and the maximum possible number of apartments that are good for Maxim.


-----Input-----

The only line of the input contains two integers: n and k (1 ≤ n ≤ 10^9, 0 ≤ k ≤ n).


-----Output-----

Print the minimum possible and the maximum possible number of apartments good for Maxim.


-----Example-----
Input
6 3

Output
1 3



-----Note-----

In the sample test, the number of good apartments could be minimum possible if, for example, apartments with indices 1, 2 and 3 were inhabited. In this case only apartment 4 is good. The maximum possible number could be, for example, if apartments with indices 1, 3 and 5 were inhabited. In this case all other apartments: 2, 4 and 6 are good.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    min_good_apartments = max(1, k - 1)
    max_good_apartments = min(n - k, k) * 2
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    # Minimum number of good apartments is 1 if k is greater than 0,
    # otherwise 0
    min_good_apartments = min(1, k)

    # Maximum number of good apartments is the minimum of k or n - k
    max_good_apartments = min(k, n - k)

    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good_apartments = max(1, min(k, n-k))
    max_good_apartments = min(2*k, n-k)
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    min_good_apartments = max(1, k - 1)
    max_good_apartments = min(n-k, k) * 2
    
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good_apartments = max(1, k - 1)
    max_good_apartments = min(n - k, k) * 2
    print(min_good_apartments, max_good_apartments)
    
solve()
","
def solve():
    # Input
    n, k = map(int, input().split())
    
    # Calculate minimum possible good apartments
    min_good = max(1, k - (n - k))
    
    # Calculate maximum possible good apartments
    max_good = min(k, n - k)
    
    # Output
    print(min_good, max_good)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good_apt = max(1, k - (n - k))
    max_good_apt = min(n - k, k * 2)
    print(min_good_apt, max_good_apt)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good = max(1, k - (n - k))
    max_good = min(k, n - k) + 1
    print(min_good, max_good)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good = max(1, k-1)
    max_good = min(n-k, 2*k)
    print(min_good, max_good)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good_apartments = max(1, k - 1)
    max_good_apartments = min(n - k, k) * 2
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    min_good = max(1, k - 1)
    max_good = min(n - k, k) + 2 * min(k, 1)
    
    print(min_good, max_good)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good_apartments = max(1, k - 1)
    max_good_apartments = min(n - k, 2 * k)
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good_apartments = max(1, k - 1)
    max_good_apartments = min(n - k, k) + (k > 0)
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    min_good_apartments = max(1, k - 1)
    max_good_apartments = min(n - k, k) * 2
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    min_good_apartments = max(1, k - 1)
    
    max_good_apartments = min(n - k, 2 * k)
    
    print(min_good_apartments, max_good_apartments)

solve()
","
def solve():
    # Input
    n, k = map(int, input().split())
    
    # Minimum possible number of good apartments
    min_good_apartments = min(1, n - k)
    
    # Maximum possible number of good apartments
    max_good_apartments = min(k * 2, n - k)
    
    # Output
    print(min_good_apartments, max_good_apartments)

# Call the function to execute
solve()
","20.0","46.666666666666664","20.0","20.0","20.0","13.333333333333334","46.666666666666664","13.333333333333334","26.666666666666668","20.0","13.333333333333334","26.666666666666668","6.666666666666667","20.0","26.666666666666668","80.0","","","","","","","","","","","","","","","",""
"APPS/288","
QUESTION:
Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.

Organizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.

Tournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.


-----Input-----

The only line of the input contains a single integer n (2 ≤ n ≤ 10^18) — the number of players to participate in the tournament.


-----Output-----

Print the maximum number of games in which the winner of the tournament can take part.


-----Examples-----
Input
2

Output
1

Input
3

Output
2

Input
4

Output
2

Input
10

Output
4



-----Note-----

In all samples we consider that player number 1 is the winner.

In the first sample, there would be only one game so the answer is 1.

In the second sample, player 1 can consequently beat players 2 and 3. 

In the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1, 2) and (3, 4) and then clash the winners.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    games = 0
    while n > 1:
        games += 1
        n = (n + 1) // 2
    print(games)

solve()
","
def solve():
    n = int(input())
    games = 0
    while n > 1:
        games += 1
        n = (n + 1) // 2
    print(games)

solve()
","
def solve():
    n = int(input())
    a, b = 0, 1
    while b <= n:
        a, b = b, a + b
    print(a // 2)

solve()","
def solve():
    n = int(input())

    if n == 2:
        print(1)
    else:
        games = 0
        while n > 1:
            games += 1
            n = (n + 1) // 2
        print(games)

solve()
","
def solve():
    n = int(input())
    if n == 2:
        print(1)
    else:
        k = 1
        while k * (k - 1) // 2 < n:
            k += 1
        print(k - 1)
  
solve()","
def solve():
    n = int(input())
    games = 0
    
    while n > 1:
        k = 1
        while 2*k <= n:
            k *= 2
        games += 1
        n -= k
    
    print(games)

solve()
","
def solve():
    n = int(input())
    ans = 0
    while n > 1:
        ans += 1
        n //= 2
    print(ans)

solve()
","
def solve():
    n = int(input())
    if n == 2:
        print(1)
    else:
        print(2)

solve()
","
def solve():
    n = int(input())
    if n % 2 == 0:
        print(n.bit_length() - 1)
    else:
        print(n.bit_length())
  
solve()","
def solve():
    n = int(input())
    if n == 2:
        print(1)
    else:
        games = 1
        while n > 2:
            games += 1
            n = (n + 1) // 2
        print(games)

solve()
","
def solve():
    n = int(input())
    games = 0
    while n > 1:
        games += 1
        n = (n + 1) // 2
    print(games)

solve()
","
def solve():
    n = int(input())
    games = 0
    while n > 1:
        k = int((-1 + (1 + 8 * n) ** 0.5) / 2)
        n -= (k * (k + 1)) // 2
        games += 1
    print(games)

solve()
","
def solve():
    n = int(input())
    if n == 2:
        print(1)
    else:
        games = 1
        while n > 2:
            n = (n + 1) // 2
            games += 1
        print(games)

solve()
","
def solve():
    n = int(input())
    games = 0
    while n > 1:
        n = (n + 1) // 2
        games += 1
    print(games)

solve()
","
def solve():
    n = int(input())
    
    # Calculate the maximum number of games the winner can take part in
    games = 0
    while n > 1:
        n = (n + 1) // 2
        games += 1
    
    print(games)

solve()
  ","
def solve():
    n = int(input())
    
    games = 0
    while n > 1:
        max_games = (n.bit_length() - 1) // 2
        games = max(games, max_games)
        n = (n + 1) // 2
    
    print(games)

solve()
","33.33333333333333","33.33333333333333","13.333333333333334","33.33333333333333","28.57142857142857","6.666666666666667","13.333333333333334","20.0","26.666666666666668","33.33333333333333","33.33333333333333","6.666666666666667","33.33333333333333","33.33333333333333","33.33333333333333","0.0","","","","","","","","","","","","","","","",""
"APPS/289","
QUESTION:
Tonio has a keyboard with only two letters, ""V"" and ""K"".

One day, he has typed out a string s with only these two letters. He really likes it when the string ""VK"" appears, so he wishes to change at most one letter in the string (or do no changes) to maximize the number of occurrences of that string. Compute the maximum number of times ""VK"" can appear as a substring (i. e. a letter ""K"" right after a letter ""V"") in the resulting string.


-----Input-----

The first line will contain a string s consisting only of uppercase English letters ""V"" and ""K"" with length not less than 1 and not greater than 100.


-----Output-----

Output a single integer, the maximum number of times ""VK"" can appear as a substring of the given string after changing at most one character.


-----Examples-----
Input
VK

Output
1

Input
VV

Output
1

Input
V

Output
0

Input
VKKKKKKKKKVVVVVVVVVK

Output
3

Input
KVKV

Output
1



-----Note-----

For the first case, we do not change any letters. ""VK"" appears once, which is the maximum number of times it could appear.

For the second case, we can change the second character from a ""V"" to a ""K"". This will give us the string ""VK"". This has one occurrence of the string ""VK"" as a substring.

For the fourth case, we can change the fourth character from a ""K"" to a ""V"". This will give us the string ""VKKVKKKKKKVVVVVVVVVK"". This has three occurrences of the string ""VK"" as a substring. We can check no other moves can give us strictly more occurrences.
Use user-input-Based format and function signature solve()","
def solve():
    s = input().strip()
    vk_count = s.count(""VK"")
    max_count = vk_count
    for i in range(len(s)):
        if s[i] == ""V"":
            new_s = s[:i] + ""K"" + s[i+1:]
            vk_count = new_s.count(""VK"")
            max_count = max(max_count, vk_count)
        elif s[i] == ""K"":
            new_s = s[:i] + ""V"" + s[i+1:]
            vk_count = new_s.count(""VK"")
            max_count = max(max_count, vk_count)
    print(max_count)

solve()
","
def solve():
    s = input().strip()
    
    count = s.count('VK')
    
    for i in range(len(s)):
        if s[i] == 'V':
            new_s = s[:i] + 'K' + s[i+1:]
            count = max(count, new_s.count('VK'))
        elif s[i] == 'K':
            new_s = s[:i] + 'V' + s[i+1:]
            count = max(count, new_s.count('VK'))
    
    print(count)

solve()","
def solve():
    s = input().strip()
    
    vk_count = s.count(""VK"")
    k_to_v_count = s.count(""VK"") + (1 if ""K"" in s and ""V"" not in s.replace(""K"", ""V"", 1) else 0)
    v_to_k_count = s.count(""VK"") + (1 if ""V"" in s and ""K"" not in s.replace(""V"", ""K"", 1) else 0)
    
    print(max(vk_count, k_to_v_count, v_to_k_count))

solve()
","
def solve():
    s = input().strip()
    count_vk = s.count(""VK"")
    for i in range(len(s)):
        if s[i] == ""V"":
            s_lst = list(s)
            s_lst[i] = ""K""
            new_s = """".join(s_lst)
            count_vk = max(count_vk, new_s.count(""VK""))
            s_lst[i] = ""V""
            new_s = """".join(s_lst)
            count_vk = max(count_vk, new_s.count(""VK""))
    print(count_vk)

solve()
","
def solve():
    s = input()
    count_vk = s.count(""VK"")
    
    for i in range(len(s)):
        modified = s[:i] + ""VK"" + s[i+2:]  # Change at most one character
        count_vk = max(count_vk, modified.count(""VK""))
    
    print(count_vk)

solve()
","
def solve(s: str) -> int:
    count_vk = s.count(""VK"")
    count_v = s.count(""VV"")
    count_k = s.count(""KK"")
    
    if ""VV"" in s and count_vk == 0:
        return count_v
    elif ""KK"" in s and count_vk == 0:
        return count_k
    else:
        return count_vk

# Example usage:
# s = input().strip()
# print(solve(s))

solve()","
def solve():
    s = input().strip()
    
    vk_count = s.count(""VK"")

    for i in range(len(s)):
        if s[i] == ""V"":
            s_list = list(s)
            s_list[i] = ""K""
            new_s = """".join(s_list)
            vk_count = max(vk_count, new_s.count(""VK""))

        if s[i] == ""K"":
            s_list = list(s)
            s_list[i] = ""V""
            new_s = """".join(s_list)
            vk_count = max(vk_count, new_s.count(""VK""))

    print(vk_count)

solve()
","
def solve(s: str) -> int:
    count_vk = s.count('VK')
    if 'VV' in s:
        count_vk = max(count_vk, s.count('VV') + 1)
    if 'KK' in s:
        count_vk = max(count_vk, s.count('KK') + 1)
    return count_vk

# Test cases
inputs = ['VK', 'VV', 'V', 'VKKKKKKKKKVVVVVVVVVK', 'KVKV']
for inp in inputs:
    print(solve(inp))

solve()","
def solve():
    s = input().strip()
    vk_count = s.count(""VK"")
    for i in range(len(s)):
        if s[i] == ""V"":
            s_list = list(s)
            s_list[i] = ""K""
            vk_count = max(vk_count, s_list.count(""VK""))
        elif s[i] == ""K"":
            s_list = list(s)
            s_list[i] = ""V""
            vk_count = max(vk_count, s_list.count(""VK""))
    print(vk_count)

solve()
","
def solve(s: str) -> int:
    count_vk = s.count(""VK"")
    
    for i in range(len(s)):
        if s[i] == ""V"":
            s_list = list(s)
            s_list[i] = ""K""
            new_s = """".join(s_list)
            count_vk = max(count_vk, new_s.count(""VK""))
            s_list[i] = ""V""
            new_s = """".join(s_list)
            count_vk = max(count_vk, new_s.count(""VK""))
    
    return count_vk

solve()","
def solve():
    s = input()
    vk_count = s.count(""VK"")
    
    max_count = 0
    for i in range(len(s)):
        new_s = list(s)
        if new_s[i] == ""V"":
            new_s[i] = ""K""
        elif new_s[i] == ""K"":
            new_s[i] = ""V""
        
        new_count = """".join(new_s).count(""VK"")
        max_count = max(max_count, new_count)
    
    print(max(vk_count, max_count))

solve()
","
def solve():
    s = input().strip()
    vk_count = s.count(""VK"")
    if vk_count >= 2:
        print(vk_count)
    else:
        max_count = vk_count
        for i in range(len(s)):
            modified_s = list(s)
            if modified_s[i] == ""V"":
                modified_s[i] = ""K""
            else:
                modified_s[i] = ""V""
            new_count = """".join(modified_s).count(""VK"")
            max_count = max(max_count, new_count)
        print(max_count)

solve()
","
def solve(s: str) -> int:
    count = s.count('VK')
    for i in range(len(s)):
        if s[i] == 'V':
            new_s = s[:i] + 'K' + s[i+1:]
            count = max(count, new_s.count('VK'))
        elif s[i] == 'K':
            new_s = s[:i] + 'V' + s[i+1:]
            count = max(count, new_s.count('VK'))
    return count

# Test cases
s = input().strip()
print(solve(s))

solve()","
def solve():
    s = input()
    count_vk = s.count('VK')
    for i in range(len(s)):
        if s[i] == 'V':
            s_modified = s[:i] + 'K' + s[i+1:]
            count_vk = max(count_vk, s_modified.count('VK'))
        elif s[i] == 'K':
            s_modified = s[:i] + 'V' + s[i+1:]
            count_vk = max(count_vk, s_modified.count('VK'))
    print(count_vk)

solve()
","
def solve():
    s = input().strip()
    
    vk_count = s.count(""VK"")
    
    for i in range(len(s)):
        if s[i] == ""V"":
            new_s = s[:i] + ""K"" + s[i+1:]
            vk_count = max(vk_count, new_s.count(""VK""))
        elif s[i] == ""K"":
            new_s = s[:i] + ""V"" + s[i+1:]
            vk_count = max(vk_count, new_s.count(""VK""))
    
    print(vk_count)

solve()
","
def solve():  
    s = input()
    vk_count = s.count(""VK"")
    for i in range(len(s)):
        if s[i] == 'V':
            new_s = s[:i] + 'K' + s[i+1:]
            vk_count = max(vk_count, new_s.count(""VK""))
        elif s[i] == ""K"":
            new_s = s[:i] + 'V' + s[i+1:]
            vk_count = max(vk_count, new_s.count(""VK""))
    print(vk_count)

solve()","100.0","100.0","33.33333333333333","93.33333333333333","73.33333333333333","0.0","100.0","0.0","33.33333333333333","0.0","100.0","40.0","0.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/290","
QUESTION:
Little Sofia is in fourth grade. Today in the geometry lesson she learned about segments and squares. On the way home, she decided to draw $n$ squares in the snow with a side length of $1$. For simplicity, we assume that Sofia lives on a plane and can draw only segments of length $1$, parallel to the coordinate axes, with vertices at integer points.

In order to draw a segment, Sofia proceeds as follows. If she wants to draw a vertical segment with the coordinates of the ends $(x, y)$ and $(x, y+1)$. Then Sofia looks if there is already a drawn segment with the coordinates of the ends $(x', y)$ and $(x', y+1)$ for some $x'$. If such a segment exists, then Sofia quickly draws a new segment, using the old one as a guideline. If there is no such segment, then Sofia has to take a ruler and measure a new segment for a long time. Same thing happens when Sofia wants to draw a horizontal segment, but only now she checks for the existence of a segment with the same coordinates $x$, $x+1$ and the differing coordinate $y$.

For example, if Sofia needs to draw one square, she will have to draw two segments using a ruler:  [Image] 

After that, she can draw the remaining two segments, using the first two as a guide:  [Image] 

If Sofia needs to draw two squares, she will have to draw three segments using a ruler:  [Image] 

After that, she can draw the remaining four segments, using the first three as a guide:  [Image] 

Sofia is in a hurry, so she wants to minimize the number of segments that she will have to draw with a ruler without a guide. Help her find this minimum number.


-----Input-----

The only line of input contains a single integer $n$ ($1 \le n \le 10^{9}$), the number of squares that Sofia wants to draw.


-----Output-----

Print single integer, the minimum number of segments that Sofia will have to draw with a ruler without a guide in order to draw $n$ squares in the manner described above.


-----Examples-----
Input
1

Output
2

Input
2

Output
3

Input
4

Output
4
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    if n == 1:
        print(2)
    else:
        print(n + 1)

solve()
","
def solve():
    n = int(input())
    result = (int(n**0.5) * 2) + (n**0.5 - int(n**0.5) >= 0.5)
    print(result)

solve()
","
def solve():
    n = int(input())
    
    if n == 1:
        print(2)
    elif n == 2:
        print(3)
    else:
        segments = n * 2
        remaining_segments = 2
        for i in range(2, n):
            remaining_segments += i
            segments += remaining_segments
        
        print(segments)

solve()
","
def solve():
    n = int(input())
    if n == 1:
        print(2)
    else:
        print(2*n - int(n**0.5)**2)

solve()
","
def solve():
    n = int(input())
    if n == 1:
        print(2)
    else:
        middle = int((n-1)**0.5)
        if middle**2 < n-1:
            middle += 1
        print(2 + 2*middle)

solve()","
def solve():
    n = int(input())
    
    m = (n + 1) // 2
    
    result = m + 2 * (m - 1)
    
    return result

solve()","
def solve():
    n = int(input())
    segments_drawn = 2  # minimum segments required to draw the first square
    for i in range(2, n+1):
        segments_drawn += i + 1  # each additional square requires i+1 new segments
    print(segments_drawn)

solve()
","
def solve():
    n = int(input())
    segments = 2
    while n > 1:
        segments += 4 * (n - 1)
        n -= 1
    print(segments)

solve()
","
def solve():
    n = int(input())
    segments = 2
    while n > 1:
        segments += n + 1
        n //= 2
    return segments
 
solve()","
def solve():
    n = int(input())
    if n == 1:
        return 2
    elif n == 2:
        return 3
    else:
        return n + 1

solve()","
def solve():
    n = int(input())
    if n == 1:
        print(2)
    else:
        result = n + int((n - 1) ** 0.5) * 2
        print(result)

solve()
","
def solve():
    n = int(input())
    segments = 2
    while n > 1:
        segments += (n + 1) // 2
        n //= 2
    return segments

solve()","
def solve():
    n = int(input())
    ans = 2 * n - int(n ** 0.5) ** 2
    print(ans)

solve()
","
def solve():
    n = int(input())
    k = int((n * 2) ** 0.5)
    if (k * (k + 1)) < n * 2:
        k += 1
    print(k * 2)

solve()
","
def solve():
    n = int(input())
    ans = 2
    while (ans*(ans+1))//2 < n:
        ans += 1
    print(ans)

solve()
","
def solve():
    n = int(input())
    segments = 2
    while n > 1:
        segments += 4 * (n - 1)
        n -= 1
    print(segments)

solve()
","13.333333333333334","13.333333333333334","13.333333333333334","20.0","6.666666666666667","0.0","6.666666666666667","6.666666666666667","0.0","0.0","6.666666666666667","0.0","13.333333333333334","6.666666666666667","6.666666666666667","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/291","
QUESTION:
Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh a and b respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?


-----Input-----

The only line of the input contains two integers a and b (1 ≤ a ≤ b ≤ 10) — the weight of Limak and the weight of Bob respectively.


-----Output-----

Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.


-----Examples-----
Input
4 7

Output
2

Input
4 9

Output
3

Input
1 1

Output
1



-----Note-----

In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.
Use user-input-Based format and function signature solve()","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())

    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1

    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        years += 1
        a *= 3
        b *= 2
    return years

solve()","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0

    while a <= b:
        years += 1
        a *= 3
        b *= 2

    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0
    
    while a <= b:
        a *= 3
        b *= 2
        years += 1
        
    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    return years

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    return years

solve()","
def solve():
    a, b = map(int, input().split())
    years = 0
    
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    
    return years

solve()","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0

    while a <= b:
        a *= 3
        b *= 2
        years += 1

    print(years)

solve()","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    return years

solve()","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    print(years)

solve()
  ","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        years += 1
        a *= 3
        b *= 2
    print(years)

solve()
","
def solve():
    a, b = map(int, input().split())
    years = 0
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    print(years)

solve()
","100.0","100.0","0.0","100.0","100.0","100.0","0.0","0.0","0.0","100.0","100.0","0.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/292","
QUESTION:
Amr bought a new video game ""Guess Your Way Out!"". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. 

Let's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 ≤ n ≤ 2^{h}, the player doesn't know where the exit is so he has to guess his way out!

Amr follows simple algorithm to choose the path. Let's consider infinite command string ""LRLRLRLRL..."" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means ""go to the left child of the current node"";  Character 'R' means ""go to the right child of the current node"";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. 

Now Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?


-----Input-----

Input consists of two integers h, n (1 ≤ h ≤ 50, 1 ≤ n ≤ 2^{h}).


-----Output-----

Output a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.


-----Examples-----
Input
1 2

Output
2
Input
2 3

Output
5
Input
3 6

Output
10
Input
10 1024

Output
2046


-----Note-----

A perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. 

Following picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.

[Image]
Use user-input-Based format and function signature solve()","
def solve():
    h, n = map(int, input().split())
    nodes_visited = 0
    current_node = 1
    step = 1

    while current_node != n:
        nodes_visited += 1
        if n % 2 == 0:
            n = n // 2
        else:
            n = (n + 1) // 2
        if step % 2 == 1:
            current_node = current_node * 2
        else:
            current_node = current_node * 2 + 1
        step += 1

    print(nodes_visited)

solve()
","
def solve():
    h, n = map(int, input().split())
    visited = set()
    cnt = 0
    node = 1
    direction = 'L'
    
    while node != n:
        if node not in visited:
            visited.add(node)
            cnt += 1

        if direction == 'L':
            node = node * 2
            direction = 'R'
        else:
            node = node * 2 + 1
            direction = 'L'

        if node > 2**h:
            node //= 2
            direction = 'R'

        if node in visited:
            node //= 2
            direction = 'R' if direction == 'L' else 'L'

    print(cnt)

solve()
","
def solve():
    h, n = map(int, input().split())
    result = 0

    for i in range(h, 0, -1):
        mid = 2 ** (i-1)
        if n > mid:
            result += 2 ** i
            n -= mid
        else:
            result += 1

    print(result - 1)

solve()
","
def solve(h: int, n: int) -> int:
    visited = set()
    node = 1
    path = 'L'
    steps = 0

    while node != n:
        steps += 1
        visited.add(node)
        
        if path[steps % len(path)] == 'L':
            if 2*node not in visited and 2*node <= 2**h:
                node *= 2
                path += 'L'
            elif 2*node + 1 not in visited and 2*node + 1 <= 2**h:
                node = 2*node + 1
                path += 'R'
            else:
                while path[steps % len(path)] != 'R':
                    steps -= 1
                steps -= 1
                node //= 2
                path = path[:-1]
        else:
            if 2*node + 1 not in visited and 2*node + 1 <= 2**h:
                node = 2*node + 1
                path += 'R'
            elif 2*node not in visited and 2*node <= 2**h:
                node *= 2
                path += 'L'
            else:
                while path[steps % len(path)] != 'R':
                    steps -= 1
                steps -= 1
                node //= 2
                path = path[:-1]

    return steps


solve()","
from math import pow

def solve(h: int, n: int) -> int:
    visited = 0
    current = 1

    for i in range(h, 0, -1):
        midpoint = pow(2, i-1)
        if n > midpoint:
            visited += current
            n -= midpoint
            current += 1
        else:
            visited += current
            current += 1

    return visited


solve()","
def solve(h: int, n: int) -> int:
    visited = set()
    current_node = 1
    steps = 0

    while current_node != n:
        visited.add(current_node)
        steps += 1

        if current_node < n:
            current_node = current_node * 2
        else:
            current_node = current_node // 2

        if current_node in visited:
            continue

        if current_node < n:
            current_node += 1
        else:
            current_node -= 1

    return steps


# Example usage:
h, n = map(int, input().split())
print(solve(h, n))

solve()","
def solve(h: int, n: int) -> int:
    visited_nodes = set()
    node = 1
    count = 0
    
    while node != n:
        visited_nodes.add(node)
        count += 1
        
        if node * 2 == n or (node + 1) * 2 == n:
            break
        
        if n % 2 == 0:
            node //= 2
        else:
            node = (n + 1) // 2
        
        while node in visited_nodes:
            count += 1
            node //= 2
        
    return count


solve()","
def solve():
    from math import log2
    h, n = map(int, input().split())
    nodes_visited = 0
    for i in range(h, 0, -1):
        mid_point = 2**i // 2
        if n > mid_point:
            nodes_visited += 2**(i+1) - 1
            n = mid_point - (n - mid_point)
        else:
            nodes_visited += 1
            n = mid_point + (mid_point - n)
    print(nodes_visited)

solve()
","
def solve():
    import sys
    h, n = map(int, input().split())

    def calculate_nodes_to_visit(h, n):
        nodes_to_visit = 0
        for i in range(h, 0, -1):
            is_left = n % (2**i) > 0 and ((n // (2**i)) % 2 == 0)
            nodes_to_visit += 1
            if is_left:
                n = n // 2
            else:
                n = (n // 2) + 1
            if n != 1 and n != 2:
                nodes_to_visit += 1

        return nodes_to_visit

    print(calculate_nodes_to_visit(h, n) - 1)

solve()
","
def solve(h, n):
    visited = set()
    node = 1
    path = 'LRLRLRLR' * h
    count = 0
    for i in path:
        if i == 'L':
            node = node * 2
        else:
            node = node * 2 + 1
        count += 1
        visited.add(node)
        if node == n:
            return count - 1
        if node in visited:
            if count > 1:
                count -= 1
            else:
                count = 0
                node //= 2
    return count - 1
  
solve()","
def solve():
    h, n = map(int, input().split())
    count = 0
    for i in range(h, 0, -1):
        count += 1
        mid = 2**(i-1)
        if n > mid:
            n -= mid
            count += mid
        else:
            count += n-1
            break
    print(count)

solve()
","
def solve():
    h, n = map(int, input().split())
    visited = set()
    node = 1
    steps = 0
    
    while node != n:
        visited.add(node)
        if n % 2 == node % 2:
            node //= 2
        else:
            node = (node // 2) + (1 - node % 2) * (2 ** (h - 1))
        steps += 1
        
        if node in visited:
            visited.clear()
            steps -= 1
    
    print(steps)

solve()
","
def solve():
    import sys

    h, n = map(int, input().split())

    total_nodes = (1 << h) - 1
    height = h
    nodes_visited = 0
    curr_node = 1

    for i in range(h):
        middle = (1 << (height - 1)) + (1 << (height - 2))
        if n > middle:
            nodes_visited += curr_node
            curr_node = curr_node * 2 + 1
            n -= middle
        else:
            nodes_visited += curr_node
            curr_node = curr_node * 2
        height -= 1

    print(nodes_visited)

solve()
  ","
def solve():
    from math import log2

    h, n = map(int, input().split())

    def count_nodes_to_exit(h, n):
        nodes_visited = 0
        node = 1
        for i in range(h, 0, -1):
            mid = 2**(i-1)
            nodes_visited += 1
            if n > mid:
                nodes_visited += 2**i - node
                node = 2**(i+1) - n
                n = mid
            elif n < mid:
                node = 2**i - n
                n = mid
            else:
                break
        return nodes_visited

    print(count_nodes_to_exit(h, n) - 1)

solve()
","
def solve():
    h, n = map(int, input().split())
    n -= 1
    result = 0
    for i in range(h-1, -1, -1):
        bit = (n >> i) & 1
        if bit == 0:
            result += 1 << i
        else:
            result += 1 + (1 << i)
        n >>= 1
    print(result)

solve()
","
def solve():
    h, n = map(int, input().split())
    nodes_visited = 0
    divisor = 2
    for i in range(h, 0, -1):
        if n > (divisor / 2):
            nodes_visited += divisor // 2
            n = (divisor + 1) - n
        divisor *= 2
    print(nodes_visited)

solve()
","0.0","0.0","6.666666666666667","0.0","0.0","0.0","0.0","0.0","0.0","0.0","6.666666666666667","0.0","0.0","0.0","20.0","0.0","","","","","","","","","","","","","","","",""
"APPS/293","
QUESTION:
Spongebob is already tired trying to reason his weird actions and calculations, so he simply asked you to find all pairs of n and m, such that there are exactly x distinct squares in the table consisting of n rows and m columns. For example, in a 3 × 5 table there are 15 squares with side one, 8 squares with side two and 3 squares with side three. The total number of distinct squares in a 3 × 5 table is 15 + 8 + 3 = 26.


-----Input-----

The first line of the input contains a single integer x (1 ≤ x ≤ 10^18) — the number of squares inside the tables Spongebob is interested in.


-----Output-----

First print a single integer k — the number of tables with exactly x distinct squares inside.

Then print k pairs of integers describing the tables. Print the pairs in the order of increasing n, and in case of equality — in the order of increasing m.


-----Examples-----
Input
26

Output
6
1 26
2 9
3 5
5 3
9 2
26 1

Input
2

Output
2
1 2
2 1

Input
8

Output
4
1 8
2 3
3 2
8 1



-----Note-----

In a 1 × 2 table there are 2 1 × 1 squares. So, 2 distinct squares in total. [Image] 

In a 2 × 3 table there are 6 1 × 1 squares and 2 2 × 2 squares. That is equal to 8 squares in total. [Image]
Use user-input-Based format and function signature solve()","
def solve():
    x = int(input())
    tables = []
    for n in range(1, int(x**0.5) + 1):
        if x % n == 0:
            m = x // n
            tables.append((n, m))
            if n != m:
                tables.append((m, n))
    tables.sort()
    print(len(tables))
    for table in tables:
        print(table[0], table[1])

solve()
","
def solve():
    x = int(input())
    k = 0
    result = []

    for n in range(1, int(x**0.5) + 1):
        if x % n == 0:
            m = x // n
            if n + m <= 2 * int(x**0.5):
                k += 1
                result.append((n, m))
                if n != m:
                    k += 1
                    result.append((m, n))

    print(k)
    for pair in sorted(result):
        print(pair[0], pair[1])

solve()
","
def solve():
    x = int(input())
    result = []
    for n in range(1, int(x**0.5) + 1):
        if x % n == 0:
            m = x // n
            result.append((n, m))

            if n != m:
                result.append((m, n))

    result.sort()
    print(len(result))
    for pair in result:
        print(pair[0], pair[1])

solve()
  ","
from math import sqrt

def solve():
    x = int(input())
    
    result = []
    for n in range(1, int(sqrt(x)) + 1):
        if x % n == 0:
            m = x // n
            result.append((n, m))
            if n != m:
                result.append((m, n))

    result.sort()
    print(len(result))
    for n, m in result:
        print(n, m)

solve()
","
def solve():
    x = int(input())
    ans = []
    for i in range(1, int(x ** 0.5) + 1):
        if x % i == 0:
            ans.append((i, x // i))
    k = len(ans) * 2 - (int(x ** 0.5) ** 2 == x)
    print(k)
    for n, m in ans:
        print(n, m)
    if int(x ** 0.5) ** 2 == x:
        print(int(x ** 0.5), int(x ** 0.5))

solve()
  ","
def solve():
    x = int(input())
    k = 0
    tables = []
    
    for n in range(1, int(x ** 0.5) + 1):
        if x % n == 0:
            m = x // n
            if (n + m) % 2 == 0 and (m - n) % 2 == 0:
                k += 1
                tables.append((n, m))
    
    print(k)
    for table in tables:
        print(table[0], table[1])

if __name__ == '__main__':
    solve()
","
def solve():
    x = int(input())
    ans = []
    for n in range(1, int(x**0.5) + 1):
        if x % n == 0:
            m = x // n
            ans.append((n, m))
            if n != m:
                ans.append((m, n))
    
    ans.sort()
    k = len(ans)
    
    print(k)
    for pair in ans:
        print(pair[0], pair[1])

solve()","
def solve():
    x = int(input())
    k = 0
    result = []

    for n in range(1, int(x ** 0.5) + 1):
        if x % n == 0:
            m = x // n
            if (n + 1) * n // 2 <= x // n:
                k += 1
                result.append((n, m))

            if n != m and (m + 1) * m // 2 <= x // m:
                k += 1
                result.append((m, n))

    print(k)
    for pair in sorted(result):
        print(pair[0], pair[1])

solve()","
def solve():
    x = int(input())
    k = 0
    tables = []

    for n in range(1, int(x**0.5) + 1):
        if x % n == 0:
            m = x // n
            if n <= m:
                k += 1
                tables.append((n, m))

    print(k)
    for table in tables:
        print(table[0], table[1])

if __name__ == ""__main__"":
    solve()
","
def solve():
    x = int(input())
    result = []
    for n in range(1, int(x ** 0.5) + 1):
        if x % n == 0:
            m = x // n
            if n > m:
                break
            result.append((n, m))
            if n != m:
                result.append((m, n))
    
    print(len(result))
    for pair in result:
        print(pair[0], pair[1])

solve()","
def solve():
    x = int(input())
    ans = []
    for n in range(1, int(x**0.5) + 1):
        if x % n == 0:
            m = x // n
            if n <= m:
                ans.append((n, m))
    print(len(ans))
    for pair in ans:
        print(pair[0], pair[1])

solve()
","
def solve():
    import math
    
    x = int(input())
    
    squares = []
    
    for n in range(1, int(math.sqrt(x))+1):
        if x % n == 0:
            m = x // n
            if n + m - 1 > 0:
                squares.append((n, m))
                
    k = len(squares)
    print(k)
    for n, m in squares:
        print(n, m)

solve()","
def solve():
    x = int(input())
    ans = []
    for n in range(1, int(x ** 0.5) + 1): 
        if x % n == 0:
            m = x // n
            ans.append((n, m))
            if n != m:
                ans.append((m, n))
    
    ans.sort()
    print(len(ans))
    for pair in ans:
        print(pair[0], pair[1])

solve()
","
def solve():
    x = int(input())
    
    tables = []
    for n in range(1, int(x ** 0.5) + 1):
        if x % n == 0:
            m = x // n
            tables.append((n, m))
            if n != m:
                tables.append((m, n))
    
    k = len(tables)
    print(k)
    tables.sort()
    for pair in tables:
        print(pair[0], pair[1])

solve()","
import math

def solve():
    x = int(input())
    ans = []
    for n in range(1, int(math.sqrt(x) + 1)):
        if x % n == 0:
            m = x // n
            ans.append((n, m))
            if n != m:
                ans.append((m, n))
    
    ans.sort()
    k = len(ans)
    
    print(k)
    for pair in ans:
        print(pair[0], pair[1])

solve()
","
def solve():
    x = int(input())
    ans = []
    for n in range(1, int(x**0.5) + 1):
        if x % n == 0:
            m = x // n
            if m >= n:
                ans.append((n, m))
    print(len(ans))
    for pair in ans:
        print(pair[0], pair[1])

solve()
","14.285714285714285","7.142857142857142","14.285714285714285","14.285714285714285","0.0","7.142857142857142","14.285714285714285","7.142857142857142","7.142857142857142","14.285714285714285","7.142857142857142","7.142857142857142","14.285714285714285","14.285714285714285","14.285714285714285","7.142857142857142","","","","","","","","","","","","","","","",""
"APPS/294","
QUESTION:
Everybody in Russia uses Gregorian calendar. In this calendar there are 31 days in January, 28 or 29 days in February (depending on whether the year is leap or not), 31 days in March, 30 days in April, 31 days in May, 30 in June, 31 in July, 31 in August, 30 in September, 31 in October, 30 in November, 31 in December.

A year is leap in one of two cases: either its number is divisible by 4, but not divisible by 100, or is divisible by 400. For example, the following years are leap: 2000, 2004, but years 1900 and 2018 are not leap.

In this problem you are given n (1 ≤ n ≤ 24) integers a_1, a_2, ..., a_{n}, and you have to check if these integers could be durations in days of n consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is a_1 days, duration of the next month is a_2 days, and so on.


-----Input-----

The first line contains single integer n (1 ≤ n ≤ 24) — the number of integers.

The second line contains n integers a_1, a_2, ..., a_{n} (28 ≤ a_{i} ≤ 31) — the numbers you are to check.


-----Output-----

If there are several consecutive months that fit the sequence, print ""YES"" (without quotes). Otherwise, print ""NO"" (without quotes).

You can print each letter in arbitrary case (small or large).


-----Examples-----
Input
4
31 31 30 31

Output
Yes


Input
2
30 30

Output
No


Input
5
29 31 30 31 30

Output
Yes


Input
3
31 28 30

Output
No


Input
3
31 31 28

Output
Yes




-----Note-----

In the first example the integers can denote months July, August, September and October.

In the second example the answer is no, because there are no two consecutive months each having 30 days.

In the third example the months are: February (leap year) — March — April – May — June.

In the fourth example the number of days in the second month is 28, so this is February. March follows February and has 31 days, but not 30, so the answer is NO.

In the fifth example the months are: December — January — February (non-leap year).
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    durations = list(map(int, input().split()))

    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    for i in range(12):
        valid = True
        for j in range(n):
            if durations[j] != leap_year[(i+j)%12] and durations[j] != non_leap_year[(i+j)%12]:
                valid = False
                break
        if valid:
            print(""YES"")
            return

    print(""NO"")

solve()
","
def solve():
    n = int(input())
    days = list(map(int, input().split()))

    leap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    non_leap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    for i in range(12):
        if days == leap[i:i+n] or days == non_leap[i:i+n]:
            print(""YES"")
            return

    print(""NO"")

solve()","
def solve():
    n = int(input())
    days = list(map(int, input().split()))

    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    for start_month in range(12):
        is_valid = True
        for i in range(n):
            if months[(start_month + i) % 12] != days[i]:
                is_valid = False
                break
        if is_valid:
            print(""YES"")
            return

    print(""NO"")


solve()
","
def solve():
    n = int(input())
    months = list(map(int, input().split()))
    
    leap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # Days in each month for leap year
    non_leap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # Days in each month for non-leap year
    
    for i in range(12):
        valid = True
        for j in range(n):
            if months[j] != leap[(i+j)%12] and months[j] != non_leap[(i+j)%12]:
                valid = False
                break
        if valid:
            print(""YES"")
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    durations = list(map(int, input().split()))
    
    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    for i in range(12): 
        for j in range(n): 
            if i+j < 12:
                if durations[j] != leap_year[i+j] and durations[j] != non_leap_year[i+j]: 
                    break
            else: 
                if durations[j] != leap_year[i+j-12] and durations[j] != non_leap_year[i+j-12]: 
                    break
        else: 
                print('YES')
                return
                
    print('NO')

solve()
  ","
def solve():
    n = int(input())
    durations = list(map(int, input().split()))
    
    possible_durations = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    for i in range(12):
        valid = True
        for j in range(n):
            if i+j >= 12 or (durations[j] != possible_durations[i+j] and (not (i+j == 1 and durations[j] == 29))):
                valid = False
                break
        if valid:
            print(""YES"")
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    days = list(map(int, input().split()))
    
    leap_years = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    non_leap_years = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    def is_valid_sequence(days_list):
        for i in range(12):
            valid = True
            for j in range(len(days_list)):
                if days_list[j] != leap_years[(i+j)%12] and days_list[j] != non_leap_years[(i+j)%12]:
                    valid = False
                    break
            if valid:
                return True
        return False
    
    if is_valid_sequence(days):
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    durations = list(map(int, input().split()))

    days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    for start_month in range(12):
        leap = False
        
        for i in range(n):
            if days_in_months[(start_month + i) % 12] == 28 and (start_month + i) % 12 == 1:
                leap = True
            elif days_in_months[(start_month + i) % 12] != durations[i]:
                break
        else:
            if n == 1:
                print(""YES"")
                return
            elif n == 2 and leap and days_in_months[start_month % 12] == 29:
                print(""YES"")
                return
            elif n > 2:
                print(""YES"")
                return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    data = list(map(int, input().split()))
    
    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    for i in range(12):
        valid = True
        for j in range(n):
            if data[j] != months[(i+j)%12]:
                valid = False
                break
        if valid:
            print(""YES"")
            return
    print(""NO"")

solve()","
def solve():
    n = int(input())
    months = list(map(int, input().split()))
    
    for i in range(12):
        valid = True
        for j in range(n):
            days = months[j]
            if i == 1:  # February
                if ((i + j) % 4 == 0 and (i + j) % 100 != 0) or (i + j) % 400 == 0:
                    if days != 29:
                        valid = False
                        break
                else:
                    if days != 28:
                        valid = False
                        break
            elif days != [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][i]:
                valid = False
                break
        
        if valid:
            print(""YES"")
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    durations = list(map(int, input().split()))
    
    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    for i in range(12):
        valid = True
        for j in range(n):
            if i+j < 12 and (durations[j] != leap_year[i+j] and durations[j] != non_leap_year[i+j]):
                valid = False
                break
        if valid:
            print(""YES"")
            return
    
    print(""NO"")

solve()
","
def solve():
    n = int(input())
    days = list(map(int, input().split()))

    def is_leap(year):
        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
            return True
        return False

    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    possible = False

    for i in range(12):
        for j in range(12):
            curr_days = []
            for k in range(n):
                curr_month = (i + k) % 12
                if curr_month == 1 and is_leap(2000 + (i + k) // 12):
                    curr_days.append(29)
                else:
                    curr_days.append(months[curr_month])
            if curr_days == days:
                possible = True

    if possible:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n = int(input())
    days = list(map(int, input().split()))

    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    for i in range(12):
        valid = True
        for j in range(n):
            if i + j < 12:
                if (leap_year if (i + j) % 12 == 1 else non_leap_year)[i + j] != days[j]:
                    valid = False
                    break
            else:
                if leap_year[i + j - 12] != days[j]:
                    valid = False
                    break
        if valid:
            print(""YES"")
            return
    print(""NO"")
  
solve()","
def solve():
    n = int(input())
    nums = list(map(int, input().split()))
    
    def is_leap(year):
        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)
    
    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    for i in range(0, 12):
        for j in range(n):
            if nums[j] != months[(i+j) % 12] and not (i+j == 1 and is_leap(2020+i//12)):
                break
        else:
            print(""YES"")
            return
    print(""NO"")

solve()
  ","
def solve():
    n = int(input())
    months = list(map(int, input().split()))

    # Calculate all possible lengths of consecutive months in a cumulative manner
    days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    cumulative_days = [days_in_months[0]]
    for i in range(1, 12):
        cumulative_days.append(cumulative_days[i-1] + days_in_months[i])

    # Check if any consecutive n months can fit the given sequence
    for i in range(12):
        for j in range(12):
            seq = cumulative_days[j:]+cumulative_days[:j]
            valid = True
            for k in range(n):
                if seq[k] != months[k]:
                    valid = False
                    break
            if valid:
                print(""YES"")
                return

    print(""NO"")

solve()","
def solve():
    n = int(input())
    days = list(map(int, input().split()))
    
    leap_days = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    non_leap_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    for i in range(12):
        for j in range(12 - n + 1):
            if days == leap_days[j:j+n] or days == non_leap_days[j:j+n]:
                print(""YES"")
                return
    
    print(""NO"")

solve()","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/295","
QUESTION:
You are given a positive integer $n$.

Find a sequence of fractions $\frac{a_i}{b_i}$, $i = 1 \ldots k$ (where $a_i$ and $b_i$ are positive integers) for some $k$ such that:

$$ \begin{cases} \text{$b_i$ divides $n$, $1 < b_i < n$ for $i = 1 \ldots k$} \\ \text{$1 \le a_i < b_i$ for $i = 1 \ldots k$} \\ \text{$\sum\limits_{i=1}^k \frac{a_i}{b_i} = 1 - \frac{1}{n}$} \end{cases} $$


-----Input-----

The input consists of a single integer $n$ ($2 \le n \le 10^9$).


-----Output-----

In the first line print ""YES"" if there exists such a sequence of fractions or ""NO"" otherwise.

If there exists such a sequence, next lines should contain a description of the sequence in the following format.

The second line should contain integer $k$ ($1 \le k \le 100\,000$) — the number of elements in the sequence. It is guaranteed that if such a sequence exists, then there exists a sequence of length at most $100\,000$.

Next $k$ lines should contain fractions of the sequence with two integers $a_i$ and $b_i$ on each line.


-----Examples-----
Input
2

Output
NO

Input
6

Output
YES
2
1 2
1 3



-----Note-----

In the second example there is a sequence $\frac{1}{2}, \frac{1}{3}$ such that $\frac{1}{2} + \frac{1}{3} = 1 - \frac{1}{6}$.
Use user-input-Based format and function signature solve()","
from fractions import Fraction

def solve(n):
    def find_sequence(n):
        if n == 2:
            return ""NO""
        else:
            sequence = []
            for i in range(2, n):
                sequence.append((1, i))
            return sequence

    target_sum = 1 - Fraction(1, n)
    sequence = find_sequence(n)
    if sequence == ""NO"":
        return ""NO""
    else:
        current_sum = sum(Fraction(a, b) for a, b in sequence)
        if current_sum == target_sum:
            result = [""YES"", len(sequence)]
            for a, b in sequence:
                result.append(f""{a} {b}"")
            return result
        else:
            return ""NO""

# Test the function
print(solve(2))
print(solve(6))

solve()","
from fractions import Fraction

def solve(n):
    if n == 2:
        print(""NO"")
        return
    
    result = []
    for i in range(2, n):
        result.append((1, i))
    
    result.append((n-2, n))
    
    print(""YES"")
    print(len(result))
    for a, b in result:
        print(f""{a} {b}"")

solve()","
from fractions import Fraction

def solve():
    n = int(input())
    if n % 2 == 0:
        print(""NO"")
    else:
        print(""YES"")
        print(2)
        print(f""1 2"")
        print(f""1 {n}"")

solve()","
from math import gcd

def solve():
    n = int(input())
    
    if n == 2:
        print(""NO"")
    else:
        print(""YES"")
        seq = []
        for i in range(2, n):
            if gcd(i, n) == 1:
                seq.append((1, i))
        
        print(len(seq))
        for frac in seq:
            print(frac[0], frac[1])

solve()","
from math import gcd

def solve():
    n = int(input())
    
    def find_fraction_sequence(n):
        if n == 2:
            print(""NO"")
        else:
            print(""YES"")
            print(2)
            print(1, 2)
            print(1, 3)

    find_fraction_sequence(n)

solve()
","
from fractions import Fraction

def solve():
    n = int(input())
    
    if n == 2:
        print(""NO"")
    else:
        print(""YES"")
        print(2)
        print(""1 2"")
        print(f""1 {n}"")

solve()","
from fractions import Fraction

def solve():
    n = int(input())
    
    if n == 2:
        print(""NO"")
    else:
        print(""YES"")
        print(2)
        print(1, 2)
        print(1, 3)

solve()
","
from fractions import Fraction

def solve(n):
    def find_fractions(num):
        res = []
        for i in range(2, num):
            if num % i == 0:
                res.append((1, i))
        return res

    target_fraction = Fraction(1 - 1/n)

    fractions = find_fractions(n)
    found = False
    for i in range(1, len(fractions)+1):
        for combo in itertools.combinations(fractions, i):
            current_sum = sum(Fraction(a, b) for a, b in combo)
            if current_sum == target_fraction:
                found = True
                result = combo
                break
        if found:
            break

    if found:
        print(""YES"")
        print(len(result))
        for a, b in result:
            print(f""{a} {b}"")
    else:
        print(""NO"")

solve()","
from fractions import Fraction

def solve():
    n = int(input())
    if n == 2:
        print(""NO"")
    else:
        print(""YES"")
        fractions = []
        fractions.append((1, 2))
        fractions.append((1, 3))
        print(""2"")
        for a, b in fractions:
            print(a, b)

solve()","
from fractions import Fraction

def solve():
    n = int(input())
    
    if n == 2:
        print(""NO"")
        return
    
    k = 2
    print(""YES"")
    print(k)
    
    b1 = n
    a1 = b1 - 1
    
    b2 = n + 1
    a2 = b2 - 1
    
    print(f""{a1} {b1}"")
    print(f""{a2} {b2}"")

solve()
","
from fractions import Fraction

def solve():
    n = int(input())
    if n == 2:
        print(""NO"")
    else:
        print(""YES"")
        print(2)
        print(f""1 2"")
        print(f""1 {n}"")

solve()
","
from math import gcd

def solve():
    n = int(input())
    
    def find_fractions(n):
        factors = set()
        for i in range(2, n):
            if n % i == 0:
                factors.add(i)
        fractions = []
        for b in factors:
            a = n - 1
            gcd_ab = gcd(a, b)
            a //= gcd_ab
            b //= gcd_ab
            fractions.append((a, b))
        return fractions

    fractions = find_fractions(n)
    if fractions:
        print(""YES"")
        print(len(fractions))
        for a, b in fractions:
            print(f""{a} {b}"")
    else:
        print(""NO"")

solve()
","
from fractions import Fraction

def solve():
    n = int(input())

    if n == 2:
        print(""NO"")
    else:
        k = 2
        print(""YES"")
        print(k)
        print(1, 2)
        print(1, 3)

solve()
","
from fractions import Fraction

def solve():
    n = int(input())
    
    if n == 2:
        print(""NO"")
        return
    
    result = []
    remainder = Fraction(1 - 1/n)
    
    for i in range(2, n):
        if n % i == 0:
            result.append((1, i))
            remainder -= Fraction(1, i)
    
    if remainder == 0:
        print(""YES"")
        print(len(result))
        for a, b in result:
            print(a, b)
    else:
        print(""NO"")

solve()","
from fractions import Fraction

def solve(n):
    def find_fractions(n):
        if n <= 2:
            return []

        fractions = []
        for i in range(n - 1, 1, -1):
            fractions.append((1, i))

        remaining = 1 - Fraction(1, n)
        fractions.append((remaining.numerator, remaining.denominator))

        return fractions

    fractions = find_fractions(n)

    if sum(Fraction(a, b) for a, b in fractions) == 1 - Fraction(1, n):
        print(""YES"")
        print(len(fractions))
        for a, b in fractions:
            print(str(a) + "" "" + str(b))
    else:
        print(""NO"")

# Example usage:
solve(2)

solve()","
from fractions import Fraction

def solve():
    n = int(input())

    if n == 2:
        print(""NO"")
    else:
        print(""YES"")
        print(2)
        a = n - 1
        b1 = n
        print(f""{a} {b1}"")
        b2 = n + 1
        print(f""{a} {b2}"")

solve()
","0.0","0.0","13.333333333333334","7.6923076923076925","13.333333333333334","6.666666666666667","13.333333333333334","0.0","13.333333333333334","6.666666666666667","6.666666666666667","33.33333333333333","13.333333333333334","40.0","0.0","6.666666666666667","","","","","","","","","","","","","","","",""
"APPS/296","
QUESTION:
Vasya should paint a fence in front of his own cottage. The fence is a sequence of n wooden boards arranged in a single row. Each board is a 1 centimeter wide rectangle. Let's number the board fence using numbers 1, 2, ..., n from left to right. The height of the i-th board is h_{i} centimeters.

Vasya has a 1 centimeter wide brush and the paint of two colors, red and green. Of course, the amount of the paint is limited. Vasya counted the area he can paint each of the colors. It turned out that he can not paint over a square centimeters of the fence red, and he can not paint over b square centimeters green. Each board of the fence should be painted exactly one of the two colors. Perhaps Vasya won't need one of the colors.

In addition, Vasya wants his fence to look smart. To do this, he should paint the fence so as to minimize the value that Vasya called the fence unattractiveness value. Vasya believes that two consecutive fence boards, painted different colors, look unattractive. The unattractiveness value of a fence is the total length of contact between the neighboring boards of various colors. To make the fence look nice, you need to minimize the value as low as possible. Your task is to find what is the minimum unattractiveness Vasya can get, if he paints his fence completely. $1$ 

The picture shows the fence, where the heights of boards (from left to right) are 2,3,2,4,3,1. The first and the fifth boards are painted red, the others are painted green. The first and the second boards have contact length 2, the fourth and fifth boards have contact length 3, the fifth and the sixth have contact length 1. Therefore, the unattractiveness of the given painted fence is 2+3+1=6.


-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 200) — the number of boards in Vasya's fence.

The second line contains two integers a and b (0 ≤ a, b ≤ 4·10^4) — the area that can be painted red and the area that can be painted green, correspondingly.

The third line contains a sequence of n integers h_1, h_2, ..., h_{n} (1 ≤ h_{i} ≤ 200) — the heights of the fence boards.

All numbers in the lines are separated by single spaces.


-----Output-----

Print a single number — the minimum unattractiveness value Vasya can get if he paints his fence completely. If it is impossible to do, print  - 1.


-----Examples-----
Input
4
5 7
3 3 4 1

Output
3

Input
3
2 3
1 3 1

Output
2

Input
3
3 3
2 2 2

Output
-1
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_area = sum(heights)
    min_unattractiveness = float('inf')

    for i in range(1, total_area + 1):
        for j in range(1, total_area + 1):
            if i * a + j * b == total_area:
                unattractiveness = 0
                for k in range(n):
                    if k % 2 == 0:
                        if heights[k] < i:
                            unattractiveness += i - heights[k]
                    else:
                        if heights[k] < j:
                            unattractiveness += j - heights[k]
                min_unattractiveness = min(min_unattractiveness, unattractiveness)

    if min_unattractiveness == float('inf'):
        print(-1)
    else:
        print(min_unattractiveness)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_height = sum(heights)
    min_unattractiveness = 0

    for i in range(n - 1):
        red_area = min(a, total_height - heights[i])
        green_area = min(b, total_height - heights[i])
        remaining_area = a + b - red_area - green_area

        if remaining_area < 0:
            return -1

        min_unattractiveness += min(remaining_area, heights[i])

    return min_unattractiveness

# Run the function
result = solve()
print(result)

solve()","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_area = sum(heights)
    min_unattractiveness = float('inf')

    for i in range(1, n-1):
        for j in range(i+1, n):
            red_area = sum(heights[:i])
            green_area = sum(heights[i:j])
            red_unattractiveness = max(0, i-1) * a
            green_unattractiveness = max(0, j-i-1) * b
            unattractiveness = red_unattractiveness + green_unattractiveness
            if total_area - red_area - green_area >= a + b:
                min_unattractiveness = min(min_unattractiveness, unattractiveness)

    if min_unattractiveness == float('inf'):
        print(-1)
    else:
        print(min_unattractiveness)

solve()
","
from typing import List

def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))
    
    dp = [[[float('inf')]*(a+1) for _ in range(b+1)] for _ in range(n+1)]
    dp[0][0][0] = 0
    
    for i in range(1, n+1):
        for j in range(a+1):
            for k in range(b+1):
                for last_color in range(2):
                    if j >= heights[i-1] or k >= heights[i-1]:
                        dp[i][j][k] = min(dp[i][j][k], dp[i-1][j-heights[i-1]][k] + (last_color != 0))
                    if k >= heights[i-1]:
                        dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][k-heights[i-1]] + (last_color != 1))
    
    result = dp[n][a][b]
    
    if result == float('inf'):
        print(-1)
    else:
        print(result)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_unattractiveness = 0
    for i in range(n-1):
        if heights[i] < heights[i+1]:  # current board shorter than next board
            if a > 0:
                a -= min(a, heights[i+1] - heights[i])
            else:
                total_unattractiveness += heights[i+1] - heights[i]
        elif heights[i] > heights[i+1]:  # current board taller than next board
            if b > 0:
                b -= min(b, heights[i] - heights[i+1])
            else:
                total_unattractiveness += heights[i] - heights[i+1]
        else:  # current board same height as next board
            min_paint = min(a, b)
            if min_paint >= heights[i]:
                min_paint = heights[i]
            a -= min_paint
            b -= min_paint
    
    print(total_unattractiveness)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    dp = [[float('inf')] * 2 for _ in range(n+1)]
    dp[0][0] = dp[0][1] = 0

    for i in range(1, n+1):
        for color in range(2):
            for prev_color in range(2):
                if heights[i-1] + prev_color == heights[i-2] + color:
                    continue
                dp[i][color] = min(dp[i][color], dp[i-1][prev_color] + (a if color == 0 else b))

    result = min(dp[n])
    print(result if result != float('inf') else -1)

solve()
  ","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_unattractiveness = 0
    for i in range(n-1):
        if heights[i] < heights[i+1]:
            if a > 0:
                a_used = min(a, heights[i+1])
                a -= a_used
            else:
                total_unattractiveness += 1
        else:
            if b > 0:
                b_used = min(b, heights[i])
                b -= b_used
            else:
                total_unattractiveness += 1

    print(total_unattractiveness)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_unattractiveness = float('inf')
    
    for i in range(1, n-1):
        for j in range(i+1, n):
            red_length = sum(heights[:i])
            green_length = sum(heights[i:j])
            red_area = min(red_length, a)
            green_area = min(green_length, b)
            unattractiveness = red_area + green_area
            total_unattractiveness = min(total_unattractiveness, unattractiveness)

    if total_unattractiveness == float('inf'):
        print(-1)
    else:
        print(total_unattractiveness)

solve()
  ","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    h = list(map(int, input().split()))

    dp = [[float('inf')] * 2 for _ in range(n + 1)]
    dp[0][0] = dp[0][1] = 0

    for i in range(1, n + 1):
        for color in range(2):
            for j in range(2):
                if j * h[i - 1] <= (color == 0) * a:
                    dp[i][color] = min(dp[i][color], dp[i - 1][j] + (j != color))

    result = min(dp[n])
    if result == float('inf'):
        return -1
    else:
        return result

# Example usage
print(solve())

solve()","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_area = sum(heights)
    min_unattractiveness = float('inf')

    for i in range(1, n):
        for j in range(i, n):
            red_area = sum(heights[:i])
            green_area = sum(heights[i:j+1])

            if a >= red_area and b >= green_area:
                contact_length = 0
                if heights[i-1] != heights[i]:
                    contact_length += 1
                if heights[j] != heights[j+1]:
                    contact_length += 1

                min_unattractiveness = min(min_unattractiveness, contact_length)

    if min_unattractiveness == float('inf'):
        print(-1)
    else:
        print(min_unattractiveness)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total = sum(heights)
    dp = [[float('inf')] * (total+1) for _ in range(n+1)]
    dp[0][0] = 0

    for i in range(1, n+1):
        for j in range(total+1):
            dp[i][j] = dp[i-1][j]
            for k in range(1, min(j, heights[i-1])+1):
                if a >= k or b >= heights[i-1]-k:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-k] + i - 1)

    result = float('inf')
    for j in range(total+1):
        result = min(result, dp[n][j])

    if result == float('inf'):
        print(-1)
    else:
        print(result)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))

    total_contact = 0
    
    for i in range(n-1):
        if heights[i] > heights[i+1]:
            # Attempt to paint board i red
            if a >= heights[i]:
                a -= heights[i]
            else:
                total_contact += 1

        else:
            # Attempt to paint board i green
            if b >= heights[i]:
                b -= heights[i]
            else:
                total_contact += 1

    print(total_contact)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))
    
    min_unattractiveness = float('inf')
    
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if i == j:
                continue
            red_length = sum(heights[min(i-1, j-1):max(i-1, j-1)]) if i > j else 0
            green_length = sum(heights[min(i-1, j-1):max(i-1, j-1)]) if i < j else 0
            total_length = min(red_length, a) + min(green_length, b)
            unattractiveness = red_length + green_length - total_length
            min_unattractiveness = min(min_unattractiveness, unattractiveness)
    
    if min_unattractiveness == float('inf'):
        print(-1)
    else:
        print(min_unattractiveness)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))
    
    dp = [[float('inf') for _ in range(a+1)] for _ in range(b+1)]
    dp[0][0] = 0
    
    for i in range(1, n+1):
        for j in range(a+1):
            for k in range(b+1):
                cost = abs(heights[i-1] - j - k)
                if cost <= j + k:
                    dp[j][k] = min(dp[j][k], dp[j-cost][k] + (1 if k == 0 else 0), dp[j][k-cost] + (1 if j == 0 else 0))
                    
    ans = min(dp[a][b], dp[b][a])
    if ans == float('inf'):
        print(-1)
    else:
        print(ans)

solve()
","
def solve():
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))
    
    dp = [[float('inf')] * 2 for _ in range(n + 1)]
    dp[0][0] = dp[0][1] = 0
    
    for i in range(1, n + 1):
        for j in range(2):
            for k in range(2):
                if a >= heights[i - 1] * j and b >= heights[i - 1] * k:
                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + (j != k))
    
    result = min(dp[n])
    if result == float('inf'):
        print(-1)
    else:
        print(result)

solve()
","
def solve():
    import sys
    
    n = int(input())
    a, b = map(int, input().split())
    heights = list(map(int, input().split()))
    
    dp = [[sys.maxsize] * 2 for _ in range(n + 1)]
    dp[0][0] = dp[0][1] = 0
    
    for i in range(1, n + 1):
        for j in range(2):
            for k in range(2):
                if j + k <= i:
                    color = 1 if k == 0 else 0
                    dp[i][color] = min(dp[i][color], dp[i - j][j] + (a if color == 0 else b) * j)
    
    result = min(dp[n][0], dp[n][1])
    print(result if result < sys.maxsize else -1)

solve()
  ","33.33333333333333","0.0","13.333333333333334","7.142857142857142","20.0","0.0","20.0","0.0","0.0","6.666666666666667","14.285714285714285","20.0","20.0","7.142857142857142","20.0","0.0","","","","","","","","","","","","","","","",""
"APPS/297","
QUESTION:
Vasya has got three integers $n$, $m$ and $k$. He'd like to find three integer points $(x_1, y_1)$, $(x_2, y_2)$, $(x_3, y_3)$, such that $0 \le x_1, x_2, x_3 \le n$, $0 \le y_1, y_2, y_3 \le m$ and the area of the triangle formed by these points is equal to $\frac{nm}{k}$.

Help Vasya! Find such points (if it's possible). If there are multiple solutions, print any of them.


-----Input-----

The single line contains three integers $n$, $m$, $k$ ($1\le n, m \le 10^9$, $2 \le k \le 10^9$).


-----Output-----

If there are no such points, print ""NO"".

Otherwise print ""YES"" in the first line. The next three lines should contain integers $x_i, y_i$ — coordinates of the points, one point per line. If there are multiple solutions, print any of them.

You can print each letter in any case (upper or lower).


-----Examples-----
Input
4 3 3

Output
YES
1 0
2 3
4 1

Input
4 4 7

Output
NO



-----Note-----

In the first example area of the triangle should be equal to $\frac{nm}{k} = 4$. The triangle mentioned in the output is pictured below:  [Image] 

In the second example there is no triangle with area $\frac{nm}{k} = \frac{16}{7}$.
Use user-input-Based format and function signature solve()","
def solve():
    n, m, k = map(int, input().split())
    
    if n * m % k != 0:
        print(""NO"")
    else:
        print(""YES"")
        a = n * m // k
        x1 = 0
        y1 = 0
        x2 = a
        y2 = 0
        x3 = 0
        y3 = 1
        print(x1, y1)
        print(x2, y2)
        print(x3, y3)

solve()
","
def solve():
    n, m, k = map(int, input().split())
    if 2 * n * m % k != 0:
        print(""NO"")
    else:
        print(""YES"")
        a = 2 * n * m // k
        x1, y1 = 0, 0
        x2, y2 = a // n, 0
        if x2 == n:
            x1, x2 = 0, 0
            y1, y2 = a // m, 0
            print(x1, y1)
            print(x2, y2)
        else:
            print(x1, y1)
            print(x2, y2)
        x3 = 0
        y3 = a // x2 if x2 != 0 else a // x1
        print(x3, y3)

solve()

","
def solve():
    import math
    
    n, m, k = map(int, input().split())
    
    total_area = n * m / k
    
    if total_area % 1 != 0:
        print(""NO"")
    else:
        print(""YES"")
        area_side = int(math.sqrt(total_area))
        
        print(""0 0"")
        print(f""{area_side} 0"")
        print(f""0 {area_side}"")

solve()","
def solve():
    n, m, k = map(int, input().split())

    if 2*(n*m) % k != 0:
        print(""NO"")
    else:
        print(""YES"")
        a = 2*(n*m) // k
        if n % a == 0:
            print(""0"", n, sep="" "", end=""\n"")
            print(""0"", 0, sep="" "", end=""\n"")
            print(n, 0, sep="" "", end=""\n"")
        else:
            print(""0"", m, sep="" "", end=""\n"")
            print(n, a // n, sep="" "", end=""\n"")
            print((a - m*(a // n)), 0, sep="" "", end=""\n"")

solve()
  ","
def solve():
    # Required imports
    import math
    
    # Input
    n, m, k = map(int, input().split())
    
    # Calculate the area of the triangle
    area = n * m / k
    
    # Check if it's possible to form a triangle
    if area != int(area):
        print(""NO"")
    else:
        # Find the points
        a = int(math.sqrt(area))
        b = k
        while a % k == 0:
            a //= k
            b *= k
        
        x1, y1 = 0, 0
        x2, y2 = a, 0
        x3, y3 = 0, b // m
        
        # Output
        print(""YES"")
        print(x1, y1)
        print(x2, y2)
        print(x3, y3)

# Call the function
solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    
    area = n * m / k
    if area.is_integer():
        print(""YES"")
        print(""0 0"")
        print(f""{n} 0"")
        print(f""0 {m}"")
    else:
        print(""NO"")

solve()","
def solve():
    import math
    
    n, m, k = map(int, input().split())
    target_area = n * m / k
    
    for x1 in range(n + 1):
        for y1 in range(m + 1):
            for x2 in range(n + 1):
                for y2 in range(m + 1):
                    area = abs((x1 - x2) * (y1 - y2))
                    if area == target_area:
                        print(""YES"")
                        print(x1, y1)
                        print(x2, y2)
                        print(n, m)
                        return
    
    print(""NO"")

solve()","
def solve():
    import math
    
    n, m, k = map(int, input().split())
    area = n * m / k
    
    if area.is_integer():
        a = int(math.sqrt(area))
        if a <= n and a*m <= k:
            print(""YES"")
            print(""0 0"")
            print(f""{a} 0"")
            print(f""0 {m}"")
        elif a <= m and a*n <= k:
            print(""YES"")
            print(""0 0"")
            print(f""0 {a}"")
            print(f""{n} 0"")
        else:
            print(""NO"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m, k = map(int, input().split())
    
    if 2 * n * m % k == 0:
        a = 2 * n * m // k
        side = int(a ** 0.5)
        if side <= n:
            print(""YES"")
            print(""0 0"")
            print(f""{side} 0"")
            print(f""0 {side}"")
        else:
            print(""NO"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    solve()
","
def solve():
    n, m, k = map(int, input().split())
    area = n * m / k
    if area.is_integer():
        print(""YES"")
        print(""0 0"")
        print(f""{n} 0"")
        print(f""0 {int(m / area)}"")
    else:
        print(""NO"")

solve()","
def solve():
    n, m, k = map(int, input().split())
    
    if 2 * k > n * m or n * m % k != 0:
        print(""NO"")
    else:
        print(""YES"")
        x1 = 0
        y1 = 0
        x2 = int(n)
        y2 = int((m * n) // k)
        x3 = 1
        y3 = 0
        print(x1, y1)
        print(x2, y2)
        print(x3, y3)

solve()
  ","
def solve():
    n, m, k = map(int, input().split())
    
    if (n * m) % k != 0:
        print(""NO"")
    else:
        print(""YES"")
        a = n
        c = (n * m) // k
        b = c // a
        print(""0 0"")
        print(f""{a} 0"")
        print(f""0 {b}"")

solve()","
def solve():
    import math

    n, m, k = map(int, input().split())
    area = n * m / k

    side1 = math.isqrt(n * m)  # Calculate the length of one side of the triangle
    if side1 == 0 or side1 * k != n * m:  # Check if the triangle is not possible
        print(""NO"")
    else:
        side2 = k // side1  # Calculate the length of the second side of the triangle
        print(""YES"")
        print(f""0 0"")
        print(f""{side1} 0"")
        print(f""0 {side2}"")

solve()","
def solve():
    n, m, k = map(int, input().split())
    area = n * m / k
    if area % 1 != 0:
        print(""NO"")
    else:
        print(""YES"")
        a = int(area)
        print(f""0 0\n{a} 0\n0 {m}"")

solve()","
def solve():
    import math

    n, m, k = map(int, input().split())
    area = n * m / k

    if area.is_integer():
        print(""YES"")
        print(0, 0)
        print(int(math.sqrt(area)), 0)
        print(0, int(m / math.sqrt(area)))
    else:
        print(""NO"")

solve()","
import math

def solve():
    n, m, k = map(int, input().split())

    if 2 * n * m % k != 0:
        print(""NO"")
    else:
        print(""YES"")
        a = 2 * n * m // k
        d = math.gcd(a, n)
        x = n // d
        y = m * d // 2
        print(0, 0)
        print(x, 0)
        print(0, y)

solve()","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","14.285714285714285","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","13.333333333333334","","","","","","","","","","","","","","","",""
"APPS/298","
QUESTION:
It's one more school day now. Sasha doesn't like classes and is always bored at them. So, each day he invents some game and plays in it alone or with friends.

Today he invented one simple game to play with Lena, with whom he shares a desk. The rules are simple. Sasha draws n sticks in a row. After that the players take turns crossing out exactly k sticks from left or right in each turn. Sasha moves first, because he is the inventor of the game. If there are less than k sticks on the paper before some turn, the game ends. Sasha wins if he makes strictly more moves than Lena. Sasha wants to know the result of the game before playing, you are to help him.


-----Input-----

The first line contains two integers n and k (1 ≤ n, k ≤ 10^18, k ≤ n) — the number of sticks drawn by Sasha and the number k — the number of sticks to be crossed out on each turn.


-----Output-----

If Sasha wins, print ""YES"" (without quotes), otherwise print ""NO"" (without quotes).

You can print each letter in arbitrary case (upper of lower).


-----Examples-----
Input
1 1

Output
YES

Input
10 4

Output
NO



-----Note-----

In the first example Sasha crosses out 1 stick, and then there are no sticks. So Lena can't make a move, and Sasha wins.

In the second example Sasha crosses out 4 sticks, then Lena crosses out 4 sticks, and after that there are only 2 sticks left. Sasha can't make a move. The players make equal number of moves, so Sasha doesn't win.
Use user-input-Based format and function signature solve()","
def solve():
    n, k = map(int, input().split())
    if n % (2*k) < k:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    result = ""YES"" if (n // k) % 2 == 1 else ""NO""
    print(result)

solve()
","
def solve():
    n, k = map(int, input().split())
    
    total_moves = (n // k) * k
    remaining_sticks = n - total_moves
    
    if remaining_sticks // k % 2 != 0:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    
    if n % (2 * k) == 0:
        print(""NO"")
    else:
        print(""YES"")

# Call the function to run and provide input
solve()
","
def solve():
    n, k = map(int, input().split())
    if n % (2*k) < k:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    if n // k % 2 == 1:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n, k = map(int, input().split())
    total_moves = n // k
    if total_moves % 2 == 1:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n, k = map(int, input().split())
    if n % (2*k) // k == 1:
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    if n % (2*k) < k:
        print(""YES"")
    else:
        print(""NO"")
  
solve()","
def solve():
    n, k = map(int, input().split())
    if n // k % 2 == 0:
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    if n % (2 * k) < k:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    if n//k % 2 != 0:
        print(""YES"")
    else:
        print(""NO"")

solve()
","
def solve():
    n, k = map(int, input().split())
    
    if n % k == 0:
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    if n // k % 2 == 0:
        print(""NO"")
    else:
        print(""YES"")

solve()","
def solve():
    n, k = map(int, input().split())
    if n % (2 * k) < k:
        print(""YES"")
    else:
        print(""NO"")

solve()","
def solve():
    n, k = map(int, input().split())
    if n % (2 * k) < k:
        print(""YES"")
    else:
        print(""NO"")

solve()","0.0","100.0","46.666666666666664","60.0","0.0","100.0","100.0","0.0","0.0","100.0","0.0","100.0","46.666666666666664","100.0","0.0","0.0","","","","","","","","","","","","","","","",""
"APPS/299","
QUESTION:
Greg is a beginner bodybuilder. Today the gym coach gave him the training plan. All it had was n integers a_1, a_2, ..., a_{n}. These numbers mean that Greg needs to do exactly n exercises today. Besides, Greg should repeat the i-th in order exercise a_{i} times.

Greg now only does three types of exercises: ""chest"" exercises, ""biceps"" exercises and ""back"" exercises. Besides, his training is cyclic, that is, the first exercise he does is a ""chest"" one, the second one is ""biceps"", the third one is ""back"", the fourth one is ""chest"", the fifth one is ""biceps"", and so on to the n-th exercise.

Now Greg wonders, which muscle will get the most exercise during his training. We know that the exercise Greg repeats the maximum number of times, trains the corresponding muscle the most. Help Greg, determine which muscle will get the most training.


-----Input-----

The first line contains integer n (1 ≤ n ≤ 20). The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 25) — the number of times Greg repeats the exercises.


-----Output-----

Print word ""chest"" (without the quotes), if the chest gets the most exercise, ""biceps"" (without the quotes), if the biceps gets the most exercise and print ""back"" (without the quotes) if the back gets the most exercise.

It is guaranteed that the input is such that the answer to the problem is unambiguous.


-----Examples-----
Input
2
2 8

Output
biceps

Input
3
5 1 10

Output
back

Input
7
3 3 2 7 9 6 8

Output
chest



-----Note-----

In the first sample Greg does 2 chest, 8 biceps and zero back exercises, so the biceps gets the most exercises.

In the second sample Greg does 5 chest, 1 biceps and 10 back exercises, so the back gets the most exercises.

In the third sample Greg does 18 chest, 12 biceps and 8 back exercises, so the chest gets the most exercise.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    chest = 0
    biceps = 0
    back = 0

    for i in range(n):
        if i % 3 == 0:
            chest += exercises[i]
        elif i % 3 == 1:
            biceps += exercises[i]
        else:
            back += exercises[i]

    if chest >= biceps and chest >= back:
        print(""chest"")
    elif biceps >= chest and biceps >= back:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    
    chest_count = 0
    biceps_count = 0
    back_count = 0
    
    for i in range(n):
        if i % 3 == 0:
            chest_count += exercises[i]
        elif i % 3 == 1:
            biceps_count += exercises[i]
        else:
            back_count += exercises[i]
    
    if chest_count >= biceps_count and chest_count >= back_count:
        print(""chest"")
    elif biceps_count >= chest_count and biceps_count >= back_count:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    chest_total = 0
    biceps_total = 0
    back_total = 0

    for i in range(n):
        if i % 3 == 0:
            chest_total += exercises[i]
        elif i % 3 == 1:
            biceps_total += exercises[i]
        else:
            back_total += exercises[i]

    if chest_total >= biceps_total and chest_total >= back_total:
        print(""chest"")
    elif biceps_total >= chest_total and biceps_total >= back_total:
        print(""biceps"")
    else:
        print(""back"")

solve()
  ","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    chest, biceps, back = 0, 0, 0

    for i in range(n):
        if i % 3 == 0:
            chest += exercises[i]
        elif i % 3 == 1:
            biceps += exercises[i]
        else:
            back += exercises[i]

    if chest > biceps and chest > back:
        print(""chest"")
    elif biceps > chest and biceps > back:
        print(""biceps"")
    else:
        print(""back"")

solve()","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    chest_count = 0
    biceps_count = 0
    back_count = 0

    for i in range(n):
        if i % 3 == 0:
            chest_count += exercises[i]
        elif i % 3 == 1:
            biceps_count += exercises[i]
        else:
            back_count += exercises[i]

    if chest_count > biceps_count and chest_count > back_count:
        print(""chest"")
    elif biceps_count > chest_count and biceps_count > back_count:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    chest_count = 0
    biceps_count = 0
    back_count = 0

    for i in range(n):
        if i % 3 == 0:
            chest_count += exercises[i]
        elif i % 3 == 1:
            biceps_count += exercises[i]
        else:
            back_count += exercises[i]

    if chest_count >= biceps_count and chest_count >= back_count:
        print(""chest"")
    elif biceps_count >= chest_count and biceps_count >= back_count:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    
    chest = sum(exercises[::3])
    biceps = sum(exercises[1::3])
    back = sum(exercises[2::3])
    
    if chest >= biceps and chest >= back:
        print(""chest"")
    elif biceps >= chest and biceps >= back:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    
    chest_count = sum(exercises[::3])
    biceps_count = sum(exercises[1::3])
    back_count = sum(exercises[2::3])
    
    if chest_count > biceps_count and chest_count > back_count:
        print(""chest"")
    elif biceps_count > chest_count and biceps_count > back_count:
        print(""biceps"")
    else:
        print(""back"")

solve()","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    chest_exercises = 0
    biceps_exercises = 0
    back_exercises = 0

    for i in range(n):
        if i % 3 == 0:
            chest_exercises += exercises[i]
        elif i % 3 == 1:
            biceps_exercises += exercises[i]
        else:
            back_exercises += exercises[i]
    
    if max(chest_exercises, biceps_exercises, back_exercises) == chest_exercises:
        print('chest')
    elif max(chest_exercises, biceps_exercises, back_exercises) == biceps_exercises:
        print('biceps')
    else:
        print('back')

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    
    chest_count = 0
    biceps_count = 0
    back_count = 0
    
    for i in range(n):
        if i % 3 == 0:
            chest_count += exercises[i]
        elif i % 3 == 1:
            biceps_count += exercises[i]
        else:
            back_count += exercises[i]
    
    if chest_count >= biceps_count and chest_count >= back_count:
        print(""chest"")
    elif biceps_count >= chest_count and biceps_count >= back_count:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    count = {'chest': 0, 'biceps': 0, 'back': 0}

    for i, exercise in enumerate(exercises):
        muscle = i % 3
        if muscle == 0:
            count['chest'] += exercise
        elif muscle == 1:
            count['biceps'] += exercise
        else:
            count['back'] += exercise
    
    max_muscle = max(count, key=count.get)
    print(max_muscle)

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    total_chest = sum(exercises[::3])
    total_biceps = sum(exercises[1::3])
    total_back = sum(exercises[2::3])

    if total_chest >= total_biceps and total_chest >= total_back:
        print(""chest"")
    elif total_biceps >= total_chest and total_biceps >= total_back:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    
    chest = sum([exercises[i] for i in range(0, n, 3)])
    biceps = sum([exercises[i] for i in range(1, n, 3)])
    back = sum([exercises[i] for i in range(2, n, 3)])
    
    if chest > biceps and chest > back:
        print(""chest"")
    elif biceps > chest and biceps > back:
        print(""biceps"")
    else:
        print(""back"")
  
solve()","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    
    chest = sum(exercises[i] for i in range(0, n, 3))
    biceps = sum(exercises[i] for i in range(1, n, 3))
    back = sum(exercises[i] for i in range(2, n, 3))
    
    if chest > biceps and chest > back:
        print(""chest"")
    elif biceps > chest and biceps > back:
        print(""biceps"")
    else:
        print(""back"")
  
solve()","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))
    
    chest_total = 0
    biceps_total = 0
    back_total = 0
    
    for i in range(n):
        if i % 3 == 0:
            chest_total += exercises[i]
        elif i % 3 == 1:
            biceps_total += exercises[i]
        else:
            back_total += exercises[i]
    
    if chest_total >= biceps_total and chest_total >= back_total:
        print(""chest"")
    elif biceps_total >= chest_total and biceps_total >= back_total:
        print(""biceps"")
    else:
        print(""back"")

solve()
","
def solve():
    n = int(input())
    exercises = list(map(int, input().split()))

    chest_total = 0
    biceps_total = 0
    back_total = 0

    for i in range(n):
        if i % 3 == 0:
            chest_total += exercises[i]
        elif i % 3 == 1:
            biceps_total += exercises[i]
        else:
            back_total += exercises[i]

    if chest_total > biceps_total and chest_total > back_total:
        print(""chest"")
    elif biceps_total > chest_total and biceps_total > back_total:
        print(""biceps"")
    else:
        print(""back"")

solve()
","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","100.0","","","","","","","","","","","","","","","",""
"APPS/300","
QUESTION:
Translator's note: in Russia's most widespread grading system, there are four grades: 5, 4, 3, 2, the higher the better, roughly corresponding to A, B, C and F respectively in American grading system.

The term is coming to an end and students start thinking about their grades. Today, a professor told his students that the grades for his course would be given out automatically  — he would calculate the simple average (arithmetic mean) of all grades given out for lab works this term and round to the nearest integer. The rounding would be done in favour of the student — $4.5$ would be rounded up to $5$ (as in example 3), but $4.4$ would be rounded down to $4$.

This does not bode well for Vasya who didn't think those lab works would influence anything, so he may receive a grade worse than $5$ (maybe even the dreaded $2$). However, the professor allowed him to redo some of his works of Vasya's choosing to increase his average grade. Vasya wants to redo as as few lab works as possible in order to get $5$ for the course. Of course, Vasya will get $5$ for the lab works he chooses to redo.

Help Vasya — calculate the minimum amount of lab works Vasya has to redo.


-----Input-----

The first line contains a single integer $n$ — the number of Vasya's grades ($1 \leq n \leq 100$).

The second line contains $n$ integers from $2$ to $5$ — Vasya's grades for his lab works.


-----Output-----

Output a single integer — the minimum amount of lab works that Vasya has to redo. It can be shown that Vasya can always redo enough lab works to get a $5$.


-----Examples-----
Input
3
4 4 4

Output
2

Input
4
5 4 5 5

Output
0

Input
4
5 3 3 5

Output
1



-----Note-----

In the first sample, it is enough to redo two lab works to make two $4$s into $5$s.

In the second sample, Vasya's average is already $4.75$ so he doesn't have to redo anything to get a $5$.

In the second sample Vasya has to redo one lab work to get rid of one of the $3$s, that will make the average exactly $4.5$ so the final grade would be $5$.
Use user-input-Based format and function signature solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))
    
    total = sum(grades)
    target = n * 4.5
    to_redo = 0
    
    while total < target:
        total += 5
        to_redo += 1
    
    print(to_redo)

solve()
","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    target_grade = 5
    total_sum = sum(grades)
    
    min_redo = 0
    while total_sum / n < target_grade - 0.5:
        total_sum += target_grade
        n += 1
        min_redo += 1

    print(min_redo)

solve()
","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    total_grade = sum(grades)
    num_to_redo = 0

    while total_grade / n < 4.5:
        total_grade += 5
        n += 1
        num_to_redo += 1

    return num_to_redo

solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    total_grades = sum(grades)
    min_grades = n * 5
    min_redo = 0

    while total_grades < min_grades:
        total_grades += 5
        min_grades += 5
        min_redo += 1

    print(min_redo)

solve()
","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    total_sum = sum(grades)
    required_sum = n * 4.5

    if total_sum >= required_sum:
        print(0)
    else:
        diff = required_sum - total_sum
        sorted_grades = sorted(grades)
        count = 0
        i = 0
        while diff > 0:
            diff -= 5 - sorted_grades[i]
            count += 1
            i += 1

        print(count)

solve()
","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    total = sum(grades)
    
    min_redo = 0
    while total / n < 4.5:
        total += 5
        n += 1
        min_redo += 1
        
    return min_redo

solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    total_grades = sum(grades)
    total_required = n * 5
    count = 0

    while total_grades < total_required:
        count += 1
        total_grades += 5

    print(count)

solve()
","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))
    
    total = sum(grades)
    target_grade = n * 4.5
    
    if total >= target_grade:
        print(0)
    else:
        diff = target_grade - total
        sorted_grades = sorted(grades)
        
        count = 0
        i = 0
        while diff > 0:
            diff -= 5 - sorted_grades[i]
            count += 1
            i += 1
        
        print(count)

solve()
","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))
    
    current_sum = sum(grades)
    desired_sum = 5 * n
    grade_diff = desired_sum - current_sum
    
    if grade_diff <= 0:
        return 0
    
    min_redo = grade_diff // 3
    if grade_diff % 3 != 0:
        min_redo += 1
    
    return min_redo

solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))
    
    total_sum = sum(grades)
    target_grade = n * 4.5
    
    if total_sum >= target_grade:
        print(0)
    else:
        sorted_grades = sorted(grades)
        count = 0
        i = 0
        
        while total_sum < target_grade:
            total_sum += 5 - sorted_grades[i]
            count += 1
            i += 1
        
        print(count)

solve()
  ","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    current_average = sum(grades) / n
    count_to_redo = 0
    
    while current_average < 4.5:
        grades.append(5)
        count_to_redo += 1
        n += 1
        current_average = sum(grades) / n
    
    print(count_to_redo)

solve()
","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    sum_grades = sum(grades)
    target_average = n * 4.5

    if sum_grades >= target_average:
        return 0

    grades.sort()
    redo = 0
    for grade in grades:
        sum_grades += 5 - grade
        redo += 1
        if sum_grades >= target_average:
            return redo

solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))

    total = sum(grades)
    target_grade = n * 4.5

    if total >= target_grade:
        return 0

    grades.sort(reverse=True)
    count = 0
    for grade in grades:
        total += 5 - grade
        count += 1
        if total >= target_grade:
            return count

solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))
    
    total = sum(grades)
    final_avg = total / n
    
    if final_avg >= 4.5:
        return 0
    else:
        needed = 0
        while final_avg < 4.5:
            total += 5
            needed += 1
            final_avg = total / (n + needed)
        return needed

# Required import statement
import sys

solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))
    
    total = sum(grades)
    final_grade = round(total / n)
    
    if final_grade == 5:
        print(0)
    else:
        min_redo = 0
        while final_grade < 5:
            min_redo += 1
            total += 5
            final_grade = round(total / (n + min_redo))
        
        print(min_redo)

solve()","
def solve():
    n = int(input())
    grades = list(map(int, input().split()))
    
    total = sum(grades)
    target = n * 4.5
    
    if total >= target:
        print(0)
    else:
        grades.sort()
        count = 0
        for grade in grades:
            total += (5 - grade)
            count += 1
            if total >= target:
                break
        print(count)

solve()
","66.66666666666666","33.33333333333333","0.0","100.0","100.0","0.0","60.0","100.0","0.0","100.0","33.33333333333333","0.0","0.0","0.0","13.333333333333334","100.0","","","","","","","","","","","","","","","",""
